--------------------------------------------------------
-- Archivo creado  - jueves-febrero-27-2020   
--------------------------------------------------------
--------------------------------------------------------
--  DDL for View EVENTOS_CALENDARIO
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "FUNDAUC"."EVENTOS_CALENDARIO" ("ID_CALENDARIO", "DESCRIPCION", "FECHA_INI", "FECHA_FIN", "ID_SECCION", "PERIODO", "ID_METODO", "NIVEL", "HORARIO", "DIAS") AS 
  SELECT
        c.id_calendario,
        c.descripcion
        || ' ('
        || m.descripcion
        || ')' AS descripcion,
        cd.fecha_ini,
        cd.fecha_fin,
        s.id_seccion,
        s.periodo,
        s.id_metodo,
        s.nivel,
        s.horario,
        m.dias
    FROM
        fundauc.calendarios           c,
        fundauc.calendarios_detalle   cd,
        fundauc.modalidades           m,
        fundauc.secciones             s
    WHERE
        c.id_calendario = cd.id_calendario
        AND m.id_modalidad = cd.modalidad
        AND s.periodo = cd.periodo
        AND s.fec_inicio = cd.fecha_ini
;
--------------------------------------------------------
--  DDL for View MOVIMIENTO_CAJA
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "FUNDAUC"."MOVIMIENTO_CAJA" ("PROG_ACADEMICO", "ORDEN", "FEC_FAC", "TIPO_ITEM", "ITEM", "TOTAL") AS 
  select decode(prog_academico,1,'IDIOMAS',2,'IDIOMAS',3,'DIPLOMADOS',6,'DIRECCION CENTRAL') prog_academico,orden, fec_fac,tipo_item,item,sum(total) total from
(
/* Libros y Guias paquetes*/
select f.prog_academico,c.orden orden,c.descripcion concepto,decode(token(df.descripcion, 1, ' '),'AEC-A','AEC',token(df.descripcion, 1, ' ')) curso,to_number(trim(token(df.descripcion,3, ' '))) nivel,f.fecha_emi fec_fac,df.id_fact,m.tipo tipo_item,m.id_mat item,m.descripcion,decode(m.tipo,'G',165,'L',325,0) p_venta, sum(decode(m.tipo,'G',165,'L',325,0)) total, count(*) cant
from factura f,detalle_factura df,tipo_material tm, materiales m, metodos mt, conceptos c, conceptos_tipo ct
where f.id_fact = df.id_fact
and df.tipo_item=tm.abrev and tipo_item in 'C' and subtotal=1720 and m.tipo in ('G','L')
and decode(token(df.descripcion, 1, ' '),'AEC-A','AEC',token(df.descripcion, 1, ' '))=m.id_curso and token(df.descripcion,3, ' ')=lpad(m.nivel,2,'0')
and decode(token(df.descripcion, 1, ' '),'AEC-A','AEC',token(df.descripcion, 1, ' '))=mt.id_metodo and mt.idioma='INGLES'
and f.status='V' and nvl(f.rif,' ') not in (select rif from empresa_tipo where tipo = 1) and c.id_concepto= ct.id_concepto and ct.tipo=m.tipo
group by f.prog_academico,c.orden,c.descripcion,decode(token(df.descripcion, 1, ' '),'AEC-A','AEC',token(df.descripcion, 1, ' ')),to_number(trim(token(df.descripcion,3, ' '))),f.fecha_emi,df.id_fact, m.tipo,m.id_mat,m.descripcion
UNION
select f.prog_academico,c.orden orden,c.descripcion concepto,decode(token(df.descripcion, 1, ' '),'AEC-A','AEC',token(df.descripcion, 1, ' ')) curso,to_number(trim(token(df.descripcion,3, ' '))) nivel,f.fecha_emi fec_fac,df.id_fact,m.tipo tipo_item,m.id_mat item,m.descripcion,decode(m.tipo,'G',165,'L',325,0) p_venta, sum(decode(m.tipo,'G',165,'L',325,0)) total, count(*) cant
from factura f,detalle_factura df,tipo_material tm, materiales m, metodos mt, conceptos c, conceptos_tipo ct
where f.id_fact = df.id_fact
and df.tipo_item=tm.abrev and tipo_item in 'C' and subtotal=1840 and m.tipo in ('G','L')
and decode(token(df.descripcion, 1, ' '),'AEC-A','AEC',token(df.descripcion, 1, ' '))=m.id_curso and token(df.descripcion,3, ' ')=lpad(m.nivel,2,'0')
and decode(token(df.descripcion, 1, ' '),'AEC-A','AEC',token(df.descripcion, 1, ' '))=mt.id_metodo and mt.idioma='INGLES'
and f.status='V' and nvl(f.rif,' ') not in (select rif from empresa_tipo where tipo = 1) and c.id_concepto= ct.id_concepto and ct.tipo=m.tipo
group by f.prog_academico,c.orden,c.descripcion,decode(token(df.descripcion, 1, ' '),'AEC-A','AEC',token(df.descripcion, 1, ' ')),to_number(trim(token(df.descripcion,3, ' '))),f.fecha_emi,df.id_fact, m.tipo,m.id_mat,m.descripcion
/* Guias paquetes */
UNION
select f.prog_academico,c.orden orden,c.descripcion concepto,decode(token(df.descripcion, 1, ' '),'AEC-A','AEC',token(df.descripcion, 1, ' ')) curso,to_number(trim(token(df.descripcion,3, ' '))) nivel,f.fecha_emi fec_fac,df.id_fact,m.tipo tipo_item,m.id_mat item,m.descripcion,264 p_venta, sum(264) total, count(*) cant
from factura f,detalle_factura df,tipo_material tm, materiales m, metodos mt, conceptos c, conceptos_tipo ct
where f.id_fact = df.id_fact
and df.tipo_item=tm.abrev and tipo_item in 'C' and subtotal=1990 and m.tipo='G'
and decode(token(df.descripcion, 1, ' '),'AEC-A','AEC',token(df.descripcion, 1, ' '))=m.id_curso and token(df.descripcion,3, ' ')=lpad(m.nivel,2,'0')
and decode(token(df.descripcion, 1, ' '),'AEC-A','AEC',token(df.descripcion, 1, ' '))=mt.id_metodo and mt.idioma='INGLES'
and f.status='V' and nvl(f.rif,' ') not in (select rif from empresa_tipo where tipo = 1) and c.id_concepto= ct.id_concepto and ct.tipo=m.tipo
group by f.prog_academico,c.orden,c.descripcion,decode(token(df.descripcion, 1, ' '),'AEC-A','AEC',token(df.descripcion, 1, ' ')),to_number(trim(token(df.descripcion,3, ' '))),f.fecha_emi,df.id_fact, m.tipo,m.id_mat,m.descripcion
UNION
select f.prog_academico,c.orden orden,c.descripcion concepto,decode(token(df.descripcion, 1, ' '),'AEC-A','AEC',token(df.descripcion, 1, ' ')) curso,to_number(trim(token(df.descripcion,3, ' '))) nivel,f.fecha_emi fec_fac,df.id_fact,m.tipo tipo_item,m.id_mat item,m.descripcion,264 p_venta, sum(264) total, count(*) cant
from factura f,detalle_factura df,tipo_material tm, materiales m, metodos mt, conceptos c, conceptos_tipo ct
where f.id_fact = df.id_fact 
and df.tipo_item=tm.abrev and tipo_item in 'C' and subtotal=2260 and m.tipo='G'
and decode(token(df.descripcion, 1, ' '),'AEC-A','AEC',token(df.descripcion, 1, ' '))=m.id_curso and token(df.descripcion,3, ' ')=lpad(m.nivel,2,'0')
and decode(token(df.descripcion, 1, ' '),'AEC-A','AEC',token(df.descripcion, 1, ' '))=mt.id_metodo and mt.idioma='INGLES'
and f.status='V' and nvl(f.rif,' ') not in (select rif from empresa_tipo where tipo = 1) and c.id_concepto= ct.id_concepto and ct.tipo=m.tipo
group by f.prog_academico,c.orden,c.descripcion,decode(token(df.descripcion, 1, ' '),'AEC-A','AEC',token(df.descripcion, 1, ' ')),to_number(trim(token(df.descripcion,3, ' '))),f.fecha_emi,df.id_fact, m.tipo,m.id_mat,m.descripcion
UNION
select f.prog_academico,c.orden orden,c.descripcion concepto,m.id_curso curso,m.nivel,f.fecha_emi fec_fac,df.id_fact,df.tipo_item,df.item,m.descripcion,p_unidad p_venta, sum(decode(df.subtotal,0,df.p_unidad,df.subtotal)) total,decode(cantidad,0,1,cantidad) cant
from factura f,detalle_factura df,tipo_material tm, materiales m, conceptos c, conceptos_tipo ct
where f.id_fact = df.id_fact 
and df.tipo_item=tm.abrev and tipo_item='G' and f.status='V' and df.item=m.id_mat
and nvl(f.rif,' ') not in (select rif from empresa_tipo where tipo = 1) and c.id_concepto= ct.id_concepto and ct.tipo=m.tipo
group by f.prog_academico,c.orden,c.descripcion,m.id_curso,m.nivel,f.fecha_emi,df.id_fact, df.tipo_item,df.item,m.descripcion,p_unidad, cantidad
UNION
select f.prog_academico,c.orden orden,c.descripcion concepto,decode(token(df.descripcion, 1, ' '),'AEC-A','AEC',token(df.descripcion, 1, ' ')) curso,to_number(trim(token(df.descripcion,3, ' '))) nivel,f.fecha_emi fec_fac,df.id_fact,m.tipo tipo_item,m.id_mat item,m.descripcion,264 p_venta, sum(264) total, count(*) cant
from factura f,detalle_factura df,tipo_material tm, materiales m, metodos mt, conceptos c, conceptos_tipo ct
where f.id_fact = df.id_fact 
and df.tipo_item=tm.abrev and tipo_item in 'C' and subtotal=2500 and m.tipo='G'
and decode(token(df.descripcion, 1, ' '),'AEC-A','AEC',token(df.descripcion, 1, ' '))=m.id_curso and token(df.descripcion,3, ' ')=lpad(m.nivel,2,'0')
and decode(token(df.descripcion, 1, ' '),'AEC-A','AEC',token(df.descripcion, 1, ' '))=mt.id_metodo and mt.idioma='INGLES'
and f.status='V' and nvl(f.rif,' ') not in (select rif from empresa_tipo where tipo = 1) and c.id_concepto= ct.id_concepto and ct.tipo=m.tipo
group by f.prog_academico,c.orden,c.descripcion,decode(token(df.descripcion, 1, ' '),'AEC-A','AEC',token(df.descripcion, 1, ' ')),to_number(trim(token(df.descripcion,3, ' '))),f.fecha_emi,df.id_fact, m.tipo,m.id_mat,m.descripcion
UNION
select f.prog_academico,c.orden orden,c.descripcion concepto,decode(token(df.descripcion, 1, ' '),'AEC-A','AEC',token(df.descripcion, 1, ' ')) curso,to_number(trim(token(df.descripcion,3, ' '))) nivel,f.fecha_emi fec_fac,df.id_fact,m.tipo tipo_item,m.id_mat item,m.descripcion,264 p_venta, sum(264) total, count(*) cant
from factura f,detalle_factura df,tipo_material tm, materiales m, metodos mt, conceptos c, conceptos_tipo ct
where f.id_fact = df.id_fact 
and df.tipo_item=tm.abrev and tipo_item in 'C' and subtotal=2770 and m.tipo='G'
and decode(token(df.descripcion, 1, ' '),'AEC-A','AEC',token(df.descripcion, 1, ' '))=m.id_curso and token(df.descripcion,3, ' ')=lpad(m.nivel,2,'0')
and decode(token(df.descripcion, 1, ' '),'AEC-A','AEC',token(df.descripcion, 1, ' '))=mt.id_metodo and mt.idioma='INGLES'
and f.status='V' and nvl(f.rif,' ') not in (select rif from empresa_tipo where tipo = 1) and c.id_concepto= ct.id_concepto and ct.tipo=m.tipo
group by f.prog_academico,c.orden,c.descripcion,decode(token(df.descripcion, 1, ' '),'AEC-A','AEC',token(df.descripcion, 1, ' ')),to_number(trim(token(df.descripcion,3, ' '))),f.fecha_emi,df.id_fact, m.tipo,m.id_mat,m.descripcion
UNION
/* Libros paquetes*/
select f.prog_academico,c.orden orden,c.descripcion concepto,decode(token(df.descripcion, 1, ' '),'AEC-A','AEC',token(df.descripcion, 1, ' ')) curso,to_number(trim(token(df.descripcion,3, ' '))) nivel,f.fecha_emi fec_fac,df.id_fact,m.tipo tipo_item,m.id_mat item,m.descripcion,510 p_venta, sum(510) total, count(*) cant
from factura f,detalle_factura df,tipo_material tm, materiales m, metodos mt, conceptos c, conceptos_tipo ct
where f.id_fact = df.id_fact 
and df.tipo_item=tm.abrev and tipo_item in 'C' and subtotal=2500 and m.tipo='L'
and decode(token(df.descripcion, 1, ' '),'AEC-A','AEC',token(df.descripcion, 1, ' '))=m.id_curso and token(df.descripcion,3, ' ')=lpad(m.nivel,2,'0')
and decode(token(df.descripcion, 1, ' '),'AEC-A','AEC',token(df.descripcion, 1, ' '))=mt.id_metodo and mt.idioma='INGLES'
and f.status='V' and nvl(f.rif,' ') not in (select rif from empresa_tipo where tipo = 1) and c.id_concepto= ct.id_concepto and ct.tipo=m.tipo
group by f.prog_academico,c.orden,c.descripcion,decode(token(df.descripcion, 1, ' '),'AEC-A','AEC',token(df.descripcion, 1, ' ')),to_number(trim(token(df.descripcion,3, ' '))),f.fecha_emi,df.id_fact, m.tipo,m.id_mat,m.descripcion
UNION
select f.prog_academico,c.orden orden,c.descripcion concepto,decode(token(df.descripcion, 1, ' '),'AEC-A','AEC',token(df.descripcion, 1, ' ')) curso,to_number(trim(token(df.descripcion,3, ' '))) nivel,f.fecha_emi fec_fac,df.id_fact,m.tipo tipo_item,m.id_mat item,m.descripcion,510 p_venta, sum(510) total, count(*) cant
from factura f,detalle_factura df,tipo_material tm, materiales m, metodos mt, conceptos c, conceptos_tipo ct
where f.id_fact = df.id_fact
and df.tipo_item=tm.abrev and tipo_item in 'C' and subtotal=2770 and m.tipo='L'
and decode(token(df.descripcion, 1, ' '),'AEC-A','AEC',token(df.descripcion, 1, ' '))=m.id_curso and token(df.descripcion,3, ' ')=lpad(m.nivel,2,'0')
and decode(token(df.descripcion, 1, ' '),'AEC-A','AEC',token(df.descripcion, 1, ' '))=mt.id_metodo and mt.idioma='INGLES'
and f.status='V' and nvl(f.rif,' ') not in (select rif from empresa_tipo where tipo = 1) and c.id_concepto= ct.id_concepto and ct.tipo=m.tipo
group by f.prog_academico,c.orden,c.descripcion,decode(token(df.descripcion, 1, ' '),'AEC-A','AEC',token(df.descripcion, 1, ' ')),to_number(trim(token(df.descripcion,3, ' '))),f.fecha_emi,df.id_fact, m.tipo,m.id_mat,m.descripcion
UNION
select f.prog_academico,c.orden orden,c.descripcion concepto,m.id_curso curso, m.nivel,f.fecha_emi fec_fac,df.id_fact,df.tipo_item,df.item,m.descripcion,p_unidad p_venta, sum(decode(df.subtotal,0,df.p_unidad,df.subtotal)) total,decode(cantidad,0,1,cantidad) cant
from factura f,detalle_factura df,tipo_material tm, materiales m, conceptos c, conceptos_tipo ct
where f.id_fact = df.id_fact
and df.tipo_item=tm.abrev and tipo_item='L' and f.status='V' and DF.P_UNIDAD>0 and df.item=m.id_mat
and nvl(f.rif,' ') not in (select rif from empresa_tipo where tipo = 1) and c.id_concepto= ct.id_concepto and ct.tipo=df.tipo_item
group by f.prog_academico,c.orden,c.descripcion,m.id_curso, m.nivel,f.fecha_emi,df.id_fact, df.tipo_item,df.item,m.descripcion,p_unidad, cantidad
/* libros monto negativo sin libro */
UNION
select f.prog_academico,c.orden orden,c.descripcion concepto,m.id_curso curso, m.nivel,f.fecha_emi fec_fac,df.id_fact,df.tipo_item,df.item,m.descripcion,decode(p_unidad,-395,-325,p_unidad)*-1 p_venta, sum(decode(df.subtotal,0,df.p_unidad,df.subtotal)) total,decode(cantidad,0,-1,cantidad*-1) cant
from factura f,detalle_factura df,tipo_material tm, materiales m, conceptos c, conceptos_tipo ct
where f.id_fact = df.id_fact 
and df.tipo_item=tm.abrev and tipo_item='L' and f.status='V' and DF.P_UNIDAD<0 and df.item=m.id_mat
and nvl(f.rif,' ') not in (select rif from empresa_tipo where tipo = 1) and c.id_concepto= ct.id_concepto and ct.tipo=df.tipo_item
group by f.prog_academico,c.orden,c.descripcion,m.id_curso, m.nivel,f.fecha_emi,df.id_fact, df.tipo_item,df.item,m.descripcion,p_unidad, cantidad
UNION
/* Cursos de Libros y Guias paquetes*/
select f.prog_academico,c.orden orden,c.descripcion concepto,decode(token(df.descripcion, 1, ' '),'AEC-A','AEC',token(df.descripcion, 1, ' ')) curso,to_number(trim(token(df.descripcion,3, ' '))) nivel,f.fecha_emi fec_fac,df.id_fact,df.tipo_item tipo_item,df.item item,df.descripcion,p_unidad - (165+325) p_venta, sum(df.subtotal-(165+325)) total, count(*) cant
from factura f,detalle_factura df,tipo_material tm, metodos mt, conceptos c, conceptos_tipo ct
where f.id_fact = df.id_fact 
and df.tipo_item=tm.abrev and tipo_item in 'C' and subtotal=1720
and decode(token(df.descripcion, 1, ' '),'AEC-A','AEC',token(df.descripcion, 1, ' '))=mt.id_metodo and mt.idioma='INGLES'
and f.status='V' and nvl(f.rif,' ') not in (select rif from empresa_tipo where tipo = 1) and c.id_concepto= ct.id_concepto and ct.tipo=df.tipo_item
group by f.prog_academico,c.orden,c.descripcion,decode(token(df.descripcion, 1, ' '),'AEC-A','AEC',token(df.descripcion, 1, ' ')),to_number(trim(token(df.descripcion,3, ' '))),f.fecha_emi,df.id_fact, df.tipo_item,df.item,df.descripcion,p_unidad - (165+325)
UNION
select f.prog_academico,c.orden orden,c.descripcion concepto,decode(token(df.descripcion, 1, ' '),'AEC-A','AEC',token(df.descripcion, 1, ' ')) curso,to_number(trim(token(df.descripcion,3, ' '))) nivel,f.fecha_emi fec_fac,df.id_fact,df.tipo_item tipo_item,df.item item,df.descripcion,p_unidad - (165+325) p_venta, sum(df.subtotal-(165+325)) total, count(*) cant
from factura f,detalle_factura df,tipo_material tm, metodos mt, conceptos c, conceptos_tipo ct
where f.id_fact = df.id_fact 
and df.tipo_item=tm.abrev and tipo_item in 'C' and subtotal=1840
and decode(token(df.descripcion, 1, ' '),'AEC-A','AEC',token(df.descripcion, 1, ' '))=mt.id_metodo and mt.idioma='INGLES'
and f.status='V' and nvl(f.rif,' ') not in (select rif from empresa_tipo where tipo = 1) and c.id_concepto= ct.id_concepto and ct.tipo=df.tipo_item
group by f.prog_academico,c.orden,c.descripcion,decode(token(df.descripcion, 1, ' '),'AEC-A','AEC',token(df.descripcion, 1, ' ')),to_number(trim(token(df.descripcion,3, ' '))),f.fecha_emi,df.id_fact, df.tipo_item,df.item,df.descripcion,p_unidad - (165+325)
/*Cursos con Guias paquetes */
UNION
select f.prog_academico,c.orden orden,c.descripcion concepto,decode(token(df.descripcion, 1, ' '),'AEC-A','AEC',token(df.descripcion, 1, ' ')) curso,to_number(trim(token(df.descripcion,3, ' '))) nivel,f.fecha_emi fec_fac,df.id_fact,df.tipo_item tipo_item,df.item item,df.descripcion,p_unidad - (264) p_venta, sum(df.subtotal-(264)) total, count(*) cant
from factura f,detalle_factura df,tipo_material tm, metodos mt, conceptos c, conceptos_tipo ct
where f.id_fact = df.id_fact 
and df.tipo_item=tm.abrev and tipo_item in 'C' and subtotal=1990
and decode(token(df.descripcion, 1, ' '),'AEC-A','AEC',token(df.descripcion, 1, ' '))=mt.id_metodo and mt.idioma='INGLES'
and f.status='V' and nvl(f.rif,' ') not in (select rif from empresa_tipo where tipo = 1) and c.id_concepto= ct.id_concepto and ct.tipo=df.tipo_item
group by f.prog_academico,c.orden,c.descripcion,decode(token(df.descripcion, 1, ' '),'AEC-A','AEC',token(df.descripcion, 1, ' ')),to_number(trim(token(df.descripcion,3, ' '))),f.fecha_emi,df.id_fact, df.tipo_item,df.item,df.descripcion,p_unidad - (264)
UNION
select f.prog_academico,c.orden orden,c.descripcion concepto,decode(token(df.descripcion, 1, ' '),'AEC-A','AEC',token(df.descripcion, 1, ' ')) curso,to_number(trim(token(df.descripcion,3, ' '))) nivel,f.fecha_emi fec_fac,df.id_fact,df.tipo_item tipo_item,df.item item,df.descripcion,p_unidad - (264) p_venta, sum(df.subtotal-(264)) total, count(*) cant
from factura f,detalle_factura df,tipo_material tm, metodos mt, conceptos c, conceptos_tipo ct
where f.id_fact = df.id_fact 
and df.tipo_item=tm.abrev and tipo_item in 'C' and subtotal=2260
and decode(token(df.descripcion, 1, ' '),'AEC-A','AEC',token(df.descripcion, 1, ' '))=mt.id_metodo and mt.idioma='INGLES'
and f.status='V' and nvl(f.rif,' ') not in (select rif from empresa_tipo where tipo = 1) and c.id_concepto= ct.id_concepto and ct.tipo=df.tipo_item
group by f.prog_academico,c.orden,c.descripcion,decode(token(df.descripcion, 1, ' '),'AEC-A','AEC',token(df.descripcion, 1, ' ')),to_number(trim(token(df.descripcion,3, ' '))),f.fecha_emi,df.id_fact, df.tipo_item,df.item,df.descripcion,p_unidad - (264)
UNION
/* Curso nivel 10 con Guia Empaquetada */
select f.prog_academico,c.orden orden,c.descripcion concepto,decode(token(df.descripcion, 1, ' '),'AEC-A','AEC',token(df.descripcion, 1, ' ')) curso,to_number(trim(token(df.descripcion,3, ' '))) nivel,f.fecha_emi fec_fac,df.id_fact,df.tipo_item tipo_item,df.item item,df.descripcion,p_unidad - (264) p_venta, sum(df.subtotal-(264)) total, count(*) cant
from factura f,detalle_factura df,tipo_material tm, metodos mt, conceptos c, conceptos_tipo ct
where f.id_fact = df.id_fact
and df.tipo_item=tm.abrev and tipo_item in 'C' and subtotal=2500
and decode(token(df.descripcion, 1, ' '),'AEC-A','AEC',token(df.descripcion, 1, ' '))=mt.id_metodo and mt.idioma='INGLES'
and f.status='V' and nvl(f.rif,' ') not in (select rif from empresa_tipo where tipo = 1) and c.id_concepto= ct.id_concepto and ct.tipo=df.tipo_item
group by f.prog_academico,c.orden,c.descripcion,decode(token(df.descripcion, 1, ' '),'AEC-A','AEC',token(df.descripcion, 1, ' ')),to_number(trim(token(df.descripcion,3, ' '))),f.fecha_emi,df.id_fact, df.tipo_item,df.item,df.descripcion,p_unidad - (264)
UNION
select f.prog_academico,c.orden orden,c.descripcion concepto,decode(token(df.descripcion, 1, ' '),'AEC-A','AEC',token(df.descripcion, 1, ' ')) curso,to_number(trim(token(df.descripcion,3, ' '))) nivel,f.fecha_emi fec_fac,df.id_fact,df.tipo_item tipo_item,df.item item,df.descripcion,p_unidad - (264) p_venta, sum(df.subtotal-(264)) total, count(*) cant
from factura f,detalle_factura df,tipo_material tm, metodos mt, conceptos c, conceptos_tipo ct
where f.id_fact = df.id_fact 
and df.tipo_item=tm.abrev and tipo_item in 'C' and subtotal=2770
and decode(token(df.descripcion, 1, ' '),'AEC-A','AEC',token(df.descripcion, 1, ' '))=mt.id_metodo and mt.idioma='INGLES'
and f.status='V' and nvl(f.rif,' ') not in (select rif from empresa_tipo where tipo = 1) and c.id_concepto= ct.id_concepto and ct.tipo=df.tipo_item
group by f.prog_academico,c.orden,c.descripcion,decode(token(df.descripcion, 1, ' '),'AEC-A','AEC',token(df.descripcion, 1, ' ')),to_number(trim(token(df.descripcion,3, ' '))),f.fecha_emi,df.id_fact, df.tipo_item,df.item,df.descripcion,p_unidad - (264)
UNION
/* Cursos Libros paquetes*/
select f.prog_academico,c.orden orden,c.descripcion concepto,decode(token(df.descripcion, 1, ' '),'AEC-A','AEC',token(df.descripcion, 1, ' ')) curso,to_number(trim(token(df.descripcion,3, ' '))) nivel,f.fecha_emi fec_fac,df.id_fact,df.tipo_item tipo_item,df.item item,df.descripcion,p_unidad - (264) p_venta, sum(df.subtotal-(264)) total, count(*) cant
from factura f,detalle_factura df,tipo_material tm, metodos mt, conceptos c, conceptos_tipo ct
where f.id_fact = df.id_fact
and df.tipo_item=tm.abrev and tipo_item in 'C' and subtotal=2770
and decode(token(df.descripcion, 1, ' '),'AEC-A','AEC',token(df.descripcion, 1, ' '))=mt.id_metodo and mt.idioma='INGLES'
and f.status='V' and nvl(f.rif,' ') not in (select rif from empresa_tipo where tipo = 1) and c.id_concepto= ct.id_concepto and ct.tipo=df.tipo_item
group by f.prog_academico,c.orden,c.descripcion,decode(token(df.descripcion, 1, ' '),'AEC-A','AEC',token(df.descripcion, 1, ' ')),to_number(trim(token(df.descripcion,3, ' '))),f.fecha_emi,df.id_fact, df.tipo_item,df.item,df.descripcion,p_unidad - (264)
UNION
/*Control de Notas*/
select f.prog_academico,c.orden orden,c.descripcion concepto,null curso,null nivel,f.fecha_emi fec_fac,df.id_fact,df.tipo_item,df.item,tm.descripcion,p_unidad p_venta, sum(df.subtotal) total,count(*) cant
from factura f,detalle_factura df,tipo_material tm, conceptos c, conceptos_tipo ct
where f.id_fact = df.id_fact 
and df.tipo_item=tm.abrev and f.status='V' and tipo_item = 'B'
and c.id_concepto= ct.id_concepto and ct.tipo=df.tipo_item
and nvl(f.rif,' ') not in (select rif from empresa_tipo where tipo = 1)
group by f.prog_academico,c.orden,c.descripcion,f.fecha_emi,df.id_fact,df.tipo_item,df.item,tm.descripcion,p_unidad
UNION
/*Examenes*/
select f.prog_academico,c.orden orden,c.descripcion concepto,null curso,null nivel,f.fecha_emi fec_fac,df.id_fact,df.tipo_item,df.item,tm.descripcion,p_unidad p_venta, sum(df.subtotal) total,count(*) cant
from factura f,detalle_factura df,tipo_material tm, conceptos c, conceptos_tipo ct
where f.id_fact = df.id_fact 
and df.tipo_item=tm.abrev and f.status='V' and tipo_item = 'E'
and c.id_concepto= ct.id_concepto and ct.tipo=df.tipo_item
and nvl(f.rif,' ') not in (select rif from empresa_tipo where tipo = 1)
group by f.prog_academico,c.orden,c.descripcion,f.fecha_emi,df.id_fact,df.tipo_item,df.item,tm.descripcion,p_unidad
UNION
/*Matriculas*/
select f.prog_academico,c.orden orden,c.descripcion concepto,null curso,null nivel,f.fecha_emi fec_fac,df.id_fact,df.tipo_item,df.item,tm.descripcion,p_unidad p_venta, sum(df.subtotal) total,count(*) cant
from factura f,detalle_factura df,tipo_material tm, conceptos c, conceptos_tipo ct
where f.id_fact = df.id_fact 
and df.tipo_item=tm.abrev and f.status='V' and tipo_item = 'M'
and c.id_concepto= ct.id_concepto and ct.tipo=df.tipo_item
and nvl(f.rif,' ') not in (select rif from empresa_tipo where tipo = 1)
group by f.prog_academico,c.orden,c.descripcion,f.fecha_emi,df.id_fact,df.tipo_item,df.item,tm.descripcion,p_unidad
UNION
/*Aranceles de Graduacio y Ubicacion*/
select f.prog_academico,c.orden orden,c.descripcion concepto,null curso,null nivel,f.fecha_emi fec_fac,df.id_fact,df.tipo_item,df.item,tm.descripcion,p_unidad p_venta, sum(df.subtotal) total,count(*) cant
from factura f,detalle_factura df,tipo_material tm, conceptos c, conceptos_tipo ct
where f.id_fact = df.id_fact 
and df.tipo_item=tm.abrev and f.status='V' and tipo_item = 'A'
and c.id_concepto= ct.id_concepto and ct.tipo=df.tipo_item and ct.id_mat=df.item
and nvl(f.rif,' ') not in (select rif from empresa_tipo where tipo = 1)
group by f.prog_academico,c.orden,c.descripcion,f.fecha_emi,df.id_fact,df.tipo_item,df.item,tm.descripcion,p_unidad
UNION
/*Ingresos Diferidos*/
select f.prog_academico,c.orden orden,c.descripcion concepto,null curso,null nivel,f.fecha_emi fec_fac,df.id_fact,df.tipo_item,df.item,tm.descripcion,p_unidad p_venta, sum(df.subtotal) total,count(*) cant
from factura f,detalle_factura df,tipo_material tm, conceptos c, conceptos_tipo ct
where f.id_fact = df.id_fact 
and df.tipo_item=tm.abrev and f.status='V' and tipo_item = 'ID'
and c.id_concepto= ct.id_concepto and ct.tipo=df.tipo_item
and nvl(f.rif,' ') not in (select rif from empresa_tipo where tipo = 1)
group by f.prog_academico,c.orden,c.descripcion,f.fecha_emi,df.id_fact,df.tipo_item,df.item,tm.descripcion,p_unidad
UNION
/*Descuentos*/
select f.prog_academico,c.orden orden,c.descripcion concepto,null curso,null nivel,f.fecha_emi fec_fac,df.id_fact,df.tipo_item,df.item,tm.descripcion,p_unidad p_venta, sum(df.subtotal) total,count(*) cant
from factura f,detalle_factura df,tipo_material tm, conceptos c, conceptos_tipo ct
where f.id_fact = df.id_fact 
and df.tipo_item=tm.abrev and f.status='V' and tipo_item = 'D'
and c.id_concepto= ct.id_concepto and ct.tipo=df.tipo_item
and nvl(f.rif,' ') not in (select rif from empresa_tipo where tipo = 1)
group by f.prog_academico,c.orden,c.descripcion,f.fecha_emi,df.id_fact,df.tipo_item,df.item,tm.descripcion,p_unidad
UNION
/*Constacia de Estudios*/
select f.prog_academico,c.orden orden,c.descripcion concepto,null curso,null nivel,f.fecha_emi fec_fac,df.id_fact,df.tipo_item,df.item,tm.descripcion,p_unidad p_venta, sum(df.subtotal) total,count(*) cant
from factura f,detalle_factura df,tipo_material tm, conceptos c, conceptos_tipo ct
where f.id_fact = df.id_fact 
and df.tipo_item=tm.abrev and f.status='V' and tipo_item = 'CO'
and c.id_concepto= ct.id_concepto and ct.tipo=df.tipo_item
and nvl(f.rif,' ') not in (select rif from empresa_tipo where tipo = 1)
group by f.prog_academico,c.orden,c.descripcion,f.fecha_emi,df.id_fact,df.tipo_item,df.item,tm.descripcion,p_unidad
UNION
/*Reposicion de Factura*/
select f.prog_academico,c.orden orden,c.descripcion concepto,null curso,null nivel,f.fecha_emi fec_fac,df.id_fact,df.tipo_item,df.item,tm.descripcion,p_unidad p_venta, sum(df.subtotal) total,count(*) cant
from factura f,detalle_factura df,tipo_material tm, conceptos c, conceptos_tipo ct
where f.id_fact = df.id_fact 
and df.tipo_item=tm.abrev and f.status='V' and tipo_item = 'F'
and c.id_concepto= ct.id_concepto and ct.tipo=df.tipo_item
and nvl(f.rif,' ') not in (select rif from empresa_tipo where tipo = 1)
group by f.prog_academico,c.orden,c.descripcion,f.fecha_emi,df.id_fact,df.tipo_item,df.item,tm.descripcion,p_unidad
UNION
/*Recargo Administrativo*/
select f.prog_academico,c.orden orden,c.descripcion concepto,null curso,null nivel,f.fecha_emi fec_fac,df.id_fact,df.tipo_item,df.item,tm.descripcion,p_unidad p_venta, sum(df.subtotal) total,count(*) cant
from factura f,detalle_factura df,tipo_material tm, conceptos c, conceptos_tipo ct
where f.id_fact = df.id_fact 
and df.tipo_item=tm.abrev and f.status='V' and tipo_item = 'R'
and c.id_concepto= ct.id_concepto and ct.tipo=df.tipo_item
and nvl(f.rif,' ') not in (select rif from empresa_tipo where tipo = 1)
group by f.prog_academico,c.orden,c.descripcion,f.fecha_emi,df.id_fact,df.tipo_item,df.item,tm.descripcion,p_unidad
UNION
/*Colocacion de Nota*/
select f.prog_academico,c.orden orden,c.descripcion concepto,null curso,null nivel,f.fecha_emi fec_fac,df.id_fact,df.tipo_item,df.item,tm.descripcion,p_unidad p_venta, sum(df.subtotal) total,count(*) cant
from factura f,detalle_factura df,tipo_material tm, conceptos c, conceptos_tipo ct
where f.id_fact = df.id_fact 
and df.tipo_item=tm.abrev and f.status='V' and tipo_item = 'O' and df.item = 'CN'
and c.id_concepto= ct.id_concepto and ct.tipo=df.tipo_item
and nvl(f.rif,' ') not in (select rif from empresa_tipo where tipo = 1)
group by f.prog_academico,c.orden,c.descripcion,f.fecha_emi,df.id_fact,df.tipo_item,df.item,tm.descripcion,p_unidad
UNION
/*Diplomados y Certificaciones*/
select f.prog_academico,c.orden orden,d.descripcion concepto,null curso,null nivel,f.fecha_emi fec_fac,df.id_fact,df.tipo_item,df.item,tm.descripcion,p_unidad p_venta, sum(df.subtotal) total,count(*) cant
from factura f,detalle_factura df,tipo_material tm, conceptos c, conceptos_tipo ct,
(select distinct id,id_diplocer from 
(select id,id_diplomado id_diplocer from cohortes
UNION
select id, id_certi id_diplocer from cohorte_certi)) ch, 
(select distinct id, descripcion from
(select id_diplomado id, descripcion, 'DIPLOMADO' tipo from diplomados
UNION
select id_certi id,descripcion, 'CERTIFICACION' tipo from diplo_certi)) d
where f.id_fact = df.id_fact 
and df.tipo_item=tm.abrev and f.status='V' and tipo_item in ('CU','PC') and df.item=ch.id and ch.id_diplocer=d.id
and c.id_concepto= ct.id_concepto and ct.tipo=df.tipo_item
and nvl(f.rif,' ') not in (select rif from empresa_tipo where tipo = 1)
group by f.prog_academico,c.orden,d.descripcion,f.fecha_emi,df.id_fact,df.tipo_item,df.item,tm.descripcion,p_unidad
UNION
/*Diplomados Empresas*/
select 3 prog_academico,c.orden orden,e.razon concepto,null curso,null nivel,f.fecha_emi fec_fac,df.id_fact,df.tipo_item,df.item,tm.descripcion,p_unidad p_venta, sum(nvl(df.subtotal,0)) total,count(*) cant
from factura f,detalle_factura df,tipo_material tm, conceptos c, conceptos_tipo ct, empresas e
where f.id_fact = df.id_fact 
and df.tipo_item=tm.abrev and f.status='V' and tipo_item = 'DC' and f.rif=e.rif 
and c.id_concepto= ct.id_concepto and ct.tipo=df.tipo_item
and nvl(f.rif,' ') in (select rif from empresa_tipo where tipo = 2)
group by f.prog_academico,c.orden,e.razon,f.fecha_emi,df.id_fact,df.tipo_item,df.item,tm.descripcion,p_unidad
UNION
/*Diplomados Empresas Cuentas x Cobrar*/
select 3 prog_academico,c.orden orden,e.razon concepto,null curso,null nivel,f.fecha_emi fec_fac,df.id_fact,df.tipo_item,df.item,tm.descripcion,p_unidad p_venta, sum(df.subtotal*-1) total,count(*) cant
from factura f,detalle_factura df,tipo_material tm, conceptos c, conceptos_tipo ct, empresas e, cuentas_por_cobrar cc
where f.id_fact = df.id_fact 
and df.tipo_item=tm.abrev and f.status='V' and tipo_item = 'DC' and f.rif=e.rif and f.rif=cc.cliente and f.id_fact=cc.id_fact
and c.id_concepto= ct.id_concepto and ct.tipo=df.tipo_item
and nvl(f.rif,' ') in (select rif from empresa_tipo where tipo = 2)
group by f.prog_academico,c.orden,e.razon,f.fecha_emi,df.id_fact,df.tipo_item,df.item,tm.descripcion,p_unidad
UNION
/*Bancos*/
select distinct f.prog_academico,1 orden,fp.descripcion concepto,null curso, null nivel,f.fecha_emi fec_fac,to_number(fd.referencia) ID_FACT,decode(d.forma_pago,3,'DEPOSITOS','PUNTO DE VENTA') tipo_item,to_char(fd.id_banco) item,b.nombre descripcion,0 P_VENTA,d.monto total, 1 cant
from factura f,factura_deposito fd, bancos b, deposito d, forma_pago fp
where f.id_fact=fd.id_fact
AND f.status='V'
and b.id_banco=fd.id_banco and fd.id_banco=d.ID_BANCO and fd.referencia=d.referencia and d.forma_pago = fp.id_pago
and nvl(f.rif,' ') not in (select rif from empresa_tipo where tipo = 1)
)
group by decode(prog_academico,1,'IDIOMAS',2,'IDIOMAS',3,'DIPLOMADOS',6,'DIRECCION CENTRAL'),orden, fec_fac,tipo_item,item
;
--------------------------------------------------------
--  DDL for Type STRING_AGG_TYPE
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TYPE "FUNDAUC"."STRING_AGG_TYPE" as object
   (
      total varchar2(4000),
      static function
           ODCIAggregateInitialize(sctx IN OUT string_agg_type )
           return number,
      member function
           ODCIAggregateIterate(self IN OUT string_agg_type ,
                                value IN varchar2 )
           return number,
      member function
           ODCIAggregateTerminate(self IN string_agg_type,
                                  returnValue OUT  varchar2,
                                  flags IN number)
           return number,
      member function
           ODCIAggregateMerge(self IN OUT string_agg_type,
                              ctx2 IN string_agg_type)
           return number
 )
/
CREATE OR REPLACE EDITIONABLE TYPE BODY "FUNDAUC"."STRING_AGG_TYPE" 
   is
   static function ODCIAggregateInitialize(sctx IN OUT string_agg_type)
   return number
   is
   begin
       sctx := string_agg_type( null );
       return ODCIConst.Success;
   end;
   member function ODCIAggregateIterate(self IN OUT string_agg_type,
                                        value IN varchar2 )
   return number
   is
   begin
       self.total := self.total || ',' || value;
       return ODCIConst.Success;
   end;
   member function ODCIAggregateTerminate(self IN string_agg_type,
                                          returnValue OUT varchar2,
                                          flags IN number)
   return number
   is
   begin
       returnValue := ltrim(self.total,',');
       return ODCIConst.Success;
   end;
   member function ODCIAggregateMerge(self IN OUT string_agg_type,
                                      ctx2 IN string_agg_type)
  return number
   is
   begin
       self.total := self.total || ctx2.total;
       return ODCIConst.Success;
   end;
   end;



/
-- No se ha podido presentar el DDL TYPE para el objeto FUNDAUC.SYS_PLSQL_A57DFA36_DUMMY_1 mientras que DBMS_METADATA intenta utilizar el generador interno.
CREATE TYPE           SYS_PLSQL_A57DFA36_DUMMY_1 as table of number;
-- No se ha podido presentar el DDL TYPE para el objeto FUNDAUC.SYS_PLSQL_A57DFA36_183_1 mientras que DBMS_METADATA intenta utilizar el generador interno.
CREATE TYPE           SYS_PLSQL_A57DFA36_183_1 as table of "FUNDAUC"."SYS_PLSQL_A57DFA36_87_1";
-- No se ha podido presentar el DDL TYPE para el objeto FUNDAUC.SYS_PLSQL_A57DFA36_87_1 mientras que DBMS_METADATA intenta utilizar el generador interno.
CREATE TYPE           SYS_PLSQL_A57DFA36_87_1 as object (TIPO_ITEM VARCHAR2(2 BYTE),
FECHA DATE,
PRECIO1 NUMBER(14,2),
PRECIO2 NUMBER(14,2),
PRECIO3 NUMBER(14,2),
STATUS VARCHAR2(1 BYTE),
PRECIO4 NUMBER(14,2),
PRECIO5 NUMBER(14,2),
ID NUMBER,
HASH VARCHAR2(40 BYTE),
ROW_ID VARCHAR2(64 BYTE));
-- No se ha podido presentar el DDL TYPE para el objeto FUNDAUC.SYS_PLSQL_A9D531FF_DUMMY_1 mientras que DBMS_METADATA intenta utilizar el generador interno.
CREATE TYPE           SYS_PLSQL_A9D531FF_DUMMY_1 as table of number;
-- No se ha podido presentar el DDL TYPE para el objeto FUNDAUC.SYS_PLSQL_A9D531FF_149_1 mientras que DBMS_METADATA intenta utilizar el generador interno.
CREATE TYPE           SYS_PLSQL_A9D531FF_149_1 as table of "FUNDAUC"."SYS_PLSQL_A9D531FF_71_1";
-- No se ha podido presentar el DDL TYPE para el objeto FUNDAUC.SYS_PLSQL_A9D531FF_71_1 mientras que DBMS_METADATA intenta utilizar el generador interno.
CREATE TYPE           SYS_PLSQL_A9D531FF_71_1 as object (ID NUMBER,
CLIENTE_ID NUMBER,
FECHA DATE,
FACTURA_ID NUMBER,
DEPOSITO_ID NUMBER,
CREDITO VARCHAR2(2 BYTE),
MONTO NUMBER(12,2),
HASH VARCHAR2(40 BYTE),
ROW_ID VARCHAR2(64 BYTE));
-- No se ha podido presentar el DDL TYPE para el objeto FUNDAUC.SYS_PLSQL_D26CE444_DUMMY_1 mientras que DBMS_METADATA intenta utilizar el generador interno.
CREATE TYPE           SYS_PLSQL_D26CE444_DUMMY_1 as table of number;
-- No se ha podido presentar el DDL TYPE para el objeto FUNDAUC.SYS_PLSQL_D26CE444_135_1 mientras que DBMS_METADATA intenta utilizar el generador interno.
CREATE TYPE           SYS_PLSQL_D26CE444_135_1 as object (ID NUMBER,
FECHA_INS TIMESTAMP (6) ,
EST_MATRICULA NUMBER(10),
FECHA_PAGO DATE,
ESTATUS VARCHAR2(255 BYTE),
SECCION_ID NUMBER,
PERIODO_ID NUMBER,
CREADO_POR VARCHAR2(255 BYTE),
ES_EXONERADO CHAR(1 BYTE),
PROG_ACADEMICO NUMBER,
ES_SUSPENDIDO CHAR(1 BYTE),
COHORTE_ID NUMBER,
HORARIO_ID NUMBER,
MODIFICADO_POR VARCHAR2(255 BYTE),
MODIFICADO_EL DATE,
HASH VARCHAR2(40 BYTE),
ROW_ID VARCHAR2(64 BYTE));
-- No se ha podido presentar el DDL TYPE para el objeto FUNDAUC.SYS_PLSQL_D26CE444_285_1 mientras que DBMS_METADATA intenta utilizar el generador interno.
CREATE TYPE           SYS_PLSQL_D26CE444_285_1 as table of "FUNDAUC"."SYS_PLSQL_D26CE444_135_1";
-- No se ha podido presentar el DDL TYPE para el objeto FUNDAUC.SYS_PLSQL_D3F5E14_DUMMY_1 mientras que DBMS_METADATA intenta utilizar el generador interno.
CREATE TYPE           SYS_PLSQL_D3F5E14_DUMMY_1 as table of number;
-- No se ha podido presentar el DDL TYPE para el objeto FUNDAUC.SYS_PLSQL_D3F5E14_47_1 mientras que DBMS_METADATA intenta utilizar el generador interno.
CREATE TYPE           SYS_PLSQL_D3F5E14_47_1 as object (ID_CONDICION VARCHAR2(2 BYTE),
DESCRIPCION VARCHAR2(30 BYTE),
DESCUENTO VARCHAR2(10 BYTE),
PORCENTAJE NUMBER(10,2),
HASH VARCHAR2(40 BYTE),
ROW_ID VARCHAR2(64 BYTE));
-- No se ha podido presentar el DDL TYPE para el objeto FUNDAUC.SYS_PLSQL_D3F5E14_98_1 mientras que DBMS_METADATA intenta utilizar el generador interno.
CREATE TYPE           SYS_PLSQL_D3F5E14_98_1 as table of "FUNDAUC"."SYS_PLSQL_D3F5E14_47_1";
-- No se ha podido presentar el DDL TYPE para el objeto FUNDAUC.SYS_PLSQL_D984D45A_DUMMY_1 mientras que DBMS_METADATA intenta utilizar el generador interno.
CREATE TYPE           SYS_PLSQL_D984D45A_DUMMY_1 as table of number;
-- No se ha podido presentar el DDL TYPE para el objeto FUNDAUC.SYS_PLSQL_D984D45A_183_1 mientras que DBMS_METADATA intenta utilizar el generador interno.
CREATE TYPE           SYS_PLSQL_D984D45A_183_1 as table of "FUNDAUC"."SYS_PLSQL_D984D45A_87_1";
-- No se ha podido presentar el DDL TYPE para el objeto FUNDAUC.SYS_PLSQL_D984D45A_87_1 mientras que DBMS_METADATA intenta utilizar el generador interno.
CREATE TYPE           SYS_PLSQL_D984D45A_87_1 as object (REFERENCIA VARCHAR2(20 BYTE),
FECHA_EMI DATE,
ID_BANCO NUMBER(2),
MONTO NUMBER(14,2),
SEDE VARCHAR2(5 BYTE),
USUARIO VARCHAR2(50 BYTE),
STATUS VARCHAR2(1 BYTE),
FORMA_PAGO NUMBER(2),
ID NUMBER,
HASH VARCHAR2(40 BYTE),
ROW_ID VARCHAR2(64 BYTE));
-- No se ha podido presentar el DDL TYPE para el objeto FUNDAUC.SYS_PLSQL_FD56EEDC_DUMMY_1 mientras que DBMS_METADATA intenta utilizar el generador interno.
CREATE TYPE           SYS_PLSQL_FD56EEDC_DUMMY_1 as table of number;
-- No se ha podido presentar el DDL TYPE para el objeto FUNDAUC.SYS_PLSQL_FD56EEDC_111_1 mientras que DBMS_METADATA intenta utilizar el generador interno.
CREATE TYPE           SYS_PLSQL_FD56EEDC_111_1 as object (ID NUMBER,
SECCION_ID NUMBER,
CODIGO_SEC VARCHAR2(50 BYTE),
METODO_ID VARCHAR2(20 BYTE),
NIVEL NUMBER(2),
PERIODO_ID NUMBER,
HORARIO_ID NUMBER,
MODALIDAD_ID NUMBER,
CEDULA_PROF VARCHAR2(20 BYTE),
F_INICIO DATE,
F_FIN DATE,
ESTATUS VARCHAR2(20 BYTE),
HASH VARCHAR2(40 BYTE),
ROW_ID VARCHAR2(64 BYTE));
-- No se ha podido presentar el DDL TYPE para el objeto FUNDAUC.SYS_PLSQL_FD56EEDC_234_1 mientras que DBMS_METADATA intenta utilizar el generador interno.
CREATE TYPE           SYS_PLSQL_FD56EEDC_234_1 as table of "FUNDAUC"."SYS_PLSQL_FD56EEDC_111_1";
-- No se ha podido presentar el DDL TYPE para el objeto FUNDAUC.SYS_PLSQL_103C5D84_DUMMY_1 mientras que DBMS_METADATA intenta utilizar el generador interno.
CREATE TYPE           SYS_PLSQL_103C5D84_DUMMY_1 as table of number;
-- No se ha podido presentar el DDL TYPE para el objeto FUNDAUC.SYS_PLSQL_103C5D84_231_1 mientras que DBMS_METADATA intenta utilizar el generador interno.
CREATE TYPE           SYS_PLSQL_103C5D84_231_1 as object (CEDULA_EST NUMBER(10),
NACIONALIDAD CHAR(1 BYTE),
NOMBRE VARCHAR2(50 BYTE),
TELF_HAB VARCHAR2(14 BYTE),
TELF_CEL VARCHAR2(14 BYTE),
CIUDAD NUMBER(10),
ESTADO NUMBER(10),
EMAIL VARCHAR2(50 BYTE),
SEXO CHAR(1 BYTE),
EDO_CIVIL VARCHAR2(20 BYTE),
GRADO_INS VARCHAR2(20 BYTE),
PROFESION NUMBER,
FECHA_NAC DATE,
STATUS VARCHAR2(2 BYTE),
ID_TIPO_EST VARCHAR2(1 BYTE),
RIF VARCHAR2(16 BYTE),
MATRICULA NUMBER(10),
SEDE VARCHAR2(3 BYTE),
CONDICION_ESPECIAL VARCHAR2(2 BYTE),
APELLIDO VARCHAR2(30 BYTE),
ZONA NUMBER,
CEDULA_REP VARCHAR2(16 BYTE),
DIRECCION VARCHAR2(500 BYTE),
CREADO_POR VARCHAR2(30 BYTE),
CREADO_EL DATE,
MODIFICADO_POR VARCHAR2(30 BYTE),
MODIFICADO_EL DATE,
HASH VARCHAR2(40 BYTE),
ROW_ID VARCHAR2(64 BYTE));
-- No se ha podido presentar el DDL TYPE para el objeto FUNDAUC.SYS_PLSQL_103C5D84_489_1 mientras que DBMS_METADATA intenta utilizar el generador interno.
CREATE TYPE           SYS_PLSQL_103C5D84_489_1 as table of "FUNDAUC"."SYS_PLSQL_103C5D84_231_1";
-- No se ha podido presentar el DDL TYPE para el objeto FUNDAUC.SYS_PLSQL_4324232B_DUMMY_1 mientras que DBMS_METADATA intenta utilizar el generador interno.
CREATE TYPE           SYS_PLSQL_4324232B_DUMMY_1 as table of number;
-- No se ha podido presentar el DDL TYPE para el objeto FUNDAUC.SYS_PLSQL_4324232B_167_1 mientras que DBMS_METADATA intenta utilizar el generador interno.
CREATE TYPE           SYS_PLSQL_4324232B_167_1 as object (ID_SECCION VARCHAR2(50 BYTE),
ID_METODO VARCHAR2(10 BYTE),
NIVEL NUMBER(2),
ID_SALON NUMBER(3),
TOPE NUMBER(2),
STATUS CHAR(1 BYTE),
ID_EDIF NUMBER(3),
HORARIO VARCHAR2(17 BYTE),
CEDULA_PROF NUMBER(10),
MODALIDAD NUMBER(3),
FEC_INICIO DATE,
PERIODO NUMBER,
ID_HORARIO NUMBER(3),
ID_CALENDARIO NUMBER,
ID NUMBER,
CREADO_POR VARCHAR2(255 BYTE),
CREADO_EL DATE,
MODIFICADO_POR VARCHAR2(255 BYTE),
MODIFICADO_EL DATE,
HASH VARCHAR2(40 BYTE),
ROW_ID VARCHAR2(64 BYTE));
-- No se ha podido presentar el DDL TYPE para el objeto FUNDAUC.SYS_PLSQL_4324232B_353_1 mientras que DBMS_METADATA intenta utilizar el generador interno.
CREATE TYPE           SYS_PLSQL_4324232B_353_1 as table of "FUNDAUC"."SYS_PLSQL_4324232B_167_1";
-- No se ha podido presentar el DDL TYPE para el objeto FUNDAUC.SYS_PLSQL_4401B2CE_DUMMY_1 mientras que DBMS_METADATA intenta utilizar el generador interno.
CREATE TYPE           SYS_PLSQL_4401B2CE_DUMMY_1 as table of number;
-- No se ha podido presentar el DDL TYPE para el objeto FUNDAUC.SYS_PLSQL_4401B2CE_200_1 mientras que DBMS_METADATA intenta utilizar el generador interno.
CREATE TYPE           SYS_PLSQL_4401B2CE_200_1 as table of "FUNDAUC"."SYS_PLSQL_4401B2CE_95_1";
-- No se ha podido presentar el DDL TYPE para el objeto FUNDAUC.SYS_PLSQL_4401B2CE_95_1 mientras que DBMS_METADATA intenta utilizar el generador interno.
CREATE TYPE           SYS_PLSQL_4401B2CE_95_1 as object (RENGLON NUMBER(12),
TIPO_ITEM VARCHAR2(3 BYTE),
ITEM VARCHAR2(20 BYTE),
DESCRIPCION VARCHAR2(255 BYTE),
CANTIDAD NUMBER(8,2),
P_UNIDAD NUMBER(14,2),
BS_DESCUENTO NUMBER(14,2),
SUBTOTAL NUMBER(14,2),
MATERIALES_ID NUMBER,
FACTURA_ID NUMBER,
HASH VARCHAR2(40 BYTE),
ROW_ID VARCHAR2(64 BYTE));
-- No se ha podido presentar el DDL TYPE para el objeto FUNDAUC.SYS_PLSQL_48C7DF34_DUMMY_1 mientras que DBMS_METADATA intenta utilizar el generador interno.
CREATE TYPE           SYS_PLSQL_48C7DF34_DUMMY_1 as table of number;
-- No se ha podido presentar el DDL TYPE para el objeto FUNDAUC.SYS_PLSQL_48C7DF34_199_1 mientras que DBMS_METADATA intenta utilizar el generador interno.
CREATE TYPE           SYS_PLSQL_48C7DF34_199_1 as object (ID_FACT NUMBER(8),
TIPO VARCHAR2(2 BYTE),
CEDULA_EST NUMBER(10),
NOMBRE_CLIENTE VARCHAR2(100 BYTE),
FECHA_EMI DATE,
MONTO NUMBER(14,2),
P_IVA NUMBER(5,2),
MONTO_IVA NUMBER(14,2),
FLETE NUMBER(14,2),
BS_DESCUENTO NUMBER(14,2),
DIR_FISCAL VARCHAR2(500 BYTE),
RIF VARCHAR2(16 BYTE),
STATUS VARCHAR2(2 BYTE),
PROGRAMA VARCHAR2(3 BYTE),
PROG_ACADEMICO NUMBER(2),
CREADO_POR VARCHAR2(30 BYTE),
MONTO_EXENTO NUMBER(14,2),
BASE_IMPONIBLE NUMBER(14,2),
ID NUMBER,
CREADO_EL DATE,
FACTURADO_POR VARCHAR2(30 BYTE),
OBSERVACIONES VARCHAR2(2000 BYTE),
ESCREDITO CHAR(1 BYTE),
HASH VARCHAR2(40 BYTE),
ROW_ID VARCHAR2(64 BYTE));
-- No se ha podido presentar el DDL TYPE para el objeto FUNDAUC.SYS_PLSQL_48C7DF34_421_1 mientras que DBMS_METADATA intenta utilizar el generador interno.
CREATE TYPE           SYS_PLSQL_48C7DF34_421_1 as table of "FUNDAUC"."SYS_PLSQL_48C7DF34_199_1";
-- No se ha podido presentar el DDL TYPE para el objeto FUNDAUC.SYS_PLSQL_5F389762_DUMMY_1 mientras que DBMS_METADATA intenta utilizar el generador interno.
CREATE TYPE           SYS_PLSQL_5F389762_DUMMY_1 as table of number;
-- No se ha podido presentar el DDL TYPE para el objeto FUNDAUC.SYS_PLSQL_5F389762_149_1 mientras que DBMS_METADATA intenta utilizar el generador interno.
CREATE TYPE           SYS_PLSQL_5F389762_149_1 as table of "FUNDAUC"."SYS_PLSQL_5F389762_71_1";
-- No se ha podido presentar el DDL TYPE para el objeto FUNDAUC.SYS_PLSQL_5F389762_71_1 mientras que DBMS_METADATA intenta utilizar el generador interno.
CREATE TYPE           SYS_PLSQL_5F389762_71_1 as object (ID_CALENDARIO NUMBER(3),
PERIODO NUMBER(6),
FECHA_INI DATE,
FECHA_FIN DATE,
MODALIDAD NUMBER(2),
PERIODO_ACTIVO CHAR(1 BYTE),
ID NUMBER,
HASH VARCHAR2(40 BYTE),
ROW_ID VARCHAR2(64 BYTE));
-- No se ha podido presentar el DDL TYPE para el objeto FUNDAUC.SYS_PLSQL_563E914C_DUMMY_1 mientras que DBMS_METADATA intenta utilizar el generador interno.
CREATE TYPE           SYS_PLSQL_563E914C_DUMMY_1 as table of number;
-- No se ha podido presentar el DDL TYPE para el objeto FUNDAUC.SYS_PLSQL_563E914C_31_1 mientras que DBMS_METADATA intenta utilizar el generador interno.
CREATE TYPE           SYS_PLSQL_563E914C_31_1 as object (DEPOSITO_ID NUMBER,
FACTURA_ID NUMBER,
HASH VARCHAR2(40 BYTE),
ROW_ID VARCHAR2(64 BYTE));
-- No se ha podido presentar el DDL TYPE para el objeto FUNDAUC.SYS_PLSQL_563E914C_64_1 mientras que DBMS_METADATA intenta utilizar el generador interno.
CREATE TYPE           SYS_PLSQL_563E914C_64_1 as table of "FUNDAUC"."SYS_PLSQL_563E914C_31_1";
-- No se ha podido presentar el DDL TYPE para el objeto FUNDAUC.SYS_PLSQL_6C2F9E7E_DUMMY_1 mientras que DBMS_METADATA intenta utilizar el generador interno.
CREATE TYPE           SYS_PLSQL_6C2F9E7E_DUMMY_1 as table of number;
-- No se ha podido presentar el DDL TYPE para el objeto FUNDAUC.SYS_PLSQL_6C2F9E7E_47_1 mientras que DBMS_METADATA intenta utilizar el generador interno.
CREATE TYPE           SYS_PLSQL_6C2F9E7E_47_1 as object (ID_CALENDARIO NUMBER(3),
DESCRIPCION VARCHAR2(200 BYTE),
ACTIVO CHAR(1 BYTE),
TIPO_CAL CHAR(1 BYTE),
HASH VARCHAR2(40 BYTE),
ROW_ID VARCHAR2(64 BYTE));
-- No se ha podido presentar el DDL TYPE para el objeto FUNDAUC.SYS_PLSQL_6C2F9E7E_98_1 mientras que DBMS_METADATA intenta utilizar el generador interno.
CREATE TYPE           SYS_PLSQL_6C2F9E7E_98_1 as table of "FUNDAUC"."SYS_PLSQL_6C2F9E7E_47_1";
-- No se ha podido presentar el DDL TYPE para el objeto FUNDAUC.SYS_PLSQL_61F81DB9_DUMMY_1 mientras que DBMS_METADATA intenta utilizar el generador interno.
CREATE TYPE           SYS_PLSQL_61F81DB9_DUMMY_1 as table of number;
-- No se ha podido presentar el DDL TYPE para el objeto FUNDAUC.SYS_PLSQL_61F81DB9_132_1 mientras que DBMS_METADATA intenta utilizar el generador interno.
CREATE TYPE           SYS_PLSQL_61F81DB9_132_1 as table of "FUNDAUC"."SYS_PLSQL_61F81DB9_63_1";
-- No se ha podido presentar el DDL TYPE para el objeto FUNDAUC.SYS_PLSQL_61F81DB9_63_1 mientras que DBMS_METADATA intenta utilizar el generador interno.
CREATE TYPE           SYS_PLSQL_61F81DB9_63_1 as object (ID NUMBER,
MATRICULA NUMBER,
EVENTO_ID NUMBER,
FECHA TIMESTAMP (6) ,
METADATA CLOB,
OBSERVACION VARCHAR2(4000 BYTE),
HASH VARCHAR2(40 BYTE),
ROW_ID VARCHAR2(64 BYTE));
-- No se ha podido presentar el DDL TYPE para el objeto FUNDAUC.SYS_PLSQL_8FB2B9A5_DUMMY_1 mientras que DBMS_METADATA intenta utilizar el generador interno.
CREATE TYPE           SYS_PLSQL_8FB2B9A5_DUMMY_1 as table of number;
-- No se ha podido presentar el DDL TYPE para el objeto FUNDAUC.SYS_PLSQL_8FB2B9A5_207_1 mientras que DBMS_METADATA intenta utilizar el generador interno.
CREATE TYPE           SYS_PLSQL_8FB2B9A5_207_1 as object (CODIGO VARCHAR2(20 BYTE),
ID_HORARIO NUMBER,
ID_MODALIDAD NUMBER(2),
COHORTE NUMBER(3),
CUPO NUMBER(5),
COSTO NUMBER(14,2),
INICIAL NUMBER(14,2),
COSTO_CUOTA NUMBER(14,2),
CUOTAS NUMBER(3),
STATUS CHAR(1 BYTE),
ID_CIUDAD NUMBER,
ID NUMBER,
TIPO_DIPLO VARCHAR2(15 BYTE),
CREADO_POR VARCHAR2(255 BYTE),
CREADO_EL DATE,
MODIFICADO_POR VARCHAR2(255 BYTE),
MODIFICADO_EL DATE,
DIPLOMADO_ID NUMBER,
PERIODO NUMBER,
ID_CALENDARIO NUMBER,
NIVEL NUMBER,
ID_METODO NUMBER,
EMPRESA NUMBER,
FACILITADOR NUMBER(10),
HASH VARCHAR2(40 BYTE),
ROW_ID VARCHAR2(64 BYTE));
-- No se ha podido presentar el DDL TYPE para el objeto FUNDAUC.SYS_PLSQL_8FB2B9A5_438_1 mientras que DBMS_METADATA intenta utilizar el generador interno.
CREATE TYPE           SYS_PLSQL_8FB2B9A5_438_1 as table of "FUNDAUC"."SYS_PLSQL_8FB2B9A5_207_1";
-- No se ha podido presentar el DDL TYPE para el objeto FUNDAUC.SYS_PLSQL_9E128FDB_DUMMY_1 mientras que DBMS_METADATA intenta utilizar el generador interno.
CREATE TYPE           SYS_PLSQL_9E128FDB_DUMMY_1 as table of number;
-- No se ha podido presentar el DDL TYPE para el objeto FUNDAUC.SYS_PLSQL_9E128FDB_135_1 mientras que DBMS_METADATA intenta utilizar el generador interno.
CREATE TYPE           SYS_PLSQL_9E128FDB_135_1 as object (ID_MAT VARCHAR2(50 BYTE),
TIPO VARCHAR2(3 BYTE),
DESCRIPCION VARCHAR2(255 BYTE),
ID_CURSO VARCHAR2(10 BYTE),
EVENTO NUMBER(2),
NIVEL NUMBER(2),
IVA_EXENTO CHAR(1 BYTE),
ACTIVO CHAR(1 BYTE),
ID NUMBER,
SECCION_ID NUMBER,
CREADO_POR VARCHAR2(255 BYTE),
CREADO_EL DATE,
MODIFICADO_POR VARCHAR2(255 BYTE),
MODIFICADO_EL DATE,
COHORTE_ID NUMBER,
HASH VARCHAR2(40 BYTE),
ROW_ID VARCHAR2(64 BYTE));
-- No se ha podido presentar el DDL TYPE para el objeto FUNDAUC.SYS_PLSQL_9E128FDB_285_1 mientras que DBMS_METADATA intenta utilizar el generador interno.
CREATE TYPE           SYS_PLSQL_9E128FDB_285_1 as table of "FUNDAUC"."SYS_PLSQL_9E128FDB_135_1";
-- No se ha podido presentar el DDL TYPE para el objeto FUNDAUC.SYS_PLSQL_93F503A2_DUMMY_1 mientras que DBMS_METADATA intenta utilizar el generador interno.
CREATE TYPE           SYS_PLSQL_93F503A2_DUMMY_1 as table of number;
-- No se ha podido presentar el DDL TYPE para el objeto FUNDAUC.SYS_PLSQL_93F503A2_127_1 mientras que DBMS_METADATA intenta utilizar el generador interno.
CREATE TYPE           SYS_PLSQL_93F503A2_127_1 as object (CEDULA NUMBER(10),
NOMBRE_USUARIO VARCHAR2(50 BYTE),
CONTRASENA VARCHAR2(255 BYTE),
ID_ROL NUMBER(3),
EMAIL VARCHAR2(100 BYTE),
NOMBRE VARCHAR2(50 BYTE),
CIA NUMBER(2),
PROG_ACADEMICO NUMBER(2),
ACTIVO CHAR(1 BYTE),
BLOQUEADO CHAR(1 BYTE),
CREADO_POR VARCHAR2(100 BYTE),
CREADO_EL DATE,
MODIFICADO_POR VARCHAR2(100 BYTE),
MODIFICADO_EL DATE,
HASH VARCHAR2(40 BYTE),
ROW_ID VARCHAR2(64 BYTE));
-- No se ha podido presentar el DDL TYPE para el objeto FUNDAUC.SYS_PLSQL_93F503A2_268_1 mientras que DBMS_METADATA intenta utilizar el generador interno.
CREATE TYPE           SYS_PLSQL_93F503A2_268_1 as table of "FUNDAUC"."SYS_PLSQL_93F503A2_127_1";
--------------------------------------------------------
--  DDL for Table BANCOS
--------------------------------------------------------

  CREATE TABLE "FUNDAUC"."BANCOS" 
   (	"ID_BANCO" NUMBER(2,0), 
	"NOMBRE" VARCHAR2(100 BYTE), 
	"CIUDAD" VARCHAR2(20 BYTE), 
	"DEBITO" CHAR(1 BYTE), 
	"DEPOSITO" CHAR(1 BYTE), 
	"CREDITO" CHAR(1 BYTE), 
	"CTA" VARCHAR2(25 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;

   COMMENT ON COLUMN "FUNDAUC"."BANCOS"."ID_BANCO" IS 'ID_BANCO';
   COMMENT ON COLUMN "FUNDAUC"."BANCOS"."NOMBRE" IS 'NOMBRE';
   COMMENT ON COLUMN "FUNDAUC"."BANCOS"."CIUDAD" IS 'CIUDAD';
   COMMENT ON COLUMN "FUNDAUC"."BANCOS"."DEBITO" IS 'DEBITO';
   COMMENT ON COLUMN "FUNDAUC"."BANCOS"."DEPOSITO" IS 'DEPOSITO';
   COMMENT ON COLUMN "FUNDAUC"."BANCOS"."CREDITO" IS 'CREDITO';
   COMMENT ON COLUMN "FUNDAUC"."BANCOS"."CTA" IS 'CTA';
   COMMENT ON TABLE "FUNDAUC"."BANCOS"  IS 'BANCOS';
--------------------------------------------------------
--  DDL for Table CALENDARIOS
--------------------------------------------------------

  CREATE TABLE "FUNDAUC"."CALENDARIOS" 
   (	"ID_CALENDARIO" NUMBER(3,0), 
	"DESCRIPCION" VARCHAR2(200 BYTE), 
	"ACTIVO" CHAR(1 BYTE) DEFAULT 'S', 
	"TIPO_CAL" CHAR(1 BYTE) DEFAULT 'I'
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;

   COMMENT ON COLUMN "FUNDAUC"."CALENDARIOS"."ID_CALENDARIO" IS 'ID_CALENDARIO';
   COMMENT ON COLUMN "FUNDAUC"."CALENDARIOS"."DESCRIPCION" IS 'DESCRIPCION';
   COMMENT ON COLUMN "FUNDAUC"."CALENDARIOS"."ACTIVO" IS 'ACTIVO SI O NO';
   COMMENT ON TABLE "FUNDAUC"."CALENDARIOS"  IS 'CALENDARIOS';
--------------------------------------------------------
--  DDL for Table CALENDARIOS_DETALLE
--------------------------------------------------------

  CREATE TABLE "FUNDAUC"."CALENDARIOS_DETALLE" 
   (	"ID_CALENDARIO" NUMBER(3,0), 
	"PERIODO" NUMBER(6,0), 
	"FECHA_INI" DATE, 
	"FECHA_FIN" DATE, 
	"MODALIDAD" NUMBER(2,0), 
	"PERIODO_ACTIVO" CHAR(1 BYTE) DEFAULT 'S', 
	"ID" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;

   COMMENT ON COLUMN "FUNDAUC"."CALENDARIOS_DETALLE"."ID_CALENDARIO" IS 'ID_CALENDARIO';
   COMMENT ON COLUMN "FUNDAUC"."CALENDARIOS_DETALLE"."PERIODO" IS 'PERIODO';
   COMMENT ON COLUMN "FUNDAUC"."CALENDARIOS_DETALLE"."FECHA_INI" IS 'FECHA_INI';
   COMMENT ON COLUMN "FUNDAUC"."CALENDARIOS_DETALLE"."FECHA_FIN" IS 'FECHA_FIN';
   COMMENT ON COLUMN "FUNDAUC"."CALENDARIOS_DETALLE"."MODALIDAD" IS 'MODALIDAD';
   COMMENT ON COLUMN "FUNDAUC"."CALENDARIOS_DETALLE"."PERIODO_ACTIVO" IS 'Si el Periodo esta Activo o no';
   COMMENT ON COLUMN "FUNDAUC"."CALENDARIOS_DETALLE"."ID" IS 'Identificador Unico de Calendario';
   COMMENT ON TABLE "FUNDAUC"."CALENDARIOS_DETALLE"  IS 'CALENDARIOS_DETALLE';
--------------------------------------------------------
--  DDL for Table CIUDADES
--------------------------------------------------------

  CREATE TABLE "FUNDAUC"."CIUDADES" 
   (	"ID_CIUDAD" NUMBER(10,0), 
	"ID_ESTADO" NUMBER(10,0), 
	"NOMBRE" VARCHAR2(255 BYTE), 
	"ES_CAPITAL" CHAR(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;

   COMMENT ON COLUMN "FUNDAUC"."CIUDADES"."ID_CIUDAD" IS 'ID_CIUDAD';
   COMMENT ON COLUMN "FUNDAUC"."CIUDADES"."ID_ESTADO" IS 'ID_ESTADO';
   COMMENT ON COLUMN "FUNDAUC"."CIUDADES"."NOMBRE" IS 'NOMBRE';
   COMMENT ON TABLE "FUNDAUC"."CIUDADES"  IS 'CIUDADES';
--------------------------------------------------------
--  DDL for Table CLIENTES
--------------------------------------------------------

  CREATE TABLE "FUNDAUC"."CLIENTES" 
   (	"RIF" VARCHAR2(16 BYTE), 
	"RAZON" VARCHAR2(60 BYTE), 
	"DIRECCION" VARCHAR2(100 BYTE), 
	"TELEFONO" VARCHAR2(14 BYTE), 
	"ID" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 131072 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;

   COMMENT ON COLUMN "FUNDAUC"."CLIENTES"."RIF" IS 'RIF';
   COMMENT ON COLUMN "FUNDAUC"."CLIENTES"."RAZON" IS 'RAZON';
   COMMENT ON COLUMN "FUNDAUC"."CLIENTES"."DIRECCION" IS 'DIRECCION';
   COMMENT ON COLUMN "FUNDAUC"."CLIENTES"."TELEFONO" IS 'TELEFONO';
   COMMENT ON TABLE "FUNDAUC"."CLIENTES"  IS 'EMPRESAS';
--------------------------------------------------------
--  DDL for Table CLIENTES_BAK
--------------------------------------------------------

  CREATE TABLE "FUNDAUC"."CLIENTES_BAK" 
   (	"RIF" VARCHAR2(16 BYTE), 
	"RAZON" VARCHAR2(60 BYTE), 
	"DIRECCION" VARCHAR2(100 BYTE), 
	"TELEFONO" VARCHAR2(14 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 131072 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Table COHORTES
--------------------------------------------------------

  CREATE TABLE "FUNDAUC"."COHORTES" 
   (	"CODIGO" VARCHAR2(20 BYTE), 
	"ID_HORARIO" NUMBER, 
	"ID_MODALIDAD" NUMBER(2,0), 
	"COHORTE" NUMBER(3,0), 
	"CUPO" NUMBER(5,0), 
	"COSTO" NUMBER(14,2), 
	"INICIAL" NUMBER(14,2), 
	"COSTO_CUOTA" NUMBER(14,2), 
	"CUOTAS" NUMBER(3,0), 
	"STATUS" CHAR(1 BYTE), 
	"ID_CIUDAD" NUMBER, 
	"ID" NUMBER, 
	"TIPO_DIPLO" VARCHAR2(15 BYTE), 
	"CREADO_POR" VARCHAR2(255 BYTE), 
	"CREADO_EL" DATE, 
	"MODIFICADO_POR" VARCHAR2(255 BYTE), 
	"MODIFICADO_EL" DATE, 
	"DIPLOMADO_ID" NUMBER, 
	"PERIODO" NUMBER, 
	"ID_CALENDARIO" NUMBER, 
	"NIVEL" NUMBER, 
	"ID_METODO" NUMBER, 
	"EMPRESA" NUMBER, 
	"FACILITADOR" NUMBER(10,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 131072 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;

   COMMENT ON COLUMN "FUNDAUC"."COHORTES"."CODIGO" IS 'CODIGO';
   COMMENT ON COLUMN "FUNDAUC"."COHORTES"."ID_HORARIO" IS 'ID_HORARIO';
   COMMENT ON COLUMN "FUNDAUC"."COHORTES"."ID_MODALIDAD" IS 'ID_MODALIDAD';
   COMMENT ON COLUMN "FUNDAUC"."COHORTES"."COHORTE" IS 'COHORTE';
   COMMENT ON COLUMN "FUNDAUC"."COHORTES"."CUPO" IS 'CANT_ACTUAL';
   COMMENT ON COLUMN "FUNDAUC"."COHORTES"."COSTO" IS 'COSTO';
   COMMENT ON COLUMN "FUNDAUC"."COHORTES"."INICIAL" IS 'INICIAL';
   COMMENT ON COLUMN "FUNDAUC"."COHORTES"."COSTO_CUOTA" IS 'COSTO_CUOTA';
   COMMENT ON COLUMN "FUNDAUC"."COHORTES"."CUOTAS" IS 'CUOTAS';
   COMMENT ON COLUMN "FUNDAUC"."COHORTES"."STATUS" IS 'STATUS';
   COMMENT ON COLUMN "FUNDAUC"."COHORTES"."ID_CIUDAD" IS 'CIUDAD';
   COMMENT ON COLUMN "FUNDAUC"."COHORTES"."ID" IS 'Identificador unico de Cohorte';
   COMMENT ON COLUMN "FUNDAUC"."COHORTES"."TIPO_DIPLO" IS 'Tipo de diplomado: Ej ADMINISTRADO, CERTIFICACION';
   COMMENT ON COLUMN "FUNDAUC"."COHORTES"."CREADO_POR" IS 'usuario quien crea la seccion';
   COMMENT ON COLUMN "FUNDAUC"."COHORTES"."CREADO_EL" IS 'Fecha de Creacion';
   COMMENT ON COLUMN "FUNDAUC"."COHORTES"."MODIFICADO_POR" IS 'usuario quien modifica la seccion';
   COMMENT ON COLUMN "FUNDAUC"."COHORTES"."MODIFICADO_EL" IS 'Fecha de Modificacion';
   COMMENT ON TABLE "FUNDAUC"."COHORTES"  IS 'COHORTES';
--------------------------------------------------------
--  DDL for Table COMPANIAS
--------------------------------------------------------

  CREATE TABLE "FUNDAUC"."COMPANIAS" 
   (	"CODIGO" VARCHAR2(3 BYTE), 
	"DESCRIPCION" VARCHAR2(100 BYTE), 
	"ID" NUMBER(2,0), 
	"DIRECCION" VARCHAR2(200 BYTE), 
	"TELEFONO" VARCHAR2(30 BYTE), 
	"EMAIL" VARCHAR2(50 BYTE), 
	"DIRECTOR" VARCHAR2(60 BYTE), 
	"CIUDAD" VARCHAR2(30 BYTE), 
	"SERIE" VARCHAR2(10 BYTE), 
	"ACTIVA" CHAR(1 BYTE) DEFAULT 'S', 
	"IVA" NUMBER(10,2)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;

   COMMENT ON COLUMN "FUNDAUC"."COMPANIAS"."CODIGO" IS 'CODIGO';
   COMMENT ON COLUMN "FUNDAUC"."COMPANIAS"."DESCRIPCION" IS 'DESCRIPCION';
   COMMENT ON COLUMN "FUNDAUC"."COMPANIAS"."ID" IS 'ID';
   COMMENT ON COLUMN "FUNDAUC"."COMPANIAS"."DIRECCION" IS 'DIRECCION';
   COMMENT ON COLUMN "FUNDAUC"."COMPANIAS"."TELEFONO" IS 'TELEFONO';
   COMMENT ON COLUMN "FUNDAUC"."COMPANIAS"."EMAIL" IS 'EMAIL';
   COMMENT ON COLUMN "FUNDAUC"."COMPANIAS"."DIRECTOR" IS 'DIRECTOR';
   COMMENT ON COLUMN "FUNDAUC"."COMPANIAS"."CIUDAD" IS 'CIUDAD';
   COMMENT ON COLUMN "FUNDAUC"."COMPANIAS"."SERIE" IS 'SERIE';
   COMMENT ON COLUMN "FUNDAUC"."COMPANIAS"."ACTIVA" IS 'ACTIVA';
   COMMENT ON COLUMN "FUNDAUC"."COMPANIAS"."IVA" IS 'IVA';
   COMMENT ON TABLE "FUNDAUC"."COMPANIAS"  IS 'COMPANIAS';
--------------------------------------------------------
--  DDL for Table CONDICIONES_ESPECIALES
--------------------------------------------------------

  CREATE TABLE "FUNDAUC"."CONDICIONES_ESPECIALES" 
   (	"ID_CONDICION" VARCHAR2(2 BYTE), 
	"DESCRIPCION" VARCHAR2(30 BYTE), 
	"DESCUENTO" VARCHAR2(10 BYTE), 
	"PORCENTAJE" NUMBER(10,2)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;

   COMMENT ON COLUMN "FUNDAUC"."CONDICIONES_ESPECIALES"."ID_CONDICION" IS 'ID_CONDICION';
   COMMENT ON COLUMN "FUNDAUC"."CONDICIONES_ESPECIALES"."DESCRIPCION" IS 'DESCRIPCION';
   COMMENT ON COLUMN "FUNDAUC"."CONDICIONES_ESPECIALES"."DESCUENTO" IS 'DESCUENTO';
   COMMENT ON COLUMN "FUNDAUC"."CONDICIONES_ESPECIALES"."PORCENTAJE" IS 'PORCENTAJE DE DESCUENTO';
   COMMENT ON TABLE "FUNDAUC"."CONDICIONES_ESPECIALES"  IS 'CONDICIONES_ESPECIALES';
--------------------------------------------------------
--  DDL for Table CONFIGURACION
--------------------------------------------------------

  CREATE TABLE "FUNDAUC"."CONFIGURACION" 
   (	"ULT_FACTURA" NUMBER, 
	"PORC_TARJ_DEB" NUMBER(10,5), 
	"PORC_TARJ_CRE" NUMBER(10,5), 
	"TASA_IVA" NUMBER(10,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;

   COMMENT ON COLUMN "FUNDAUC"."CONFIGURACION"."ULT_FACTURA" IS 'Ultimo Correlativo de Factura automatica';
   COMMENT ON COLUMN "FUNDAUC"."CONFIGURACION"."PORC_TARJ_DEB" IS 'Porcentaje Comision tarjeta de Debito';
   COMMENT ON COLUMN "FUNDAUC"."CONFIGURACION"."PORC_TARJ_CRE" IS 'Porcentaje comision Tarjeta de Credito';
--------------------------------------------------------
--  DDL for Table CTAXCOB
--------------------------------------------------------

  CREATE TABLE "FUNDAUC"."CTAXCOB" 
   (	"ID" NUMBER, 
	"CLIENTE_ID" NUMBER, 
	"FECHA" DATE, 
	"FACTURA_ID" NUMBER, 
	"DEPOSITO_ID" NUMBER, 
	"CREDITO" VARCHAR2(2 BYTE), 
	"MONTO" NUMBER(12,2)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Table DEPOSITO
--------------------------------------------------------

  CREATE TABLE "FUNDAUC"."DEPOSITO" 
   (	"REFERENCIA" VARCHAR2(20 BYTE), 
	"FECHA_EMI" DATE, 
	"ID_BANCO" NUMBER(2,0), 
	"MONTO" NUMBER(14,2), 
	"SEDE" VARCHAR2(5 BYTE), 
	"USUARIO" VARCHAR2(50 BYTE) DEFAULT coalesce(sys_context('APEX$SESSION', 'app_user'), regexp_substr(sys_context('userenv', 'client_identifier'), '^[^:]*'), sys_context('userenv', 'session_user')), 
	"STATUS" VARCHAR2(1 BYTE), 
	"FORMA_PAGO" NUMBER(2,0), 
	"ID" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 262144 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;

   COMMENT ON COLUMN "FUNDAUC"."DEPOSITO"."REFERENCIA" IS 'REFERENCIA';
   COMMENT ON COLUMN "FUNDAUC"."DEPOSITO"."FECHA_EMI" IS 'FECHA_EMI';
   COMMENT ON COLUMN "FUNDAUC"."DEPOSITO"."ID_BANCO" IS 'ID_BANCO';
   COMMENT ON COLUMN "FUNDAUC"."DEPOSITO"."MONTO" IS 'MONTO';
   COMMENT ON COLUMN "FUNDAUC"."DEPOSITO"."SEDE" IS 'CIA';
   COMMENT ON COLUMN "FUNDAUC"."DEPOSITO"."USUARIO" IS 'USUARIO';
   COMMENT ON COLUMN "FUNDAUC"."DEPOSITO"."STATUS" IS 'STATUS';
   COMMENT ON COLUMN "FUNDAUC"."DEPOSITO"."FORMA_PAGO" IS 'FORMA_PAGO';
   COMMENT ON COLUMN "FUNDAUC"."DEPOSITO"."ID" IS 'Identificador Unido del Pago de factura';
   COMMENT ON TABLE "FUNDAUC"."DEPOSITO"  IS 'DEPOSITO';
--------------------------------------------------------
--  DDL for Table DEPT
--------------------------------------------------------

  CREATE TABLE "FUNDAUC"."DEPT" 
   (	"DEPTNO" NUMBER(2,0), 
	"DNAME" VARCHAR2(14 BYTE), 
	"LOC" VARCHAR2(13 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Table DETALLE_FACTURA
--------------------------------------------------------

  CREATE TABLE "FUNDAUC"."DETALLE_FACTURA" 
   (	"RENGLON" NUMBER(12,0), 
	"TIPO_ITEM" VARCHAR2(3 BYTE), 
	"ITEM" VARCHAR2(20 BYTE), 
	"DESCRIPCION" VARCHAR2(255 BYTE), 
	"CANTIDAD" NUMBER(8,2), 
	"P_UNIDAD" NUMBER(14,2), 
	"BS_DESCUENTO" NUMBER(14,2), 
	"SUBTOTAL" NUMBER(14,2), 
	"MATERIALES_ID" NUMBER, 
	"FACTURA_ID" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 851968 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;

   COMMENT ON COLUMN "FUNDAUC"."DETALLE_FACTURA"."RENGLON" IS 'RENGLON';
   COMMENT ON COLUMN "FUNDAUC"."DETALLE_FACTURA"."TIPO_ITEM" IS 'TIPO_ITEM';
   COMMENT ON COLUMN "FUNDAUC"."DETALLE_FACTURA"."DESCRIPCION" IS 'DESCRIPCION';
   COMMENT ON COLUMN "FUNDAUC"."DETALLE_FACTURA"."CANTIDAD" IS 'CANTIDAD';
   COMMENT ON COLUMN "FUNDAUC"."DETALLE_FACTURA"."P_UNIDAD" IS 'P_UNIDAD';
   COMMENT ON COLUMN "FUNDAUC"."DETALLE_FACTURA"."BS_DESCUENTO" IS 'BS_DESCUENTO';
   COMMENT ON COLUMN "FUNDAUC"."DETALLE_FACTURA"."SUBTOTAL" IS 'SUBTOTAL';
   COMMENT ON COLUMN "FUNDAUC"."DETALLE_FACTURA"."FACTURA_ID" IS 'id de la factura';
   COMMENT ON TABLE "FUNDAUC"."DETALLE_FACTURA"  IS 'DETALLE_FACTURA';
--------------------------------------------------------
--  DDL for Table DIPLOMADOS
--------------------------------------------------------

  CREATE TABLE "FUNDAUC"."DIPLOMADOS" 
   (	"ID_DIPLOMADO" VARCHAR2(10 BYTE), 
	"DESCRIPCION" VARCHAR2(200 BYTE), 
	"HORAS" NUMBER(3,0), 
	"COORDINADOR" VARCHAR2(100 BYTE), 
	"MODULOS" NUMBER(3,0), 
	"STATUS" VARCHAR2(1 BYTE), 
	"CLASE_DOC" NUMBER(3,0), 
	"MINIMO" NUMBER(3,0), 
	"MAXIMO" NUMBER(3,0), 
	"COD_CONTABLE" VARCHAR2(15 BYTE), 
	"COD_DESCUENTO" VARCHAR2(15 BYTE), 
	"ID" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;

   COMMENT ON COLUMN "FUNDAUC"."DIPLOMADOS"."ID_DIPLOMADO" IS 'ID_DIPLOMADO';
   COMMENT ON COLUMN "FUNDAUC"."DIPLOMADOS"."DESCRIPCION" IS 'DESCRIPCION';
   COMMENT ON COLUMN "FUNDAUC"."DIPLOMADOS"."HORAS" IS 'HORAS';
   COMMENT ON COLUMN "FUNDAUC"."DIPLOMADOS"."COORDINADOR" IS 'COORDINADOR';
   COMMENT ON COLUMN "FUNDAUC"."DIPLOMADOS"."MODULOS" IS 'MODULOS';
   COMMENT ON COLUMN "FUNDAUC"."DIPLOMADOS"."STATUS" IS 'STATUS';
   COMMENT ON COLUMN "FUNDAUC"."DIPLOMADOS"."CLASE_DOC" IS 'CLASE_DOC';
   COMMENT ON COLUMN "FUNDAUC"."DIPLOMADOS"."MINIMO" IS 'MINIMO';
   COMMENT ON COLUMN "FUNDAUC"."DIPLOMADOS"."MAXIMO" IS 'MAXIMO';
   COMMENT ON COLUMN "FUNDAUC"."DIPLOMADOS"."COD_CONTABLE" IS 'COD_CONTABLE';
   COMMENT ON COLUMN "FUNDAUC"."DIPLOMADOS"."COD_DESCUENTO" IS 'COD_DESCUENTO';
   COMMENT ON COLUMN "FUNDAUC"."DIPLOMADOS"."ID" IS 'Identificador unico de diplomado';
   COMMENT ON TABLE "FUNDAUC"."DIPLOMADOS"  IS 'DIPLOMADOS';
--------------------------------------------------------
--  DDL for Table EDIFICIOS
--------------------------------------------------------

  CREATE TABLE "FUNDAUC"."EDIFICIOS" 
   (	"ID_EDIF" NUMBER(3,0), 
	"DESCRIPCION" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;

   COMMENT ON COLUMN "FUNDAUC"."EDIFICIOS"."ID_EDIF" IS 'ID_EDIF';
   COMMENT ON COLUMN "FUNDAUC"."EDIFICIOS"."DESCRIPCION" IS 'DESCRIPCION';
   COMMENT ON TABLE "FUNDAUC"."EDIFICIOS"  IS 'EDIFICIOS';
--------------------------------------------------------
--  DDL for Table EMP
--------------------------------------------------------

  CREATE TABLE "FUNDAUC"."EMP" 
   (	"EMPNO" NUMBER(4,0), 
	"ENAME" VARCHAR2(10 BYTE), 
	"JOB" VARCHAR2(9 BYTE), 
	"MGR" NUMBER(4,0), 
	"HIREDATE" DATE, 
	"SAL" NUMBER(7,2), 
	"COMM" NUMBER(7,2), 
	"DEPTNO" NUMBER(2,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Table ESTADOS
--------------------------------------------------------

  CREATE TABLE "FUNDAUC"."ESTADOS" 
   (	"ID_ESTADO" NUMBER(10,0), 
	"NOMBRE" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;

   COMMENT ON COLUMN "FUNDAUC"."ESTADOS"."ID_ESTADO" IS 'ID_ESTADO';
   COMMENT ON COLUMN "FUNDAUC"."ESTADOS"."NOMBRE" IS 'NOMBRE';
   COMMENT ON TABLE "FUNDAUC"."ESTADOS"  IS 'ESTADOS';
--------------------------------------------------------
--  DDL for Table ESTUDIANTE
--------------------------------------------------------

  CREATE TABLE "FUNDAUC"."ESTUDIANTE" 
   (	"CEDULA_EST" NUMBER(10,0), 
	"NACIONALIDAD" CHAR(1 BYTE), 
	"NOMBRE" VARCHAR2(50 BYTE), 
	"TELF_HAB" VARCHAR2(14 BYTE), 
	"TELF_CEL" VARCHAR2(14 BYTE), 
	"CIUDAD" NUMBER(10,0), 
	"ESTADO" NUMBER(10,0), 
	"EMAIL" VARCHAR2(50 BYTE), 
	"SEXO" CHAR(1 BYTE), 
	"EDO_CIVIL" VARCHAR2(20 BYTE), 
	"GRADO_INS" VARCHAR2(20 BYTE), 
	"PROFESION" NUMBER, 
	"FECHA_NAC" DATE, 
	"STATUS" VARCHAR2(2 BYTE), 
	"ID_TIPO_EST" VARCHAR2(1 BYTE), 
	"RIF" VARCHAR2(16 BYTE), 
	"MATRICULA" NUMBER(10,0), 
	"SEDE" VARCHAR2(3 BYTE), 
	"CONDICION_ESPECIAL" VARCHAR2(2 BYTE), 
	"APELLIDO" VARCHAR2(30 BYTE), 
	"ZONA" NUMBER, 
	"CEDULA_REP" VARCHAR2(16 BYTE), 
	"DIRECCION" VARCHAR2(500 BYTE), 
	"CREADO_POR" VARCHAR2(30 BYTE) DEFAULT coalesce(sys_context('APEX$SESSION', 'app_user'), regexp_substr(sys_context('userenv', 'client_identifier'), '^[^:]*'), sys_context('userenv', 'session_user')), 
	"CREADO_EL" DATE DEFAULT SYSDATE, 
	"MODIFICADO_POR" VARCHAR2(30 BYTE), 
	"MODIFICADO_EL" DATE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 4194304 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;

   COMMENT ON COLUMN "FUNDAUC"."ESTUDIANTE"."CEDULA_EST" IS 'CEDULA_EST';
   COMMENT ON COLUMN "FUNDAUC"."ESTUDIANTE"."NACIONALIDAD" IS 'NACIONALIDAD';
   COMMENT ON COLUMN "FUNDAUC"."ESTUDIANTE"."NOMBRE" IS 'NOMBRE';
   COMMENT ON COLUMN "FUNDAUC"."ESTUDIANTE"."TELF_HAB" IS 'TELF_HAB';
   COMMENT ON COLUMN "FUNDAUC"."ESTUDIANTE"."TELF_CEL" IS 'TELF_CEL';
   COMMENT ON COLUMN "FUNDAUC"."ESTUDIANTE"."CIUDAD" IS 'CIUDAD';
   COMMENT ON COLUMN "FUNDAUC"."ESTUDIANTE"."ESTADO" IS 'ESTADO';
   COMMENT ON COLUMN "FUNDAUC"."ESTUDIANTE"."EMAIL" IS 'EMAIL';
   COMMENT ON COLUMN "FUNDAUC"."ESTUDIANTE"."SEXO" IS 'SEXO';
   COMMENT ON COLUMN "FUNDAUC"."ESTUDIANTE"."EDO_CIVIL" IS 'EDO_CIVIL';
   COMMENT ON COLUMN "FUNDAUC"."ESTUDIANTE"."GRADO_INS" IS 'GRADO_INS';
   COMMENT ON COLUMN "FUNDAUC"."ESTUDIANTE"."PROFESION" IS 'PROFESION';
   COMMENT ON COLUMN "FUNDAUC"."ESTUDIANTE"."FECHA_NAC" IS 'FECHA_NAC';
   COMMENT ON COLUMN "FUNDAUC"."ESTUDIANTE"."STATUS" IS 'STATUS';
   COMMENT ON COLUMN "FUNDAUC"."ESTUDIANTE"."ID_TIPO_EST" IS 'ID_TIPO_EST';
   COMMENT ON COLUMN "FUNDAUC"."ESTUDIANTE"."RIF" IS 'RIF';
   COMMENT ON COLUMN "FUNDAUC"."ESTUDIANTE"."MATRICULA" IS 'MATRICULA';
   COMMENT ON COLUMN "FUNDAUC"."ESTUDIANTE"."SEDE" IS 'SEDE';
   COMMENT ON COLUMN "FUNDAUC"."ESTUDIANTE"."CONDICION_ESPECIAL" IS 'CONDICION_ESPECIAL';
   COMMENT ON COLUMN "FUNDAUC"."ESTUDIANTE"."APELLIDO" IS 'APELLIDO';
   COMMENT ON COLUMN "FUNDAUC"."ESTUDIANTE"."ZONA" IS 'ZONA';
   COMMENT ON COLUMN "FUNDAUC"."ESTUDIANTE"."CEDULA_REP" IS 'CEDULA_REP';
   COMMENT ON COLUMN "FUNDAUC"."ESTUDIANTE"."DIRECCION" IS 'DIRECCION';
   COMMENT ON COLUMN "FUNDAUC"."ESTUDIANTE"."CREADO_POR" IS 'creado por';
   COMMENT ON COLUMN "FUNDAUC"."ESTUDIANTE"."MODIFICADO_POR" IS 'modificado por';
   COMMENT ON TABLE "FUNDAUC"."ESTUDIANTE"  IS 'ESTUDIANTE';
--------------------------------------------------------
--  DDL for Table ESTUDIANTE_RESP
--------------------------------------------------------

  CREATE TABLE "FUNDAUC"."ESTUDIANTE_RESP" 
   (	"CEDULA_EST" NUMBER(10,0), 
	"NACIONALIDAD" CHAR(1 BYTE), 
	"NOMBRE" VARCHAR2(50 BYTE), 
	"TELF_HAB" VARCHAR2(14 BYTE), 
	"TELF_CEL" VARCHAR2(14 BYTE), 
	"CIUDAD" NUMBER(10,0), 
	"ESTADO" NUMBER(10,0), 
	"EMAIL" VARCHAR2(50 BYTE), 
	"SEXO" CHAR(1 BYTE), 
	"EDO_CIVIL" VARCHAR2(20 BYTE), 
	"GRADO_INS" VARCHAR2(20 BYTE), 
	"PROFESION" NUMBER, 
	"FECHA_NAC" DATE, 
	"STATUS" VARCHAR2(2 BYTE), 
	"ID_TIPO_EST" VARCHAR2(1 BYTE), 
	"RIF" VARCHAR2(16 BYTE), 
	"MATRICULA" NUMBER(10,0), 
	"SEDE" VARCHAR2(3 BYTE), 
	"CONDICION_ESPECIAL" VARCHAR2(2 BYTE), 
	"APELLIDO" VARCHAR2(30 BYTE), 
	"ZONA" NUMBER, 
	"CEDULA_REP" VARCHAR2(16 BYTE), 
	"DIRECCION" VARCHAR2(500 BYTE), 
	"CREADO_POR" VARCHAR2(30 BYTE), 
	"CREADO_EL" DATE, 
	"MODIFICADO_POR" VARCHAR2(30 BYTE), 
	"MODIFICADO_EL" DATE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 4194304 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Table EVENTOS
--------------------------------------------------------

  CREATE TABLE "FUNDAUC"."EVENTOS" 
   (	"ID_EVENTO" NUMBER(4,0), 
	"DESCRIPCION" VARCHAR2(100 BYTE), 
	"TIPO_EVENTO" VARCHAR2(5 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;

   COMMENT ON COLUMN "FUNDAUC"."EVENTOS"."ID_EVENTO" IS 'ID_EVENTO';
   COMMENT ON COLUMN "FUNDAUC"."EVENTOS"."DESCRIPCION" IS 'DESCRIPCION';
   COMMENT ON COLUMN "FUNDAUC"."EVENTOS"."TIPO_EVENTO" IS 'TIPO DE EVENTO EJ. ACADEMICO ACAD, ADMINISTRATIVO ADM';
   COMMENT ON TABLE "FUNDAUC"."EVENTOS"  IS 'EVENTOS';
--------------------------------------------------------
--  DDL for Table FACTURA
--------------------------------------------------------

  CREATE TABLE "FUNDAUC"."FACTURA" 
   (	"ID_FACT" NUMBER(8,0), 
	"TIPO" VARCHAR2(2 BYTE), 
	"CEDULA_EST" NUMBER(10,0), 
	"NOMBRE_CLIENTE" VARCHAR2(100 BYTE), 
	"FECHA_EMI" DATE, 
	"MONTO" NUMBER(14,2), 
	"P_IVA" NUMBER(5,2), 
	"MONTO_IVA" NUMBER(14,2), 
	"FLETE" NUMBER(14,2), 
	"BS_DESCUENTO" NUMBER(14,2), 
	"DIR_FISCAL" VARCHAR2(500 BYTE), 
	"RIF" VARCHAR2(16 BYTE), 
	"STATUS" VARCHAR2(2 BYTE), 
	"PROGRAMA" VARCHAR2(3 BYTE), 
	"PROG_ACADEMICO" NUMBER(2,0), 
	"CREADO_POR" VARCHAR2(30 BYTE), 
	"MONTO_EXENTO" NUMBER(14,2), 
	"BASE_IMPONIBLE" NUMBER(14,2), 
	"ID" NUMBER, 
	"CREADO_EL" DATE DEFAULT SYSDATE, 
	"FACTURADO_POR" VARCHAR2(30 BYTE) DEFAULT coalesce(sys_context('APEX$SESSION', 'app_user'), regexp_substr(sys_context('userenv', 'client_identifier'), '^[^:]*'), sys_context('userenv', 'session_user')), 
	"OBSERVACIONES" VARCHAR2(2000 BYTE), 
	"ESCREDITO" CHAR(1 BYTE) DEFAULT 'N'
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 983040 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;

   COMMENT ON COLUMN "FUNDAUC"."FACTURA"."ID_FACT" IS 'ID_FACT';
   COMMENT ON COLUMN "FUNDAUC"."FACTURA"."TIPO" IS 'TIPO';
   COMMENT ON COLUMN "FUNDAUC"."FACTURA"."CEDULA_EST" IS 'CEDULA_EST';
   COMMENT ON COLUMN "FUNDAUC"."FACTURA"."NOMBRE_CLIENTE" IS 'NOMBRE_CLIENTE';
   COMMENT ON COLUMN "FUNDAUC"."FACTURA"."FECHA_EMI" IS 'FECHA_EMI';
   COMMENT ON COLUMN "FUNDAUC"."FACTURA"."MONTO" IS 'MONTO';
   COMMENT ON COLUMN "FUNDAUC"."FACTURA"."P_IVA" IS 'P_IVA';
   COMMENT ON COLUMN "FUNDAUC"."FACTURA"."MONTO_IVA" IS 'MONTO_IVA';
   COMMENT ON COLUMN "FUNDAUC"."FACTURA"."FLETE" IS 'FLETE';
   COMMENT ON COLUMN "FUNDAUC"."FACTURA"."BS_DESCUENTO" IS 'BS_DESCUENTO';
   COMMENT ON COLUMN "FUNDAUC"."FACTURA"."DIR_FISCAL" IS 'DIR_FISCAL';
   COMMENT ON COLUMN "FUNDAUC"."FACTURA"."RIF" IS 'RIF';
   COMMENT ON COLUMN "FUNDAUC"."FACTURA"."STATUS" IS 'STATUS';
   COMMENT ON COLUMN "FUNDAUC"."FACTURA"."PROGRAMA" IS 'PROGRAMA';
   COMMENT ON COLUMN "FUNDAUC"."FACTURA"."PROG_ACADEMICO" IS 'PROG_ACADEMICO';
   COMMENT ON COLUMN "FUNDAUC"."FACTURA"."CREADO_POR" IS 'USUARIO';
   COMMENT ON COLUMN "FUNDAUC"."FACTURA"."MONTO_EXENTO" IS 'MONTO_EXENTO';
   COMMENT ON COLUMN "FUNDAUC"."FACTURA"."BASE_IMPONIBLE" IS 'BASE_IMPONIBLE';
   COMMENT ON COLUMN "FUNDAUC"."FACTURA"."ID" IS 'Identificador unico de Factura';
   COMMENT ON COLUMN "FUNDAUC"."FACTURA"."ESCREDITO" IS 'Si es A credito o al contado';
   COMMENT ON TABLE "FUNDAUC"."FACTURA"  IS 'FACTURA';
--------------------------------------------------------
--  DDL for Table FACTURA_BAK
--------------------------------------------------------

  CREATE TABLE "FUNDAUC"."FACTURA_BAK" 
   (	"ID_FACT" NUMBER(8,0), 
	"TIPO" VARCHAR2(2 BYTE), 
	"CEDULA_EST" NUMBER(10,0), 
	"NOMBRE_CLIENTE" VARCHAR2(100 BYTE), 
	"FECHA_EMI" DATE, 
	"MONTO" NUMBER(14,2), 
	"P_IVA" NUMBER(5,2), 
	"MONTO_IVA" NUMBER(14,2), 
	"FLETE" NUMBER(14,2), 
	"BS_DESCUENTO" NUMBER(14,2), 
	"DIR_FISCAL" VARCHAR2(500 BYTE), 
	"RIF" VARCHAR2(16 BYTE), 
	"STATUS" VARCHAR2(2 BYTE), 
	"PROGRAMA" VARCHAR2(3 BYTE), 
	"PROG_ACADEMICO" NUMBER(2,0), 
	"CREADO_POR" VARCHAR2(30 BYTE), 
	"MONTO_EXENTO" NUMBER(14,2), 
	"BASE_IMPONIBLE" NUMBER(14,2), 
	"ID" NUMBER, 
	"CREADO_EL" DATE, 
	"FACTURADO_POR" VARCHAR2(30 BYTE), 
	"OBSERVACIONES" VARCHAR2(2000 BYTE), 
	"INSCRIPCION_ID" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 131072 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Table FACTURA_DEPOSITO
--------------------------------------------------------

  CREATE TABLE "FUNDAUC"."FACTURA_DEPOSITO" 
   (	"DEPOSITO_ID" NUMBER, 
	"FACTURA_ID" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 131072 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Table FORMA_PAGO
--------------------------------------------------------

  CREATE TABLE "FUNDAUC"."FORMA_PAGO" 
   (	"ID_PAGO" NUMBER(2,0), 
	"DESCRIPCION" VARCHAR2(20 BYTE), 
	"VENCIMIENTO" NUMBER(3,0), 
	"TIPO" VARCHAR2(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;

   COMMENT ON COLUMN "FUNDAUC"."FORMA_PAGO"."ID_PAGO" IS 'ID_PAGO';
   COMMENT ON COLUMN "FUNDAUC"."FORMA_PAGO"."DESCRIPCION" IS 'DESCRIPCION';
   COMMENT ON COLUMN "FUNDAUC"."FORMA_PAGO"."VENCIMIENTO" IS 'VENCIMIENTO';
   COMMENT ON COLUMN "FUNDAUC"."FORMA_PAGO"."TIPO" IS 'TIPO';
   COMMENT ON TABLE "FUNDAUC"."FORMA_PAGO"  IS 'FORMA_PAGO';
--------------------------------------------------------
--  DDL for Table GLOBAL_VALUE
--------------------------------------------------------

  CREATE TABLE "FUNDAUC"."GLOBAL_VALUE" 
   (	"USR" VARCHAR2(255 BYTE), 
	"VAR" VARCHAR2(100 BYTE), 
	"VALUE" VARCHAR2(255 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Table HOJA_VIDA_EST
--------------------------------------------------------

  CREATE TABLE "FUNDAUC"."HOJA_VIDA_EST" 
   (	"ID" NUMBER, 
	"MATRICULA" NUMBER, 
	"EVENTO_ID" NUMBER, 
	"FECHA" TIMESTAMP (6) DEFAULT systimestamp, 
	"METADATA" CLOB, 
	"OBSERVACION" VARCHAR2(4000 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" 
 LOB ("METADATA") STORE AS SECUREFILE (
  TABLESPACE "FUNDAUC" ENABLE STORAGE IN ROW CHUNK 8192
  CACHE  NOCOMPRESS  KEEP_DUPLICATES 
  STORAGE(INITIAL 106496 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) ;
--------------------------------------------------------
--  DDL for Table HOJA_VIDA_EST_BK
--------------------------------------------------------

  CREATE TABLE "FUNDAUC"."HOJA_VIDA_EST_BK" 
   (	"ID" NUMBER, 
	"MATRICULA" NUMBER, 
	"EVENTO_ID" NUMBER, 
	"FECHA" TIMESTAMP (6) DEFAULT systimestamp, 
	"METADATA" CLOB, 
	"OBSERVACION" VARCHAR2(4000 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" 
 LOB ("METADATA") STORE AS SECUREFILE (
  TABLESPACE "FUNDAUC" ENABLE STORAGE IN ROW CHUNK 8192
  NOCACHE LOGGING  NOCOMPRESS  KEEP_DUPLICATES 
  STORAGE(INITIAL 106496 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) ;
--------------------------------------------------------
--  DDL for Table HORARIOS
--------------------------------------------------------

  CREATE TABLE "FUNDAUC"."HORARIOS" 
   (	"ID_HORARIO" NUMBER(10,0), 
	"HORA" DATE, 
	"MODALIDAD" NUMBER(3,0), 
	"HORA_FIN" DATE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;

   COMMENT ON COLUMN "FUNDAUC"."HORARIOS"."ID_HORARIO" IS 'ID_HORARIO';
   COMMENT ON COLUMN "FUNDAUC"."HORARIOS"."HORA" IS 'HORA';
   COMMENT ON COLUMN "FUNDAUC"."HORARIOS"."MODALIDAD" IS 'MODALIDAD';
   COMMENT ON COLUMN "FUNDAUC"."HORARIOS"."HORA_FIN" IS 'HORA_FIN';
   COMMENT ON TABLE "FUNDAUC"."HORARIOS"  IS 'HORARIOS';
--------------------------------------------------------
--  DDL for Table INSCRIPCIONES
--------------------------------------------------------

  CREATE TABLE "FUNDAUC"."INSCRIPCIONES" 
   (	"ID" NUMBER, 
	"FECHA_INS" TIMESTAMP (6) DEFAULT systimestamp, 
	"EST_MATRICULA" NUMBER(10,0), 
	"FECHA_PAGO" DATE, 
	"ESTATUS" VARCHAR2(255 BYTE), 
	"SECCION_ID" NUMBER, 
	"PERIODO_ID" NUMBER, 
	"CREADO_POR" VARCHAR2(255 BYTE) DEFAULT coalesce(sys_context('APEX$SESSION', 'app_user'), regexp_substr(sys_context('userenv', 'client_identifier'
    ), '^[^:]*'), sys_context('userenv', 'session_user')), 
	"ES_EXONERADO" CHAR(1 BYTE) DEFAULT 'N', 
	"PROG_ACADEMICO" NUMBER, 
	"ES_SUSPENDIDO" CHAR(1 BYTE) DEFAULT 'N', 
	"COHORTE_ID" NUMBER, 
	"HORARIO_ID" NUMBER, 
	"MODIFICADO_POR" VARCHAR2(255 BYTE), 
	"MODIFICADO_EL" DATE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 262144 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;

   COMMENT ON COLUMN "FUNDAUC"."INSCRIPCIONES"."ID" IS 'Identificador unico de la iscripcion del estudiante en el curso';
   COMMENT ON COLUMN "FUNDAUC"."INSCRIPCIONES"."FECHA_INS" IS 'Fecha de la Inscripcion';
   COMMENT ON COLUMN "FUNDAUC"."INSCRIPCIONES"."EST_MATRICULA" IS 'MAtricula Estudiante';
   COMMENT ON COLUMN "FUNDAUC"."INSCRIPCIONES"."FECHA_PAGO" IS 'Fecha de Pago de la Inscripcion';
   COMMENT ON COLUMN "FUNDAUC"."INSCRIPCIONES"."ESTATUS" IS 'Estado de laInscripcion Ej, Pre-Inscripcion, Inscripcion Efectiva, Inscripcion Anulada, Inscripcion Exonerada, Inactiva';
   COMMENT ON COLUMN "FUNDAUC"."INSCRIPCIONES"."SECCION_ID" IS 'Identificador Unico de la Seccion';
   COMMENT ON COLUMN "FUNDAUC"."INSCRIPCIONES"."PERIODO_ID" IS 'Pediodo de Inscripcion';
   COMMENT ON COLUMN "FUNDAUC"."INSCRIPCIONES"."CREADO_POR" IS 'Usuario quien creo la Inscripcion';
   COMMENT ON COLUMN "FUNDAUC"."INSCRIPCIONES"."ES_EXONERADO" IS 'Si esestudiante es exonerado o no';
   COMMENT ON COLUMN "FUNDAUC"."INSCRIPCIONES"."PROG_ACADEMICO" IS 'Programa Academico';
   COMMENT ON COLUMN "FUNDAUC"."INSCRIPCIONES"."ES_SUSPENDIDO" IS 'Si el Estudiante Suspendio un curso o no';
   COMMENT ON COLUMN "FUNDAUC"."INSCRIPCIONES"."COHORTE_ID" IS 'Cohorte id';
   COMMENT ON COLUMN "FUNDAUC"."INSCRIPCIONES"."HORARIO_ID" IS 'Id del horario de Inscripcion';
   COMMENT ON COLUMN "FUNDAUC"."INSCRIPCIONES"."MODIFICADO_POR" IS 'Quien modifico el registro';
   COMMENT ON COLUMN "FUNDAUC"."INSCRIPCIONES"."MODIFICADO_EL" IS 'Cuando se Modifico el Registro';
   COMMENT ON TABLE "FUNDAUC"."INSCRIPCIONES"  IS 'Tabla de Inscripciones';
--------------------------------------------------------
--  DDL for Table INSCRIPCIONES_BAK
--------------------------------------------------------

  CREATE TABLE "FUNDAUC"."INSCRIPCIONES_BAK" 
   (	"ID" NUMBER, 
	"FECHA_INS" TIMESTAMP (6), 
	"EST_MATRICULA" NUMBER(10,0), 
	"FECHA_PAGO" DATE, 
	"ESTATUS" VARCHAR2(255 BYTE), 
	"SECCION_ID" NUMBER, 
	"PERIODO_ID" NUMBER, 
	"CREADO_POR" VARCHAR2(255 BYTE), 
	"ES_EXONERADO" CHAR(1 BYTE), 
	"PROG_ACADEMICO" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Table INSCRIPCIONES_HIS
--------------------------------------------------------

  CREATE TABLE "FUNDAUC"."INSCRIPCIONES_HIS" 
   (	"ID" NUMBER, 
	"FECHA_INS" TIMESTAMP (6), 
	"EST_MATRICULA" NUMBER(10,0), 
	"FECHA_PAGO" DATE, 
	"ESTATUS" VARCHAR2(255 BYTE), 
	"SECCION_ID" NUMBER, 
	"FACTURA_ID" NUMBER, 
	"CREADO_POR" VARCHAR2(255 BYTE), 
	"ES_EXONERADO" CHAR(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Table INSCRIPCIONES_RESP
--------------------------------------------------------

  CREATE TABLE "FUNDAUC"."INSCRIPCIONES_RESP" 
   (	"ID" NUMBER, 
	"FECHA_INS" TIMESTAMP (6), 
	"EST_MATRICULA" NUMBER(10,0), 
	"FECHA_PAGO" DATE, 
	"ESTATUS" VARCHAR2(255 BYTE), 
	"SECCION_ID" NUMBER, 
	"FACTURA_ID" NUMBER, 
	"CREADO_POR" VARCHAR2(255 BYTE), 
	"ES_EXONERADO" CHAR(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Table INSCRIPCION_FACTURA
--------------------------------------------------------

  CREATE TABLE "FUNDAUC"."INSCRIPCION_FACTURA" 
   (	"INSCRIPCION_ID" NUMBER, 
	"FACTURA_ID" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 131072 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;

   COMMENT ON COLUMN "FUNDAUC"."INSCRIPCION_FACTURA"."INSCRIPCION_ID" IS 'Id de la inscripcion';
--------------------------------------------------------
--  DDL for Table INSTANCIAS_SECCIONES
--------------------------------------------------------

  CREATE TABLE "FUNDAUC"."INSTANCIAS_SECCIONES" 
   (	"ID" NUMBER, 
	"SECCION_ID" NUMBER, 
	"CODIGO_SEC" VARCHAR2(50 BYTE), 
	"METODO_ID" VARCHAR2(20 BYTE), 
	"NIVEL" NUMBER(2,0), 
	"PERIODO_ID" NUMBER, 
	"HORARIO_ID" NUMBER, 
	"MODALIDAD_ID" NUMBER, 
	"CEDULA_PROF" VARCHAR2(20 BYTE), 
	"F_INICIO" DATE, 
	"F_FIN" DATE, 
	"ESTATUS" VARCHAR2(20 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;

   COMMENT ON COLUMN "FUNDAUC"."INSTANCIAS_SECCIONES"."ID" IS 'Identificador Unico de Instancia de Seccion';
   COMMENT ON COLUMN "FUNDAUC"."INSTANCIAS_SECCIONES"."SECCION_ID" IS 'Identificador unico de la seccion';
   COMMENT ON COLUMN "FUNDAUC"."INSTANCIAS_SECCIONES"."CODIGO_SEC" IS 'Codigo de la Seccion';
   COMMENT ON COLUMN "FUNDAUC"."INSTANCIAS_SECCIONES"."METODO_ID" IS 'identificador unco del metodo';
--------------------------------------------------------
--  DDL for Table JOB_LOG
--------------------------------------------------------

  CREATE TABLE "FUNDAUC"."JOB_LOG" 
   (	"LOG_ID" NUMBER(9,0), 
	"LOG_MESSAGE" VARCHAR2(1000 BYTE), 
	"LOG_TIME" TIMESTAMP (6)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Table MATERIALES
--------------------------------------------------------

  CREATE TABLE "FUNDAUC"."MATERIALES" 
   (	"ID_MAT" VARCHAR2(50 BYTE), 
	"TIPO" VARCHAR2(3 BYTE), 
	"DESCRIPCION" VARCHAR2(255 BYTE), 
	"ID_CURSO" VARCHAR2(10 BYTE), 
	"EVENTO" NUMBER(2,0), 
	"NIVEL" NUMBER(2,0), 
	"IVA_EXENTO" CHAR(1 BYTE) DEFAULT 'S', 
	"ACTIVO" CHAR(1 BYTE) DEFAULT 'S', 
	"ID" NUMBER, 
	"SECCION_ID" NUMBER, 
	"CREADO_POR" VARCHAR2(255 BYTE) DEFAULT coalesce(sys_context('APEX$SESSION', 'app_user'), regexp_substr(sys_context('userenv', 'client_identifier'
    ), '^[^:]*'), sys_context('userenv', 'session_user')), 
	"CREADO_EL" DATE DEFAULT SYSDATE, 
	"MODIFICADO_POR" VARCHAR2(255 BYTE), 
	"MODIFICADO_EL" DATE, 
	"COHORTE_ID" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 131072 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;

   COMMENT ON COLUMN "FUNDAUC"."MATERIALES"."ID_MAT" IS 'ID_MAT';
   COMMENT ON COLUMN "FUNDAUC"."MATERIALES"."TIPO" IS 'TIPO';
   COMMENT ON COLUMN "FUNDAUC"."MATERIALES"."DESCRIPCION" IS 'DESCRIPCION';
   COMMENT ON COLUMN "FUNDAUC"."MATERIALES"."ID_CURSO" IS 'ID_CURSO';
   COMMENT ON COLUMN "FUNDAUC"."MATERIALES"."EVENTO" IS 'EVENTO';
   COMMENT ON COLUMN "FUNDAUC"."MATERIALES"."NIVEL" IS 'NIVEL';
   COMMENT ON COLUMN "FUNDAUC"."MATERIALES"."IVA_EXENTO" IS 'IVA_EXENTO';
   COMMENT ON COLUMN "FUNDAUC"."MATERIALES"."ACTIVO" IS 'ACTIVO';
   COMMENT ON COLUMN "FUNDAUC"."MATERIALES"."ID" IS 'Identificador unico de material';
   COMMENT ON COLUMN "FUNDAUC"."MATERIALES"."SECCION_ID" IS 'Identificador Unico de Seccion';
   COMMENT ON COLUMN "FUNDAUC"."MATERIALES"."CREADO_POR" IS 'Usuario quien creo el material';
   COMMENT ON COLUMN "FUNDAUC"."MATERIALES"."CREADO_EL" IS 'Fecha en que se creo el material';
   COMMENT ON COLUMN "FUNDAUC"."MATERIALES"."MODIFICADO_POR" IS 'Usuario quien modifico el material';
   COMMENT ON COLUMN "FUNDAUC"."MATERIALES"."MODIFICADO_EL" IS 'fecha cuando se modifico el material';
   COMMENT ON TABLE "FUNDAUC"."MATERIALES"  IS 'MATERIALES';
--------------------------------------------------------
--  DDL for Table METODOS
--------------------------------------------------------

  CREATE TABLE "FUNDAUC"."METODOS" 
   (	"ID_METODO" VARCHAR2(10 BYTE), 
	"DESCRIPCION" VARCHAR2(80 BYTE), 
	"IDIOMA" VARCHAR2(30 BYTE), 
	"NIVELES" NUMBER(2,0), 
	"EVALUACIONES" NUMBER(2,0), 
	"DIURNO" CHAR(1 BYTE), 
	"NOCTURNO" CHAR(1 BYTE), 
	"SABATINO" CHAR(1 BYTE), 
	"ID_CALENDARIO" NUMBER(2,0), 
	"PROG_ACADEMICO" NUMBER(2,0), 
	"CUOTAS" NUMBER(2,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;

   COMMENT ON COLUMN "FUNDAUC"."METODOS"."ID_METODO" IS 'ID_METODO';
   COMMENT ON COLUMN "FUNDAUC"."METODOS"."DESCRIPCION" IS 'DESCRIPCION';
   COMMENT ON COLUMN "FUNDAUC"."METODOS"."IDIOMA" IS 'IDIOMA';
   COMMENT ON COLUMN "FUNDAUC"."METODOS"."NIVELES" IS 'NIVELES';
   COMMENT ON COLUMN "FUNDAUC"."METODOS"."EVALUACIONES" IS 'EVALUACIONES';
   COMMENT ON COLUMN "FUNDAUC"."METODOS"."DIURNO" IS 'DIURNO';
   COMMENT ON COLUMN "FUNDAUC"."METODOS"."NOCTURNO" IS 'NOCTURNO';
   COMMENT ON COLUMN "FUNDAUC"."METODOS"."SABATINO" IS 'SABATINO';
   COMMENT ON COLUMN "FUNDAUC"."METODOS"."ID_CALENDARIO" IS 'ID_CALENDARIO';
   COMMENT ON COLUMN "FUNDAUC"."METODOS"."PROG_ACADEMICO" IS 'PROG_ACADEMICO';
   COMMENT ON COLUMN "FUNDAUC"."METODOS"."CUOTAS" IS 'CUOTAS';
   COMMENT ON TABLE "FUNDAUC"."METODOS"  IS 'METODOS';
--------------------------------------------------------
--  DDL for Table MODALIDADES
--------------------------------------------------------

  CREATE TABLE "FUNDAUC"."MODALIDADES" 
   (	"ID_MODALIDAD" NUMBER(2,0), 
	"DESCRIPCION" VARCHAR2(25 BYTE), 
	"DIAS" VARCHAR2(50 BYTE), 
	"SIGLAS" VARCHAR2(20 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;

   COMMENT ON COLUMN "FUNDAUC"."MODALIDADES"."ID_MODALIDAD" IS 'ID_MODALIDAD';
   COMMENT ON COLUMN "FUNDAUC"."MODALIDADES"."DESCRIPCION" IS 'DESCRIPCION';
   COMMENT ON COLUMN "FUNDAUC"."MODALIDADES"."SIGLAS" IS 'SIGLAS DE DIAS EN LETRAS';
   COMMENT ON TABLE "FUNDAUC"."MODALIDADES"  IS 'MODALIDADES';
--------------------------------------------------------
--  DDL for Table OCUPACIONES
--------------------------------------------------------

  CREATE TABLE "FUNDAUC"."OCUPACIONES" 
   (	"ID_OCUPACION" NUMBER, 
	"NOMBRE" VARCHAR2(20 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;

   COMMENT ON COLUMN "FUNDAUC"."OCUPACIONES"."ID_OCUPACION" IS 'ID_OCUPACION';
   COMMENT ON COLUMN "FUNDAUC"."OCUPACIONES"."NOMBRE" IS 'NOMBRE';
   COMMENT ON TABLE "FUNDAUC"."OCUPACIONES"  IS 'OCUPACIONES';
--------------------------------------------------------
--  DDL for Table PRECIOS
--------------------------------------------------------

  CREATE TABLE "FUNDAUC"."PRECIOS" 
   (	"TIPO_ITEM" VARCHAR2(2 BYTE), 
	"FECHA" DATE, 
	"PRECIO1" NUMBER(14,2), 
	"PRECIO2" NUMBER(14,2), 
	"PRECIO3" NUMBER(14,2), 
	"STATUS" VARCHAR2(1 BYTE), 
	"PRECIO4" NUMBER(14,2), 
	"PRECIO5" NUMBER(14,2), 
	"ID" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;

   COMMENT ON COLUMN "FUNDAUC"."PRECIOS"."TIPO_ITEM" IS 'TIPO_ITEM';
   COMMENT ON COLUMN "FUNDAUC"."PRECIOS"."FECHA" IS 'FECHA';
   COMMENT ON COLUMN "FUNDAUC"."PRECIOS"."PRECIO1" IS 'PRECIO1';
   COMMENT ON COLUMN "FUNDAUC"."PRECIOS"."PRECIO2" IS 'PRECIO2';
   COMMENT ON COLUMN "FUNDAUC"."PRECIOS"."PRECIO3" IS 'PRECIO3';
   COMMENT ON COLUMN "FUNDAUC"."PRECIOS"."STATUS" IS 'STATUS';
   COMMENT ON COLUMN "FUNDAUC"."PRECIOS"."PRECIO4" IS 'PRECIO4';
   COMMENT ON COLUMN "FUNDAUC"."PRECIOS"."PRECIO5" IS 'PRECIO5';
   COMMENT ON COLUMN "FUNDAUC"."PRECIOS"."ID" IS 'ID PRECIO';
   COMMENT ON TABLE "FUNDAUC"."PRECIOS"  IS 'PRECIOS';
--------------------------------------------------------
--  DDL for Table PROFESOR
--------------------------------------------------------

  CREATE TABLE "FUNDAUC"."PROFESOR" 
   (	"CEDULA_PROF" NUMBER(10,0), 
	"NACIONALIDAD" CHAR(1 BYTE), 
	"NOMBRE" VARCHAR2(50 BYTE), 
	"TELF_HAB" VARCHAR2(14 BYTE), 
	"TELF_CEL" VARCHAR2(14 BYTE), 
	"CIUDAD" VARCHAR2(20 BYTE), 
	"ESTADO" VARCHAR2(20 BYTE), 
	"EMAIL" VARCHAR2(50 BYTE), 
	"SEXO" CHAR(1 BYTE), 
	"EDO_CIVIL" CHAR(1 BYTE), 
	"GRADO_INS" CHAR(1 BYTE), 
	"PROFESION" VARCHAR2(20 BYTE), 
	"FECHA_NAC" DATE, 
	"STATUS" VARCHAR2(2 BYTE), 
	"ID_TIPO_PROF" VARCHAR2(1 BYTE), 
	"RIF" VARCHAR2(16 BYTE), 
	"SEDE" VARCHAR2(3 BYTE), 
	"APELLIDO" VARCHAR2(25 BYTE), 
	"ZONA" VARCHAR2(30 BYTE), 
	"DIRECCION" VARCHAR2(255 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;

   COMMENT ON COLUMN "FUNDAUC"."PROFESOR"."CEDULA_PROF" IS 'CEDULA_PROF';
   COMMENT ON COLUMN "FUNDAUC"."PROFESOR"."NACIONALIDAD" IS 'NACIONALIDAD';
   COMMENT ON COLUMN "FUNDAUC"."PROFESOR"."NOMBRE" IS 'NOMBRE';
   COMMENT ON COLUMN "FUNDAUC"."PROFESOR"."TELF_HAB" IS 'TELF_HAB';
   COMMENT ON COLUMN "FUNDAUC"."PROFESOR"."TELF_CEL" IS 'TELF_CEL';
   COMMENT ON COLUMN "FUNDAUC"."PROFESOR"."CIUDAD" IS 'CIUDAD';
   COMMENT ON COLUMN "FUNDAUC"."PROFESOR"."ESTADO" IS 'ESTADO';
   COMMENT ON COLUMN "FUNDAUC"."PROFESOR"."EMAIL" IS 'EMAIL';
   COMMENT ON COLUMN "FUNDAUC"."PROFESOR"."SEXO" IS 'SEXO';
   COMMENT ON COLUMN "FUNDAUC"."PROFESOR"."EDO_CIVIL" IS 'EDO_CIVIL';
   COMMENT ON COLUMN "FUNDAUC"."PROFESOR"."GRADO_INS" IS 'GRADO_INS';
   COMMENT ON COLUMN "FUNDAUC"."PROFESOR"."PROFESION" IS 'PROFESION';
   COMMENT ON COLUMN "FUNDAUC"."PROFESOR"."FECHA_NAC" IS 'FECHA_NAC';
   COMMENT ON COLUMN "FUNDAUC"."PROFESOR"."STATUS" IS 'STATUS';
   COMMENT ON COLUMN "FUNDAUC"."PROFESOR"."ID_TIPO_PROF" IS 'ID_TIPO_PROF';
   COMMENT ON COLUMN "FUNDAUC"."PROFESOR"."RIF" IS 'RIF';
   COMMENT ON COLUMN "FUNDAUC"."PROFESOR"."SEDE" IS 'SEDE';
   COMMENT ON COLUMN "FUNDAUC"."PROFESOR"."APELLIDO" IS 'APELLIDO';
   COMMENT ON COLUMN "FUNDAUC"."PROFESOR"."ZONA" IS 'ZONA';
   COMMENT ON COLUMN "FUNDAUC"."PROFESOR"."DIRECCION" IS 'DIRECCION';
   COMMENT ON TABLE "FUNDAUC"."PROFESOR"  IS 'PROFESOR';
--------------------------------------------------------
--  DDL for Table PROGRAMA_ACADEMICO
--------------------------------------------------------

  CREATE TABLE "FUNDAUC"."PROGRAMA_ACADEMICO" 
   (	"ID" NUMBER(2,0), 
	"DESCRIPCION" VARCHAR2(100 BYTE), 
	"ACTIVO" CHAR(1 BYTE) DEFAULT 'S'
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;

   COMMENT ON COLUMN "FUNDAUC"."PROGRAMA_ACADEMICO"."ID" IS 'ID';
   COMMENT ON COLUMN "FUNDAUC"."PROGRAMA_ACADEMICO"."DESCRIPCION" IS 'DESCRIPCION';
   COMMENT ON COLUMN "FUNDAUC"."PROGRAMA_ACADEMICO"."ACTIVO" IS 'ACTIVO';
   COMMENT ON TABLE "FUNDAUC"."PROGRAMA_ACADEMICO"  IS 'PROGRAMA_ACADEMICO';
--------------------------------------------------------
--  DDL for Table ROLES
--------------------------------------------------------

  CREATE TABLE "FUNDAUC"."ROLES" 
   (	"ID_ROL" NUMBER(3,0), 
	"DESCRIPCION" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;

   COMMENT ON COLUMN "FUNDAUC"."ROLES"."ID_ROL" IS 'ID_ROL';
   COMMENT ON COLUMN "FUNDAUC"."ROLES"."DESCRIPCION" IS 'DESCRIPCION';
   COMMENT ON TABLE "FUNDAUC"."ROLES"  IS 'ROLES';
--------------------------------------------------------
--  DDL for Table SALONES
--------------------------------------------------------

  CREATE TABLE "FUNDAUC"."SALONES" 
   (	"ID_SALON" NUMBER(3,0), 
	"EDIFICIO" NUMBER(3,0), 
	"DESCRIPCION" VARCHAR2(50 BYTE), 
	"CAPACIDAD" NUMBER(3,0), 
	"ANCHO" NUMBER(4,0), 
	"LARGO" NUMBER(4,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;

   COMMENT ON COLUMN "FUNDAUC"."SALONES"."ID_SALON" IS 'ID_SALON';
   COMMENT ON COLUMN "FUNDAUC"."SALONES"."EDIFICIO" IS 'EDIFICIO';
   COMMENT ON COLUMN "FUNDAUC"."SALONES"."DESCRIPCION" IS 'DESCRIPCION';
   COMMENT ON COLUMN "FUNDAUC"."SALONES"."CAPACIDAD" IS 'CAPACIDAD';
   COMMENT ON COLUMN "FUNDAUC"."SALONES"."ANCHO" IS 'ANCHO';
   COMMENT ON COLUMN "FUNDAUC"."SALONES"."LARGO" IS 'LARGO';
   COMMENT ON TABLE "FUNDAUC"."SALONES"  IS 'SALONES';
--------------------------------------------------------
--  DDL for Table SECCIONES
--------------------------------------------------------

  CREATE TABLE "FUNDAUC"."SECCIONES" 
   (	"ID_SECCION" VARCHAR2(50 BYTE), 
	"ID_METODO" VARCHAR2(10 BYTE), 
	"NIVEL" NUMBER(2,0), 
	"ID_SALON" NUMBER(3,0), 
	"TOPE" NUMBER(2,0), 
	"STATUS" CHAR(1 BYTE), 
	"ID_EDIF" NUMBER(3,0), 
	"HORARIO" VARCHAR2(17 BYTE), 
	"CEDULA_PROF" NUMBER(10,0), 
	"MODALIDAD" NUMBER(3,0), 
	"FEC_INICIO" DATE, 
	"PERIODO" NUMBER, 
	"ID_HORARIO" NUMBER(3,0), 
	"ID_CALENDARIO" NUMBER, 
	"ID" NUMBER, 
	"CREADO_POR" VARCHAR2(255 BYTE), 
	"CREADO_EL" DATE, 
	"MODIFICADO_POR" VARCHAR2(255 BYTE), 
	"MODIFICADO_EL" DATE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;

   COMMENT ON COLUMN "FUNDAUC"."SECCIONES"."ID_SECCION" IS 'ID_SECCION';
   COMMENT ON COLUMN "FUNDAUC"."SECCIONES"."ID_METODO" IS 'ID_METODO';
   COMMENT ON COLUMN "FUNDAUC"."SECCIONES"."NIVEL" IS 'NIVEL';
   COMMENT ON COLUMN "FUNDAUC"."SECCIONES"."ID_SALON" IS 'ID_SALON';
   COMMENT ON COLUMN "FUNDAUC"."SECCIONES"."TOPE" IS 'TOPE';
   COMMENT ON COLUMN "FUNDAUC"."SECCIONES"."STATUS" IS 'STATUS';
   COMMENT ON COLUMN "FUNDAUC"."SECCIONES"."ID_EDIF" IS 'ID_EDIF';
   COMMENT ON COLUMN "FUNDAUC"."SECCIONES"."HORARIO" IS 'HORARIO';
   COMMENT ON COLUMN "FUNDAUC"."SECCIONES"."CEDULA_PROF" IS 'CEDULA_PROF';
   COMMENT ON COLUMN "FUNDAUC"."SECCIONES"."MODALIDAD" IS 'MODALIDAD';
   COMMENT ON COLUMN "FUNDAUC"."SECCIONES"."FEC_INICIO" IS 'FEC_INICIO';
   COMMENT ON COLUMN "FUNDAUC"."SECCIONES"."PERIODO" IS 'PERIODO';
   COMMENT ON COLUMN "FUNDAUC"."SECCIONES"."ID" IS 'Identificador Unico de la Seccion';
   COMMENT ON COLUMN "FUNDAUC"."SECCIONES"."CREADO_POR" IS 'usuario quien crea la seccion';
   COMMENT ON COLUMN "FUNDAUC"."SECCIONES"."CREADO_EL" IS 'Fecha de Creacion';
   COMMENT ON COLUMN "FUNDAUC"."SECCIONES"."MODIFICADO_POR" IS 'usuario quien modifica la seccion';
   COMMENT ON COLUMN "FUNDAUC"."SECCIONES"."MODIFICADO_EL" IS 'Fecha de Modificacion';
   COMMENT ON TABLE "FUNDAUC"."SECCIONES"  IS 'SECCIONES';
--------------------------------------------------------
--  DDL for Table SECCIONES_BAK
--------------------------------------------------------

  CREATE TABLE "FUNDAUC"."SECCIONES_BAK" 
   (	"ID_SECCION" VARCHAR2(50 BYTE), 
	"ID_METODO" VARCHAR2(10 BYTE), 
	"NIVEL" NUMBER(2,0), 
	"ID_SALON" NUMBER(3,0), 
	"TOPE" NUMBER(2,0), 
	"STATUS" CHAR(1 BYTE), 
	"ID_EDIF" NUMBER(3,0), 
	"HORARIO" VARCHAR2(17 BYTE), 
	"CEDULA_PROF" NUMBER(10,0), 
	"MODALIDAD" NUMBER(3,0), 
	"FEC_INICIO" DATE, 
	"PERIODO" NUMBER, 
	"ID_HORARIO" NUMBER(3,0), 
	"ID_CALENDARIO" NUMBER, 
	"ID" NUMBER, 
	"CREADO_POR" VARCHAR2(255 BYTE), 
	"CREADO_EL" DATE, 
	"MODIFICADO_POR" VARCHAR2(255 BYTE), 
	"MODIFICADO_EL" DATE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Table TE_TEMPLATES
--------------------------------------------------------

  CREATE TABLE "FUNDAUC"."TE_TEMPLATES" 
   (	"NAME" VARCHAR2(300 BYTE), 
	"TEMPLATE" CLOB, 
	"DESCRIPTION" VARCHAR2(300 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE) DEFAULT user, 
	"CREATED_DATE" DATE DEFAULT SYSDATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE) DEFAULT user, 
	"MODIFIED_DATE" DATE DEFAULT SYSDATE
   ) SEGMENT CREATION DEFERRED 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  TABLESPACE "FUNDAUC" 
 LOB ("TEMPLATE") STORE AS SECUREFILE (
  TABLESPACE "FUNDAUC" ENABLE STORAGE IN ROW CHUNK 8192
  NOCACHE LOGGING  NOCOMPRESS  KEEP_DUPLICATES ) ;
--------------------------------------------------------
--  DDL for Table TIPO_ESTUDIANTE
--------------------------------------------------------

  CREATE TABLE "FUNDAUC"."TIPO_ESTUDIANTE" 
   (	"ID_TIPO_EST" VARCHAR2(1 BYTE), 
	"DESCRIPCION" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;

   COMMENT ON COLUMN "FUNDAUC"."TIPO_ESTUDIANTE"."ID_TIPO_EST" IS 'ID_TIPO_EST';
   COMMENT ON COLUMN "FUNDAUC"."TIPO_ESTUDIANTE"."DESCRIPCION" IS 'DESCRIPCION';
   COMMENT ON TABLE "FUNDAUC"."TIPO_ESTUDIANTE"  IS 'TIPO_ESTUDIANTE';
--------------------------------------------------------
--  DDL for Table TIPO_MATERIAL
--------------------------------------------------------

  CREATE TABLE "FUNDAUC"."TIPO_MATERIAL" 
   (	"ABREV" VARCHAR2(3 BYTE), 
	"DESCRIPCION" VARCHAR2(20 BYTE), 
	"IDIOMAS" CHAR(1 BYTE), 
	"CTC" CHAR(1 BYTE), 
	"CFP" CHAR(1 BYTE), 
	"USA_SECCION" CHAR(1 BYTE) DEFAULT 'N'
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;

   COMMENT ON COLUMN "FUNDAUC"."TIPO_MATERIAL"."ABREV" IS 'ABREV';
   COMMENT ON COLUMN "FUNDAUC"."TIPO_MATERIAL"."DESCRIPCION" IS 'DESCRIPCION';
   COMMENT ON COLUMN "FUNDAUC"."TIPO_MATERIAL"."IDIOMAS" IS 'IDIOMAS';
   COMMENT ON COLUMN "FUNDAUC"."TIPO_MATERIAL"."CTC" IS 'CTC';
   COMMENT ON COLUMN "FUNDAUC"."TIPO_MATERIAL"."CFP" IS 'CFP';
   COMMENT ON COLUMN "FUNDAUC"."TIPO_MATERIAL"."USA_SECCION" IS 'FVTC';
   COMMENT ON TABLE "FUNDAUC"."TIPO_MATERIAL"  IS 'TIPO_MATERIAL';
--------------------------------------------------------
--  DDL for Table TIPO_PROFESOR
--------------------------------------------------------

  CREATE TABLE "FUNDAUC"."TIPO_PROFESOR" 
   (	"ID_TIPO_PROF" VARCHAR2(1 BYTE), 
	"DESCRIPCION" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Table USUARIOS
--------------------------------------------------------

  CREATE TABLE "FUNDAUC"."USUARIOS" 
   (	"CEDULA" NUMBER(10,0), 
	"NOMBRE_USUARIO" VARCHAR2(50 BYTE), 
	"CONTRASENA" VARCHAR2(255 BYTE), 
	"ID_ROL" NUMBER(3,0), 
	"EMAIL" VARCHAR2(100 BYTE), 
	"NOMBRE" VARCHAR2(50 BYTE), 
	"CIA" NUMBER(2,0), 
	"PROG_ACADEMICO" NUMBER(2,0), 
	"ACTIVO" CHAR(1 BYTE) DEFAULT 'S', 
	"BLOQUEADO" CHAR(1 BYTE) DEFAULT 'N', 
	"CREADO_POR" VARCHAR2(100 BYTE), 
	"CREADO_EL" DATE DEFAULT SYSDATE, 
	"MODIFICADO_POR" VARCHAR2(100 BYTE), 
	"MODIFICADO_EL" DATE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;

   COMMENT ON COLUMN "FUNDAUC"."USUARIOS"."CEDULA" IS 'CEDULA';
   COMMENT ON COLUMN "FUNDAUC"."USUARIOS"."NOMBRE_USUARIO" IS 'NOMBRE_USUARIO';
   COMMENT ON COLUMN "FUNDAUC"."USUARIOS"."CONTRASENA" IS 'CONTRASENA';
   COMMENT ON COLUMN "FUNDAUC"."USUARIOS"."ID_ROL" IS 'ID_ROL';
   COMMENT ON COLUMN "FUNDAUC"."USUARIOS"."EMAIL" IS 'EMAIL';
   COMMENT ON COLUMN "FUNDAUC"."USUARIOS"."NOMBRE" IS 'NOMBRE';
   COMMENT ON COLUMN "FUNDAUC"."USUARIOS"."CIA" IS 'CIA';
   COMMENT ON COLUMN "FUNDAUC"."USUARIOS"."PROG_ACADEMICO" IS 'PROG_ACADEMICO';
   COMMENT ON COLUMN "FUNDAUC"."USUARIOS"."BLOQUEADO" IS 'Usuario Bloqueado?';
   COMMENT ON COLUMN "FUNDAUC"."USUARIOS"."CREADO_EL" IS 'fecha de creacion del usuario';
   COMMENT ON TABLE "FUNDAUC"."USUARIOS"  IS 'USUARIOS';
--------------------------------------------------------
--  DDL for Table ZONAS
--------------------------------------------------------

  CREATE TABLE "FUNDAUC"."ZONAS" 
   (	"ID_ZONA" NUMBER, 
	"DESCRIPCION" VARCHAR2(50 BYTE), 
	"ID_CIUDAD" NUMBER(10,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;

   COMMENT ON COLUMN "FUNDAUC"."ZONAS"."ID_ZONA" IS 'ID_ZONA';
   COMMENT ON COLUMN "FUNDAUC"."ZONAS"."DESCRIPCION" IS 'DESCRIPCION';
   COMMENT ON COLUMN "FUNDAUC"."ZONAS"."ID_CIUDAD" IS 'ID_CIUDAD';
   COMMENT ON TABLE "FUNDAUC"."ZONAS"  IS 'ZONAS';
--------------------------------------------------------
--  DDL for Sequence CALENDARIOS_DETALLE_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "FUNDAUC"."CALENDARIOS_DETALLE_SEQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 167 NOCACHE  NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence CALENDARIOS_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "FUNDAUC"."CALENDARIOS_SEQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 79 NOCACHE  NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence CIUDADES_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "FUNDAUC"."CIUDADES_SEQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 524 NOCACHE  NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence CLIENTES_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "FUNDAUC"."CLIENTES_SEQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 1221 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence COHORTES_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "FUNDAUC"."COHORTES_SEQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 21 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence CONDICIONES_ESPECIALES_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "FUNDAUC"."CONDICIONES_ESPECIALES_SEQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 6 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence CTAXCOB_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "FUNDAUC"."CTAXCOB_SEQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 5 NOCACHE  NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence DEMO_CUST_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "FUNDAUC"."DEMO_CUST_SEQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 100 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence DEMO_ORDER_ITEMS_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "FUNDAUC"."DEMO_ORDER_ITEMS_SEQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 160 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence DEMO_ORD_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "FUNDAUC"."DEMO_ORD_SEQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 11 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence DEMO_PROD_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "FUNDAUC"."DEMO_PROD_SEQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 100 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence DEPOSITO_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "FUNDAUC"."DEPOSITO_SEQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 4411 NOCACHE  NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence DEPT_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "FUNDAUC"."DEPT_SEQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 50 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence DETALLE_FACTURA_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "FUNDAUC"."DETALLE_FACTURA_SEQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 9543 NOCACHE  NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence DIPLOMADOS_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "FUNDAUC"."DIPLOMADOS_SEQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 21 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence EMP_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "FUNDAUC"."EMP_SEQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 8000 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence ESTADOS_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "FUNDAUC"."ESTADOS_SEQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 26 NOCACHE  NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence ESTUDIANTE_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "FUNDAUC"."ESTUDIANTE_SEQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 99 NOCACHE  NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence FACTURA_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "FUNDAUC"."FACTURA_SEQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 4790 NOCACHE  NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence HOJA_VIDA_EST_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "FUNDAUC"."HOJA_VIDA_EST_SEQ"  MINVALUE 11634 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 11644 NOCACHE  NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence HORARIOS_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "FUNDAUC"."HORARIOS_SEQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 103 NOCACHE  NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence INSCRIPCIONES_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "FUNDAUC"."INSCRIPCIONES_SEQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 4000 NOCACHE  NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence INSTANCIAS_SECCIONES_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "FUNDAUC"."INSTANCIAS_SECCIONES_SEQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 325 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence JRXML_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "FUNDAUC"."JRXML_SEQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 1 NOCACHE  NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence MATERIALES_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "FUNDAUC"."MATERIALES_SEQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 987 NOCACHE  NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence OCUPACION_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "FUNDAUC"."OCUPACION_SEQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 3 NOCACHE  NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence SECCIONES_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "FUNDAUC"."SECCIONES_SEQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 352 NOCACHE  NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Index SYS_C0018511
--------------------------------------------------------

  CREATE UNIQUE INDEX "FUNDAUC"."SYS_C0018511" ON "FUNDAUC"."BANCOS" ("ID_BANCO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Index SYS_C0018513
--------------------------------------------------------

  CREATE UNIQUE INDEX "FUNDAUC"."SYS_C0018513" ON "FUNDAUC"."CALENDARIOS" ("ID_CALENDARIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Index CALENDARIOS_DETALLE_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "FUNDAUC"."CALENDARIOS_DETALLE_PK" ON "FUNDAUC"."CALENDARIOS_DETALLE" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Index SYS_C0018514
--------------------------------------------------------

  CREATE UNIQUE INDEX "FUNDAUC"."SYS_C0018514" ON "FUNDAUC"."CIUDADES" ("ID_CIUDAD") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Index CLIENTES_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "FUNDAUC"."CLIENTES_PK" ON "FUNDAUC"."CLIENTES" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Index SYS_C0018547
--------------------------------------------------------

  CREATE UNIQUE INDEX "FUNDAUC"."SYS_C0018547" ON "FUNDAUC"."CLIENTES" ("RIF") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Index COHORTES_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "FUNDAUC"."COHORTES_PK" ON "FUNDAUC"."COHORTES" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Index SYS_C0018522
--------------------------------------------------------

  CREATE UNIQUE INDEX "FUNDAUC"."SYS_C0018522" ON "FUNDAUC"."COMPANIAS" ("CODIGO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Index CONDICIONES_ESPECIALES_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "FUNDAUC"."CONDICIONES_ESPECIALES_PK" ON "FUNDAUC"."CONDICIONES_ESPECIALES" ("ID_CONDICION") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Index CTAXCOB_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "FUNDAUC"."CTAXCOB_PK" ON "FUNDAUC"."CTAXCOB" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Index PK_DEPOSITO
--------------------------------------------------------

  CREATE UNIQUE INDEX "FUNDAUC"."PK_DEPOSITO" ON "FUNDAUC"."DEPOSITO" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 131072 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Index DEPOSITO_UK
--------------------------------------------------------

  CREATE UNIQUE INDEX "FUNDAUC"."DEPOSITO_UK" ON "FUNDAUC"."DEPOSITO" ("REFERENCIA", "ID_BANCO", "FORMA_PAGO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 196608 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Index SYS_C0018532
--------------------------------------------------------

  CREATE UNIQUE INDEX "FUNDAUC"."SYS_C0018532" ON "FUNDAUC"."DETALLE_FACTURA" ("RENGLON") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 196608 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Index DIPLOMADOS_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "FUNDAUC"."DIPLOMADOS_PK" ON "FUNDAUC"."DIPLOMADOS" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Index EDIFICIOS_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "FUNDAUC"."EDIFICIOS_PK" ON "FUNDAUC"."EDIFICIOS" ("ID_EDIF") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Index SYS_C0018552
--------------------------------------------------------

  CREATE UNIQUE INDEX "FUNDAUC"."SYS_C0018552" ON "FUNDAUC"."ESTADOS" ("ID_ESTADO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Index PK_ESTUDIANTE
--------------------------------------------------------

  CREATE UNIQUE INDEX "FUNDAUC"."PK_ESTUDIANTE" ON "FUNDAUC"."ESTUDIANTE" ("MATRICULA") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 720896 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Index SYS_C0018558
--------------------------------------------------------

  CREATE UNIQUE INDEX "FUNDAUC"."SYS_C0018558" ON "FUNDAUC"."EVENTOS" ("ID_EVENTO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Index PK_FACT
--------------------------------------------------------

  CREATE UNIQUE INDEX "FUNDAUC"."PK_FACT" ON "FUNDAUC"."FACTURA" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 131072 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Index FACTURA_DEPOSITO_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "FUNDAUC"."FACTURA_DEPOSITO_PK" ON "FUNDAUC"."FACTURA_DEPOSITO" ("FACTURA_ID", "DEPOSITO_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 262144 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Index SYS_C0018578
--------------------------------------------------------

  CREATE UNIQUE INDEX "FUNDAUC"."SYS_C0018578" ON "FUNDAUC"."FORMA_PAGO" ("ID_PAGO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Index HORARIOS_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "FUNDAUC"."HORARIOS_PK" ON "FUNDAUC"."HORARIOS" ("ID_HORARIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Index INSCRIPCIONES_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "FUNDAUC"."INSCRIPCIONES_PK" ON "FUNDAUC"."INSCRIPCIONES" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 131072 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Index INSCRIPCION_FACTURA_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "FUNDAUC"."INSCRIPCION_FACTURA_PK" ON "FUNDAUC"."INSCRIPCION_FACTURA" ("INSCRIPCION_ID", "FACTURA_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 131072 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Index MATERIALES_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "FUNDAUC"."MATERIALES_PK" ON "FUNDAUC"."MATERIALES" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Index PK_METODO
--------------------------------------------------------

  CREATE UNIQUE INDEX "FUNDAUC"."PK_METODO" ON "FUNDAUC"."METODOS" ("ID_METODO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Index MODALIDADES_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "FUNDAUC"."MODALIDADES_PK" ON "FUNDAUC"."MODALIDADES" ("ID_MODALIDAD") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Index SYS_C0018591
--------------------------------------------------------

  CREATE UNIQUE INDEX "FUNDAUC"."SYS_C0018591" ON "FUNDAUC"."OCUPACIONES" ("ID_OCUPACION") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Index PRECIOS_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "FUNDAUC"."PRECIOS_PK" ON "FUNDAUC"."PRECIOS" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Index SYS_C0018599
--------------------------------------------------------

  CREATE UNIQUE INDEX "FUNDAUC"."SYS_C0018599" ON "FUNDAUC"."PROFESOR" ("CEDULA_PROF") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Index SYS_C0018602
--------------------------------------------------------

  CREATE UNIQUE INDEX "FUNDAUC"."SYS_C0018602" ON "FUNDAUC"."PROGRAMA_ACADEMICO" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Index SYS_C0018603
--------------------------------------------------------

  CREATE UNIQUE INDEX "FUNDAUC"."SYS_C0018603" ON "FUNDAUC"."ROLES" ("ID_ROL") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Index PK_SALON
--------------------------------------------------------

  CREATE UNIQUE INDEX "FUNDAUC"."PK_SALON" ON "FUNDAUC"."SALONES" ("ID_SALON", "EDIFICIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Index SECCIONES_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "FUNDAUC"."SECCIONES_PK" ON "FUNDAUC"."SECCIONES" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Index SECCIONES_UK1
--------------------------------------------------------

  CREATE UNIQUE INDEX "FUNDAUC"."SECCIONES_UK1" ON "FUNDAUC"."SECCIONES" ("ID_SECCION") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Index SYS_C0018611
--------------------------------------------------------

  CREATE UNIQUE INDEX "FUNDAUC"."SYS_C0018611" ON "FUNDAUC"."TIPO_ESTUDIANTE" ("ID_TIPO_EST") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Index PK_TIPO_MATERIAL
--------------------------------------------------------

  CREATE UNIQUE INDEX "FUNDAUC"."PK_TIPO_MATERIAL" ON "FUNDAUC"."TIPO_MATERIAL" ("ABREV") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Index TIPO_PROF_UK
--------------------------------------------------------

  CREATE UNIQUE INDEX "FUNDAUC"."TIPO_PROF_UK" ON "FUNDAUC"."TIPO_PROFESOR" ("ID_TIPO_PROF") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Index SYS_C0018616
--------------------------------------------------------

  CREATE UNIQUE INDEX "FUNDAUC"."SYS_C0018616" ON "FUNDAUC"."USUARIOS" ("CEDULA") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Index USUARIOS_UK1
--------------------------------------------------------

  CREATE UNIQUE INDEX "FUNDAUC"."USUARIOS_UK1" ON "FUNDAUC"."USUARIOS" ("NOMBRE_USUARIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Index SYS_C0018618
--------------------------------------------------------

  CREATE UNIQUE INDEX "FUNDAUC"."SYS_C0018618" ON "FUNDAUC"."ZONAS" ("ID_ZONA") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Index HOJA_VIDA_BK_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "FUNDAUC"."HOJA_VIDA_BK_PK" ON "FUNDAUC"."HOJA_VIDA_EST_BK" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Index HOJA_VIDA_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "FUNDAUC"."HOJA_VIDA_PK" ON "FUNDAUC"."HOJA_VIDA_EST" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Index TE_TEMPLATES_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "FUNDAUC"."TE_TEMPLATES_PK" ON "FUNDAUC"."TE_TEMPLATES" ("NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Index INSTANCIAS_SECCIONES_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "FUNDAUC"."INSTANCIAS_SECCIONES_PK" ON "FUNDAUC"."INSTANCIAS_SECCIONES" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Index INSCRIPCIONES_UK
--------------------------------------------------------

  CREATE UNIQUE INDEX "FUNDAUC"."INSCRIPCIONES_UK" ON "FUNDAUC"."INSCRIPCIONES" (TRUNC("FECHA_INS"), "EST_MATRICULA", "SECCION_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 196608 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Index MATERIALES_UK
--------------------------------------------------------

  CREATE UNIQUE INDEX "FUNDAUC"."MATERIALES_UK" ON "FUNDAUC"."MATERIALES" ("ID_MAT") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Index IDX_CEDULA_EST_UN
--------------------------------------------------------

  CREATE UNIQUE INDEX "FUNDAUC"."IDX_CEDULA_EST_UN" ON "FUNDAUC"."ESTUDIANTE" ("CEDULA_EST") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 720896 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Index DIPLOMADOS_UK1
--------------------------------------------------------

  CREATE UNIQUE INDEX "FUNDAUC"."DIPLOMADOS_UK1" ON "FUNDAUC"."DIPLOMADOS" ("ID_DIPLOMADO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Index MODALIDAD_UK
--------------------------------------------------------

  CREATE UNIQUE INDEX "FUNDAUC"."MODALIDAD_UK" ON "FUNDAUC"."MODALIDADES" ("DESCRIPCION") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Index CALENDARIOS_DETALLE_IDX
--------------------------------------------------------

  CREATE UNIQUE INDEX "FUNDAUC"."CALENDARIOS_DETALLE_IDX" ON "FUNDAUC"."CALENDARIOS_DETALLE" ("ID_CALENDARIO", "PERIODO", "MODALIDAD") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Index COHORTES_UK1
--------------------------------------------------------

  CREATE UNIQUE INDEX "FUNDAUC"."COHORTES_UK1" ON "FUNDAUC"."COHORTES" ("CODIGO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Index I_HORARIO_H
--------------------------------------------------------

  CREATE UNIQUE INDEX "FUNDAUC"."I_HORARIO_H" ON "FUNDAUC"."HORARIOS" ("MODALIDAD", TO_CHAR("HORA",'HH:MI AM'), TO_CHAR("HORA_FIN",'HH:MI AM')) 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" ;
--------------------------------------------------------
--  DDL for Trigger CALENDARIOS_DETALLE_TRG
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "FUNDAUC"."CALENDARIOS_DETALLE_TRG" 
before insert on calendarios_detalle 
for each row 
begin
  <<COLUMN_SEQUENCES>>
  BEGIN
    IF INSERTING AND :NEW.ID IS NULL THEN
      SELECT CALENDARIOS_DETALLE_SEQ.NEXTVAL INTO :NEW.ID FROM SYS.DUAL;
    END IF;
  END COLUMN_SEQUENCES;
end;
/
ALTER TRIGGER "FUNDAUC"."CALENDARIOS_DETALLE_TRG" ENABLE;
--------------------------------------------------------
--  DDL for Trigger CALENDARIOS_TRG
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "FUNDAUC"."CALENDARIOS_TRG" 
BEFORE INSERT ON CALENDARIOS 
FOR EACH ROW 
BEGIN
  <<COLUMN_SEQUENCES>>
  BEGIN
    IF INSERTING AND :NEW.ID_CALENDARIO IS NULL THEN
      SELECT CALENDARIOS_SEQ.NEXTVAL INTO :NEW.ID_CALENDARIO FROM SYS.DUAL;
    END IF;
  END COLUMN_SEQUENCES;
END;
/
ALTER TRIGGER "FUNDAUC"."CALENDARIOS_TRG" ENABLE;
--------------------------------------------------------
--  DDL for Trigger CIUDADES_TRG
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "FUNDAUC"."CIUDADES_TRG" 
BEFORE INSERT ON CIUDADES 
FOR EACH ROW 
BEGIN
  <<COLUMN_SEQUENCES>>
  BEGIN
    IF INSERTING AND :NEW.ID_CIUDAD IS NULL THEN
      SELECT CIUDADES_SEQ.NEXTVAL INTO :NEW.ID_CIUDAD FROM SYS.DUAL;
    END IF;
  END COLUMN_SEQUENCES;
END;
/
ALTER TRIGGER "FUNDAUC"."CIUDADES_TRG" ENABLE;
--------------------------------------------------------
--  DDL for Trigger CLIENTES_TRG
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "FUNDAUC"."CLIENTES_TRG" 
BEFORE INSERT ON CLIENTES 
FOR EACH ROW 
BEGIN
  <<COLUMN_SEQUENCES>>
  BEGIN
    IF INSERTING AND :NEW.ID IS NULL THEN
      SELECT CLIENTES_SEQ.NEXTVAL INTO :NEW.ID FROM SYS.DUAL;
    END IF;
  END COLUMN_SEQUENCES;
END;

/
ALTER TRIGGER "FUNDAUC"."CLIENTES_TRG" ENABLE;
--------------------------------------------------------
--  DDL for Trigger COHORTES_TRG
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "FUNDAUC"."COHORTES_TRG" 
BEFORE INSERT OR UPDATE ON COHORTES 
FOR EACH ROW 
BEGIN
  <<COLUMN_SEQUENCES>>
  BEGIN
    IF INSERTING AND :NEW.ID IS NULL THEN
      SELECT COHORTES_SEQ.NEXTVAL INTO :NEW.ID FROM SYS.DUAL;
      :NEW.CREADO_POR := coalesce(sys_context('APEX$SESSION', 'app_user'), regexp_substr(sys_context('userenv', 'client_identifier'), '^[^:]*'), sys_context('userenv', 'session_user'));
      :NEW.CREADO_EL := SYSDATE;

    ELSIF UPDATING THEN
      :NEW.MODIFICADO_POR := coalesce(sys_context('APEX$SESSION', 'app_user'), regexp_substr(sys_context('userenv', 'client_identifier'), '^[^:]*'), sys_context('userenv', 'session_user'));
      :NEW.MODIFICADO_EL := SYSDATE;
    END IF;
  END COLUMN_SEQUENCES;
END;

/
ALTER TRIGGER "FUNDAUC"."COHORTES_TRG" ENABLE;
--------------------------------------------------------
--  DDL for Trigger CONDICIONES_ESPECIALES_TRG
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "FUNDAUC"."CONDICIONES_ESPECIALES_TRG" 
BEFORE INSERT ON CONDICIONES_ESPECIALES 
FOR EACH ROW 
BEGIN
  <<COLUMN_SEQUENCES>>
  BEGIN
    IF INSERTING AND :NEW.ID_CONDICION IS NULL THEN
      SELECT CONDICIONES_ESPECIALES_SEQ.NEXTVAL INTO :NEW.ID_CONDICION FROM SYS.DUAL;
    END IF;
  END COLUMN_SEQUENCES;
END;
/
ALTER TRIGGER "FUNDAUC"."CONDICIONES_ESPECIALES_TRG" ENABLE;
--------------------------------------------------------
--  DDL for Trigger CTAXCOB_TRG
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "FUNDAUC"."CTAXCOB_TRG" 
BEFORE INSERT ON CTAXCOB 
FOR EACH ROW 
BEGIN
  <<COLUMN_SEQUENCES>>
  BEGIN
    IF INSERTING AND :NEW.ID IS NULL THEN
      SELECT CTAXCOB_SEQ.NEXTVAL INTO :NEW.ID FROM SYS.DUAL;
    END IF;
  END COLUMN_SEQUENCES;
END;

/
ALTER TRIGGER "FUNDAUC"."CTAXCOB_TRG" ENABLE;
--------------------------------------------------------
--  DDL for Trigger DEPOSITO_TRG
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "FUNDAUC"."DEPOSITO_TRG" 
BEFORE INSERT ON DEPOSITO 
FOR EACH ROW 
BEGIN
  <<COLUMN_SEQUENCES>>
  BEGIN
    IF INSERTING AND :NEW.REFERENCIA IS NULL THEN
      SELECT DEPOSITO_SEQ.NEXTVAL INTO :NEW.REFERENCIA FROM SYS.DUAL;
    END IF;
  END COLUMN_SEQUENCES;
END;
/
ALTER TRIGGER "FUNDAUC"."DEPOSITO_TRG" ENABLE;
--------------------------------------------------------
--  DDL for Trigger DEPT_TRG1
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "FUNDAUC"."DEPT_TRG1" 
              before insert on dept
              for each row
              begin
                  if :new.deptno is null then
                      select dept_seq.nextval into :new.deptno from sys.dual;
                 end if;
              end;
/
ALTER TRIGGER "FUNDAUC"."DEPT_TRG1" ENABLE;
--------------------------------------------------------
--  DDL for Trigger DETALLE_FACTURA_TRG
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "FUNDAUC"."DETALLE_FACTURA_TRG" 
before insert on detalle_factura 
for each row 
begin
  <<COLUMN_SEQUENCES>>
  BEGIN
    NULL;
  END COLUMN_SEQUENCES;
end;
/
ALTER TRIGGER "FUNDAUC"."DETALLE_FACTURA_TRG" ENABLE;
--------------------------------------------------------
--  DDL for Trigger DIPLOMADOS_TRG
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "FUNDAUC"."DIPLOMADOS_TRG" 
BEFORE INSERT ON DIPLOMADOS 
FOR EACH ROW 
BEGIN
  <<COLUMN_SEQUENCES>>
  BEGIN
    IF INSERTING AND :NEW.ID IS NULL THEN
      SELECT DIPLOMADOS_SEQ.NEXTVAL INTO :NEW.ID FROM SYS.DUAL;
    END IF;
  END COLUMN_SEQUENCES;
END;

/
ALTER TRIGGER "FUNDAUC"."DIPLOMADOS_TRG" ENABLE;
--------------------------------------------------------
--  DDL for Trigger EMP_TRG1
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "FUNDAUC"."EMP_TRG1" 
              before insert on emp
              for each row
              begin
                  if :new.empno is null then
                      select emp_seq.nextval into :new.empno from sys.dual;
                 end if;
              end;
/
ALTER TRIGGER "FUNDAUC"."EMP_TRG1" ENABLE;
--------------------------------------------------------
--  DDL for Trigger ESTUDIANTE_TRG
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "FUNDAUC"."ESTUDIANTE_TRG" 
BEFORE INSERT OR UPDATE ON ESTUDIANTE 
FOR EACH ROW 
BEGIN
  <<COLUMN_SEQUENCES>>
  BEGIN
    IF INSERTING AND :NEW.MATRICULA IS NULL THEN
      SELECT MAX(MATRICULA)+1 INTO :NEW.MATRICULA FROM ESTUDIANTE;
    ELSIF UPDATING THEN
      :NEW.MODIFICADO_POR := coalesce(sys_context('APEX$SESSION', 'app_user'), regexp_substr(sys_context('userenv', 'client_identifier'), '^[^:]*'), sys_context('userenv', 'session_user'));
      :NEW.MODIFICADO_EL := SYSDATE;
    END IF;
  END COLUMN_SEQUENCES;
END;
/
ALTER TRIGGER "FUNDAUC"."ESTUDIANTE_TRG" ENABLE;
--------------------------------------------------------
--  DDL for Trigger FACTURA_TRG
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "FUNDAUC"."FACTURA_TRG" 
before insert on factura 
for each row 
begin
  <<COLUMN_SEQUENCES>>
  BEGIN
    IF INSERTING AND :NEW.ID IS NULL THEN
      SELECT FACTURA_SEQ.NEXTVAL INTO :NEW.ID FROM SYS.DUAL;
    END IF;
  END COLUMN_SEQUENCES;
end;
/
ALTER TRIGGER "FUNDAUC"."FACTURA_TRG" ENABLE;
--------------------------------------------------------
--  DDL for Trigger HOJA_VIDA_EST_TRG
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "FUNDAUC"."HOJA_VIDA_EST_TRG" 
BEFORE INSERT ON HOJA_VIDA_EST 
FOR EACH ROW 
BEGIN
  <<COLUMN_SEQUENCES>>
  BEGIN
    IF INSERTING AND :NEW.ID IS NULL THEN
      SELECT HOJA_VIDA_EST_SEQ.NEXTVAL INTO :NEW.ID FROM SYS.DUAL;
    END IF;
  END COLUMN_SEQUENCES;
END;


/
ALTER TRIGGER "FUNDAUC"."HOJA_VIDA_EST_TRG" ENABLE;
--------------------------------------------------------
--  DDL for Trigger HORARIOS_TRG
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "FUNDAUC"."HORARIOS_TRG" 
before insert on horarios 
for each row 
begin
  <<COLUMN_SEQUENCES>>
  BEGIN
    IF INSERTING AND :NEW.ID_HORARIO IS NULL THEN
      SELECT HORARIOS_SEQ.NEXTVAL INTO :NEW.ID_HORARIO FROM SYS.DUAL;
    END IF;
  END COLUMN_SEQUENCES;
end;
/
ALTER TRIGGER "FUNDAUC"."HORARIOS_TRG" ENABLE;
--------------------------------------------------------
--  DDL for Trigger INSCRIPCIONES_TRG
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "FUNDAUC"."INSCRIPCIONES_TRG" 
BEFORE INSERT ON INSCRIPCIONES 
FOR EACH ROW 
DECLARE
    p_estudiante_rec fundauc.tapi_estudiante.estudiante_rt;
BEGIN
  <<COLUMN_SEQUENCES>>
  BEGIN
    IF INSERTING AND :NEW.ID IS NULL THEN
      SELECT INSCRIPCIONES_SEQ.NEXTVAL INTO :NEW.ID FROM SYS.DUAL;

      select periodo into :NEW.PERIODO_ID from secciones where id = :NEW.SECCION_ID;

      p_estudiante_rec := TAPI_ESTUDIANTE.RT(P_MATRICULA => :NEW.EST_MATRICULA);

          case
              when utl_periodos.getStatusPeriodoSec(:NEW.SECCION_ID)='En Curso' and p_estudiante_rec.condicion_especial <> 5 then 
                :NEW.ESTATUS :='ACXC';
                :NEW.ES_EXONERADO := 'N';
              when utl_periodos.getStatusPeriodoSec(:NEW.SECCION_ID)='En Curso' and p_estudiante_rec.condicion_especial = 5 then 
                :NEW.ESTATUS := 'ACX';
                :NEW.ES_EXONERADO := 'S';
              when utl_periodos.getStatusPeriodoSec(:NEW.SECCION_ID)='Por Comenzar' and p_estudiante_rec.condicion_especial <> 5 then 
                :NEW.ESTATUS := 'AEXC';
                :NEW.ES_EXONERADO := 'N';
              when utl_periodos.getStatusPeriodoSec(:NEW.SECCION_ID)='Por Comenzar' and p_estudiante_rec.condicion_especial = 5 then 
                :NEW.ESTATUS := 'AEX';
                :NEW.ES_EXONERADO := 'S';
          end case;

    END IF;
  END COLUMN_SEQUENCES;
END;
/
ALTER TRIGGER "FUNDAUC"."INSCRIPCIONES_TRG" ENABLE;
--------------------------------------------------------
--  DDL for Trigger INSTANCIAS_SECCIONES_TRG
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "FUNDAUC"."INSTANCIAS_SECCIONES_TRG" 
BEFORE INSERT ON INSTANCIAS_SECCIONES 
FOR EACH ROW 
BEGIN
  <<COLUMN_SEQUENCES>>
  BEGIN
    IF INSERTING AND :NEW.ID IS NULL THEN
      SELECT INSTANCIAS_SECCIONES_SEQ.NEXTVAL INTO :NEW.ID FROM SYS.DUAL;
    END IF;
  END COLUMN_SEQUENCES;
END;
/
ALTER TRIGGER "FUNDAUC"."INSTANCIAS_SECCIONES_TRG" ENABLE;
--------------------------------------------------------
--  DDL for Trigger MATERIALES_TRG
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "FUNDAUC"."MATERIALES_TRG" 
BEFORE INSERT ON MATERIALES 
FOR EACH ROW 
BEGIN
  <<COLUMN_SEQUENCES>>
  BEGIN
    IF INSERTING AND :NEW.ID IS NULL THEN
      SELECT MATERIALES_SEQ.NEXTVAL INTO :NEW.ID FROM SYS.DUAL;
    END IF;
  END COLUMN_SEQUENCES;
END;

/
ALTER TRIGGER "FUNDAUC"."MATERIALES_TRG" ENABLE;
--------------------------------------------------------
--  DDL for Trigger SECCIONES_TRG
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "FUNDAUC"."SECCIONES_TRG" 
before insert or update on secciones 
for each row 
begin
  <<COLUMN_SEQUENCES>>
  BEGIN
    IF INSERTING AND :NEW.ID IS NULL THEN
      SELECT SECCIONES_SEQ.NEXTVAL INTO :NEW.ID FROM SYS.DUAL;
      :NEW.CREADO_POR := coalesce(sys_context('APEX$SESSION', 'app_user'), regexp_substr(sys_context('userenv', 'client_identifier'), '^[^:]*'), sys_context('userenv', 'session_user'));
      :NEW.CREADO_EL := SYSDATE;

    ELSIF UPDATING THEN
      :NEW.MODIFICADO_POR := coalesce(sys_context('APEX$SESSION', 'app_user'), regexp_substr(sys_context('userenv', 'client_identifier'), '^[^:]*'), sys_context('userenv', 'session_user'));
      :NEW.MODIFICADO_EL := SYSDATE;
    END IF;
  END COLUMN_SEQUENCES;
end;
/
ALTER TRIGGER "FUNDAUC"."SECCIONES_TRG" ENABLE;
--------------------------------------------------------
--  DDL for Trigger T_COHORTES_AUID
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "FUNDAUC"."T_COHORTES_AUID" 
AFTER
    UPDATE OR DELETE OR INSERT ON  cohortes
for each row 
DECLARE
  l_fecha date;
  l_precio number;
  l_id_curso varchar2(10);
  l_des_curso varchar(255);
  l_ciudad    varchar2(255);
  P_MATERIALES_REC FUNDAUC.TAPI_MATERIALES.MATERIALES_RT;
  P_PRECIOS_REC FUNDAUC.TAPI_PRECIOS.PRECIOS_RT;

begin
  BEGIN
    select fecha_ini into l_fecha from calendarios_detalle
    where id = :NEW.PERIODO;

    if :NEW.TIPO_DIPLO in ('DP','PC') then
        select id_diplomado, descripcion into l_id_curso, l_des_curso from diplomados
        where id = :NEW.DIPLOMADO_ID;

        select upper(nombre) into l_ciudad from ciudades
        where id_ciudad = :NEW.ID_CIUDAD;
    elsif :NEW.TIPO_DIPLO = 'IC' then
        l_id_curso := :NEW.ID_METODO;
    end if;

    select max(precio1) into l_precio from precios
    where tipo_item = 'C';
    IF INSERTING THEN
      --Inserta Secciones nuevas

            P_MATERIALES_REC.id_mat := :NEW.CODIGO;
            P_MATERIALES_REC.tipo := :NEW.TIPO_DIPLO;
            if :NEW.TIPO_DIPLO in ('DP','PC') then
              P_MATERIALES_REC.descripcion := l_des_curso||' - '||l_ciudad;
            elsif :NEW.TIPO_DIPLO = 'IC' then
              P_MATERIALES_REC.descripcion := :NEW.ID_METODO||'|NIVEL '||lpad(:OLD.nivel,2,'0')||'|'||UTL_HORARIOS.GETHORARIO(:NEW.ID_HORARIO)||'|'||to_char(l_fecha,'DD/MM/YYYY')||'|'||utl_modalidades.getModalidad(:NEW.id_modalidad);
            end if;
            P_MATERIALES_REC.id_curso := l_id_curso;
            P_MATERIALES_REC.evento := 2;
            P_MATERIALES_REC.nivel := :NEW.NIVEL;
            P_MATERIALES_REC.iva_exento := 'S';
            P_MATERIALES_REC.activo := 'S';
          --  P_MATERIALES_REC.id := 
            P_MATERIALES_REC.seccion_id := null;
            P_MATERIALES_REC.creado_por := coalesce(sys_context('APEX$SESSION', 'app_user'), regexp_substr(sys_context('userenv', 'client_identifier'), '^[^:]*'), sys_context('userenv', 'session_user'));
            P_MATERIALES_REC.creado_el := SYSDATE;
            P_MATERIALES_REC.modificado_por := null;
            P_MATERIALES_REC.modificado_el := null;
            P_MATERIALES_REC.cohorte_id := :NEW.ID;

      TAPI_MATERIALES.INS(P_MATERIALES_REC);

            P_PRECIOS_REC.id := P_MATERIALES_REC.id;
            P_PRECIOS_REC.tipo_item := P_MATERIALES_REC.tipo;
            P_PRECIOS_REC.fecha := SYSDATE;
            P_PRECIOS_REC.precio1 := l_precio;
            P_PRECIOS_REC.precio2 := 0;
            P_PRECIOS_REC.precio3 := 0;
            P_PRECIOS_REC.status := 'V';
            P_PRECIOS_REC.precio4 := 0;
            P_PRECIOS_REC.precio5 := 0;


        TAPI_PRECIOS.INS(P_PRECIOS_REC);


    ELSIF UPDATING THEN

        if :OLD.TIPO_DIPLO in ('DP','PC') then
          update materiales set descripcion = l_des_curso||' - '||l_ciudad
          where tipo=:OLD.TIPO_DIPLO and cohorte_id = :OLD.ID;
        elsif :OLD.TIPO_DIPLO = 'IC' then
          update materiales set descripcion = :NEW.ID_METODO||'|NIVEL '||lpad(:OLD.nivel,2,'0')||'|'||UTL_HORARIOS.GETHORARIO(:NEW.ID_HORARIO)||'|'||to_char(l_fecha,'DD/MM/YYYY')||'|'||utl_modalidades.getModalidad(:NEW.id_modalidad)
          where tipo=:OLD.TIPO_DIPLO and cohorte_id = :OLD.ID;
        end if;

    END IF;
  END;
  exception
    when no_data_found then null;
end;
/
ALTER TRIGGER "FUNDAUC"."T_COHORTES_AUID" ENABLE;
--------------------------------------------------------
--  DDL for Trigger T_DETALLE_FACTURA_AIUD
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "FUNDAUC"."T_DETALLE_FACTURA_AIUD" AFTER
    DELETE OR INSERT OR UPDATE ON detalle_factura
    FOR EACH ROW
DECLARE
    p_factura_rec fundauc.tapi_factura.factura_rt;
    mon_exento number;
    o_mon_exento number;
    base_imp number;
    o_base_imp number;
    mon_iva number;
    o_mon_iva number;
    v_iva number;
    o_subtotal number;
BEGIN
    IF inserting THEN

        v_iva := UTL_CONFIGURACION.GETCONFIVA();

        if UTL_MATERIALES.GETEXENTOIVA(:NEW.MATERIALES_ID) = 'S' THEN 
            mon_exento := :new.subtotal;
        else
            base_imp := :new.subtotal;
            mon_iva := (base_imp*v_iva)/100;
        end if;

        update factura set monto = (nvl(monto,0) + nvl(:new.subtotal,0) + nvl(mon_iva,0)), 
            p_iva = nvl(v_iva,0), 
            monto_exento = (nvl(monto_exento,0) + nvl(mon_exento,0)), 
            base_imponible = (nvl(base_imponible,0) + nvl(base_imp,0)),
            monto_iva = (nvl(monto_iva,0) + nvl(mon_iva,0))
        where id = :new.factura_id;
    ELSIF updating THEN

        o_subtotal := nvl(:old.cantidad,0) * nvl(:old.p_unidad,0);


        v_iva := UTL_CONFIGURACION.GETCONFIVA();

        if UTL_MATERIALES.GETEXENTOIVA(:OLD.MATERIALES_ID) = 'S' THEN 
            o_mon_exento := :old.subtotal;
            mon_exento := :new.subtotal;
        else

            base_imp := :new.subtotal;
            o_base_imp := :old.subtotal;
            mon_iva := (base_imp*v_iva)/100;
            o_mon_iva := (o_base_imp*v_iva)/100;
        end if;

        update factura 
          set monto = (nvl(monto,0) - nvl(:old.subtotal,0) - nvl(o_mon_iva,0)) + nvl(:new.subtotal,0) + nvl(mon_iva,0), 
            p_iva = nvl(v_iva,0), 
            monto_exento = (nvl(monto_exento,0) - nvl(o_mon_exento,0)) + nvl(mon_exento,0), 
            base_imponible = (nvl(base_imponible,0) - nvl(o_base_imp,0)) + nvl(base_imp,0),
            monto_iva = (nvl(monto_iva,0) - nvl(o_mon_iva,0)) + nvl(mon_iva,0)
        where id = :new.factura_id;
    ELSIF deleting THEN

        o_subtotal := nvl(:old.cantidad,0) * nvl(:old.p_unidad,0);
        v_iva := UTL_CONFIGURACION.GETCONFIVA();

        if UTL_MATERIALES.GETEXENTOIVA(:OLD.MATERIALES_ID) = 'S' THEN 
            o_mon_exento := o_subtotal;
        else
            o_base_imp := o_subtotal;
            o_mon_iva := (o_base_imp*v_iva)/100;
        end if;
        update factura set monto = (nvl(monto,0) - nvl(:old.subtotal,0) ),
            monto_exento = (nvl(monto_exento,0) - nvl(o_mon_exento,0)),
            base_imponible = (nvl(base_imponible,0) - nvl(o_base_imp,0))
        where id = :old.factura_id;
    END IF;

END;

/
ALTER TRIGGER "FUNDAUC"."T_DETALLE_FACTURA_AIUD" ENABLE;
--------------------------------------------------------
--  DDL for Trigger T_FACTURA_DEPOSITO_SEQ
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "FUNDAUC"."T_FACTURA_DEPOSITO_SEQ" 
   after insert on "FUNDAUC"."FACTURA_DEPOSITO" 
   for each row 
declare   
   P_FACTURA_REC FUNDAUC.TAPI_FACTURA.FACTURA_RT;
   P_CTAXCOB_REC FUNDAUC.TAPI_CTAXCOB.CTAXCOB_RT;
   P_IGNORE_NULLS BOOLEAN;
   P_ULT_FAC NUMBER := UTL_CONFIGURACION.getConfUltFactura();
   l_es_credito varchar2(1);
   l_rif  varchar2(16);
   l_ctaxcob number := 0;
   l_monto_fac number := 0;
begin  
   if inserting then 
      if :NEW."FACTURA_ID" is not null then 
        select escredito into l_es_credito from table(tapi_factura.tt(:NEW.FACTURA_ID));


        P_IGNORE_NULLS := TRUE;

          P_FACTURA_REC.ID := :NEW.FACTURA_ID;
          P_FACTURA_REC.ID_FACT := P_ULT_FAC;
          if l_es_credito = 'S' then
            P_FACTURA_REC.STATUS := 'PP';
          else
            P_FACTURA_REC.STATUS := 'V';
          end if;
          P_FACTURA_REC.FECHA_EMI := SYSDATE;
          P_FACTURA_REC.FACTURADO_POR := coalesce(sys_context('APEX$SESSION', 'app_user'), regexp_substr(sys_context('userenv', 'client_identifier'), '^[^:]*'), sys_context('userenv', 'session_user'));

          TAPI_FACTURA.UPD(
            P_FACTURA_REC => P_FACTURA_REC,
            P_IGNORE_NULLS => P_IGNORE_NULLS
          );

          UTL_CONFIGURACION.actConfUltFactura(P_ULT_FAC);

          if l_es_credito = 'S' then
            select rif, fecha_emi, id, monto 
              into l_rif,P_CTAXCOB_REC.FECHA,P_CTAXCOB_REC.FACTURA_ID, l_monto_fac  
              from table(tapi_factura.tt(:NEW.FACTURA_ID));

            select id into P_CTAXCOB_REC.CLIENTE_ID from clientes where rif = l_rif;

            select count(*) into l_ctaxcob from ctaxcob where factura_id = :NEW.FACTURA_ID;

            if l_ctaxcob = 0 then
              P_CTAXCOB_REC.DEPOSITO_ID := :NEW.DEPOSITO_ID;
              P_CTAXCOB_REC.CREDITO := 'DB';
              P_CTAXCOB_REC.MONTO := l_monto_fac;
            else
              P_CTAXCOB_REC.DEPOSITO_ID := :NEW.DEPOSITO_ID;
              P_CTAXCOB_REC.CREDITO := 'CR';
              select monto into P_CTAXCOB_REC.MONTO from table(tapi_deposito.tt(:NEW.DEPOSITO_ID));
            end if;

            tapi_ctaxcob.ins(p_ctaxcob_rec => p_ctaxcob_rec);

          end if;


      end if; 
   end if; 
end;

/
ALTER TRIGGER "FUNDAUC"."T_FACTURA_DEPOSITO_SEQ" ENABLE;
--------------------------------------------------------
--  DDL for Trigger T_INSCRIPCIONES_BID
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "FUNDAUC"."T_INSCRIPCIONES_BID" AFTER
    DELETE OR INSERT OR UPDATE ON inscripciones
    FOR EACH ROW
DECLARE
    p_factura_rec           fundauc.tapi_factura.factura_rt;
    p_estudiante_rec        fundauc.tapi_estudiante.estudiante_rt;
    p_cond_especial_rec     fundauc.tapi_condiciones_especiales.condiciones_especiales_rt;
    p_detalle_factura_rec   fundauc.tapi_detalle_factura.detalle_factura_rt;
    p_material_mat_rec      fundauc.utl_materiales.detalle_factura_rt;
    p_hoja_vida_est_rec     fundauc.tapi_hoja_vida_est.hoja_vida_est_rt;
    l_precio                NUMBER := 0;
    l_fact_id               NUMBER := 0;
    l_modalidad             NUMBER := 0;
    P_IGNORE_NULLS          BOOLEAN;
    l_facid                 NUMBER := 0;
    l_renglonid             NUMBER := 0;
BEGIN
    IF
        inserting  --si esta insertando
    THEN
        --llena registro estudiante con el numero de matricula
        p_estudiante_rec := tapi_estudiante.rt(p_matricula =>:new.est_matricula);
        --llena registro de condicion especial
        p_cond_especial_rec := tapi_condiciones_especiales.rt(p_id_condicion => p_estudiante_rec.condicion_especial);

        -- si el codigo de la seccion no esta vacio
        if :NEW.SECCION_ID is not null then
            -- llena la variable modalidad de la seccion
            SELECT
                modalidad
            INTO
                l_modalidad
            FROM
                TABLE ( tapi_secciones.tt(:new.seccion_id) );
        end if;

        -- si el codigo de la cohorte no es nulo
        if :NEW.COHORTE_ID is not null then
            SELECT
                id_modalidad
            INTO
                l_modalidad
            FROM
                TABLE ( tapi_cohortes.tt(:new.cohorte_id) );
        end if;

        -- si la condicion especial no es EXONERADO o no es suspendido
        IF
            p_estudiante_rec.condicion_especial != 5 OR :new.es_suspendido != 'S'
        THEN
            -- llena registro de factura
            p_factura_rec.id_fact := NULL;
            p_factura_rec.tipo := 'FA';
            p_factura_rec.cedula_est := p_estudiante_rec.cedula_est;
            p_factura_rec.nombre_cliente := p_estudiante_rec.nombre
            || ' '
            || p_estudiante_rec.apellido;
            p_factura_rec.fecha_emi := NULL;
            p_factura_rec.monto := 0;
            p_factura_rec.p_iva := 0;
            p_factura_rec.monto_iva := 0;
            p_factura_rec.flete := 0;
            p_factura_rec.bs_descuento := 0;
            p_factura_rec.dir_fiscal := p_estudiante_rec.direccion;
            p_factura_rec.rif := p_estudiante_rec.cedula_est;
            p_factura_rec.status := 'PC';
            p_factura_rec.programa := global.getval('SEDE');
            p_factura_rec.prog_academico := to_number(global.getval('PROG') );
            p_factura_rec.creado_por := coalesce(sys_context('APEX$SESSION','app_user'),regexp_substr(sys_context('userenv','client_identifier'
),'^[^:]*'),sys_context('userenv','session_user') );
            p_factura_rec.creado_el := SYSDATE;
            p_factura_rec.monto_exento := 0;
            p_factura_rec.base_imponible := 0;
            p_factura_rec.escredito := 'N';
            p_factura_rec.id := factura_seq.nextval;

            --inserta registro de factura
            tapi_factura.ins(p_factura_rec => p_factura_rec);

            --inserta en inscripcion_factura
            INSERT INTO inscripcion_factura (
                inscripcion_id,
                factura_id
            ) VALUES (
                :new.id,
                p_factura_rec.id
            );

            -- si el tipo de estudiante es NUEVO INGRESO
            IF
                p_estudiante_rec.id_tipo_est = 0
            THEN
                --llena el registro de materiales con el codigo de la seccion y el tipo de material CURSO
                p_material_mat_rec := utl_materiales.getrecdetallefac(:new.seccion_id,'C');
                -- llena el registro del detalle de la factura del CURSO
                p_detalle_factura_rec.renglon := detalle_factura_seq.nextval;
                p_detalle_factura_rec.tipo_item := p_material_mat_rec.tipo_item;
                p_detalle_factura_rec.item := p_material_mat_rec.item;
                p_detalle_factura_rec.descripcion := p_material_mat_rec.descripcion;
                p_detalle_factura_rec.cantidad := p_material_mat_rec.cantidad;
                p_detalle_factura_rec.p_unidad := p_material_mat_rec.p_unidad;
                p_detalle_factura_rec.bs_descuento := p_material_mat_rec.bs_descuento;
                p_detalle_factura_rec.subtotal := p_material_mat_rec.subtotal;
                p_detalle_factura_rec.materiales_id := p_material_mat_rec.materiales_id;
                p_detalle_factura_rec.factura_id := p_factura_rec.id;

                --inserta el detalle de la factura de CURSO
                tapi_detalle_factura.ins(p_detalle_factura_rec => p_detalle_factura_rec);

                --llena registro de la hojade vida para CURSO
                p_hoja_vida_est_rec.id := hoja_vida_est_seq.nextval;
                p_hoja_vida_est_rec.matricula :=:new.est_matricula;
                p_hoja_vida_est_rec.evento_id := 2;
                p_hoja_vida_est_rec.fecha := systimestamp;
                
                --si es seccion
                if :NEW.SECCION_ID is not null then
                  -- elcampometadata con el json del seccion
                  p_hoja_vida_est_rec.metadata := get_inscripcion_json(:new.id,'S',:new.seccion_id);
                end if; 
                --si es chorte
                if :NEW.COHORTE_ID is not null then
                  --llena el campo metadata con el json de la cohorte
                  p_hoja_vida_est_rec.metadata := get_inscripcion_json(:new.id,'C',:new.cohorte_id);
                end if;  
                --llena el campo observacion con el estatus de la inscripcion
                p_hoja_vida_est_rec.observacion := upper(utl_inscripciones.getdesstatus(:new.estatus) );
                --inserta en la hoja de vida para CURSO
                tapi_hoja_vida_est.ins(p_hoja_vida_est_rec);

                -- llena registro de material con el codigo de INSCRIPCION
                p_material_mat_rec := utl_materiales.getrecdetallefac('IN01');
                -- llena el registro de detalle de factura de INSCRIPCION
                p_detalle_factura_rec.renglon := detalle_factura_seq.nextval;
                p_detalle_factura_rec.tipo_item := p_material_mat_rec.tipo_item;
                p_detalle_factura_rec.item := p_material_mat_rec.item;
                p_detalle_factura_rec.descripcion := p_material_mat_rec.descripcion;
                p_detalle_factura_rec.cantidad := p_material_mat_rec.cantidad;
                p_detalle_factura_rec.p_unidad := p_material_mat_rec.p_unidad;
                p_detalle_factura_rec.bs_descuento := p_material_mat_rec.bs_descuento;
                p_detalle_factura_rec.subtotal := p_material_mat_rec.subtotal;
                p_detalle_factura_rec.materiales_id := p_material_mat_rec.materiales_id;
                p_detalle_factura_rec.factura_id := p_factura_rec.id;
                -- Inserta detalle de factura de INSCRIPCION
                tapi_detalle_factura.ins(p_detalle_factura_rec => p_detalle_factura_rec);

                -- llena registro hoja de vida para INSCRIPCION
                p_hoja_vida_est_rec.id := hoja_vida_est_seq.nextval;
                p_hoja_vida_est_rec.matricula :=:new.est_matricula;
                p_hoja_vida_est_rec.evento_id := 1;
                p_hoja_vida_est_rec.fecha := systimestamp;
                p_hoja_vida_est_rec.metadata := NULL;
                p_hoja_vida_est_rec.observacion := 'PAGO DE INSCRIPCION';

                -- Inserta en hoja de vida para INSCRIPCION
                tapi_hoja_vida_est.ins(p_hoja_vida_est_rec);
            ELSE --si el tipo de estudiante no es NUEVO INGRESO
                --llena registro materiales con info de CURSO
                p_material_mat_rec := utl_materiales.getrecdetallefac(:new.seccion_id,'C');
                --llena registro del detalle factura para CURSO 
                p_detalle_factura_rec.renglon := detalle_factura_seq.nextval;
                p_detalle_factura_rec.tipo_item := p_material_mat_rec.tipo_item;
                p_detalle_factura_rec.item := p_material_mat_rec.item;
                p_detalle_factura_rec.descripcion := p_material_mat_rec.descripcion;
                p_detalle_factura_rec.cantidad := p_material_mat_rec.cantidad;
                p_detalle_factura_rec.p_unidad := p_material_mat_rec.p_unidad;
                p_detalle_factura_rec.bs_descuento := p_material_mat_rec.bs_descuento;
                p_detalle_factura_rec.subtotal := p_material_mat_rec.subtotal;
                p_detalle_factura_rec.materiales_id := p_material_mat_rec.materiales_id;
                p_detalle_factura_rec.factura_id := p_factura_rec.id;
                --inserta detalle factura para CURSO
                tapi_detalle_factura.ins(p_detalle_factura_rec => p_detalle_factura_rec);
                -- llena registro hoja de vida para CURSO
                p_hoja_vida_est_rec.id := hoja_vida_est_seq.nextval;
                p_hoja_vida_est_rec.matricula :=:new.est_matricula;
                p_hoja_vida_est_rec.evento_id := 2;
                p_hoja_vida_est_rec.fecha := systimestamp;
                --si es seccion
                if :NEW.SECCION_ID is not null then
                  p_hoja_vida_est_rec.metadata := get_inscripcion_json(:new.id,'S',:new.seccion_id);
                end if; 
                --si es cohorte
                if :NEW.COHORTE_ID is not null then
                  p_hoja_vida_est_rec.metadata := get_inscripcion_json(:new.id,'C',:new.cohorte_id);
                end if;  
                -- lleno observacion con el estado del la inscripcion
                p_hoja_vida_est_rec.observacion := upper(utl_inscripciones.getdesstatus(:new.estatus) );
                --inserta registro de hoja de vida para CURSO
                tapi_hoja_vida_est.ins(p_hoja_vida_est_rec);
                
                -- llena registro de materiales con el concepto de INSCRIPCION
                p_material_mat_rec := utl_materiales.getrecdetallefac('IN01');
                p_detalle_factura_rec.renglon := detalle_factura_seq.nextval;
                p_detalle_factura_rec.tipo_item := p_material_mat_rec.tipo_item;
                p_detalle_factura_rec.item := p_material_mat_rec.item;
                p_detalle_factura_rec.descripcion := p_material_mat_rec.descripcion;
                p_detalle_factura_rec.cantidad := p_material_mat_rec.cantidad;
                p_detalle_factura_rec.p_unidad := p_material_mat_rec.p_unidad;
                p_detalle_factura_rec.bs_descuento := p_material_mat_rec.bs_descuento;
                p_detalle_factura_rec.subtotal := p_material_mat_rec.subtotal;
                p_detalle_factura_rec.materiales_id := p_material_mat_rec.materiales_id;
                p_detalle_factura_rec.factura_id := p_factura_rec.id;
                --inserta registro de detalle de facatura para INSCRIPCION
                tapi_detalle_factura.ins(p_detalle_factura_rec => p_detalle_factura_rec);
                --llena registro hoja de vida para INSCRIPCION
                p_hoja_vida_est_rec.id := hoja_vida_est_seq.nextval;
                p_hoja_vida_est_rec.matricula :=:new.est_matricula;
                p_hoja_vida_est_rec.evento_id := 1;
                p_hoja_vida_est_rec.fecha := systimestamp;
                p_hoja_vida_est_rec.metadata := NULL;
                p_hoja_vida_est_rec.observacion := 'PAGO DE INSCRIPCION';
                --Inserta registro hoja de vida para inscripcion
                tapi_hoja_vida_est.ins(p_hoja_vida_est_rec);


            END IF; -- fin si el estudiante es NUEVO ingreso o no

            --si el estudiante tiene algun tipo de DESCUENTO
            IF
                p_cond_especial_rec.descuento IS NOT NULL
            THEN
                --llena registro de materia con el DESCUENTO
                p_material_mat_rec := utl_materiales.getrecdetallefac(p_cond_especial_rec.descuento);
                -- recalcula el precio con el descuento
                l_precio := ( ( ( p_detalle_factura_rec.cantidad * p_detalle_factura_rec.p_unidad ) * p_cond_especial_rec.porcentaje ) / 100 ) *-1;
                --actualiza la tabla de precios
                UPDATE precios
                    SET
                        precio1 = l_precio
                WHERE
                    id = p_material_mat_rec.materiales_id;
                --llena registro detalle_factura con el DESCUENTO
                p_detalle_factura_rec.renglon := detalle_factura_seq.nextval;
                p_detalle_factura_rec.tipo_item := p_material_mat_rec.tipo_item;
                p_detalle_factura_rec.item := p_material_mat_rec.item;
                p_detalle_factura_rec.descripcion := p_material_mat_rec.descripcion;
                p_detalle_factura_rec.cantidad := p_material_mat_rec.cantidad;
                p_detalle_factura_rec.p_unidad := l_precio; --p_material_cur.p_unidad;
                p_detalle_factura_rec.bs_descuento := p_material_mat_rec.bs_descuento;
                p_detalle_factura_rec.subtotal := p_material_mat_rec.subtotal;
                p_detalle_factura_rec.materiales_id := p_material_mat_rec.materiales_id;
                p_detalle_factura_rec.factura_id := p_factura_rec.id;
                --inserta registro en detalle_factura para DESCUENTO
                tapi_detalle_factura.ins(p_detalle_factura_rec => p_detalle_factura_rec);
                --llena registro hova de vida para DESCUENTO
                p_hoja_vida_est_rec.id := hoja_vida_est_seq.nextval;
                p_hoja_vida_est_rec.matricula :=:new.est_matricula;
                p_hoja_vida_est_rec.evento_id := 53;
                p_hoja_vida_est_rec.fecha := systimestamp;
                --si es seccion
                if :NEW.SECCION_ID is not null then
                  p_hoja_vida_est_rec.metadata := get_inscripcion_json(:new.id,'S',:new.seccion_id);
                end if; 
                --si es cohorte
                if :NEW.COHORTE_ID is not null then
                  p_hoja_vida_est_rec.metadata := get_inscripcion_json(:new.id,'C',:new.cohorte_id);
                end if;  
                p_hoja_vida_est_rec.observacion := 'Descuento del '
                || p_cond_especial_rec.porcentaje
                || '%, por condición especial ('
                || p_cond_especial_rec.descripcion
                || ')';
                -- inserta en hoja de vida para DESCUENTO
                tapi_hoja_vida_est.ins(p_hoja_vida_est_rec);
            END IF; -- fin si tiene descuento

        ELSE -- si el estudiante esta EXONERADO o es SUSPENDIDO
            --si es exonerado
            if :NEW.es_exonerado = 'S' then
                --llena registro de hoja de vida para EXONERADO O BECADO
                p_hoja_vida_est_rec.id := hoja_vida_est_seq.nextval;
                p_hoja_vida_est_rec.matricula :=:new.est_matricula;
                p_hoja_vida_est_rec.evento_id := 29;
                p_hoja_vida_est_rec.fecha := systimestamp;
                --si es seccion
                if :NEW.SECCION_ID is not null then
                  p_hoja_vida_est_rec.metadata := get_inscripcion_json(:new.id,'S',:new.seccion_id);
                end if; 
                --si es cohorte
                if :NEW.COHORTE_ID is not null then
                  p_hoja_vida_est_rec.metadata := get_inscripcion_json(:new.id,'C',:new.cohorte_id);
                end if;  
                p_hoja_vida_est_rec.observacion := 'ESTUDIANTE EXONERADO O BECADO';
                
             --   tapi_hoja_vida_est.ins(p_hoja_vida_est_rec);
            elsif :NEW.es_suspendido = 'S' then -- Si es Suspendido
                --llena registro de hoja de vida para SUSPENDIDO
                p_hoja_vida_est_rec.id := hoja_vida_est_seq.nextval;
                p_hoja_vida_est_rec.matricula :=:new.est_matricula;
                p_hoja_vida_est_rec.evento_id := 51;
                p_hoja_vida_est_rec.fecha := systimestamp;
                --si es seccion
                if :NEW.SECCION_ID is not null then
                  p_hoja_vida_est_rec.metadata := get_inscripcion_json(:new.id,'S',:new.seccion_id);
                end if; 
                --si es cohorte
                if :NEW.COHORTE_ID is not null then
                  p_hoja_vida_est_rec.metadata := get_inscripcion_json(:new.id,'C',:new.cohorte_id);
                end if;  
                p_hoja_vida_est_rec.observacion := 'ESTUDIANTE SUSPENDIO CURSO';

              END IF; --fin si es exonerado o suspendido
              -- inserta hoja de vida para EXONERADO O BECADO
              tapi_hoja_vida_est.ins(p_hoja_vida_est_rec);

        end if;

    ELSIF deleting THEN --si esta borrando registro
        -- trae el id de la factura de la inscripcion
        SELECT
            factura_id
        INTO
            l_fact_id
        FROM
            inscripcion_factura
        WHERE
            inscripcion_id =:old.id;
        --elimina registro de inscripcion factura
        DELETE FROM inscripcion_factura
        WHERE
            inscripcion_id =:old.id;
        --elimina registro detalle de la factura
        DELETE FROM detalle_factura WHERE
            factura_id = l_fact_id;
        --elimina registro de factura
        DELETE FROM factura WHERE
            id = l_fact_id;
    ELSIF updating THEN -- si esta modificando inscripcion

        -- si cambio el codigo de la seccion
        if :NEW.SECCION_ID<>:OLD.SECCION_ID then
          -- trae el id de la factura de inscripcion_factura
          select factura_id into l_facid from inscripcion_factura where inscripcion_id = :OLD.ID;
          -- trae el renglon del detalle de la factura donde sea curso
          select renglon into l_renglonid from detalle_factura where factura_id = l_facid and tipo_item='C';

          -- llena el registro de materiales con la nueva seccion
          p_material_mat_rec := utl_materiales.getrecdetallefac(:new.seccion_id,'C');

          P_IGNORE_NULLS := TRUE;

          -- llena el registro del detalle de la factura a modificar
          p_detalle_factura_rec.renglon := l_renglonid;
          p_detalle_factura_rec.item := p_material_mat_rec.item;
          p_detalle_factura_rec.materiales_id := p_material_mat_rec.materiales_id;
          p_detalle_factura_rec.descripcion := p_material_mat_rec.descripcion;

          --modifica registro del detalle de factura
          TAPI_DETALLE_FACTURA.UPD(
            P_DETALLE_FACTURA_REC => P_DETALLE_FACTURA_REC,
            P_IGNORE_NULLS => P_IGNORE_NULLS
          );
            -- llena registro de hoja de vida CAMBIO DE SECCION
            p_hoja_vida_est_rec.id := hoja_vida_est_seq.nextval;
            p_hoja_vida_est_rec.matricula :=:new.est_matricula;
            p_hoja_vida_est_rec.evento_id := 66;
            p_hoja_vida_est_rec.fecha := systimestamp;
            --si es seccion
            if :NEW.SECCION_ID is not null then
              p_hoja_vida_est_rec.metadata := get_inscripcion_json(:new.id,'S',:new.seccion_id);
            end if; 
            --si es cohorte
            if :NEW.COHORTE_ID is not null then
              p_hoja_vida_est_rec.metadata := get_inscripcion_json(:new.id,'C',:new.cohorte_id);
            end if;  
            p_hoja_vida_est_rec.observacion := 'CAMBIO DE SECCION '||utl_inscripciones.getSeccionCod(:OLD.SECCION_ID)||' PARA '||utl_inscripciones.getSeccionCod(:NEW.SECCION_ID);
            --inserta registro de hoja de vida
            tapi_hoja_vida_est.ins(p_hoja_vida_est_rec);
         end if;
   END IF;

EXCEPTION
    WHEN no_data_found THEN
        NULL;
END;
/
ALTER TRIGGER "FUNDAUC"."T_INSCRIPCIONES_BID" ENABLE;
--------------------------------------------------------
--  DDL for Trigger T_SECCIONES_AUID
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "FUNDAUC"."T_SECCIONES_AUID" 
AFTER
    UPDATE OF PERIODO, MODALIDAD, ID_HORARIO OR DELETE OR INSERT ON  secciones 
for each row 
DECLARE
  l_precio number;
  P_MATERIALES_REC FUNDAUC.TAPI_MATERIALES.MATERIALES_RT;
  P_PRECIOS_REC FUNDAUC.TAPI_PRECIOS.PRECIOS_RT;
  P_INSTANCIAS_SECCIONES_REC FUNDAUC.TAPI_INSTANCIAS_SECCIONES.INSTANCIAS_SECCIONES_RT;
  l_id  number;
  P_IGNORE_NULLS          BOOLEAN;

begin
  BEGIN

    IF INSERTING THEN -- inserta
      --Inserta Secciones nuevas
          -- selecciona el maximo precio entre todos los cursos
          select max(precio1) into l_precio from precios
          where tipo_item = 'C';
            --llena el registro de materiales con la SECCION
            P_MATERIALES_REC.id_mat := :NEW.ID_SECCION;
            P_MATERIALES_REC.tipo := 'C';
            P_MATERIALES_REC.descripcion := :NEW.ID_METODO||'|NIVEL '||lpad(:NEW.nivel,2,'0')||'|'||UTL_HORARIOS.GETHORARIO(:NEW.ID_HORARIO)||'|'||to_char(utl_periodos.getPeriodoFInicio(:NEW.PERIODO),'DD/MM/YYYY')||'|'||utl_modalidades.getModalidad(:NEW.modalidad)||'|'||:NEW.id_salon;
            P_MATERIALES_REC.id_curso := :NEW.ID_METODO;
            P_MATERIALES_REC.evento := 2;
            P_MATERIALES_REC.nivel := :NEW.NIVEL;
            P_MATERIALES_REC.iva_exento := 'S';
            P_MATERIALES_REC.activo := 'S';
          --  P_MATERIALES_REC.id := 
            P_MATERIALES_REC.seccion_id := :NEW.ID;
            P_MATERIALES_REC.creado_por := coalesce(sys_context('APEX$SESSION', 'app_user'), regexp_substr(sys_context('userenv', 'client_identifier'), '^[^:]*'), sys_context('userenv', 'session_user'));
            P_MATERIALES_REC.creado_el := SYSDATE;
            P_MATERIALES_REC.modificado_por := null;
            P_MATERIALES_REC.modificado_el := null;
            P_MATERIALES_REC.cohorte_id := null;
      --inserta registro de materiales
      TAPI_MATERIALES.INS(P_MATERIALES_REC);
            --llena registro de precios
            P_PRECIOS_REC.id := P_MATERIALES_REC.id;
            P_PRECIOS_REC.tipo_item := P_MATERIALES_REC.tipo;
            P_PRECIOS_REC.fecha := SYSDATE;
            P_PRECIOS_REC.precio1 := l_precio;
            P_PRECIOS_REC.precio2 := 0;
            P_PRECIOS_REC.precio3 := 0;
            P_PRECIOS_REC.status := 'V';
            P_PRECIOS_REC.precio4 := 0;
            P_PRECIOS_REC.precio5 := 0;

        --Inserta registro de precios
        TAPI_PRECIOS.INS(P_PRECIOS_REC);
        
        -- llena registro de instancias secciones
        P_INSTANCIAS_SECCIONES_REC.seccion_id := :NEW.ID;
        P_INSTANCIAS_SECCIONES_REC.codigo_sec := :NEW.ID_SECCION;
        P_INSTANCIAS_SECCIONES_REC.metodo_id  := :NEW.ID_METODO;
        P_INSTANCIAS_SECCIONES_REC.nivel := :NEW.NIVEL;
        P_INSTANCIAS_SECCIONES_REC.periodo_id := :NEW.PERIODO;
        P_INSTANCIAS_SECCIONES_REC.horario_id := :NEW.ID_HORARIO;
        P_INSTANCIAS_SECCIONES_REC.modalidad_id := :NEW.MODALIDAD;
        P_INSTANCIAS_SECCIONES_REC.cedula_prof := :NEW.CEDULA_PROF;
        P_INSTANCIAS_SECCIONES_REC.f_inicio := utl_periodos.getPeriodoFInicio(:NEW.PERIODO);
        P_INSTANCIAS_SECCIONES_REC.f_fin := utl_periodos.getPeriodoFFin(:NEW.PERIODO);
        P_INSTANCIAS_SECCIONES_REC.estatus := 'ABIERTA';
    
        --Inserta registro de instancias secciones
        TAPI_INSTANCIAS_SECCIONES.INS(P_INSTANCIAS_SECCIONES_REC);

    ELSIF updating then -- si se esta modificando
      -- actualiza tabla de materiales con la descripcion modificada
      update materiales set descripcion = :NEW.ID_METODO||'|NIVEL '||lpad(:NEW.nivel,2,'0')||'|'||UTL_HORARIOS.GETHORARIO(:NEW.ID_HORARIO)||'|'||to_char(nvl(utl_periodos.getPeriodoFecIniSec(:NEW.ID),utl_periodos.getPeriodoFecIniSec(:OLD.ID)),'DD/MM/YYYY')||'|'||utl_modalidades.getModalidad(:NEW.modalidad)||'|'||:NEW.id_salon
            where tipo='C' and seccion_id = :OLD.ID;
            
      select id into P_INSTANCIAS_SECCIONES_REC.id 
      from INSTANCIAS_SECCIONES
      where seccion_id = :OLD.ID;
      
      P_IGNORE_NULLS := TRUE;
        
      case
        when :NEW.ID_SECCION<>:OLD.ID_SECCION then
            P_INSTANCIAS_SECCIONES_REC.codigo_sec := :NEW.ID_SECCION;
        when :NEW.ID_METODO<>:OLD.ID_METODO then
            P_INSTANCIAS_SECCIONES_REC.metodo_id  := :NEW.ID_METODO;
        when :NEW.NIVEL<>:OLD.NIVEL then
            P_INSTANCIAS_SECCIONES_REC.nivel := :NEW.NIVEL;
        when :NEW.PERIODO<>:OLD.PERIODO then
            P_INSTANCIAS_SECCIONES_REC.periodo_id := :NEW.PERIODO;
        when :NEW.ID_HORARIO<>:OLD.ID_HORARIO then
            P_INSTANCIAS_SECCIONES_REC.horario_id := :NEW.ID_HORARIO;
        when :NEW.MODALIDAD<>:OLD.MODALIDAD then
            P_INSTANCIAS_SECCIONES_REC.modalidad_id := :NEW.MODALIDAD;
        when :NEW.CEDULA_PROF<>:OLD.CEDULA_PROF then
            P_INSTANCIAS_SECCIONES_REC.cedula_prof := :NEW.CEDULA_PROF;
      end case;
      
      TAPI_INSTANCIAS_SECCIONES.UPD(
            P_INSTANCIAS_SECCIONES_REC => P_INSTANCIAS_SECCIONES_REC,
            P_IGNORE_NULLS => P_IGNORE_NULLS
          );

      --si cambio el periodo o la modalidad o el horario
/*      if :NEW.PERIODO<>:OLD.PERIODO or :NEW.MODALIDAD<>:OLD.MODALIDAD or :NEW.ID_HORARIO<>:OLD.ID_HORARIO then

            update inscripciones set estatus = 'IF'
            where estatus not in ('ACXC','AEXC') and seccion_id = :OLD.ID;

            update inscripciones set estatus = 'IFXC'
            where estatus in ('ACXC','AEXC') and seccion_id = :OLD.ID;
       end if;*/

    ELSIF deleting then --si esta borrando
       --trae el id del material
       select id into l_id from materiales where seccion_id = :OLD.ID and tipo='C';
       --elimina el precio
       delete from precios where id = l_id;
       --elimina el material
       delete from materiales where id = l_id;
       --elimina de instancias_secciones
       delete from instancias_secciones where seccion_id=:OLD.ID;
    END IF;
  END;
end;
/
ALTER TRIGGER "FUNDAUC"."T_SECCIONES_AUID" ENABLE;
--------------------------------------------------------
--  DDL for Procedure IMPRIME_PDF
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "FUNDAUC"."IMPRIME_PDF" 
(p_id IN NUMBER)
is
    l_mime varchar2(255);
    l_length number;
    l_file_name varchar2(200);
    l_blob blob;
begin
    select '', pdf_blob, DBMS_LOB.getlength(pdf_blob)
    into l_mime, l_blob, l_length
    from material_digital
    where PDF_ID = p_id;
    owa_util.mime_header( nvl(l_mime,'application/pdf'), FALSE );
    htp.p('Content-length: ' || l_length);
    owa_util.http_header_close;
    -- descargar el reporte pdf
    wpg_docload.download_file(l_blob);
end;

/
--------------------------------------------------------
--  DDL for Procedure PL
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "FUNDAUC"."PL" (
aiv_text                       in     varchar2 ) is
/*
pl.prc
by Donald J. Bales on 2014-10-20
A wrapper procedure for SYS.DBMS_OUTPUT.put_line()
for the lazy typist.
*/

begin
  SYS.DBMS_OUTPUT.put_line(aiv_text);
end pl;

/
--------------------------------------------------------
--  DDL for Procedure SET_CONTEXTO
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "FUNDAUC"."SET_CONTEXTO" 
( pname  VARCHAR2
, pvalue VARCHAR2) IS
BEGIN
  -- Create a session with a previously defined context.
  DBMS_SESSION.SET_CONTEXT('FUNDAUC_CTX',pname,pvalue);
END;

/
--------------------------------------------------------
--  DDL for Procedure SHOW_PDF
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "FUNDAUC"."SHOW_PDF" 
AS
   l_blob    BLOB;
   l_bfile   BFILE;
BEGIN
   DBMS_LOB.createtemporary (l_blob, TRUE, DBMS_LOB.SESSION);
   --create or replace directory MY_FILES as 'c:\pdfs'; --'/users/pdf/files'
   l_bfile := BFILENAME ('MISPDF', 'my.pdf');
   DBMS_LOB.fileopen (l_bfile);
   DBMS_LOB.loadfromfile (l_blob, l_bfile, DBMS_LOB.getlength (l_bfile));
   DBMS_LOB.fileclose (l_bfile);

   OWA_UTIL.mime_header ('application/pdf',
                         bclose_header      => FALSE);
   ------------------------------------------------------------------------
   -- set content length
   ------------------------------------------------------------------------
   HTP.p ('Content-length: ' || DBMS_LOB.getlength (l_blob));
   OWA_UTIL.http_header_close;
   ------------------------------------------------------------------------
   -- download the file and display in browser
   ------------------------------------------------------------------------
   WPG_DOCLOAD.download_file (l_blob);
   ------------------------------------------------------------------------
   -- release resources
   ------------------------------------------------------------------------
   DBMS_LOB.freetemporary (l_blob);

EXCEPTION
   WHEN NO_DATA_FOUND
   THEN
      NULL;
END;

/
--------------------------------------------------------
--  DDL for Package APEX_ENHANCED_LOV_ITEM
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "FUNDAUC"."APEX_ENHANCED_LOV_ITEM" as
  procedure render (
      p_item   in            apex_plugin.t_item,
      p_plugin in            apex_plugin.t_plugin,
      p_param  in            apex_plugin.t_item_render_param,
      p_result in out nocopy apex_plugin.t_item_render_result 
  );

  procedure ajax(
    p_item   in            apex_plugin.t_item,
    p_plugin in            apex_plugin.t_plugin,
    p_param  in            apex_plugin.t_item_ajax_param,
    p_result in out nocopy apex_plugin.t_item_ajax_result 
  );
end;

/
--------------------------------------------------------
--  DDL for Package AS_PDF3_MOD
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "FUNDAUC"."AS_PDF3_MOD" 
is
/**********************************************
**
** Additional comment by Andreas Weiden:
**AS_PDF3_MOD

** The following methods were added by me for additinal functionality needed for PK_JRXML_REPGEN
**
** -   PR_GOTO_PAGE
** -   PR_GOTO_CURRENT_PAGE;
** -   PR_LINE
** -   PR_POLYGON
** -   PR_PATH
**
** Changed in parameter p_txt for procedure raw2page  from blob to raw
** Added global collection g_settings_per_tab to store different pageformat for each page.
** changed add_page to write a MediaBox-entry with the g_settings_per_tab-content for each page
**
** Change in subset_font:Checking for raw-length reduced from 32778 to 32000 because of raw-length-error
** in specific cases
**
** Various changes for font-usage: The access to g_fonts(g_current_font) is very slow, replaced it with a specific font-record
** which is filled when g_current_font changes
**
** Changes in adler32: The num-value of a hex-byte is no longer calculated by a to_number, but taken from an associative array
** done for preformance. Also there is an additional check for step_size, because this will result in 0 with chunksizes>16383
**
** Changes in put_image_methods: the adler32-value can be provided from outside
***/


/**********************************************
**
** Author: Anton Scheffer
** Date: 11-04-2012
** Website: http://technology.amis.nl
** See also: http://technology.amis.nl/?p=17718
**
** Changelog:
**   Date: 16-04-2012
**     changed code for parse_png
**   Date: 15-04-2012
**     only dbms_lob.freetemporary for temporary blobs
**   Date: 11-04-2012
**     Initial release of as_pdf3
**
******************************************************************************
******************************************************************************
Copyright (C) 2012 by Anton Scheffer

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

******************************************************************************
******************************************** */
--
  c_get_page_width    constant pls_integer := 0;
  c_get_page_height   constant pls_integer := 1;
  c_get_margin_top    constant pls_integer := 2;
  c_get_margin_right  constant pls_integer := 3;
  c_get_margin_bottom constant pls_integer := 4;
  c_get_margin_left   constant pls_integer := 5;
  c_get_x             constant pls_integer := 6;
  c_get_y             constant pls_integer := 7;
  c_get_fontsize      constant pls_integer := 8;
  c_get_current_font  constant pls_integer := 9;

  type tVertices is table of number index by pls_integer;

  PATH_MOVE_TO    CONSTANT NUMBER:=1;
  PATH_LINE_TO    CONSTANT NUMBER:=2;
  PATH_CURVE_TO   CONSTANT NUMBER:=3;
  PATH_CLOSE      CONSTANT NUMBER:=4;

  type tPathElement IS RECORD (
    nType NUMBER,
    nVal1 NUMBER,
    nVal2 NUMBER,
    nVal3 NUMBER,
    nVal4 NUMBER,
    nVal5 NUMBER,
    nVal6 NUMBER
  );

  TYPE tPath IS TABLE OF tPathElement INDEX BY BINARY_INTEGER;
--
  function file2blob( p_dir varchar2, p_file_name varchar2 )
  return blob;
--
  function conv2uu( p_value number, p_unit varchar2 )
  return number;
--
  procedure set_page_size
    ( p_width number
    , p_height number
    , p_unit varchar2 := 'cm'
    );
--
  procedure set_page_format( p_format varchar2 := 'A4' );
--
  procedure set_page_orientation( p_orientation varchar2 := 'PORTRAIT' );
--
  procedure set_margins
    ( p_top number := null
    , p_left number := null
    , p_bottom number := null
    , p_right number := null
    , p_unit varchar2 := 'cm'
    );
--
  procedure set_info
    ( p_title varchar2 := null
    , p_author varchar2 := null
    , p_subject varchar2 := null
    , p_keywords varchar2 := null
    );
--
  procedure init;
--
  function get_pdf
  return blob;
--
  procedure save_pdf
    ( p_dir varchar2 := 'MY_DIR'
    , p_filename varchar2 := 'my.pdf'
    , p_freeblob boolean := true
    );
--
  procedure txt2page( p_txt varchar2 );
--
  procedure put_txt( p_x number, p_y number, p_txt varchar2, p_degrees_rotation number := null );
--
  function str_len( p_txt varchar2 )
  return number;
--
  procedure write
    ( p_txt in varchar2
    , p_x in number := null
    , p_y in number := null
    , p_line_height in number := null
    , p_start in number := null -- left side of the available text box
    , p_width in number := null -- width of the available text box
    , p_alignment in varchar2 := null
    );
--
  procedure set_font
    ( p_index pls_integer
    , p_fontsize_pt number
    , p_output_to_doc boolean := true
    );
--
  function set_font
    ( p_fontname varchar2
    , p_fontsize_pt number
    , p_output_to_doc boolean := true
    )
  return pls_integer;
--
  procedure set_font
    ( p_fontname varchar2
    , p_fontsize_pt number
    , p_output_to_doc boolean := true
    );
--
  function set_font
    ( p_family varchar2
    , p_style varchar2 := 'N'
    , p_fontsize_pt number := null
    , p_output_to_doc boolean := true
    )
  return pls_integer;
--
  procedure set_font
    ( p_family varchar2
    , p_style varchar2 := 'N'
    , p_fontsize_pt number := null
    , p_output_to_doc boolean := true
    );
--
  procedure new_page;
--
  function load_ttf_font
    ( p_font blob
    , p_encoding varchar2 := 'WINDOWS-1252'
    , p_embed boolean := false
    , p_compress boolean := true
    , p_offset number := 1
    )
  return pls_integer;
--
  procedure load_ttf_font
    ( p_font blob
    , p_encoding varchar2 := 'WINDOWS-1252'
    , p_embed boolean := false
    , p_compress boolean := true
    , p_offset number := 1
    );
--
  function load_ttf_font
    ( p_dir varchar2 := 'MY_FONTS'
    , p_filename varchar2 := 'BAUHS93.TTF'
    , p_encoding varchar2 := 'WINDOWS-1252'
    , p_embed boolean := false
    , p_compress boolean := true
    )
  return pls_integer;
--
  procedure load_ttf_font
    ( p_dir varchar2 := 'MY_FONTS'
    , p_filename varchar2 := 'BAUHS93.TTF'
    , p_encoding varchar2 := 'WINDOWS-1252'
    , p_embed boolean := false
    , p_compress boolean := true
    );
--
  procedure load_ttc_fonts
    ( p_ttc blob
    , p_encoding varchar2 := 'WINDOWS-1252'
    , p_embed boolean := false
    , p_compress boolean := true
    );
--
  procedure load_ttc_fonts
    ( p_dir varchar2 := 'MY_FONTS'
    , p_filename varchar2 := 'CAMBRIA.TTC'
    , p_encoding varchar2 := 'WINDOWS-1252'
    , p_embed boolean := false
    , p_compress boolean := true
    );
--
  procedure set_color( p_rgb varchar2 := '000000' );
--
  procedure set_color
    ( p_red number := 0
    , p_green number := 0
    , p_blue number := 0
    );
--
  procedure set_bk_color( p_rgb varchar2 := 'ffffff' );
--
  procedure set_bk_color
    ( p_red number := 0
    , p_green number := 0
    , p_blue number := 0
    );
--
  procedure horizontal_line
    ( p_x in number
    , p_y in number
    , p_width in number
    , p_line_width in number := 0.5
    , p_line_color in varchar2 := '000000'
    );
--
  procedure vertical_line
    ( p_x in number
    , p_y in number
    , p_height in number
    , p_line_width in number := 0.5
    , p_line_color in varchar2 := '000000'
    );
--
  procedure rect
    ( p_x in number
    , p_y in number
    , p_width in number
    , p_height in number
    , p_line_color in varchar2 := null
    , p_fill_color in varchar2 := null
    , p_line_width in number := 0.5
    );
--
  function get( p_what in pls_integer )
  return number;
--
  procedure put_image
    ( p_img blob
    , p_x number
    , p_y number
    , p_width number := null
    , p_height number := null
    , p_align varchar2 := 'center'
    , p_valign varchar2 := 'top'
    , p_adler32 varchar2 := null
    );
--
  procedure put_image
    ( p_dir varchar2
    , p_file_name varchar2
    , p_x number
    , p_y number
    , p_width number := null
    , p_height number := null
    , p_align varchar2 := 'center'
    , p_valign varchar2 := 'top'
    , p_adler32 varchar2 := null
    );
--
  procedure put_image
    ( p_url varchar2
    , p_x number
    , p_y number
    , p_width number := null
    , p_height number := null
    , p_align varchar2 := 'center'
    , p_valign varchar2 := 'top'
    , p_adler32 varchar2 := null
    );
--
  procedure set_page_proc( p_src clob );
--
  type tp_col_widths is table of number;
  type tp_headers is table of varchar2(32767);
--
  procedure query2table
    ( p_query varchar2
    , p_widths tp_col_widths := null
    , p_headers tp_headers := null
    );
--

  PROCEDURE PR_GOTO_PAGE(i_nPage IN NUMBER);

  PROCEDURE PR_GOTO_CURRENT_PAGE;

  PROCEDURE PR_LINE(i_nX1         IN NUMBER,
                    i_nY1         IN NUMBER,
                    i_nX2         IN NUMBER,
                    i_nY2         IN NUMBER,
                    i_vcLineColor IN VARCHAR2 DEFAULT NULL,
                    i_nLineWidth  IN NUMBER DEFAULT 0.5,
                    i_vcStroke    IN VARCHAR2 DEFAULT NULL
                   );

  PROCEDURE PR_POLYGON(i_lXs         IN tVertices,
                       i_lYs         IN tVertices,
                       i_vcLineColor IN VARCHAR2 DEFAULT NULL,
                       i_vcFillColor IN VARCHAR2 DEFAULT NULL,
                       i_nLineWidth  IN NUMBER DEFAULT 0.5
                      );

  PROCEDURE PR_PATH(i_lPath       IN tPath,
                    i_vcLineColor IN VARCHAR2 DEFAULT NULL,
                    i_vcFillColor IN VARCHAR2 DEFAULT NULL,
                    i_nLineWidth  IN NUMBER DEFAULT 0.5
                   );

  function adler32( p_src in blob )
  return varchar2;

$IF not DBMS_DB_VERSION.VER_LE_10 $THEN
  procedure refcursor2table
    ( p_rc sys_refcursor
    , p_widths tp_col_widths := null
    , p_headers tp_headers := null
    );
--
$END
end;

/
--------------------------------------------------------
--  DDL for Package DIALOG_DEMO
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "FUNDAUC"."DIALOG_DEMO" as
-- use $0$, $1$ ... for client side value substitutions
function prepare_dialog_url (
    p_url in varchar2 )
    return varchar2;
end dialog_demo;

/
--------------------------------------------------------
--  DDL for Package FUNDAUC_PKG
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "FUNDAUC"."FUNDAUC_PKG" 
as
    procedure setSede(sede varchar2);
    procedure setProgAcad(prog number);
end fundauc_pkg;

/
--------------------------------------------------------
--  DDL for Package GLOBAL
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "FUNDAUC"."GLOBAL" 
AS
  FUNCTION getVal(pvar varchar2)  RETURN varchar2;
  PROCEDURE setVal (pvar IN VARCHAR2,pval IN VARCHAR2 );
END;

/
--------------------------------------------------------
--  DDL for Package PRETIUS_APEX_NESTED_REPORTS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "FUNDAUC"."PRETIUS_APEX_NESTED_REPORTS" as

  function pretius_row_details (
    p_dynamic_action in apex_plugin.t_dynamic_action,
    p_plugin         in apex_plugin.t_plugin 
  ) return apex_plugin.t_dynamic_action_render_result;

  function pretius_row_details_ajax(
    p_dynamic_action in apex_plugin.t_dynamic_action,
    p_plugin         in apex_plugin.t_plugin 
  ) return apex_plugin.t_dynamic_action_ajax_result;

end;

/
--------------------------------------------------------
--  DDL for Package TAPI_CALENDARIOS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "FUNDAUC"."TAPI_CALENDARIOS" 
IS
   /**
   * TAPI_CALENDARIOS
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: 24-OCT-2019 11:06
   * Created By: FUNDAUC
   */

   --Scalar/Column types
   SUBTYPE hash_t IS varchar2 (40);
   SUBTYPE id_calendario IS calendarios.id_calendario%TYPE;
   SUBTYPE descripcion IS calendarios.descripcion%TYPE;
   SUBTYPE activo IS calendarios.activo%TYPE;
   SUBTYPE tipo_cal IS calendarios.tipo_cal%TYPE;

   --Record type
   TYPE calendarios_rt
   IS
      RECORD (
            id_calendario calendarios.id_calendario%TYPE,
            descripcion calendarios.descripcion%TYPE,
            activo calendarios.activo%TYPE,
            tipo_cal calendarios.tipo_cal%TYPE,
            hash               hash_t,
            row_id            VARCHAR2(64)
      );
   --Collection types (record)
   TYPE calendarios_tt IS TABLE OF calendarios_rt;

   --Global exceptions
   e_ol_check_failed EXCEPTION; --Optimistic lock check failed
   e_row_missing     EXCEPTION; --The cursor failed to get a row
   e_upd_failed      EXCEPTION; --The update operation failed
   e_del_failed      EXCEPTION; --The delete operation failed

   /**
   * Generates a SHA1 hash for optimistic locking purposes.
   *
   * @param    p_id_calendario        must be NOT NULL
   */
   FUNCTION hash (
                  p_id_calendario IN calendarios.id_calendario%TYPE
                 )
    RETURN VARCHAR2;

   /**
   * This function generates a SHA1 hash for optimistic locking purposes.
   * Access directly to the row by rowid
   *
   * @param  p_rowid  must be NOT NULL
   */
   FUNCTION hash_rowid (p_rowid IN varchar2)
   RETURN varchar2;

   /**
   * This is a table encapsulation function designed to retrieve information from the calendarios table.
   *
   * @param      p_id_calendario      must be NOT NULL
   * @return     calendarios Record Type
   */
   FUNCTION rt (
                p_id_calendario IN calendarios.id_calendario%TYPE 
               )
    RETURN calendarios_rt RESULT_CACHE;

   /**
   * This is a table encapsulation function designed to retrieve information
   * from the calendarios table while placing a lock on it for a potential
   * update/delete. Do not use this for updates in web based apps, instead use the
   * rt_for_web_update function to get a FOR_WEB_UPDATE_RT record which
   * includes all of the tables columns along with an md5 checksum for use in the
   * web_upd and web_del procedures.
   *
   * @param      p_id_calendario      must be NOT NULL
   * @return     calendarios Record Type
   */
   FUNCTION rt_for_update (
                          p_id_calendario IN calendarios.id_calendario%TYPE 
                          )
    RETURN calendarios_rt RESULT_CACHE;

   /**
   * This is a table encapsulation function designed to retrieve information from the calendarios table.
   * This function return Record Table as PIPELINED Function
   *
   * @param      p_id_calendario      must be NOT NULL
   * @return     calendarios Table Record Type
   */
   FUNCTION tt (
                p_id_calendario IN calendarios.id_calendario%TYPE DEFAULT NULL
               )
   RETURN calendarios_tt
   PIPELINED;

   /**
   * This is a table encapsulation function designed to insert a row into the calendarios table.
   *
   * @param      p_calendarios_rec       Record Type
   * @return     p_calendarios_rec       Record Type
   */
   PROCEDURE ins (p_calendarios_rec IN OUT calendarios_rt);

   /**
   * This is a table encapsulation function designed to update a row in the calendarios table.
   *
   * @param      p_calendarios_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE upd (p_calendarios_rec IN calendarios_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row in the calendarios table,
   * access directly to the row by rowid
   *
   * @param      p_calendarios_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE upd_rowid (p_calendarios_rec IN calendarios_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row
   * in the calendarios table whith optimistic lock validation
   *
   * @param      p_calendarios_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE web_upd (p_calendarios_rec IN calendarios_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row
   * in the calendarios table whith optimistic lock validation
   * access directly to the row by rowid
   *
   * @param      p_calendarios_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE web_upd_rowid (p_calendarios_rec IN calendarios_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to delete a row from the calendarios table.
   *
   * @param    p_id_calendario        must be NOT NULL
   */
   PROCEDURE del (
                  p_id_calendario IN calendarios.id_calendario%TYPE
                );

   /**
   * This is a table encapsulation function designed to delete a row from the calendarios table
   * access directly to the row by rowid
   *
   * @param      p_rowid      must be NOT NULL
   */
    PROCEDURE del_rowid (p_rowid IN VARCHAR2);

   /**
   * This is a table encapsulation function designed to delete a row from the calendarios table
   * whith optimistic lock validation
   *
   * @param      p_id_calendario      must be NOT NULL
   * @param      p_hash       must be NOT NULL
   */
    PROCEDURE web_del (
                      p_id_calendario IN calendarios.id_calendario%TYPE,
                      p_hash IN varchar2
                      );

   /**
   * This is a table encapsulation function designed to delete a row from the calendarios table
   * whith optimistic lock validation, access directly to the row by rowid
   *
   * @param      p_rowid      must be NOT NULL
   * @param      p_hash       must be NOT NULL
   */
    PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2);

END tapi_calendarios;
 

/
--------------------------------------------------------
--  DDL for Package TAPI_CALENDARIOS_DETALLE
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "FUNDAUC"."TAPI_CALENDARIOS_DETALLE" 
IS
   /**
   * TAPI_CALENDARIOS_DETALLE
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: 30-JUL-2019 17:33
   * Created By: FUNDAUC
   */

   --Scalar/Column types
   SUBTYPE hash_t IS varchar2 (40);
   SUBTYPE id_calendario IS calendarios_detalle.id_calendario%TYPE;
   SUBTYPE periodo IS calendarios_detalle.periodo%TYPE;
   SUBTYPE fecha_ini IS calendarios_detalle.fecha_ini%TYPE;
   SUBTYPE fecha_fin IS calendarios_detalle.fecha_fin%TYPE;
   SUBTYPE modalidad IS calendarios_detalle.modalidad%TYPE;
   SUBTYPE periodo_activo IS calendarios_detalle.periodo_activo%TYPE;
   SUBTYPE id IS calendarios_detalle.id%TYPE;

   --Record type
   TYPE calendarios_detalle_rt
   IS
      RECORD (
            id_calendario calendarios_detalle.id_calendario%TYPE,
            periodo calendarios_detalle.periodo%TYPE,
            fecha_ini calendarios_detalle.fecha_ini%TYPE,
            fecha_fin calendarios_detalle.fecha_fin%TYPE,
            modalidad calendarios_detalle.modalidad%TYPE,
            periodo_activo calendarios_detalle.periodo_activo%TYPE,
            id calendarios_detalle.id%TYPE,
            hash               hash_t,
            row_id            VARCHAR2(64)
      );
   --Collection types (record)
   TYPE calendarios_detalle_tt IS TABLE OF calendarios_detalle_rt;

   --Global exceptions
   e_ol_check_failed EXCEPTION; --Optimistic lock check failed
   e_row_missing     EXCEPTION; --The cursor failed to get a row
   e_upd_failed      EXCEPTION; --The update operation failed
   e_del_failed      EXCEPTION; --The delete operation failed

   /**
   * Generates a SHA1 hash for optimistic locking purposes.
   *
   * @param    p_id        must be NOT NULL
   */
   FUNCTION hash (
                  p_id IN calendarios_detalle.id%TYPE
                 )
    RETURN VARCHAR2;

   /**
   * This function generates a SHA1 hash for optimistic locking purposes.
   * Access directly to the row by rowid
   *
   * @param  p_rowid  must be NOT NULL
   */
   FUNCTION hash_rowid (p_rowid IN varchar2)
   RETURN varchar2;

   /**
   * This is a table encapsulation function designed to retrieve information from the calendarios_detalle table.
   *
   * @param      p_id      must be NOT NULL
   * @return     calendarios_detalle Record Type
   */
   FUNCTION rt (
                p_id IN calendarios_detalle.id%TYPE 
               )
    RETURN calendarios_detalle_rt RESULT_CACHE;

   /**
   * This is a table encapsulation function designed to retrieve information
   * from the calendarios_detalle table while placing a lock on it for a potential
   * update/delete. Do not use this for updates in web based apps, instead use the
   * rt_for_web_update function to get a FOR_WEB_UPDATE_RT record which
   * includes all of the tables columns along with an md5 checksum for use in the
   * web_upd and web_del procedures.
   *
   * @param      p_id      must be NOT NULL
   * @return     calendarios_detalle Record Type
   */
   FUNCTION rt_for_update (
                          p_id IN calendarios_detalle.id%TYPE 
                          )
    RETURN calendarios_detalle_rt RESULT_CACHE;

   /**
   * This is a table encapsulation function designed to retrieve information from the calendarios_detalle table.
   * This function return Record Table as PIPELINED Function
   *
   * @param      p_id      must be NOT NULL
   * @return     calendarios_detalle Table Record Type
   */
   FUNCTION tt (
                p_id IN calendarios_detalle.id%TYPE DEFAULT NULL
               )
   RETURN calendarios_detalle_tt
   PIPELINED;

   /**
   * This is a table encapsulation function designed to insert a row into the calendarios_detalle table.
   *
   * @param      p_calendarios_detalle_rec       Record Type
   * @return     p_calendarios_detalle_rec       Record Type
   */
   PROCEDURE ins (p_calendarios_detalle_rec IN OUT calendarios_detalle_rt);

   /**
   * This is a table encapsulation function designed to update a row in the calendarios_detalle table.
   *
   * @param      p_calendarios_detalle_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE upd (p_calendarios_detalle_rec IN calendarios_detalle_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row in the calendarios_detalle table,
   * access directly to the row by rowid
   *
   * @param      p_calendarios_detalle_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE upd_rowid (p_calendarios_detalle_rec IN calendarios_detalle_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row
   * in the calendarios_detalle table whith optimistic lock validation
   *
   * @param      p_calendarios_detalle_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE web_upd (p_calendarios_detalle_rec IN calendarios_detalle_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row
   * in the calendarios_detalle table whith optimistic lock validation
   * access directly to the row by rowid
   *
   * @param      p_calendarios_detalle_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE web_upd_rowid (p_calendarios_detalle_rec IN calendarios_detalle_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to delete a row from the calendarios_detalle table.
   *
   * @param    p_id        must be NOT NULL
   */
   PROCEDURE del (
                  p_id IN calendarios_detalle.id%TYPE
                );

   /**
   * This is a table encapsulation function designed to delete a row from the calendarios_detalle table
   * access directly to the row by rowid
   *
   * @param      p_rowid      must be NOT NULL
   */
    PROCEDURE del_rowid (p_rowid IN VARCHAR2);

   /**
   * This is a table encapsulation function designed to delete a row from the calendarios_detalle table
   * whith optimistic lock validation
   *
   * @param      p_id      must be NOT NULL
   * @param      p_hash       must be NOT NULL
   */
    PROCEDURE web_del (
                      p_id IN calendarios_detalle.id%TYPE,
                      p_hash IN varchar2
                      );

   /**
   * This is a table encapsulation function designed to delete a row from the calendarios_detalle table
   * whith optimistic lock validation, access directly to the row by rowid
   *
   * @param      p_rowid      must be NOT NULL
   * @param      p_hash       must be NOT NULL
   */
    PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2);

END tapi_calendarios_detalle;


/
--------------------------------------------------------
--  DDL for Package TAPI_COHORTES
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "FUNDAUC"."TAPI_COHORTES" 
IS
   /**
   * TAPI_COHORTES
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: 25-FEB-2020 18:34
   * Created By: FUNDAUC
   */

   --Scalar/Column types
   SUBTYPE hash_t IS varchar2 (40);
   SUBTYPE codigo IS cohortes.codigo%TYPE;
   SUBTYPE id_horario IS cohortes.id_horario%TYPE;
   SUBTYPE id_modalidad IS cohortes.id_modalidad%TYPE;
   SUBTYPE cohorte IS cohortes.cohorte%TYPE;
   SUBTYPE cupo IS cohortes.cupo%TYPE;
   SUBTYPE costo IS cohortes.costo%TYPE;
   SUBTYPE inicial IS cohortes.inicial%TYPE;
   SUBTYPE costo_cuota IS cohortes.costo_cuota%TYPE;
   SUBTYPE cuotas IS cohortes.cuotas%TYPE;
   SUBTYPE status IS cohortes.status%TYPE;
   SUBTYPE id_ciudad IS cohortes.id_ciudad%TYPE;
   SUBTYPE id IS cohortes.id%TYPE;
   SUBTYPE tipo_diplo IS cohortes.tipo_diplo%TYPE;
   SUBTYPE creado_por IS cohortes.creado_por%TYPE;
   SUBTYPE creado_el IS cohortes.creado_el%TYPE;
   SUBTYPE modificado_por IS cohortes.modificado_por%TYPE;
   SUBTYPE modificado_el IS cohortes.modificado_el%TYPE;
   SUBTYPE diplomado_id IS cohortes.diplomado_id%TYPE;
   SUBTYPE periodo IS cohortes.periodo%TYPE;
   SUBTYPE id_calendario IS cohortes.id_calendario%TYPE;
   SUBTYPE nivel IS cohortes.nivel%TYPE;
   SUBTYPE id_metodo IS cohortes.id_metodo%TYPE;
   SUBTYPE empresa IS cohortes.empresa%TYPE;
   SUBTYPE facilitador IS cohortes.facilitador%TYPE;

   --Record type
   TYPE cohortes_rt
   IS
      RECORD (
            codigo cohortes.codigo%TYPE,
            id_horario cohortes.id_horario%TYPE,
            id_modalidad cohortes.id_modalidad%TYPE,
            cohorte cohortes.cohorte%TYPE,
            cupo cohortes.cupo%TYPE,
            costo cohortes.costo%TYPE,
            inicial cohortes.inicial%TYPE,
            costo_cuota cohortes.costo_cuota%TYPE,
            cuotas cohortes.cuotas%TYPE,
            status cohortes.status%TYPE,
            id_ciudad cohortes.id_ciudad%TYPE,
            id cohortes.id%TYPE,
            tipo_diplo cohortes.tipo_diplo%TYPE,
            creado_por cohortes.creado_por%TYPE,
            creado_el cohortes.creado_el%TYPE,
            modificado_por cohortes.modificado_por%TYPE,
            modificado_el cohortes.modificado_el%TYPE,
            diplomado_id cohortes.diplomado_id%TYPE,
            periodo cohortes.periodo%TYPE,
            id_calendario cohortes.id_calendario%TYPE,
            nivel cohortes.nivel%TYPE,
            id_metodo cohortes.id_metodo%TYPE,
            empresa cohortes.empresa%TYPE,
            facilitador cohortes.facilitador%TYPE,
            hash               hash_t,
            row_id            VARCHAR2(64)
      );
   --Collection types (record)
   TYPE cohortes_tt IS TABLE OF cohortes_rt;

   --Global exceptions
   e_ol_check_failed EXCEPTION; --Optimistic lock check failed
   e_row_missing     EXCEPTION; --The cursor failed to get a row
   e_upd_failed      EXCEPTION; --The update operation failed
   e_del_failed      EXCEPTION; --The delete operation failed

   /**
   * Generates a SHA1 hash for optimistic locking purposes.
   *
   * @param    p_id        must be NOT NULL
   */
   FUNCTION hash (
                  p_id IN cohortes.id%TYPE
                 )
    RETURN VARCHAR2;

   /**
   * This function generates a SHA1 hash for optimistic locking purposes.
   * Access directly to the row by rowid
   *
   * @param  p_rowid  must be NOT NULL
   */
   FUNCTION hash_rowid (p_rowid IN varchar2)
   RETURN varchar2;

   /**
   * This is a table encapsulation function designed to retrieve information from the cohortes table.
   *
   * @param      p_id      must be NOT NULL
   * @return     cohortes Record Type
   */
   FUNCTION rt (
                p_id IN cohortes.id%TYPE 
               )
    RETURN cohortes_rt RESULT_CACHE;

   /**
   * This is a table encapsulation function designed to retrieve information
   * from the cohortes table while placing a lock on it for a potential
   * update/delete. Do not use this for updates in web based apps, instead use the
   * rt_for_web_update function to get a FOR_WEB_UPDATE_RT record which
   * includes all of the tables columns along with an md5 checksum for use in the
   * web_upd and web_del procedures.
   *
   * @param      p_id      must be NOT NULL
   * @return     cohortes Record Type
   */
   FUNCTION rt_for_update (
                          p_id IN cohortes.id%TYPE 
                          )
    RETURN cohortes_rt RESULT_CACHE;

   /**
   * This is a table encapsulation function designed to retrieve information from the cohortes table.
   * This function return Record Table as PIPELINED Function
   *
   * @param      p_id      must be NOT NULL
   * @return     cohortes Table Record Type
   */
   FUNCTION tt (
                p_id IN cohortes.id%TYPE DEFAULT NULL
               )
   RETURN cohortes_tt
   PIPELINED;

   /**
   * This is a table encapsulation function designed to insert a row into the cohortes table.
   *
   * @param      p_cohortes_rec       Record Type
   * @return     p_cohortes_rec       Record Type
   */
   PROCEDURE ins (p_cohortes_rec IN OUT cohortes_rt);

   /**
   * This is a table encapsulation function designed to update a row in the cohortes table.
   *
   * @param      p_cohortes_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE upd (p_cohortes_rec IN cohortes_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row in the cohortes table,
   * access directly to the row by rowid
   *
   * @param      p_cohortes_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE upd_rowid (p_cohortes_rec IN cohortes_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row
   * in the cohortes table whith optimistic lock validation
   *
   * @param      p_cohortes_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE web_upd (p_cohortes_rec IN cohortes_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row
   * in the cohortes table whith optimistic lock validation
   * access directly to the row by rowid
   *
   * @param      p_cohortes_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE web_upd_rowid (p_cohortes_rec IN cohortes_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to delete a row from the cohortes table.
   *
   * @param    p_id        must be NOT NULL
   */
   PROCEDURE del (
                  p_id IN cohortes.id%TYPE
                );

   /**
   * This is a table encapsulation function designed to delete a row from the cohortes table
   * access directly to the row by rowid
   *
   * @param      p_rowid      must be NOT NULL
   */
    PROCEDURE del_rowid (p_rowid IN VARCHAR2);

   /**
   * This is a table encapsulation function designed to delete a row from the cohortes table
   * whith optimistic lock validation
   *
   * @param      p_id      must be NOT NULL
   * @param      p_hash       must be NOT NULL
   */
    PROCEDURE web_del (
                      p_id IN cohortes.id%TYPE,
                      p_hash IN varchar2
                      );

   /**
   * This is a table encapsulation function designed to delete a row from the cohortes table
   * whith optimistic lock validation, access directly to the row by rowid
   *
   * @param      p_rowid      must be NOT NULL
   * @param      p_hash       must be NOT NULL
   */
    PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2);

END tapi_cohortes;
 

/
--------------------------------------------------------
--  DDL for Package TAPI_CONDICIONES_ESPECIALES
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "FUNDAUC"."TAPI_CONDICIONES_ESPECIALES" 
IS
   /**
   * TAPI_CONDICIONES_ESPECIALES
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: 11-SEP-2019 08:18
   * Created By: FUNDAUC
   */

   --Scalar/Column types
   SUBTYPE hash_t IS varchar2 (40);
   SUBTYPE id_condicion IS condiciones_especiales.id_condicion%TYPE;
   SUBTYPE descripcion IS condiciones_especiales.descripcion%TYPE;
   SUBTYPE descuento IS condiciones_especiales.descuento%TYPE;
   SUBTYPE porcentaje IS condiciones_especiales.porcentaje%TYPE;

   --Record type
   TYPE condiciones_especiales_rt
   IS
      RECORD (
            id_condicion condiciones_especiales.id_condicion%TYPE,
            descripcion condiciones_especiales.descripcion%TYPE,
            descuento condiciones_especiales.descuento%TYPE,
            porcentaje condiciones_especiales.porcentaje%TYPE,
            hash               hash_t,
            row_id            VARCHAR2(64)
      );
   --Collection types (record)
   TYPE condiciones_especiales_tt IS TABLE OF condiciones_especiales_rt;

   --Global exceptions
   e_ol_check_failed EXCEPTION; --Optimistic lock check failed
   e_row_missing     EXCEPTION; --The cursor failed to get a row
   e_upd_failed      EXCEPTION; --The update operation failed
   e_del_failed      EXCEPTION; --The delete operation failed

   /**
   * Generates a SHA1 hash for optimistic locking purposes.
   *
   * @param    p_id_condicion        must be NOT NULL
   */
   FUNCTION hash (
                  p_id_condicion IN condiciones_especiales.id_condicion%TYPE
                 )
    RETURN VARCHAR2;

   /**
   * This function generates a SHA1 hash for optimistic locking purposes.
   * Access directly to the row by rowid
   *
   * @param  p_rowid  must be NOT NULL
   */
   FUNCTION hash_rowid (p_rowid IN varchar2)
   RETURN varchar2;

   /**
   * This is a table encapsulation function designed to retrieve information from the condiciones_especiales table.
   *
   * @param      p_id_condicion      must be NOT NULL
   * @return     condiciones_especiales Record Type
   */
   FUNCTION rt (
                p_id_condicion IN condiciones_especiales.id_condicion%TYPE 
               )
    RETURN condiciones_especiales_rt RESULT_CACHE;

   /**
   * This is a table encapsulation function designed to retrieve information
   * from the condiciones_especiales table while placing a lock on it for a potential
   * update/delete. Do not use this for updates in web based apps, instead use the
   * rt_for_web_update function to get a FOR_WEB_UPDATE_RT record which
   * includes all of the tables columns along with an md5 checksum for use in the
   * web_upd and web_del procedures.
   *
   * @param      p_id_condicion      must be NOT NULL
   * @return     condiciones_especiales Record Type
   */
   FUNCTION rt_for_update (
                          p_id_condicion IN condiciones_especiales.id_condicion%TYPE 
                          )
    RETURN condiciones_especiales_rt RESULT_CACHE;

   /**
   * This is a table encapsulation function designed to retrieve information from the condiciones_especiales table.
   * This function return Record Table as PIPELINED Function
   *
   * @param      p_id_condicion      must be NOT NULL
   * @return     condiciones_especiales Table Record Type
   */
   FUNCTION tt (
                p_id_condicion IN condiciones_especiales.id_condicion%TYPE DEFAULT NULL
               )
   RETURN condiciones_especiales_tt
   PIPELINED;

   /**
   * This is a table encapsulation function designed to insert a row into the condiciones_especiales table.
   *
   * @param      p_condiciones_especiales_rec       Record Type
   * @return     p_condiciones_especiales_rec       Record Type
   */
   PROCEDURE ins (p_condiciones_especiales_rec IN OUT condiciones_especiales_rt);

   /**
   * This is a table encapsulation function designed to update a row in the condiciones_especiales table.
   *
   * @param      p_condiciones_especiales_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE upd (p_condiciones_especiales_rec IN condiciones_especiales_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row in the condiciones_especiales table,
   * access directly to the row by rowid
   *
   * @param      p_condiciones_especiales_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE upd_rowid (p_condiciones_especiales_rec IN condiciones_especiales_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row
   * in the condiciones_especiales table whith optimistic lock validation
   *
   * @param      p_condiciones_especiales_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE web_upd (p_condiciones_especiales_rec IN condiciones_especiales_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row
   * in the condiciones_especiales table whith optimistic lock validation
   * access directly to the row by rowid
   *
   * @param      p_condiciones_especiales_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE web_upd_rowid (p_condiciones_especiales_rec IN condiciones_especiales_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to delete a row from the condiciones_especiales table.
   *
   * @param    p_id_condicion        must be NOT NULL
   */
   PROCEDURE del (
                  p_id_condicion IN condiciones_especiales.id_condicion%TYPE
                );

   /**
   * This is a table encapsulation function designed to delete a row from the condiciones_especiales table
   * access directly to the row by rowid
   *
   * @param      p_rowid      must be NOT NULL
   */
    PROCEDURE del_rowid (p_rowid IN VARCHAR2);

   /**
   * This is a table encapsulation function designed to delete a row from the condiciones_especiales table
   * whith optimistic lock validation
   *
   * @param      p_id_condicion      must be NOT NULL
   * @param      p_hash       must be NOT NULL
   */
    PROCEDURE web_del (
                      p_id_condicion IN condiciones_especiales.id_condicion%TYPE,
                      p_hash IN varchar2
                      );

   /**
   * This is a table encapsulation function designed to delete a row from the condiciones_especiales table
   * whith optimistic lock validation, access directly to the row by rowid
   *
   * @param      p_rowid      must be NOT NULL
   * @param      p_hash       must be NOT NULL
   */
    PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2);

END tapi_condiciones_especiales;
 

/
--------------------------------------------------------
--  DDL for Package TAPI_CTAXCOB
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "FUNDAUC"."TAPI_CTAXCOB" 
IS
   /**
   * TAPI_CTAXCOB
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: 23-OCT-2019 08:56
   * Created By: FUNDAUC
   */

   --Scalar/Column types
   SUBTYPE hash_t IS varchar2 (40);
   SUBTYPE id IS ctaxcob.id%TYPE;
   SUBTYPE cliente_id IS ctaxcob.cliente_id%TYPE;
   SUBTYPE fecha IS ctaxcob.fecha%TYPE;
   SUBTYPE factura_id IS ctaxcob.factura_id%TYPE;
   SUBTYPE deposito_id IS ctaxcob.deposito_id%TYPE;
   SUBTYPE credito IS ctaxcob.credito%TYPE;
   SUBTYPE monto IS ctaxcob.monto%TYPE;

   --Record type
   TYPE ctaxcob_rt
   IS
      RECORD (
            id ctaxcob.id%TYPE,
            cliente_id ctaxcob.cliente_id%TYPE,
            fecha ctaxcob.fecha%TYPE,
            factura_id ctaxcob.factura_id%TYPE,
            deposito_id ctaxcob.deposito_id%TYPE,
            credito ctaxcob.credito%TYPE,
            monto ctaxcob.monto%TYPE,
            hash               hash_t,
            row_id            VARCHAR2(64)
      );
   --Collection types (record)
   TYPE ctaxcob_tt IS TABLE OF ctaxcob_rt;

   --Global exceptions
   e_ol_check_failed EXCEPTION; --Optimistic lock check failed
   e_row_missing     EXCEPTION; --The cursor failed to get a row
   e_upd_failed      EXCEPTION; --The update operation failed
   e_del_failed      EXCEPTION; --The delete operation failed

   /**
   * Generates a SHA1 hash for optimistic locking purposes.
   *
   * @param    p_id        must be NOT NULL
   */
   FUNCTION hash (
                  p_id IN ctaxcob.id%TYPE
                 )
    RETURN VARCHAR2;

   /**
   * This function generates a SHA1 hash for optimistic locking purposes.
   * Access directly to the row by rowid
   *
   * @param  p_rowid  must be NOT NULL
   */
   FUNCTION hash_rowid (p_rowid IN varchar2)
   RETURN varchar2;

   /**
   * This is a table encapsulation function designed to retrieve information from the ctaxcob table.
   *
   * @param      p_id      must be NOT NULL
   * @return     ctaxcob Record Type
   */
   FUNCTION rt (
                p_id IN ctaxcob.id%TYPE 
               )
    RETURN ctaxcob_rt RESULT_CACHE;

   /**
   * This is a table encapsulation function designed to retrieve information
   * from the ctaxcob table while placing a lock on it for a potential
   * update/delete. Do not use this for updates in web based apps, instead use the
   * rt_for_web_update function to get a FOR_WEB_UPDATE_RT record which
   * includes all of the tables columns along with an md5 checksum for use in the
   * web_upd and web_del procedures.
   *
   * @param      p_id      must be NOT NULL
   * @return     ctaxcob Record Type
   */
   FUNCTION rt_for_update (
                          p_id IN ctaxcob.id%TYPE 
                          )
    RETURN ctaxcob_rt RESULT_CACHE;

   /**
   * This is a table encapsulation function designed to retrieve information from the ctaxcob table.
   * This function return Record Table as PIPELINED Function
   *
   * @param      p_id      must be NOT NULL
   * @return     ctaxcob Table Record Type
   */
   FUNCTION tt (
                p_id IN ctaxcob.id%TYPE DEFAULT NULL
               )
   RETURN ctaxcob_tt
   PIPELINED;

   /**
   * This is a table encapsulation function designed to insert a row into the ctaxcob table.
   *
   * @param      p_ctaxcob_rec       Record Type
   * @return     p_ctaxcob_rec       Record Type
   */
   PROCEDURE ins (p_ctaxcob_rec IN OUT ctaxcob_rt);

   /**
   * This is a table encapsulation function designed to update a row in the ctaxcob table.
   *
   * @param      p_ctaxcob_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE upd (p_ctaxcob_rec IN ctaxcob_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row in the ctaxcob table,
   * access directly to the row by rowid
   *
   * @param      p_ctaxcob_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE upd_rowid (p_ctaxcob_rec IN ctaxcob_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row
   * in the ctaxcob table whith optimistic lock validation
   *
   * @param      p_ctaxcob_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE web_upd (p_ctaxcob_rec IN ctaxcob_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row
   * in the ctaxcob table whith optimistic lock validation
   * access directly to the row by rowid
   *
   * @param      p_ctaxcob_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE web_upd_rowid (p_ctaxcob_rec IN ctaxcob_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to delete a row from the ctaxcob table.
   *
   * @param    p_id        must be NOT NULL
   */
   PROCEDURE del (
                  p_id IN ctaxcob.id%TYPE
                );

   /**
   * This is a table encapsulation function designed to delete a row from the ctaxcob table
   * access directly to the row by rowid
   *
   * @param      p_rowid      must be NOT NULL
   */
    PROCEDURE del_rowid (p_rowid IN VARCHAR2);

   /**
   * This is a table encapsulation function designed to delete a row from the ctaxcob table
   * whith optimistic lock validation
   *
   * @param      p_id      must be NOT NULL
   * @param      p_hash       must be NOT NULL
   */
    PROCEDURE web_del (
                      p_id IN ctaxcob.id%TYPE,
                      p_hash IN varchar2
                      );

   /**
   * This is a table encapsulation function designed to delete a row from the ctaxcob table
   * whith optimistic lock validation, access directly to the row by rowid
   *
   * @param      p_rowid      must be NOT NULL
   * @param      p_hash       must be NOT NULL
   */
    PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2);

END tapi_ctaxcob;
 

/
--------------------------------------------------------
--  DDL for Package TAPI_DEPOSITO
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "FUNDAUC"."TAPI_DEPOSITO" 
IS
   /**
   * TAPI_DEPOSITO
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: 05-OCT-2019 09:51
   * Created By: FUNDAUC
   */

   --Scalar/Column types
   SUBTYPE hash_t IS varchar2 (40);
   SUBTYPE referencia IS deposito.referencia%TYPE;
   SUBTYPE fecha_emi IS deposito.fecha_emi%TYPE;
   SUBTYPE id_banco IS deposito.id_banco%TYPE;
   SUBTYPE monto IS deposito.monto%TYPE;
   SUBTYPE sede IS deposito.sede%TYPE;
   SUBTYPE usuario IS deposito.usuario%TYPE;
   SUBTYPE status IS deposito.status%TYPE;
   SUBTYPE forma_pago IS deposito.forma_pago%TYPE;
   SUBTYPE id IS deposito.id%TYPE;

   --Record type
   TYPE deposito_rt
   IS
      RECORD (
            referencia deposito.referencia%TYPE,
            fecha_emi deposito.fecha_emi%TYPE,
            id_banco deposito.id_banco%TYPE,
            monto deposito.monto%TYPE,
            sede deposito.sede%TYPE,
            usuario deposito.usuario%TYPE,
            status deposito.status%TYPE,
            forma_pago deposito.forma_pago%TYPE,
            id deposito.id%TYPE,
            hash               hash_t,
            row_id            VARCHAR2(64)
      );
   --Collection types (record)
   TYPE deposito_tt IS TABLE OF deposito_rt;

   --Global exceptions
   e_ol_check_failed EXCEPTION; --Optimistic lock check failed
   e_row_missing     EXCEPTION; --The cursor failed to get a row
   e_upd_failed      EXCEPTION; --The update operation failed
   e_del_failed      EXCEPTION; --The delete operation failed

   /**
   * Generates a SHA1 hash for optimistic locking purposes.
   *
   * @param    p_id        must be NOT NULL
   */
   FUNCTION hash (
                  p_id IN deposito.id%TYPE
                 )
    RETURN VARCHAR2;

   /**
   * This function generates a SHA1 hash for optimistic locking purposes.
   * Access directly to the row by rowid
   *
   * @param  p_rowid  must be NOT NULL
   */
   FUNCTION hash_rowid (p_rowid IN varchar2)
   RETURN varchar2;

   /**
   * This is a table encapsulation function designed to retrieve information from the deposito table.
   *
   * @param      p_id      must be NOT NULL
   * @return     deposito Record Type
   */
   FUNCTION rt (
                p_id IN deposito.id%TYPE 
               )
    RETURN deposito_rt RESULT_CACHE;

   /**
   * This is a table encapsulation function designed to retrieve information
   * from the deposito table while placing a lock on it for a potential
   * update/delete. Do not use this for updates in web based apps, instead use the
   * rt_for_web_update function to get a FOR_WEB_UPDATE_RT record which
   * includes all of the tables columns along with an md5 checksum for use in the
   * web_upd and web_del procedures.
   *
   * @param      p_id      must be NOT NULL
   * @return     deposito Record Type
   */
   FUNCTION rt_for_update (
                          p_id IN deposito.id%TYPE 
                          )
    RETURN deposito_rt RESULT_CACHE;

   /**
   * This is a table encapsulation function designed to retrieve information from the deposito table.
   * This function return Record Table as PIPELINED Function
   *
   * @param      p_id      must be NOT NULL
   * @return     deposito Table Record Type
   */
   FUNCTION tt (
                p_id IN deposito.id%TYPE DEFAULT NULL
               )
   RETURN deposito_tt
   PIPELINED;

   /**
   * This is a table encapsulation function designed to insert a row into the deposito table.
   *
   * @param      p_deposito_rec       Record Type
   * @return     p_deposito_rec       Record Type
   */
   PROCEDURE ins (p_deposito_rec IN OUT deposito_rt);

   /**
   * This is a table encapsulation function designed to update a row in the deposito table.
   *
   * @param      p_deposito_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE upd (p_deposito_rec IN deposito_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row in the deposito table,
   * access directly to the row by rowid
   *
   * @param      p_deposito_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE upd_rowid (p_deposito_rec IN deposito_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row
   * in the deposito table whith optimistic lock validation
   *
   * @param      p_deposito_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE web_upd (p_deposito_rec IN deposito_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row
   * in the deposito table whith optimistic lock validation
   * access directly to the row by rowid
   *
   * @param      p_deposito_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE web_upd_rowid (p_deposito_rec IN deposito_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to delete a row from the deposito table.
   *
   * @param    p_id        must be NOT NULL
   */
   PROCEDURE del (
                  p_id IN deposito.id%TYPE
                );

   /**
   * This is a table encapsulation function designed to delete a row from the deposito table
   * access directly to the row by rowid
   *
   * @param      p_rowid      must be NOT NULL
   */
    PROCEDURE del_rowid (p_rowid IN VARCHAR2);

   /**
   * This is a table encapsulation function designed to delete a row from the deposito table
   * whith optimistic lock validation
   *
   * @param      p_id      must be NOT NULL
   * @param      p_hash       must be NOT NULL
   */
    PROCEDURE web_del (
                      p_id IN deposito.id%TYPE,
                      p_hash IN varchar2
                      );

   /**
   * This is a table encapsulation function designed to delete a row from the deposito table
   * whith optimistic lock validation, access directly to the row by rowid
   *
   * @param      p_rowid      must be NOT NULL
   * @param      p_hash       must be NOT NULL
   */
    PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2);

END tapi_deposito;
 

/
--------------------------------------------------------
--  DDL for Package TAPI_DETALLE_FACTURA
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "FUNDAUC"."TAPI_DETALLE_FACTURA" 
IS
   /**
   * TAPI_DETALLE_FACTURA
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: 25-FEB-2020 18:39
   * Created By: FUNDAUC
   */

   --Scalar/Column types
   SUBTYPE hash_t IS varchar2 (40);
   SUBTYPE renglon IS detalle_factura.renglon%TYPE;
   SUBTYPE tipo_item IS detalle_factura.tipo_item%TYPE;
   SUBTYPE item IS detalle_factura.item%TYPE;
   SUBTYPE descripcion IS detalle_factura.descripcion%TYPE;
   SUBTYPE cantidad IS detalle_factura.cantidad%TYPE;
   SUBTYPE p_unidad IS detalle_factura.p_unidad%TYPE;
   SUBTYPE bs_descuento IS detalle_factura.bs_descuento%TYPE;
   SUBTYPE subtotal IS detalle_factura.subtotal%TYPE;
   SUBTYPE materiales_id IS detalle_factura.materiales_id%TYPE;
   SUBTYPE factura_id IS detalle_factura.factura_id%TYPE;

   --Record type
   TYPE detalle_factura_rt
   IS
      RECORD (
            renglon detalle_factura.renglon%TYPE,
            tipo_item detalle_factura.tipo_item%TYPE,
            item detalle_factura.item%TYPE,
            descripcion detalle_factura.descripcion%TYPE,
            cantidad detalle_factura.cantidad%TYPE,
            p_unidad detalle_factura.p_unidad%TYPE,
            bs_descuento detalle_factura.bs_descuento%TYPE,
            subtotal detalle_factura.subtotal%TYPE,
            materiales_id detalle_factura.materiales_id%TYPE,
            factura_id detalle_factura.factura_id%TYPE,
            hash               hash_t,
            row_id            VARCHAR2(64)
      );
   --Collection types (record)
   TYPE detalle_factura_tt IS TABLE OF detalle_factura_rt;

   --Global exceptions
   e_ol_check_failed EXCEPTION; --Optimistic lock check failed
   e_row_missing     EXCEPTION; --The cursor failed to get a row
   e_upd_failed      EXCEPTION; --The update operation failed
   e_del_failed      EXCEPTION; --The delete operation failed

   /**
   * Generates a SHA1 hash for optimistic locking purposes.
   *
   * @param    p_renglon        must be NOT NULL
   */
   FUNCTION hash (
                  p_renglon IN detalle_factura.renglon%TYPE
                 )
    RETURN VARCHAR2;

   /**
   * This function generates a SHA1 hash for optimistic locking purposes.
   * Access directly to the row by rowid
   *
   * @param  p_rowid  must be NOT NULL
   */
   FUNCTION hash_rowid (p_rowid IN varchar2)
   RETURN varchar2;

   /**
   * This is a table encapsulation function designed to retrieve information from the detalle_factura table.
   *
   * @param      p_renglon      must be NOT NULL
   * @return     detalle_factura Record Type
   */
   FUNCTION rt (
                p_renglon IN detalle_factura.renglon%TYPE 
               )
    RETURN detalle_factura_rt RESULT_CACHE;

   /**
   * This is a table encapsulation function designed to retrieve information
   * from the detalle_factura table while placing a lock on it for a potential
   * update/delete. Do not use this for updates in web based apps, instead use the
   * rt_for_web_update function to get a FOR_WEB_UPDATE_RT record which
   * includes all of the tables columns along with an md5 checksum for use in the
   * web_upd and web_del procedures.
   *
   * @param      p_renglon      must be NOT NULL
   * @return     detalle_factura Record Type
   */
   FUNCTION rt_for_update (
                          p_renglon IN detalle_factura.renglon%TYPE 
                          )
    RETURN detalle_factura_rt RESULT_CACHE;

   /**
   * This is a table encapsulation function designed to retrieve information from the detalle_factura table.
   * This function return Record Table as PIPELINED Function
   *
   * @param      p_renglon      must be NOT NULL
   * @return     detalle_factura Table Record Type
   */
   FUNCTION tt (
                p_renglon IN detalle_factura.renglon%TYPE DEFAULT NULL
               )
   RETURN detalle_factura_tt
   PIPELINED;

   /**
   * This is a table encapsulation function designed to insert a row into the detalle_factura table.
   *
   * @param      p_detalle_factura_rec       Record Type
   * @return     p_detalle_factura_rec       Record Type
   */
   PROCEDURE ins (p_detalle_factura_rec IN OUT detalle_factura_rt);

   /**
   * This is a table encapsulation function designed to update a row in the detalle_factura table.
   *
   * @param      p_detalle_factura_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE upd (p_detalle_factura_rec IN detalle_factura_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row in the detalle_factura table,
   * access directly to the row by rowid
   *
   * @param      p_detalle_factura_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE upd_rowid (p_detalle_factura_rec IN detalle_factura_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row
   * in the detalle_factura table whith optimistic lock validation
   *
   * @param      p_detalle_factura_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE web_upd (p_detalle_factura_rec IN detalle_factura_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row
   * in the detalle_factura table whith optimistic lock validation
   * access directly to the row by rowid
   *
   * @param      p_detalle_factura_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE web_upd_rowid (p_detalle_factura_rec IN detalle_factura_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to delete a row from the detalle_factura table.
   *
   * @param    p_renglon        must be NOT NULL
   */
   PROCEDURE del (
                  p_renglon IN detalle_factura.renglon%TYPE
                );

   /**
   * This is a table encapsulation function designed to delete a row from the detalle_factura table
   * access directly to the row by rowid
   *
   * @param      p_rowid      must be NOT NULL
   */
    PROCEDURE del_rowid (p_rowid IN VARCHAR2);

   /**
   * This is a table encapsulation function designed to delete a row from the detalle_factura table
   * whith optimistic lock validation
   *
   * @param      p_renglon      must be NOT NULL
   * @param      p_hash       must be NOT NULL
   */
    PROCEDURE web_del (
                      p_renglon IN detalle_factura.renglon%TYPE,
                      p_hash IN varchar2
                      );

   /**
   * This is a table encapsulation function designed to delete a row from the detalle_factura table
   * whith optimistic lock validation, access directly to the row by rowid
   *
   * @param      p_rowid      must be NOT NULL
   * @param      p_hash       must be NOT NULL
   */
    PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2);

END tapi_detalle_factura;
 

/
--------------------------------------------------------
--  DDL for Package TAPI_ESTUDIANTE
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "FUNDAUC"."TAPI_ESTUDIANTE" 
IS
   /**
   * TAPI_ESTUDIANTE
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: 13-SEP-2019 10:24
   * Created By: FUNDAUC
   */

   --Scalar/Column types
   SUBTYPE hash_t IS varchar2 (40);
   SUBTYPE cedula_est IS estudiante.cedula_est%TYPE;
   SUBTYPE nacionalidad IS estudiante.nacionalidad%TYPE;
   SUBTYPE nombre IS estudiante.nombre%TYPE;
   SUBTYPE telf_hab IS estudiante.telf_hab%TYPE;
   SUBTYPE telf_cel IS estudiante.telf_cel%TYPE;
   SUBTYPE ciudad IS estudiante.ciudad%TYPE;
   SUBTYPE estado IS estudiante.estado%TYPE;
   SUBTYPE email IS estudiante.email%TYPE;
   SUBTYPE sexo IS estudiante.sexo%TYPE;
   SUBTYPE edo_civil IS estudiante.edo_civil%TYPE;
   SUBTYPE grado_ins IS estudiante.grado_ins%TYPE;
   SUBTYPE profesion IS estudiante.profesion%TYPE;
   SUBTYPE fecha_nac IS estudiante.fecha_nac%TYPE;
   SUBTYPE status IS estudiante.status%TYPE;
   SUBTYPE id_tipo_est IS estudiante.id_tipo_est%TYPE;
   SUBTYPE rif IS estudiante.rif%TYPE;
   SUBTYPE matricula IS estudiante.matricula%TYPE;
   SUBTYPE sede IS estudiante.sede%TYPE;
   SUBTYPE condicion_especial IS estudiante.condicion_especial%TYPE;
   SUBTYPE apellido IS estudiante.apellido%TYPE;
   SUBTYPE zona IS estudiante.zona%TYPE;
   SUBTYPE cedula_rep IS estudiante.cedula_rep%TYPE;
   SUBTYPE direccion IS estudiante.direccion%TYPE;
   SUBTYPE creado_por IS estudiante.creado_por%TYPE;
   SUBTYPE creado_el IS estudiante.creado_el%TYPE;
   SUBTYPE modificado_por IS estudiante.modificado_por%TYPE;
   SUBTYPE modificado_el IS estudiante.modificado_el%TYPE;

   --Record type
   TYPE estudiante_rt
   IS
      RECORD (
            cedula_est estudiante.cedula_est%TYPE,
            nacionalidad estudiante.nacionalidad%TYPE,
            nombre estudiante.nombre%TYPE,
            telf_hab estudiante.telf_hab%TYPE,
            telf_cel estudiante.telf_cel%TYPE,
            ciudad estudiante.ciudad%TYPE,
            estado estudiante.estado%TYPE,
            email estudiante.email%TYPE,
            sexo estudiante.sexo%TYPE,
            edo_civil estudiante.edo_civil%TYPE,
            grado_ins estudiante.grado_ins%TYPE,
            profesion estudiante.profesion%TYPE,
            fecha_nac estudiante.fecha_nac%TYPE,
            status estudiante.status%TYPE,
            id_tipo_est estudiante.id_tipo_est%TYPE,
            rif estudiante.rif%TYPE,
            matricula estudiante.matricula%TYPE,
            sede estudiante.sede%TYPE,
            condicion_especial estudiante.condicion_especial%TYPE,
            apellido estudiante.apellido%TYPE,
            zona estudiante.zona%TYPE,
            cedula_rep estudiante.cedula_rep%TYPE,
            direccion estudiante.direccion%TYPE,
            creado_por estudiante.creado_por%TYPE,
            creado_el estudiante.creado_el%TYPE,
            modificado_por estudiante.modificado_por%TYPE,
            modificado_el estudiante.modificado_el%TYPE,
            hash               hash_t,
            row_id            VARCHAR2(64)
      );
   --Collection types (record)
   TYPE estudiante_tt IS TABLE OF estudiante_rt;

   --Global exceptions
   e_ol_check_failed EXCEPTION; --Optimistic lock check failed
   e_row_missing     EXCEPTION; --The cursor failed to get a row
   e_upd_failed      EXCEPTION; --The update operation failed
   e_del_failed      EXCEPTION; --The delete operation failed

   /**
   * Generates a SHA1 hash for optimistic locking purposes.
   *
   * @param    p_matricula        must be NOT NULL
   */
   FUNCTION hash (
                  p_matricula IN estudiante.matricula%TYPE
                 )
    RETURN VARCHAR2;

   /**
   * This function generates a SHA1 hash for optimistic locking purposes.
   * Access directly to the row by rowid
   *
   * @param  p_rowid  must be NOT NULL
   */
   FUNCTION hash_rowid (p_rowid IN varchar2)
   RETURN varchar2;

   /**
   * This is a table encapsulation function designed to retrieve information from the estudiante table.
   *
   * @param      p_matricula      must be NOT NULL
   * @return     estudiante Record Type
   */
   FUNCTION rt (
                p_matricula IN estudiante.matricula%TYPE 
               )
    RETURN estudiante_rt RESULT_CACHE;

   /**
   * This is a table encapsulation function designed to retrieve information
   * from the estudiante table while placing a lock on it for a potential
   * update/delete. Do not use this for updates in web based apps, instead use the
   * rt_for_web_update function to get a FOR_WEB_UPDATE_RT record which
   * includes all of the tables columns along with an md5 checksum for use in the
   * web_upd and web_del procedures.
   *
   * @param      p_matricula      must be NOT NULL
   * @return     estudiante Record Type
   */
   FUNCTION rt_for_update (
                          p_matricula IN estudiante.matricula%TYPE 
                          )
    RETURN estudiante_rt RESULT_CACHE;

   /**
   * This is a table encapsulation function designed to retrieve information from the estudiante table.
   * This function return Record Table as PIPELINED Function
   *
   * @param      p_matricula      must be NOT NULL
   * @return     estudiante Table Record Type
   */
   FUNCTION tt (
                p_matricula IN estudiante.matricula%TYPE DEFAULT NULL
               )
   RETURN estudiante_tt
   PIPELINED;

   /**
   * This is a table encapsulation function designed to insert a row into the estudiante table.
   *
   * @param      p_estudiante_rec       Record Type
   * @return     p_estudiante_rec       Record Type
   */
   PROCEDURE ins (p_estudiante_rec IN OUT estudiante_rt);

   /**
   * This is a table encapsulation function designed to update a row in the estudiante table.
   *
   * @param      p_estudiante_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE upd (p_estudiante_rec IN estudiante_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row in the estudiante table,
   * access directly to the row by rowid
   *
   * @param      p_estudiante_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE upd_rowid (p_estudiante_rec IN estudiante_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row
   * in the estudiante table whith optimistic lock validation
   *
   * @param      p_estudiante_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE web_upd (p_estudiante_rec IN estudiante_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row
   * in the estudiante table whith optimistic lock validation
   * access directly to the row by rowid
   *
   * @param      p_estudiante_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE web_upd_rowid (p_estudiante_rec IN estudiante_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to delete a row from the estudiante table.
   *
   * @param    p_matricula        must be NOT NULL
   */
   PROCEDURE del (
                  p_matricula IN estudiante.matricula%TYPE
                );

   /**
   * This is a table encapsulation function designed to delete a row from the estudiante table
   * access directly to the row by rowid
   *
   * @param      p_rowid      must be NOT NULL
   */
    PROCEDURE del_rowid (p_rowid IN VARCHAR2);

   /**
   * This is a table encapsulation function designed to delete a row from the estudiante table
   * whith optimistic lock validation
   *
   * @param      p_matricula      must be NOT NULL
   * @param      p_hash       must be NOT NULL
   */
    PROCEDURE web_del (
                      p_matricula IN estudiante.matricula%TYPE,
                      p_hash IN varchar2
                      );

   /**
   * This is a table encapsulation function designed to delete a row from the estudiante table
   * whith optimistic lock validation, access directly to the row by rowid
   *
   * @param      p_rowid      must be NOT NULL
   * @param      p_hash       must be NOT NULL
   */
    PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2);

END tapi_estudiante;
 

/
--------------------------------------------------------
--  DDL for Package TAPI_FACTURA
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "FUNDAUC"."TAPI_FACTURA" 
IS
   /**
   * TAPI_FACTURA
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: 25-SEP-2019 08:27
   * Created By: FUNDAUC
   */

   --Scalar/Column types
   SUBTYPE hash_t IS varchar2 (40);
   SUBTYPE id_fact IS factura.id_fact%TYPE;
   SUBTYPE tipo IS factura.tipo%TYPE;
   SUBTYPE cedula_est IS factura.cedula_est%TYPE;
   SUBTYPE nombre_cliente IS factura.nombre_cliente%TYPE;
   SUBTYPE fecha_emi IS factura.fecha_emi%TYPE;
   SUBTYPE monto IS factura.monto%TYPE;
   SUBTYPE p_iva IS factura.p_iva%TYPE;
   SUBTYPE monto_iva IS factura.monto_iva%TYPE;
   SUBTYPE flete IS factura.flete%TYPE;
   SUBTYPE bs_descuento IS factura.bs_descuento%TYPE;
   SUBTYPE dir_fiscal IS factura.dir_fiscal%TYPE;
   SUBTYPE rif IS factura.rif%TYPE;
   SUBTYPE status IS factura.status%TYPE;
   SUBTYPE programa IS factura.programa%TYPE;
   SUBTYPE prog_academico IS factura.prog_academico%TYPE;
   SUBTYPE creado_por IS factura.creado_por%TYPE;
   SUBTYPE monto_exento IS factura.monto_exento%TYPE;
   SUBTYPE base_imponible IS factura.base_imponible%TYPE;
   SUBTYPE id IS factura.id%TYPE;
   SUBTYPE creado_el IS factura.creado_el%TYPE;
   SUBTYPE facturado_por IS factura.facturado_por%TYPE;
   SUBTYPE observaciones IS factura.observaciones%TYPE;
   SUBTYPE escredito IS factura.escredito%TYPE;

   --Record type
   TYPE factura_rt
   IS
      RECORD (
            id_fact factura.id_fact%TYPE,
            tipo factura.tipo%TYPE,
            cedula_est factura.cedula_est%TYPE,
            nombre_cliente factura.nombre_cliente%TYPE,
            fecha_emi factura.fecha_emi%TYPE,
            monto factura.monto%TYPE,
            p_iva factura.p_iva%TYPE,
            monto_iva factura.monto_iva%TYPE,
            flete factura.flete%TYPE,
            bs_descuento factura.bs_descuento%TYPE,
            dir_fiscal factura.dir_fiscal%TYPE,
            rif factura.rif%TYPE,
            status factura.status%TYPE,
            programa factura.programa%TYPE,
            prog_academico factura.prog_academico%TYPE,
            creado_por factura.creado_por%TYPE,
            monto_exento factura.monto_exento%TYPE,
            base_imponible factura.base_imponible%TYPE,
            id factura.id%TYPE,
            creado_el factura.creado_el%TYPE,
            facturado_por factura.facturado_por%TYPE,
            observaciones factura.observaciones%TYPE,
            escredito factura.escredito%TYPE,
            hash               hash_t,
            row_id            VARCHAR2(64)
      );
   --Collection types (record)
   TYPE factura_tt IS TABLE OF factura_rt;

   --Global exceptions
   e_ol_check_failed EXCEPTION; --Optimistic lock check failed
   e_row_missing     EXCEPTION; --The cursor failed to get a row
   e_upd_failed      EXCEPTION; --The update operation failed
   e_del_failed      EXCEPTION; --The delete operation failed

   /**
   * Generates a SHA1 hash for optimistic locking purposes.
   *
   * @param    p_id        must be NOT NULL
   */
   FUNCTION hash (
                  p_id IN factura.id%TYPE
                 )
    RETURN VARCHAR2;

   /**
   * This function generates a SHA1 hash for optimistic locking purposes.
   * Access directly to the row by rowid
   *
   * @param  p_rowid  must be NOT NULL
   */
   FUNCTION hash_rowid (p_rowid IN varchar2)
   RETURN varchar2;

   /**
   * This is a table encapsulation function designed to retrieve information from the factura table.
   *
   * @param      p_id      must be NOT NULL
   * @return     factura Record Type
   */
   FUNCTION rt (
                p_id IN factura.id%TYPE 
               )
    RETURN factura_rt RESULT_CACHE;

   /**
   * This is a table encapsulation function designed to retrieve information
   * from the factura table while placing a lock on it for a potential
   * update/delete. Do not use this for updates in web based apps, instead use the
   * rt_for_web_update function to get a FOR_WEB_UPDATE_RT record which
   * includes all of the tables columns along with an md5 checksum for use in the
   * web_upd and web_del procedures.
   *
   * @param      p_id      must be NOT NULL
   * @return     factura Record Type
   */
   FUNCTION rt_for_update (
                          p_id IN factura.id%TYPE 
                          )
    RETURN factura_rt RESULT_CACHE;

   /**
   * This is a table encapsulation function designed to retrieve information from the factura table.
   * This function return Record Table as PIPELINED Function
   *
   * @param      p_id      must be NOT NULL
   * @return     factura Table Record Type
   */
   FUNCTION tt (
                p_id IN factura.id%TYPE DEFAULT NULL
               )
   RETURN factura_tt
   PIPELINED;

   /**
   * This is a table encapsulation function designed to insert a row into the factura table.
   *
   * @param      p_factura_rec       Record Type
   * @return     p_factura_rec       Record Type
   */
   PROCEDURE ins (p_factura_rec IN OUT factura_rt);

   /**
   * This is a table encapsulation function designed to update a row in the factura table.
   *
   * @param      p_factura_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE upd (p_factura_rec IN factura_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row in the factura table,
   * access directly to the row by rowid
   *
   * @param      p_factura_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE upd_rowid (p_factura_rec IN factura_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row
   * in the factura table whith optimistic lock validation
   *
   * @param      p_factura_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE web_upd (p_factura_rec IN factura_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row
   * in the factura table whith optimistic lock validation
   * access directly to the row by rowid
   *
   * @param      p_factura_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE web_upd_rowid (p_factura_rec IN factura_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to delete a row from the factura table.
   *
   * @param    p_id        must be NOT NULL
   */
   PROCEDURE del (
                  p_id IN factura.id%TYPE
                );

   /**
   * This is a table encapsulation function designed to delete a row from the factura table
   * access directly to the row by rowid
   *
   * @param      p_rowid      must be NOT NULL
   */
    PROCEDURE del_rowid (p_rowid IN VARCHAR2);

   /**
   * This is a table encapsulation function designed to delete a row from the factura table
   * whith optimistic lock validation
   *
   * @param      p_id      must be NOT NULL
   * @param      p_hash       must be NOT NULL
   */
    PROCEDURE web_del (
                      p_id IN factura.id%TYPE,
                      p_hash IN varchar2
                      );

   /**
   * This is a table encapsulation function designed to delete a row from the factura table
   * whith optimistic lock validation, access directly to the row by rowid
   *
   * @param      p_rowid      must be NOT NULL
   * @param      p_hash       must be NOT NULL
   */
    PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2);

END tapi_factura;
 

/
--------------------------------------------------------
--  DDL for Package TAPI_FACTURA_DEPOSITO
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "FUNDAUC"."TAPI_FACTURA_DEPOSITO" 
IS
   /**
   * TAPI_FACTURA_DEPOSITO
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: 04-AGO-2019 21:41
   * Created By: FUNDAUC
   */

   --Scalar/Column types
   SUBTYPE hash_t IS varchar2 (40);
   SUBTYPE deposito_id IS factura_deposito.deposito_id%TYPE;
   SUBTYPE factura_id IS factura_deposito.factura_id%TYPE;

   --Record type
   TYPE factura_deposito_rt
   IS
      RECORD (
            deposito_id factura_deposito.deposito_id%TYPE,
            factura_id factura_deposito.factura_id%TYPE,
            hash               hash_t,
            row_id            VARCHAR2(64)
      );
   --Collection types (record)
   TYPE factura_deposito_tt IS TABLE OF factura_deposito_rt;

   --Global exceptions
   e_ol_check_failed EXCEPTION; --Optimistic lock check failed
   e_row_missing     EXCEPTION; --The cursor failed to get a row
   e_upd_failed      EXCEPTION; --The update operation failed
   e_del_failed      EXCEPTION; --The delete operation failed

   /**
   * Generates a SHA1 hash for optimistic locking purposes.
   *
   * @param    p_deposito_id        must be NOT NULL
   * @param    p_factura_id        must be NOT NULL
   */
   FUNCTION hash (
                  p_deposito_id IN factura_deposito.deposito_id%TYPE,
                  p_factura_id IN factura_deposito.factura_id%TYPE
                 )
    RETURN VARCHAR2;

   /**
   * This function generates a SHA1 hash for optimistic locking purposes.
   * Access directly to the row by rowid
   *
   * @param  p_rowid  must be NOT NULL
   */
   FUNCTION hash_rowid (p_rowid IN varchar2)
   RETURN varchar2;

   /**
   * This is a table encapsulation function designed to retrieve information from the factura_deposito table.
   *
   * @param      p_deposito_id      must be NOT NULL
   * @param      p_factura_id      must be NOT NULL
   * @return     factura_deposito Record Type
   */
   FUNCTION rt (
                p_deposito_id IN factura_deposito.deposito_id%TYPE ,
                p_factura_id IN factura_deposito.factura_id%TYPE 
               )
    RETURN factura_deposito_rt RESULT_CACHE;

   /**
   * This is a table encapsulation function designed to retrieve information
   * from the factura_deposito table while placing a lock on it for a potential
   * update/delete. Do not use this for updates in web based apps, instead use the
   * rt_for_web_update function to get a FOR_WEB_UPDATE_RT record which
   * includes all of the tables columns along with an md5 checksum for use in the
   * web_upd and web_del procedures.
   *
   * @param      p_deposito_id      must be NOT NULL
   * @param      p_factura_id      must be NOT NULL
   * @return     factura_deposito Record Type
   */
   FUNCTION rt_for_update (
                          p_deposito_id IN factura_deposito.deposito_id%TYPE ,
                          p_factura_id IN factura_deposito.factura_id%TYPE 
                          )
    RETURN factura_deposito_rt RESULT_CACHE;

   /**
   * This is a table encapsulation function designed to retrieve information from the factura_deposito table.
   * This function return Record Table as PIPELINED Function
   *
   * @param      p_deposito_id      must be NOT NULL
   * @param      p_factura_id      must be NOT NULL
   * @return     factura_deposito Table Record Type
   */
   FUNCTION tt (
                p_deposito_id IN factura_deposito.deposito_id%TYPE DEFAULT NULL,
                p_factura_id IN factura_deposito.factura_id%TYPE DEFAULT NULL
               )
   RETURN factura_deposito_tt
   PIPELINED;

   /**
   * This is a table encapsulation function designed to insert a row into the factura_deposito table.
   *
   * @param      p_factura_deposito_rec       Record Type
   * @return     p_factura_deposito_rec       Record Type
   */
   PROCEDURE ins (p_factura_deposito_rec IN OUT factura_deposito_rt);

   /**
   * This is a table encapsulation function designed to update a row in the factura_deposito table.
   *
   * @param      p_factura_deposito_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE upd (p_factura_deposito_rec IN factura_deposito_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row in the factura_deposito table,
   * access directly to the row by rowid
   *
   * @param      p_factura_deposito_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE upd_rowid (p_factura_deposito_rec IN factura_deposito_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row
   * in the factura_deposito table whith optimistic lock validation
   *
   * @param      p_factura_deposito_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE web_upd (p_factura_deposito_rec IN factura_deposito_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row
   * in the factura_deposito table whith optimistic lock validation
   * access directly to the row by rowid
   *
   * @param      p_factura_deposito_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE web_upd_rowid (p_factura_deposito_rec IN factura_deposito_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to delete a row from the factura_deposito table.
   *
   * @param    p_deposito_id        must be NOT NULL
   * @param    p_factura_id        must be NOT NULL
   */
   PROCEDURE del (
                  p_deposito_id IN factura_deposito.deposito_id%TYPE,
                  p_factura_id IN factura_deposito.factura_id%TYPE
                );

   /**
   * This is a table encapsulation function designed to delete a row from the factura_deposito table
   * access directly to the row by rowid
   *
   * @param      p_rowid      must be NOT NULL
   */
    PROCEDURE del_rowid (p_rowid IN VARCHAR2);

   /**
   * This is a table encapsulation function designed to delete a row from the factura_deposito table
   * whith optimistic lock validation
   *
   * @param      p_deposito_id      must be NOT NULL
   * @param      p_factura_id      must be NOT NULL
   * @param      p_hash       must be NOT NULL
   */
    PROCEDURE web_del (
                      p_deposito_id IN factura_deposito.deposito_id%TYPE,
                      p_factura_id IN factura_deposito.factura_id%TYPE,
                      p_hash IN varchar2
                      );

   /**
   * This is a table encapsulation function designed to delete a row from the factura_deposito table
   * whith optimistic lock validation, access directly to the row by rowid
   *
   * @param      p_rowid      must be NOT NULL
   * @param      p_hash       must be NOT NULL
   */
    PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2);

END tapi_factura_deposito;


/
--------------------------------------------------------
--  DDL for Package TAPI_GEN2
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "FUNDAUC"."TAPI_GEN2" authid current_user
AS

   /**
   * TAPI_GEN2
   * Generated by: Oscar Salvador Magallanes
   * Website: github.com/osalvador/tapiGen2
   * Created On: 16-JUL-2015
   */

   --Global public data structures
   SUBTYPE dbo_name_t IS VARCHAR2 (30); -- Max size for a DB object name

   TYPE dbo_name_aat IS TABLE OF dbo_name_t;

    TYPE column_rt
    IS
      RECORD (
         table_name        user_tab_columns.table_name%TYPE
       , column_name       user_tab_columns.column_name%TYPE
       , nullable          user_tab_columns.nullable%TYPE
       , constraint_type   user_constraints.constraint_type%TYPE
      );

   --Collection types (record)
   TYPE column_tt IS TABLE OF column_rt;

   TYPE constraint_tt IS TABLE OF user_constraints%ROWTYPE;

   /**
   * Create PL/SQL Table API
   *
   * @param     p_table_name              must be NOT NULL
   * @param     p_compile_table_api       TRUE for compile generated package, FALSE to DBMS_OUTPUT the source
   * @param     p_unique_key              If the table has no primary key, it indicates the column that will be used as a unique key
   * @param     p_created_by_col_name     Custom audit column
   * @param     p_created_date_col_name   Custom audit column
   * @param     p_modified_by_col_name    Custom audit column
   * @param     p_modified_date_col_name  Custom audit column
   * @param     p_raise_exceptions        TRUE to use logger for exception handling
   */
   PROCEDURE create_tapi_package (p_table_name               IN VARCHAR2
                                , p_compile_table_api        IN BOOLEAN DEFAULT TRUE
                                , p_unique_key               IN VARCHAR2 DEFAULT NULL
                                , p_created_by_col_name      IN VARCHAR2 DEFAULT NULL
                                , p_created_date_col_name    IN VARCHAR2 DEFAULT NULL
                                , p_modified_by_col_name     IN VARCHAR2 DEFAULT NULL
                                , p_modified_date_col_name   IN VARCHAR2 DEFAULT NULL
                                , p_raise_exceptions         IN BOOLEAN DEFAULT FALSE);

   --Public functions but for internal use.
   FUNCTION get_all_columns (p_tab_name VARCHAR2)
      RETURN column_tt;

   FUNCTION get_pk_columns (p_tab_name VARCHAR2)
      RETURN column_tt;

   FUNCTION get_noblob_columns (p_tab_name VARCHAR2)
      RETURN column_tt;

--Spec Template
$if false $then
<%@ template
    name=spec
%>
<%! col      tapi_gen2.column_tt := tapi_gen2.get_all_columns ('${table_name}'); %>
<%! pk       tapi_gen2.column_tt := tapi_gen2.get_pk_columns ('${table_name}'); %>
<%! c pls_integer; %>
<%! /* Separator procedure */
    procedure sep (p_cont in pls_integer, p_delimiter in varchar2)
    as
    begin
         if p_cont > 1
         then
               teplsql.p(p_delimiter);
         end if;
    end; %>
CREATE OR REPLACE PACKAGE tapi_${table_name}
IS
   /**
   * TAPI_<%= upper('${table_name}') %>\\n
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: ${date}
   * Created By: ${user}
   */

   --Scalar/Column types
   SUBTYPE hash_t IS varchar2 (40);
   <% for i in 1 .. col.last loop %>
   SUBTYPE <%= col(i).COLUMN_NAME%> IS ${table_name}.<%= col(i).COLUMN_NAME%>%TYPE;
   <% end loop; %>

   --Record type
   TYPE ${table_name}_rt
   IS
      RECORD (
           <% c := col.last+1;
           for i in 1 .. col.last loop %>
            <%=  col(i).COLUMN_NAME%> ${table_name}.<%=col(i).COLUMN_NAME %>%TYPE,
           <% end loop; %>
            hash               hash_t,
            row_id            VARCHAR2(64)
      );
   --Collection types (record)
   TYPE ${table_name}_tt IS TABLE OF ${table_name}_rt;

   --Global exceptions
   e_ol_check_failed EXCEPTION; --Optimistic lock check failed
   e_row_missing     EXCEPTION; --The cursor failed to get a row
   e_upd_failed      EXCEPTION; --The update operation failed
   e_del_failed      EXCEPTION; --The delete operation failed

   /**
   * Generates a SHA1 hash for optimistic locking purposes.
   *
   <% c := pk.last+1; for i in 1 .. pk.last loop %>
   * @param    p_<%=  pk(i).COLUMN_NAME %>        must be NOT NULL
   <% end loop; %>
   */
   FUNCTION hash (
              <% c := pk.last+1;
                for i in 1 .. pk.last loop %>
                  p_<%=  pk(i).COLUMN_NAME%> IN ${table_name}.<%=pk(i).COLUMN_NAME %>%TYPE<%sep(c-i,',');%>\\n
              <% end loop; %>
                 )
    RETURN VARCHAR2;

   /**
   * This function generates a SHA1 hash for optimistic locking purposes.
   * Access directly to the row by rowid
   *
   * @param  p_rowid  must be NOT NULL
   */
   FUNCTION hash_rowid (p_rowid IN varchar2)
   RETURN varchar2;

   /**
   * This is a table encapsulation function designed to retrieve information from the ${table_name} table.
   *
   <% c := pk.last+1; for i in 1 .. pk.last loop %>
   * @param      p_<%=  pk(i).COLUMN_NAME %>      must be NOT NULL
   <% end loop; %>
   * @return     ${table_name} Record Type
   */
   FUNCTION rt (
             <% c := pk.last+1; for i in 1 .. pk.last loop %>
                p_<%=  pk(i).COLUMN_NAME%> IN ${table_name}.<%=pk(i).COLUMN_NAME %>%TYPE <%sep(c-i,',');%>\\n
             <% end loop; %>
               )
    RETURN ${table_name}_rt ${result_cache};

   /**
   * This is a table encapsulation function designed to retrieve information
   * from the ${table_name} table while placing a lock on it for a potential
   * update/delete. Do not use this for updates in web based apps, instead use the
   * rt_for_web_update function to get a FOR_WEB_UPDATE_RT record which
   * includes all of the tables columns along with an md5 checksum for use in the
   * web_upd and web_del procedures.
   *
   <% c := pk.last+1; for i in 1 .. pk.last loop %>
   * @param      p_<%=  pk(i).COLUMN_NAME %>      must be NOT NULL
   <% end loop; %>
   * @return     ${table_name} Record Type
   */
   FUNCTION rt_for_update (
                      <% c := pk.last+1; for i in 1 .. pk.last loop %>
                          p_<%=  pk(i).COLUMN_NAME%> IN ${table_name}.<%=pk(i).COLUMN_NAME %>%TYPE <%sep(c-i,',');%>\\n
                      <% end loop; %>
                          )
    RETURN ${table_name}_rt ${result_cache};

   /**
   * This is a table encapsulation function designed to retrieve information from the ${table_name} table.
   * This function return Record Table as PIPELINED Function
   *
   <% c := pk.last+1; for i in 1 .. pk.last loop %>
   * @param      p_<%=  pk(i).COLUMN_NAME %>      must be NOT NULL
   <% end loop; %>
   * @return     ${table_name} Table Record Type
   */
   FUNCTION tt (
             <% c := pk.last+1; for i in 1 .. pk.last loop %>
                p_<%=  pk(i).COLUMN_NAME%> IN ${table_name}.<%=pk(i).COLUMN_NAME %>%TYPE DEFAULT NULL<%sep(c-i,',');%>\\n
             <% end loop; %>
               )
   RETURN ${table_name}_tt
   PIPELINED;

   /**
   * This is a table encapsulation function designed to insert a row into the ${table_name} table.
   *
   * @param      p_${table_name}_rec       Record Type
   * @return     p_${table_name}_rec       Record Type
   */
   PROCEDURE ins (p_${table_name}_rec IN OUT ${table_name}_rt);

   /**
   * This is a table encapsulation function designed to update a row in the ${table_name} table.
   *
   * @param      p_${table_name}_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE upd (p_${table_name}_rec IN ${table_name}_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row in the ${table_name} table,
   * access directly to the row by rowid
   *
   * @param      p_${table_name}_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE upd_rowid (p_${table_name}_rec IN ${table_name}_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row
   * in the ${table_name} table whith optimistic lock validation
   *
   * @param      p_${table_name}_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE web_upd (p_${table_name}_rec IN ${table_name}_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row
   * in the ${table_name} table whith optimistic lock validation
   * access directly to the row by rowid
   *
   * @param      p_${table_name}_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE web_upd_rowid (p_${table_name}_rec IN ${table_name}_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to delete a row from the ${table_name} table.
   *
   <% c := pk.last+1; for i in 1 .. pk.last loop %>
   * @param    p_<%=  pk(i).COLUMN_NAME %>        must be NOT NULL
   <% end loop; %>
   */
   PROCEDURE del (
              <% c := pk.last+1; for i in 1 .. pk.last loop %>
                  p_<%=pk(i).COLUMN_NAME%> IN ${table_name}.<%=pk(i).COLUMN_NAME %>%TYPE<%sep(c-i,',');%>\\n
              <% end loop; %>
                );

   /**
   * This is a table encapsulation function designed to delete a row from the ${table_name} table
   * access directly to the row by rowid
   *
   * @param      p_rowid      must be NOT NULL
   */
    PROCEDURE del_rowid (p_rowid IN VARCHAR2);

   /**
   * This is a table encapsulation function designed to delete a row from the ${table_name} table
   * whith optimistic lock validation
   *
   <% c := pk.last+1; for i in 1 .. pk.last loop %>
   * @param      p_<%=  pk(i).COLUMN_NAME %>      must be NOT NULL
   <% end loop; %>
   * @param      p_hash       must be NOT NULL
   */
    PROCEDURE web_del (
                   <% c := pk.last+1; for i in 1 .. pk.last loop %>
                      p_<%=pk(i).column_name%> IN ${table_name}.<%=pk(i).column_name %>%TYPE,
                   <% end loop; %>
                      p_hash IN varchar2
                      );

   /**
   * This is a table encapsulation function designed to delete a row from the ${table_name} table
   * whith optimistic lock validation, access directly to the row by rowid
   *
   * @param      p_rowid      must be NOT NULL
   * @param      p_hash       must be NOT NULL
   */
    PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2);

END tapi_${table_name};
$end


--Body Template
$if false $then
<%@ template
    name=body
%>
<%! col      tapi_gen2.column_tt := tapi_gen2.get_all_columns ('${table_name}'); %>
<%! pk       tapi_gen2.column_tt := tapi_gen2.get_pk_columns ('${table_name}'); %>
<%! noblob   tapi_gen2.column_tt := tapi_gen2.get_noblob_columns ('${table_name}'); %>
<%! c pls_integer; %>
<%! /* Separator procedure */
    procedure sep (p_index in pls_integer, p_delimiter in varchar2)
    as
    begin
         if p_index > 1
         then
            teplsql.p(p_delimiter);
         end if;
    end; %>
<%! /*  User column for update */
   procedure column_for_update(p_column_name in varchar2,
                               p_ignore_nulls in boolean,
                               p_index in pls_integer,
                               p_blanks in pls_integer default 16)
   as
    l_blanks varchar2(256);
   begin
     for i in 1 .. p_blanks
     loop
        l_blanks := l_blanks ||' ';
     end loop;

      if ('${created_by_col_name}' <> p_column_name or '${created_by_col_name}' is null)
        and ('${created_date_col_name}' <> p_column_name or '${created_date_col_name}' is null)
     then
        if '${modified_by_col_name}' = p_column_name
        then
           teplsql.p(p_column_name || ' = USER /*dbax_core.g$username or apex_application.g_user*/');
        elsif '${modified_date_col_name}' = p_column_name
        then
           teplsql.p(p_column_name || ' = SYSDATE');
        else
           if p_ignore_nulls
           then
            teplsql.p(p_column_name || ' = ' || 'NVL(p_${table_name}_rec.'|| p_column_name ||','|| p_column_name ||')');
           else
            teplsql.p(p_column_name || ' = p_${table_name}_rec.' || p_column_name);
           end if;
        end if;

        sep(p_index,',\\n' || l_blanks);

     end if;
   end; %>
CREATE OR REPLACE PACKAGE BODY tapi_${table_name} IS

   /**
   * TAPI_<%= upper('${table_name}') %>\\n
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: ${date}
   * Created By: ${user}
   */

  <% if '${raise_exceptions}' is not null then %>
    --Global logger scope
    gc_scope_prefix CONSTANT varchar2(31) := LOWER($$plsql_unit)||'.';
  <% end if; %>

   --GLOBAL_PRIVATE_CURSORS
   --By PK
   CURSOR ${table_name}_cur (
                    <% c := pk.last+1; for i in 1 .. pk.last loop %>
                       p_<%=pk(i).column_name%> IN ${table_name}.<%=pk(i).column_name %>%TYPE<%sep(c-i,',');%>\\n
                    <% end loop; %>
                       )
   IS
      SELECT
        <% c := col.last+1; for i in 1 .. col.last loop %>
            <%=col(i).column_name%>,
        <% end loop; %>
            tapi_${table_name}.hash(<% c := pk.last+1; for i in 1 .. pk.last loop %><%=pk(i).column_name%><%sep(c-i,','); end loop; %>),
            ROWID
      FROM ${table_name}
      WHERE
        <% c := pk.last+1; for i in 1 .. pk.last loop %>
           <%=pk(i).column_name%> = ${table_name}_cur.p_<%=pk(i).column_name%><%sep(c-i,' AND ');%>\\n
        <% end loop; %>
      FOR UPDATE;

    --By Rowid
    CURSOR ${table_name}_rowid_cur (p_rowid IN VARCHAR2)
    IS
      SELECT
        <% c := col.last+1; for i in 1 .. col.last loop %>
             <%=col(i).column_name%>,
        <% end loop; %>
             tapi_${table_name}.hash(<% c := pk.last+1; for i in 1 .. pk.last loop %><%=pk(i).column_name%><%sep(c-i,','); end loop; %>),
             ROWID
      FROM ${table_name}
      WHERE ROWID = p_rowid
      FOR UPDATE;


    FUNCTION hash (
                <% c := pk.last+1; for i in 1 .. pk.last loop %>
                  p_<%=pk(i).column_name%> IN ${table_name}.<%=pk(i).column_name %>%TYPE<%sep(c-i,',');%>\\n
                <% end loop; %>
                  )
      RETURN varchar2
   IS
    <% if '${raise_exceptions}' is not null then %>
      l_scope logger_logs.scope%TYPE := gc_scope_prefix || 'hash';
      l_params logger.tab_param;
    <% end if; %>
      l_retval hash_t;
      l_string CLOB;
      l_date_format VARCHAR2(64);
   BEGIN

     <% if '${raise_exceptions}' is not null then
      c := pk.last+1; for i in 1 .. pk.last loop %>
      logger.append_param(l_params, 'p_<%=pk(i).column_name%>', p_<%=pk(i).column_name%>);
      <% end loop; %>
      logger.LOG('START', l_scope, NULL, l_params);
      logger.LOG('Getting row data into one string', l_scope);
     <% end if; %>

     --Get actual NLS_DATE_FORMAT
     SELECT   VALUE
       INTO   l_date_format
       FROM   v$nls_parameters
      WHERE   parameter = 'NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
         <% c := noblob.last+1; for i in 1 .. noblob.last loop %>
            <%=noblob(i).column_name%><%sep(c-i,'||');%>\\n
         <% end loop; %>
      INTO l_string
      FROM ${table_name}
      WHERE
        <% c := pk.last+1; for i in 1 .. pk.last loop %>
           <%=pk(i).column_name%> = hash.p_<%=pk(i).column_name%><%sep(c-i,' AND ');%>\\n
        <% end loop; %>
           ;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      <% if '${raise_exceptions}' is not null then %>
      logger.LOG('Converting into SHA1 hash', l_scope);
      <%end if; %>
      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);
      <% if '${raise_exceptions}' is not null then %>
      logger.LOG('END', l_scope);
      <%end if; %>

      RETURN l_retval;

   <% if '${raise_exceptions}' is not null then %>
   EXCEPTION
     WHEN OTHERS
     THEN
        logger.log_error('Unhandled Exception', l_scope, NULL, l_params);
        RAISE;
   <%end if; %>
   END hash;

    FUNCTION hash_rowid (p_rowid IN varchar2)
      RETURN varchar2
   IS
    <% if '${raise_exceptions}' is not null then %>
      l_scope logger_logs.scope%TYPE := gc_scope_prefix || 'hash_rowid';
      l_params logger.tab_param;
    <% end if; %>
      l_retval hash_t;
      l_string CLOB;
      l_date_format varchar2(64);
   BEGIN
      <% if '${raise_exceptions}' is not null then %>
      logger.append_param(l_params, 'p_rowid', p_rowid);
      logger.LOG('START', l_scope, NULL, l_params);
      logger.LOG('Getting row data into one string', l_scope);
      <% end if; %>

      --Get actual NLS_DATE_FORMAT
      SELECT VALUE INTO l_date_format  FROM v$nls_parameters WHERE parameter ='NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
          <% c := noblob.last+1; for i in 1 .. noblob.last loop %>
            <%=noblob(i).column_name%><%sep(c-i,'||');%>\\n
         <% end loop; %>
      INTO l_string
      FROM ${table_name}
      WHERE  ROWID = hash_rowid.p_rowid;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      <% if '${raise_exceptions}' is not null then %>
      logger.LOG('Converting into SHA1 hash', l_scope);
      <% end if; %>
      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      <% if '${raise_exceptions}' is not null then %>
      logger.LOG('END', l_scope);
      <% end if; %>
      RETURN l_retval;

   <% if '${raise_exceptions}' is not null then %>
   EXCEPTION
     WHEN OTHERS
     THEN
        logger.log_error('Unhandled Exception', l_scope, NULL, l_params);
        RAISE;
   <% end if; %>
   END hash_rowid;

   FUNCTION rt (
            <% c := pk.last+1; for i in 1 .. pk.last loop %>
               p_<%=pk(i).column_name%> IN ${table_name}.<%=pk(i).column_name %>%TYPE<%sep(c-i,',');%>\\n
            <% end loop; %>
               )
      RETURN ${table_name}_rt ${result_cache}
   IS
    <% if '${raise_exceptions}' is not null then %>
      l_scope logger_logs.scope%TYPE := gc_scope_prefix || 'rt';
      l_params logger.tab_param;
    <% end if; %>
      l_${table_name}_rec ${table_name}_rt;
   BEGIN
      <% if '${raise_exceptions}' is not null then
      c := pk.last+1; for i in 1 .. pk.last loop %>
      logger.append_param(l_params, 'p_<%=pk(i).column_name%>', p_<%=pk(i).column_name%>);
      <% end loop; %>
      logger.LOG('START', l_scope, NULL, l_params);
      logger.LOG('Populating record type from DB', l_scope);
      <% end if; %>

      SELECT a.*,
             tapi_${table_name}.hash(<% c := pk.last+1; for i in 1 .. pk.last loop %><%=pk(i).column_name%><%sep(c-i,','); end loop; %>),
             rowid
      INTO l_${table_name}_rec
      FROM ${table_name} a
      WHERE
        <% c := pk.last+1; for i in 1 .. pk.last loop %>
           <%=pk(i).column_name%> = rt.p_<%=pk(i).column_name%><%sep(c-i,' AND ' );%>\\n
        <% end loop; %>
           ;

      <% if '${raise_exceptions}' is not null then %>
      logger.LOG('END', l_scope);
      <% end if; %>

      RETURN l_${table_name}_rec;

   <% if '${raise_exceptions}' is not null then %>
   EXCEPTION
     WHEN OTHERS
     THEN
        logger.log_error('Unhandled Exception', l_scope, NULL, l_params);
        RAISE;
   <% end if; %>
   END rt;

   FUNCTION rt_for_update (
                        <% c := pk.last+1; for i in 1 .. pk.last loop %>
                          p_<%=pk(i).column_name%> IN ${table_name}.<%=pk(i).column_name %>%TYPE<%sep(c-i,',');%>\\n
                        <% end loop; %>
                          )
      RETURN ${table_name}_rt ${result_cache}
   IS
    <% if '${raise_exceptions}' is not null then %>
      l_scope logger_logs.scope%TYPE := gc_scope_prefix || 'rt_for_update';
      l_params logger.tab_param;
    <% end if; %>
      l_${table_name}_rec ${table_name}_rt;
   BEGIN

      <% if '${raise_exceptions}' is not null then
       c := pk.last+1; for i in 1 .. pk.last loop %>
      logger.append_param(l_params, 'p_<%=pk(i).column_name%>', p_<%=pk(i).column_name%>);
      <% end loop; %>
      logger.LOG('START', l_scope, NULL, l_params);
      logger.LOG('Populating record type from DB', l_scope);
      <% end if; %>

      SELECT a.*,
             tapi_${table_name}.hash(<% c := pk.last+1; for i in 1 .. pk.last loop %><%=pk(i).column_name%><%sep(c-i,','); end loop; %>),
             rowid
      INTO l_${table_name}_rec
      FROM ${table_name} a
      WHERE
        <% c := pk.last+1; for i in 1 .. pk.last loop %>
           <%=pk(i).column_name%> = rt_for_update.p_<%=pk(i).column_name%><%sep(c-i,' AND ');%>\\n
        <% end loop; %>
      FOR UPDATE;

      <% if '${raise_exceptions}' is not null then %>
      logger.LOG('END', l_scope);
      <% end if; %>

      RETURN l_${table_name}_rec;

   <% if '${raise_exceptions}' is not null then %>
   EXCEPTION
     WHEN OTHERS
     THEN
        logger.log_error('Unhandled Exception', l_scope, NULL, l_params);
        RAISE;
   <% end if; %>
   END rt_for_update;

    FUNCTION tt (
             <% c := pk.last+1; for i in 1 .. pk.last loop %>
                p_<%=pk(i).column_name%> IN ${table_name}.<%=pk(i).column_name %>%TYPE DEFAULT NULL<%sep(c-i,',');%>\\n
             <% end loop; %>
                )
       RETURN ${table_name}_tt
       PIPELINED
    IS
       <% if '${raise_exceptions}' is not null then %>
       l_scope logger_logs.scope%TYPE := gc_scope_prefix || 'tt';
       l_params logger.tab_param;
       <% end if; %>
       l_${table_name}_rec   ${table_name}_rt;
    BEGIN
      <% if '${raise_exceptions}' is not null then
       c := pk.last+1; for i in 1 .. pk.last loop %>
      logger.append_param(l_params, 'p_<%=pk(i).column_name%>', tt.p_<%=pk(i).column_name%>);
      <% end loop; %>
      logger.LOG('START', l_scope, NULL, l_params);
      logger.LOG('Populating record type from DB', l_scope);
      <% end if; %>

       FOR c1 IN (SELECT   a.*, ROWID
                    FROM   ${table_name} a
                   WHERE
                      <% c := pk.last+1; for i in 1 .. pk.last loop %>
                        <%=pk(i).column_name%> = NVL(tt.p_<%=pk(i).column_name%>,<%=pk(i).column_name%>)<%sep(c-i,' AND ');%>\\n
                      <% end loop; %>
                        )
       LOOP
            <% for i in 1 .. col.last loop %>
              l_${table_name}_rec.<%=col(i).column_name%> := c1.<%=col(i).column_name%>;
            <% end loop; %>
              l_${table_name}_rec.hash := tapi_${table_name}.hash(<% c := pk.last+1; for i in 1 .. pk.last loop %> c1.<%=pk(i).column_name%><%sep(c-i,',');%><% end loop; %>);
              l_${table_name}_rec.row_id := c1.ROWID;
              PIPE ROW (l_${table_name}_rec);
       END LOOP;
       <% if '${raise_exceptions}' is not null then %>

       logger.LOG('END', l_scope);
       <% end if; %>

       RETURN;

    <% if '${raise_exceptions}' is not null then %>
    EXCEPTION
     WHEN OTHERS
     THEN
        logger.log_error('Unhandled Exception', l_scope, NULL, l_params);
        RAISE;
    <% end if; %>
    END tt;


    PROCEDURE ins (p_${table_name}_rec IN OUT ${table_name}_rt)
    IS
        <% if '${raise_exceptions}' is not null then %>
        l_scope logger_logs.scope%TYPE := gc_scope_prefix || 'ins';
        l_params logger.tab_param;
       <% end if; %>
        l_rowtype     ${table_name}%ROWTYPE;
       <% if '${created_by_col_name}' is not null
        or   '${modified_by_col_name}' is not null
       then
            if '${created_by_col_name}' is not null
            then%>
        l_user_name   ${table_name}.${created_by_col_name}%TYPE := USER;/*dbax_core.g$username or apex_application.g_user*/
            <%else%>
        l_user_name   ${table_name}.${modified_by_col_name}%TYPE := USER;/*dbax_core.g$username or apex_application.g_user*/
            <% end if;
       end if;
       if '${created_date_col_name}' is not null
       or '${modified_date_col_name}' is not null
       then
            if '${created_date_col_name}' is not null
            then %>
        l_date        ${table_name}.${created_date_col_name}%TYPE := SYSDATE;
            <%else%>
        l_date        ${table_name}.${modified_date_col_name}%TYPE := SYSDATE;
            <% end if;
       end if; %>

    BEGIN
        <% if '${raise_exceptions}' is not null then
          for i in 1 .. col.last loop %>
        logger.append_param(l_params, 'p_${table_name}_rec.<%=col(i).column_name%>', ins.p_${table_name}_rec.<%=col(i).column_name%>);
        <% end loop; %>
        logger.LOG('START', l_scope, NULL, l_params);
        logger.LOG('Inserting data', l_scope);
        <% end if;%>

        <% if '${created_by_col_name}'Is not null then%>
        p_${table_name}_rec.${created_by_col_name} := l_user_name;
        <% end if; %>!\n
        <% if '${created_date_col_name}' is not null then %>
        p_${table_name}_rec.${created_date_col_name} := l_date;
        <% end if; %>!\n
        <% if '${modified_by_col_name}' is not null then %>
        p_${table_name}_rec.${modified_by_col_name} := l_user_name;
        <% end if;%>!\n
        <% if '${modified_date_col_name}' is not null then %>
        p_${table_name}_rec.${modified_date_col_name} := l_date;
        <% end if; %>

        <% for i in 1 .. col.last loop %>
        l_rowtype.<%=col(i).column_name%> := ins.p_${table_name}_rec.<%=col(i).column_name%>;
        <% end loop; %>

       INSERT INTO ${table_name}
          VALUES   l_rowtype
       RETURNING
                   <%  c := col.last+1; for i in 1 .. col.last loop %>
                   <%=col(i).column_name%> <%sep(c-i,',');%>\\n
                   <% end loop; %>
            INTO   l_rowtype;

        <% for i in 1 .. col.last loop %>
         ins.p_${table_name}_rec.<%=col(i).column_name%> := l_rowtype.<%=col(i).column_name%>;
        <% end loop; %>


      <% if '${raise_exceptions}' is not null then %>
       logger.LOG('END', l_scope);
      <%end if; %>

    <% if '${raise_exceptions}' is not null then %>
    EXCEPTION
      WHEN OTHERS
      THEN
         logger.log_error('Unhandled Exception', l_scope, NULL, l_params);
         RAISE;
    <% end if; %>
    END ins;

    PROCEDURE upd (
                  p_${table_name}_rec         IN ${table_name}_rt,
                  p_ignore_nulls         IN boolean := FALSE
                  )
    IS
    <% if '${raise_exceptions}' is not null then %>
      l_scope logger_logs.scope%TYPE := gc_scope_prefix || 'upd';
      l_params logger.tab_param;
    <% end if; %>
    BEGIN
      <% if '${raise_exceptions}' is not null then
        for i in 1 .. col.last loop %>
       logger.append_param(l_params, 'p_${table_name}_rec.<%=col(i).column_name%>', upd.p_${table_name}_rec.<%=col(i).column_name%>);
      <% end loop; %>
       logger.LOG('START', l_scope, NULL, l_params);
       logger.LOG('Updating table', l_scope);
      <% end if; %>

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   ${table_name}
             SET <% c := col.last+1; for i in 1 .. col.last loop
                    column_for_update(col(i).column_name,true,c-i);
                  end loop; %>\\n
           WHERE
                <% c := pk.last+1; for i in 1 .. pk.last loop %>
                <%=pk(i).column_name%> = upd.p_${table_name}_rec.<%=pk(i).column_name%><%sep(c-i,' AND ');%>\\n
                <% end loop; %>
                ;
       ELSE
          UPDATE   ${table_name}
             SET <% c := col.last+1; for i in 1 .. col.last loop
                    column_for_update(col(i).column_name,false,c-i);
                 end loop; %>\\n
           WHERE
                <% c := pk.last+1; for i in 1 .. pk.last loop %>
                <%=pk(i).column_name%> = upd.p_${table_name}_rec.<%=pk(i).column_name%><%sep(c-i,' AND ');%>\\n
                <% end loop; %>
                ;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;
      <% if '${raise_exceptions}' is not null then %>
       logger.LOG('END', l_scope);
      <%end if; %>

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
      <% if '${raise_exceptions}' is not null then %>
       WHEN OTHERS
       THEN
        logger.log_error('Unhandled Exception', l_scope, NULL, l_params);
        RAISE;
      <% end if; %>
    END upd;


    PROCEDURE upd_rowid (
                         p_${table_name}_rec         IN ${table_name}_rt,
                         p_ignore_nulls         IN boolean := FALSE
                        )
    IS
    <% if '${raise_exceptions}' is not null then %>
      l_scope logger_logs.scope%TYPE := gc_scope_prefix || 'upd_rowid';
      l_params logger.tab_param;
    <% end if; %>
    BEGIN
      <% if '${raise_exceptions}' is not null then
        for i in 1 .. col.last loop %>
       logger.append_param(l_params, 'p_${table_name}_rec.<%=col(i).column_name%>', upd_rowid.p_${table_name}_rec.<%=col(i).column_name%>);
      <% end loop; %>
       logger.LOG('START', l_scope, NULL, l_params);
       logger.LOG('Updating table', l_scope);
      <% end if; %>

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   ${table_name}
             SET <% c := col.last+1; for i in 1 .. col.last loop
                     column_for_update(col(i).column_name,true,c-i);
                  end loop; %>\\n
           WHERE  ROWID = p_${table_name}_rec.row_id;
       ELSE
          UPDATE   ${table_name}
             SET <% c := col.last+1; for i in 1 .. col.last loop
                     column_for_update(col(i).column_name,false,c-i);
                  end loop; %>\\n
           WHERE  ROWID = p_${table_name}_rec.row_id;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;
      <% if '${raise_exceptions}' is not null then %>
       logger.LOG('END', l_scope);
      <%end if; %>

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
       <% if '${raise_exceptions}' is not null then %>
       WHEN OTHERS
       THEN
          logger.log_error('Unhandled Exception', l_scope, NULL, l_params);
          RAISE;
       <% end if; %>
    END upd_rowid;

   PROCEDURE web_upd (
                  p_${table_name}_rec         IN ${table_name}_rt,
                  p_ignore_nulls         IN boolean := FALSE
                )
   IS
    <% if '${raise_exceptions}' is not null then %>
      l_scope logger_logs.scope%TYPE := gc_scope_prefix || 'web_upd';
      l_params logger.tab_param;
    <% end if; %>
      l_${table_name}_rec ${table_name}_rt;
   BEGIN
      <% if '${raise_exceptions}' is not null then
        for i in 1 .. col.last loop %>
       logger.append_param(l_params, 'p_${table_name}_rec.<%=col(i).column_name%>', web_upd.p_${table_name}_rec.<%=col(i).column_name%>);
      <% end loop; %>
       logger.LOG('START', l_scope, NULL, l_params);
       logger.LOG('Updating table', l_scope);
      <% end if; %>

      OPEN ${table_name}_cur(
                        <% c := pk.last+1; for i in 1 .. pk.last loop %>
                             web_upd.p_${table_name}_rec.<%=pk(i).column_name%><%sep(c-i,',');%>\\n
                        <% end loop; %>
                        );

      FETCH ${table_name}_cur INTO l_${table_name}_rec;

      IF ${table_name}_cur%NOTFOUND THEN
         CLOSE ${table_name}_cur;
         RAISE e_row_missing;
      ELSE
         IF p_${table_name}_rec.hash != l_${table_name}_rec.hash THEN
            CLOSE ${table_name}_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(p_ignore_nulls, FALSE)
            THEN

                UPDATE   ${table_name}
                   SET <% c := col.last+1; for i in 1 .. col.last loop
                            column_for_update(col(i).column_name,true,c-i, 23);
                       end loop; %>\\n
               WHERE CURRENT OF ${table_name}_cur;
            ELSE
                UPDATE   ${table_name}
                   SET <% c := col.last+1; for i in 1 .. col.last loop
                            column_for_update(col(i).column_name,false,c-i,23);
                       end loop; %>\\n
               WHERE CURRENT OF ${table_name}_cur;
            END IF;

            CLOSE ${table_name}_cur;
         END IF;
      END IF;

      <% if '${raise_exceptions}' is not null then %>
      logger.LOG('END', l_scope);
      <%end if; %>

   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
     <% if '${raise_exceptions}' is not null then %>
     WHEN OTHERS
     THEN
        logger.log_error('Unhandled Exception', l_scope, NULL, l_params);
        RAISE;
     <% end if; %>
   END web_upd;

   PROCEDURE web_upd_rowid (
                            p_${table_name}_rec    IN ${table_name}_rt,
                            p_ignore_nulls         IN boolean := FALSE
                           )
   IS
    <% if '${raise_exceptions}' is not null then %>
      l_scope logger_logs.scope%TYPE := gc_scope_prefix || 'web_upd_rowid';
      l_params logger.tab_param;
    <% end if; %>
      l_${table_name}_rec ${table_name}_rt;
   BEGIN
      <% if '${raise_exceptions}' is not null then
        for i in 1 .. col.last loop %>
       logger.append_param(l_params, 'p_${table_name}_rec.<%=col(i).column_name%>', web_upd_rowid.p_${table_name}_rec.<%=col(i).column_name%>);
      <% end loop; %>
       logger.LOG('START', l_scope, NULL, l_params);
       logger.LOG('Updating table', l_scope);
      <% end if; %>

      OPEN ${table_name}_rowid_cur(web_upd_rowid.p_${table_name}_rec.row_id);

      FETCH ${table_name}_rowid_cur INTO l_${table_name}_rec;

      IF ${table_name}_rowid_cur%NOTFOUND THEN
         CLOSE ${table_name}_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_upd_rowid.p_${table_name}_rec.hash != l_${table_name}_rec.hash THEN
            CLOSE ${table_name}_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(web_upd_rowid.p_ignore_nulls, FALSE)
            THEN
                UPDATE   ${table_name}
                   SET <% c := col.last+1; for i in 1 .. col.last loop
                         column_for_update(col(i).column_name,true,c-i,23);
                       end loop; %>\\n
               WHERE CURRENT OF ${table_name}_rowid_cur;
            ELSE
                UPDATE   ${table_name}
                   SET <% c := col.last+1; for i in 1 .. col.last loop
                         column_for_update(col(i).column_name,false,c-i,23);
                       end loop; %>\\n
               WHERE CURRENT OF ${table_name}_rowid_cur;
            END IF;

            CLOSE ${table_name}_rowid_cur;
         END IF;
      END IF;

      <% if '${raise_exceptions}' is not null then %>
      logger.LOG('END', l_scope);
      <%end if; %>

   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
     <% if '${raise_exceptions}' is not null then %>
     WHEN OTHERS
     THEN
        logger.log_error('Unhandled Exception', l_scope, NULL, l_params);
        RAISE;
     <% end if; %>
   END web_upd_rowid;

    PROCEDURE del (
               <% c := pk.last+1; for i in 1 .. pk.last loop %>
                  p_<%=pk(i).column_name%> IN ${table_name}.<%=pk(i).column_name %>%TYPE<%sep(c-i,',');%>\\n
               <% end loop; %>
                  )
    IS
    <% if '${raise_exceptions}' is not null then %>
      l_scope logger_logs.scope%TYPE := gc_scope_prefix || 'del';
      l_params logger.tab_param;
    <% end if; %>
    BEGIN
      <% if '${raise_exceptions}' is not null then
       c := pk.last+1; for i in 1 .. pk.last loop %>
      logger.append_param(l_params, 'p_<%=pk(i).column_name%>', del.p_<%=pk(i).column_name%>);
      <% end loop; %>
      logger.LOG('START', l_scope, NULL, l_params);
      logger.LOG('Deleting record', l_scope);
      <% end if; %>

       DELETE FROM   ${table_name}
             WHERE
                <% c := pk.last+1; for i in 1 .. pk.last loop %>
                  <%=pk(i).column_name%> = del.p_<%=pk(i).column_name%><%sep(c-i,' AND ');%>\\n
                <% end loop; %>
                   ;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;

      <% if '${raise_exceptions}' is not null then %>
       logger.LOG('END', l_scope);
      <%end if; %>

    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
       <% if '${raise_exceptions}' is not null then %>
       WHEN OTHERS
       THEN
          logger.log_error('Unhandled Exception', l_scope, NULL, l_params);
          RAISE;
       <% end if; %>
    END del;

    PROCEDURE del_rowid (p_rowid IN varchar2)
    IS
    <% if '${raise_exceptions}' is not null then %>
      l_scope logger_logs.scope%TYPE := gc_scope_prefix || 'del_rowid';
      l_params logger.tab_param;
    <% end if; %>
    BEGIN
       <% if '${raise_exceptions}' is not null then %>
       logger.append_param(l_params, 'p_rowid', del_rowid.p_rowid);
       logger.LOG('START', l_scope, NULL, l_params);
       logger.LOG('Deleting record', l_scope);
       <% end if; %>

       DELETE FROM   ${table_name}
             WHERE   ROWID = del_rowid.p_rowid;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;

      <% if '${raise_exceptions}' is not null then %>
       logger.LOG('END', l_scope);
      <%end if; %>

    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
       <% if '${raise_exceptions}' is not null then %>
       WHEN OTHERS
       THEN
          logger.log_error('Unhandled Exception', l_scope, NULL, l_params);
          RAISE;
       <% end if; %>
    END del_rowid;

    PROCEDURE web_del (
                   <% c := pk.last+1; for i in 1 .. pk.last loop %>
                      p_<%=pk(i).column_name%> IN ${table_name}.<%=pk(i).column_name %>%TYPE,
                   <% end loop; %>
                      p_hash IN varchar2
                      )
   IS
    <% if '${raise_exceptions}' is not null then %>
      l_scope logger_logs.scope%TYPE := gc_scope_prefix || 'web_del';
      l_params logger.tab_param;
    <% end if; %>
      l_${table_name}_rec ${table_name}_rt;
   BEGIN

      <% if '${raise_exceptions}' is not null then
       c := pk.last+1; for i in 1 .. pk.last loop %>
      logger.append_param(l_params, 'p_<%=pk(i).column_name%>', web_del.p_<%=pk(i).column_name%>);
      <% end loop; %>
      logger.LOG('START', l_scope, NULL, l_params);
      logger.LOG('Deleting record', l_scope);
      <% end if; %>

      OPEN ${table_name}_cur(
                          <% c := pk.last+1; for i in 1 .. pk.last loop %>
                            web_del.p_<%=pk(i).column_name%><%sep(c-i,',');%>\\n
                          <% end loop; %>
                            );

      FETCH ${table_name}_cur INTO l_${table_name}_rec;

      IF ${table_name}_cur%NOTFOUND THEN
         CLOSE ${table_name}_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del.p_hash != l_${table_name}_rec.hash THEN
            CLOSE ${table_name}_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM ${table_name}
            WHERE CURRENT OF ${table_name}_cur;

            CLOSE ${table_name}_cur;
         END IF;
      END IF;


      <% if '${raise_exceptions}' is not null then %>
      logger.LOG('END', l_scope);
      <%end if; %>

   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
     <% if '${raise_exceptions}' is not null then %>
     WHEN OTHERS
     THEN
        logger.log_error('Unhandled Exception', l_scope, NULL, l_params);
        RAISE;
     <% end if; %>
   END web_del;

   PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2)
   IS
    <% if '${raise_exceptions}' is not null then %>
      l_scope logger_logs.scope%TYPE := gc_scope_prefix || 'web_del_rowid';
      l_params logger.tab_param;
    <% end if; %>
      l_${table_name}_rec ${table_name}_rt;
   BEGIN

      <% if '${raise_exceptions}' is not null then %>
      logger.append_param(l_params, 'p_rowid', web_del_rowid.p_rowid);
      logger.LOG('START', l_scope, NULL, l_params);
      logger.LOG('Deleting record', l_scope);
      <% end if; %>

      OPEN ${table_name}_rowid_cur(web_del_rowid.p_rowid);

      FETCH ${table_name}_rowid_cur INTO l_${table_name}_rec;

      IF ${table_name}_rowid_cur%NOTFOUND THEN
         CLOSE ${table_name}_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del_rowid.p_hash != l_${table_name}_rec.hash THEN
            CLOSE ${table_name}_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM ${table_name}
            WHERE CURRENT OF ${table_name}_rowid_cur;

            CLOSE ${table_name}_rowid_cur;
         END IF;
      END IF;

     <% if '${raise_exceptions}' is not null then %>
      logger.LOG('END', l_scope);
     <%end if; %>
   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
     <% if '${raise_exceptions}' is not null then %>
     WHEN OTHERS
     THEN
        logger.log_error('Unhandled Exception', l_scope, NULL, l_params);
        RAISE;
     <% end if; %>
   END web_del_rowid;

END tapi_${table_name};

$end

END tapi_gen2;

/
--------------------------------------------------------
--  DDL for Package TAPI_HOJA_VIDA_EST
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "FUNDAUC"."TAPI_HOJA_VIDA_EST" 
IS
   /**
   * TAPI_HOJA_VIDA_EST
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: 16-SEP-2019 13:22
   * Created By: FUNDAUC
   */

   --Scalar/Column types
   SUBTYPE hash_t IS varchar2 (40);
   SUBTYPE id IS hoja_vida_est.id%TYPE;
   SUBTYPE matricula IS hoja_vida_est.matricula%TYPE;
   SUBTYPE evento_id IS hoja_vida_est.evento_id%TYPE;
   SUBTYPE fecha IS hoja_vida_est.fecha%TYPE;
   SUBTYPE metadata IS hoja_vida_est.metadata%TYPE;
   SUBTYPE observacion IS hoja_vida_est.observacion%TYPE;

   --Record type
   TYPE hoja_vida_est_rt
   IS
      RECORD (
            id hoja_vida_est.id%TYPE,
            matricula hoja_vida_est.matricula%TYPE,
            evento_id hoja_vida_est.evento_id%TYPE,
            fecha hoja_vida_est.fecha%TYPE,
            metadata hoja_vida_est.metadata%TYPE,
            observacion hoja_vida_est.observacion%TYPE,
            hash               hash_t,
            row_id            VARCHAR2(64)
      );
   --Collection types (record)
   TYPE hoja_vida_est_tt IS TABLE OF hoja_vida_est_rt;

   --Global exceptions
   e_ol_check_failed EXCEPTION; --Optimistic lock check failed
   e_row_missing     EXCEPTION; --The cursor failed to get a row
   e_upd_failed      EXCEPTION; --The update operation failed
   e_del_failed      EXCEPTION; --The delete operation failed

   /**
   * Generates a SHA1 hash for optimistic locking purposes.
   *
   * @param    p_id        must be NOT NULL
   */
   FUNCTION hash (
                  p_id IN hoja_vida_est.id%TYPE
                 )
    RETURN VARCHAR2;

   /**
   * This function generates a SHA1 hash for optimistic locking purposes.
   * Access directly to the row by rowid
   *
   * @param  p_rowid  must be NOT NULL
   */
   FUNCTION hash_rowid (p_rowid IN varchar2)
   RETURN varchar2;

   /**
   * This is a table encapsulation function designed to retrieve information from the hoja_vida_est table.
   *
   * @param      p_id      must be NOT NULL
   * @return     hoja_vida_est Record Type
   */
   FUNCTION rt (
                p_id IN hoja_vida_est.id%TYPE 
               )
    RETURN hoja_vida_est_rt ;

   /**
   * This is a table encapsulation function designed to retrieve information
   * from the hoja_vida_est table while placing a lock on it for a potential
   * update/delete. Do not use this for updates in web based apps, instead use the
   * rt_for_web_update function to get a FOR_WEB_UPDATE_RT record which
   * includes all of the tables columns along with an md5 checksum for use in the
   * web_upd and web_del procedures.
   *
   * @param      p_id      must be NOT NULL
   * @return     hoja_vida_est Record Type
   */
   FUNCTION rt_for_update (
                          p_id IN hoja_vida_est.id%TYPE 
                          )
    RETURN hoja_vida_est_rt ;

   /**
   * This is a table encapsulation function designed to retrieve information from the hoja_vida_est table.
   * This function return Record Table as PIPELINED Function
   *
   * @param      p_id      must be NOT NULL
   * @return     hoja_vida_est Table Record Type
   */
   FUNCTION tt (
                p_id IN hoja_vida_est.id%TYPE DEFAULT NULL
               )
   RETURN hoja_vida_est_tt
   PIPELINED;

   /**
   * This is a table encapsulation function designed to insert a row into the hoja_vida_est table.
   *
   * @param      p_hoja_vida_est_rec       Record Type
   * @return     p_hoja_vida_est_rec       Record Type
   */
   PROCEDURE ins (p_hoja_vida_est_rec IN OUT hoja_vida_est_rt);

   /**
   * This is a table encapsulation function designed to update a row in the hoja_vida_est table.
   *
   * @param      p_hoja_vida_est_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE upd (p_hoja_vida_est_rec IN hoja_vida_est_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row in the hoja_vida_est table,
   * access directly to the row by rowid
   *
   * @param      p_hoja_vida_est_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE upd_rowid (p_hoja_vida_est_rec IN hoja_vida_est_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row
   * in the hoja_vida_est table whith optimistic lock validation
   *
   * @param      p_hoja_vida_est_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE web_upd (p_hoja_vida_est_rec IN hoja_vida_est_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row
   * in the hoja_vida_est table whith optimistic lock validation
   * access directly to the row by rowid
   *
   * @param      p_hoja_vida_est_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE web_upd_rowid (p_hoja_vida_est_rec IN hoja_vida_est_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to delete a row from the hoja_vida_est table.
   *
   * @param    p_id        must be NOT NULL
   */
   PROCEDURE del (
                  p_id IN hoja_vida_est.id%TYPE
                );

   /**
   * This is a table encapsulation function designed to delete a row from the hoja_vida_est table
   * access directly to the row by rowid
   *
   * @param      p_rowid      must be NOT NULL
   */
    PROCEDURE del_rowid (p_rowid IN VARCHAR2);

   /**
   * This is a table encapsulation function designed to delete a row from the hoja_vida_est table
   * whith optimistic lock validation
   *
   * @param      p_id      must be NOT NULL
   * @param      p_hash       must be NOT NULL
   */
    PROCEDURE web_del (
                      p_id IN hoja_vida_est.id%TYPE,
                      p_hash IN varchar2
                      );

   /**
   * This is a table encapsulation function designed to delete a row from the hoja_vida_est table
   * whith optimistic lock validation, access directly to the row by rowid
   *
   * @param      p_rowid      must be NOT NULL
   * @param      p_hash       must be NOT NULL
   */
    PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2);

END tapi_hoja_vida_est;

/
--------------------------------------------------------
--  DDL for Package TAPI_INSCRIPCIONES
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "FUNDAUC"."TAPI_INSCRIPCIONES" 
IS
   /**
   * TAPI_INSCRIPCIONES
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: 22-FEB-2020 03:12
   * Created By: FUNDAUC
   */

   --Scalar/Column types
   SUBTYPE hash_t IS varchar2 (40);
   SUBTYPE id IS inscripciones.id%TYPE;
   SUBTYPE fecha_ins IS inscripciones.fecha_ins%TYPE;
   SUBTYPE est_matricula IS inscripciones.est_matricula%TYPE;
   SUBTYPE fecha_pago IS inscripciones.fecha_pago%TYPE;
   SUBTYPE estatus IS inscripciones.estatus%TYPE;
   SUBTYPE seccion_id IS inscripciones.seccion_id%TYPE;
   SUBTYPE periodo_id IS inscripciones.periodo_id%TYPE;
   SUBTYPE creado_por IS inscripciones.creado_por%TYPE;
   SUBTYPE es_exonerado IS inscripciones.es_exonerado%TYPE;
   SUBTYPE prog_academico IS inscripciones.prog_academico%TYPE;
   SUBTYPE es_suspendido IS inscripciones.es_suspendido%TYPE;
   SUBTYPE cohorte_id IS inscripciones.cohorte_id%TYPE;
   SUBTYPE horario_id IS inscripciones.horario_id%TYPE;
   SUBTYPE modificado_por IS inscripciones.modificado_por%TYPE;
   SUBTYPE modificado_el IS inscripciones.modificado_el%TYPE;

   --Record type
   TYPE inscripciones_rt
   IS
      RECORD (
            id inscripciones.id%TYPE,
            fecha_ins inscripciones.fecha_ins%TYPE,
            est_matricula inscripciones.est_matricula%TYPE,
            fecha_pago inscripciones.fecha_pago%TYPE,
            estatus inscripciones.estatus%TYPE,
            seccion_id inscripciones.seccion_id%TYPE,
            periodo_id inscripciones.periodo_id%TYPE,
            creado_por inscripciones.creado_por%TYPE,
            es_exonerado inscripciones.es_exonerado%TYPE,
            prog_academico inscripciones.prog_academico%TYPE,
            es_suspendido inscripciones.es_suspendido%TYPE,
            cohorte_id inscripciones.cohorte_id%TYPE,
            horario_id inscripciones.horario_id%TYPE,
            modificado_por inscripciones.modificado_por%TYPE,
            modificado_el inscripciones.modificado_el%TYPE,
            hash               hash_t,
            row_id            VARCHAR2(64)
      );
   --Collection types (record)
   TYPE inscripciones_tt IS TABLE OF inscripciones_rt;

   --Global exceptions
   e_ol_check_failed EXCEPTION; --Optimistic lock check failed
   e_row_missing     EXCEPTION; --The cursor failed to get a row
   e_upd_failed      EXCEPTION; --The update operation failed
   e_del_failed      EXCEPTION; --The delete operation failed

   /**
   * Generates a SHA1 hash for optimistic locking purposes.
   *
   * @param    p_id        must be NOT NULL
   */
   FUNCTION hash (
                  p_id IN inscripciones.id%TYPE
                 )
    RETURN VARCHAR2;

   /**
   * This function generates a SHA1 hash for optimistic locking purposes.
   * Access directly to the row by rowid
   *
   * @param  p_rowid  must be NOT NULL
   */
   FUNCTION hash_rowid (p_rowid IN varchar2)
   RETURN varchar2;

   /**
   * This is a table encapsulation function designed to retrieve information from the inscripciones table.
   *
   * @param      p_id      must be NOT NULL
   * @return     inscripciones Record Type
   */
   FUNCTION rt (
                p_id IN inscripciones.id%TYPE 
               )
    RETURN inscripciones_rt RESULT_CACHE;

   /**
   * This is a table encapsulation function designed to retrieve information
   * from the inscripciones table while placing a lock on it for a potential
   * update/delete. Do not use this for updates in web based apps, instead use the
   * rt_for_web_update function to get a FOR_WEB_UPDATE_RT record which
   * includes all of the tables columns along with an md5 checksum for use in the
   * web_upd and web_del procedures.
   *
   * @param      p_id      must be NOT NULL
   * @return     inscripciones Record Type
   */
   FUNCTION rt_for_update (
                          p_id IN inscripciones.id%TYPE 
                          )
    RETURN inscripciones_rt RESULT_CACHE;

   /**
   * This is a table encapsulation function designed to retrieve information from the inscripciones table.
   * This function return Record Table as PIPELINED Function
   *
   * @param      p_id      must be NOT NULL
   * @return     inscripciones Table Record Type
   */
   FUNCTION tt (
                p_id IN inscripciones.id%TYPE DEFAULT NULL
               )
   RETURN inscripciones_tt
   PIPELINED;

   /**
   * This is a table encapsulation function designed to insert a row into the inscripciones table.
   *
   * @param      p_inscripciones_rec       Record Type
   * @return     p_inscripciones_rec       Record Type
   */
   PROCEDURE ins (p_inscripciones_rec IN OUT inscripciones_rt);

   /**
   * This is a table encapsulation function designed to update a row in the inscripciones table.
   *
   * @param      p_inscripciones_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE upd (p_inscripciones_rec IN inscripciones_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row in the inscripciones table,
   * access directly to the row by rowid
   *
   * @param      p_inscripciones_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE upd_rowid (p_inscripciones_rec IN inscripciones_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row
   * in the inscripciones table whith optimistic lock validation
   *
   * @param      p_inscripciones_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE web_upd (p_inscripciones_rec IN inscripciones_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row
   * in the inscripciones table whith optimistic lock validation
   * access directly to the row by rowid
   *
   * @param      p_inscripciones_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE web_upd_rowid (p_inscripciones_rec IN inscripciones_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to delete a row from the inscripciones table.
   *
   * @param    p_id        must be NOT NULL
   */
   PROCEDURE del (
                  p_id IN inscripciones.id%TYPE
                );

   /**
   * This is a table encapsulation function designed to delete a row from the inscripciones table
   * access directly to the row by rowid
   *
   * @param      p_rowid      must be NOT NULL
   */
    PROCEDURE del_rowid (p_rowid IN VARCHAR2);

   /**
   * This is a table encapsulation function designed to delete a row from the inscripciones table
   * whith optimistic lock validation
   *
   * @param      p_id      must be NOT NULL
   * @param      p_hash       must be NOT NULL
   */
    PROCEDURE web_del (
                      p_id IN inscripciones.id%TYPE,
                      p_hash IN varchar2
                      );

   /**
   * This is a table encapsulation function designed to delete a row from the inscripciones table
   * whith optimistic lock validation, access directly to the row by rowid
   *
   * @param      p_rowid      must be NOT NULL
   * @param      p_hash       must be NOT NULL
   */
    PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2);

END tapi_inscripciones;
 

/
--------------------------------------------------------
--  DDL for Package TAPI_INSTANCIAS_SECCIONES
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "FUNDAUC"."TAPI_INSTANCIAS_SECCIONES" 
IS
   /**
   * TAPI_INSTANCIAS_SECCIONES
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: 25-FEB-2020 23:11
   * Created By: FUNDAUC
   */

   --Scalar/Column types
   SUBTYPE hash_t IS varchar2 (40);
   SUBTYPE id IS instancias_secciones.id%TYPE;
   SUBTYPE seccion_id IS instancias_secciones.seccion_id%TYPE;
   SUBTYPE codigo_sec IS instancias_secciones.codigo_sec%TYPE;
   SUBTYPE metodo_id IS instancias_secciones.metodo_id%TYPE;
   SUBTYPE nivel IS instancias_secciones.nivel%TYPE;
   SUBTYPE periodo_id IS instancias_secciones.periodo_id%TYPE;
   SUBTYPE horario_id IS instancias_secciones.horario_id%TYPE;
   SUBTYPE modalidad_id IS instancias_secciones.modalidad_id%TYPE;
   SUBTYPE cedula_prof IS instancias_secciones.cedula_prof%TYPE;
   SUBTYPE f_inicio IS instancias_secciones.f_inicio%TYPE;
   SUBTYPE f_fin IS instancias_secciones.f_fin%TYPE;
   SUBTYPE estatus IS instancias_secciones.estatus%TYPE;

   --Record type
   TYPE instancias_secciones_rt
   IS
      RECORD (
            id instancias_secciones.id%TYPE,
            seccion_id instancias_secciones.seccion_id%TYPE,
            codigo_sec instancias_secciones.codigo_sec%TYPE,
            metodo_id instancias_secciones.metodo_id%TYPE,
            nivel instancias_secciones.nivel%TYPE,
            periodo_id instancias_secciones.periodo_id%TYPE,
            horario_id instancias_secciones.horario_id%TYPE,
            modalidad_id instancias_secciones.modalidad_id%TYPE,
            cedula_prof instancias_secciones.cedula_prof%TYPE,
            f_inicio instancias_secciones.f_inicio%TYPE,
            f_fin instancias_secciones.f_fin%TYPE,
            estatus instancias_secciones.estatus%TYPE,
            hash               hash_t,
            row_id            VARCHAR2(64)
      );
   --Collection types (record)
   TYPE instancias_secciones_tt IS TABLE OF instancias_secciones_rt;

   --Global exceptions
   e_ol_check_failed EXCEPTION; --Optimistic lock check failed
   e_row_missing     EXCEPTION; --The cursor failed to get a row
   e_upd_failed      EXCEPTION; --The update operation failed
   e_del_failed      EXCEPTION; --The delete operation failed

   /**
   * Generates a SHA1 hash for optimistic locking purposes.
   *
   * @param    p_id        must be NOT NULL
   */
   FUNCTION hash (
                  p_id IN instancias_secciones.id%TYPE
                 )
    RETURN VARCHAR2;

   /**
   * This function generates a SHA1 hash for optimistic locking purposes.
   * Access directly to the row by rowid
   *
   * @param  p_rowid  must be NOT NULL
   */
   FUNCTION hash_rowid (p_rowid IN varchar2)
   RETURN varchar2;

   /**
   * This is a table encapsulation function designed to retrieve information from the instancias_secciones table.
   *
   * @param      p_id      must be NOT NULL
   * @return     instancias_secciones Record Type
   */
   FUNCTION rt (
                p_id IN instancias_secciones.id%TYPE 
               )
    RETURN instancias_secciones_rt RESULT_CACHE;

   /**
   * This is a table encapsulation function designed to retrieve information
   * from the instancias_secciones table while placing a lock on it for a potential
   * update/delete. Do not use this for updates in web based apps, instead use the
   * rt_for_web_update function to get a FOR_WEB_UPDATE_RT record which
   * includes all of the tables columns along with an md5 checksum for use in the
   * web_upd and web_del procedures.
   *
   * @param      p_id      must be NOT NULL
   * @return     instancias_secciones Record Type
   */
   FUNCTION rt_for_update (
                          p_id IN instancias_secciones.id%TYPE 
                          )
    RETURN instancias_secciones_rt RESULT_CACHE;

   /**
   * This is a table encapsulation function designed to retrieve information from the instancias_secciones table.
   * This function return Record Table as PIPELINED Function
   *
   * @param      p_id      must be NOT NULL
   * @return     instancias_secciones Table Record Type
   */
   FUNCTION tt (
                p_id IN instancias_secciones.id%TYPE DEFAULT NULL
               )
   RETURN instancias_secciones_tt
   PIPELINED;

   /**
   * This is a table encapsulation function designed to insert a row into the instancias_secciones table.
   *
   * @param      p_instancias_secciones_rec       Record Type
   * @return     p_instancias_secciones_rec       Record Type
   */
   PROCEDURE ins (p_instancias_secciones_rec IN OUT instancias_secciones_rt);

   /**
   * This is a table encapsulation function designed to update a row in the instancias_secciones table.
   *
   * @param      p_instancias_secciones_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE upd (p_instancias_secciones_rec IN instancias_secciones_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row in the instancias_secciones table,
   * access directly to the row by rowid
   *
   * @param      p_instancias_secciones_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE upd_rowid (p_instancias_secciones_rec IN instancias_secciones_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row
   * in the instancias_secciones table whith optimistic lock validation
   *
   * @param      p_instancias_secciones_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE web_upd (p_instancias_secciones_rec IN instancias_secciones_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row
   * in the instancias_secciones table whith optimistic lock validation
   * access directly to the row by rowid
   *
   * @param      p_instancias_secciones_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE web_upd_rowid (p_instancias_secciones_rec IN instancias_secciones_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to delete a row from the instancias_secciones table.
   *
   * @param    p_id        must be NOT NULL
   */
   PROCEDURE del (
                  p_id IN instancias_secciones.id%TYPE
                );

   /**
   * This is a table encapsulation function designed to delete a row from the instancias_secciones table
   * access directly to the row by rowid
   *
   * @param      p_rowid      must be NOT NULL
   */
    PROCEDURE del_rowid (p_rowid IN VARCHAR2);

   /**
   * This is a table encapsulation function designed to delete a row from the instancias_secciones table
   * whith optimistic lock validation
   *
   * @param      p_id      must be NOT NULL
   * @param      p_hash       must be NOT NULL
   */
    PROCEDURE web_del (
                      p_id IN instancias_secciones.id%TYPE,
                      p_hash IN varchar2
                      );

   /**
   * This is a table encapsulation function designed to delete a row from the instancias_secciones table
   * whith optimistic lock validation, access directly to the row by rowid
   *
   * @param      p_rowid      must be NOT NULL
   * @param      p_hash       must be NOT NULL
   */
    PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2);

END tapi_instancias_secciones;
 

/
--------------------------------------------------------
--  DDL for Package TAPI_MATERIALES
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "FUNDAUC"."TAPI_MATERIALES" 
IS
   /**
   * TAPI_MATERIALES
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: 01-OCT-2019 12:25
   * Created By: FUNDAUC
   */

   --Scalar/Column types
   SUBTYPE hash_t IS varchar2 (40);
   SUBTYPE id_mat IS materiales.id_mat%TYPE;
   SUBTYPE tipo IS materiales.tipo%TYPE;
   SUBTYPE descripcion IS materiales.descripcion%TYPE;
   SUBTYPE id_curso IS materiales.id_curso%TYPE;
   SUBTYPE evento IS materiales.evento%TYPE;
   SUBTYPE nivel IS materiales.nivel%TYPE;
   SUBTYPE iva_exento IS materiales.iva_exento%TYPE;
   SUBTYPE activo IS materiales.activo%TYPE;
   SUBTYPE id IS materiales.id%TYPE;
   SUBTYPE seccion_id IS materiales.seccion_id%TYPE;
   SUBTYPE creado_por IS materiales.creado_por%TYPE;
   SUBTYPE creado_el IS materiales.creado_el%TYPE;
   SUBTYPE modificado_por IS materiales.modificado_por%TYPE;
   SUBTYPE modificado_el IS materiales.modificado_el%TYPE;
   SUBTYPE cohorte_id IS materiales.cohorte_id%TYPE;

   --Record type
   TYPE materiales_rt
   IS
      RECORD (
            id_mat materiales.id_mat%TYPE,
            tipo materiales.tipo%TYPE,
            descripcion materiales.descripcion%TYPE,
            id_curso materiales.id_curso%TYPE,
            evento materiales.evento%TYPE,
            nivel materiales.nivel%TYPE,
            iva_exento materiales.iva_exento%TYPE,
            activo materiales.activo%TYPE,
            id materiales.id%TYPE,
            seccion_id materiales.seccion_id%TYPE,
            creado_por materiales.creado_por%TYPE,
            creado_el materiales.creado_el%TYPE,
            modificado_por materiales.modificado_por%TYPE,
            modificado_el materiales.modificado_el%TYPE,
            cohorte_id materiales.cohorte_id%TYPE,
            hash               hash_t,
            row_id            VARCHAR2(64)
      );
   --Collection types (record)
   TYPE materiales_tt IS TABLE OF materiales_rt;

   --Global exceptions
   e_ol_check_failed EXCEPTION; --Optimistic lock check failed
   e_row_missing     EXCEPTION; --The cursor failed to get a row
   e_upd_failed      EXCEPTION; --The update operation failed
   e_del_failed      EXCEPTION; --The delete operation failed

   /**
   * Generates a SHA1 hash for optimistic locking purposes.
   *
   * @param    p_id        must be NOT NULL
   */
   FUNCTION hash (
                  p_id IN materiales.id%TYPE
                 )
    RETURN VARCHAR2;

   /**
   * This function generates a SHA1 hash for optimistic locking purposes.
   * Access directly to the row by rowid
   *
   * @param  p_rowid  must be NOT NULL
   */
   FUNCTION hash_rowid (p_rowid IN varchar2)
   RETURN varchar2;

   /**
   * This is a table encapsulation function designed to retrieve information from the materiales table.
   *
   * @param      p_id      must be NOT NULL
   * @return     materiales Record Type
   */
   FUNCTION rt (
                p_id IN materiales.id%TYPE 
               )
    RETURN materiales_rt RESULT_CACHE;

   /**
   * This is a table encapsulation function designed to retrieve information
   * from the materiales table while placing a lock on it for a potential
   * update/delete. Do not use this for updates in web based apps, instead use the
   * rt_for_web_update function to get a FOR_WEB_UPDATE_RT record which
   * includes all of the tables columns along with an md5 checksum for use in the
   * web_upd and web_del procedures.
   *
   * @param      p_id      must be NOT NULL
   * @return     materiales Record Type
   */
   FUNCTION rt_for_update (
                          p_id IN materiales.id%TYPE 
                          )
    RETURN materiales_rt RESULT_CACHE;

   /**
   * This is a table encapsulation function designed to retrieve information from the materiales table.
   * This function return Record Table as PIPELINED Function
   *
   * @param      p_id      must be NOT NULL
   * @return     materiales Table Record Type
   */
   FUNCTION tt (
                p_id IN materiales.id%TYPE DEFAULT NULL
               )
   RETURN materiales_tt
   PIPELINED;

   /**
   * This is a table encapsulation function designed to insert a row into the materiales table.
   *
   * @param      p_materiales_rec       Record Type
   * @return     p_materiales_rec       Record Type
   */
   PROCEDURE ins (p_materiales_rec IN OUT materiales_rt);

   /**
   * This is a table encapsulation function designed to update a row in the materiales table.
   *
   * @param      p_materiales_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE upd (p_materiales_rec IN materiales_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row in the materiales table,
   * access directly to the row by rowid
   *
   * @param      p_materiales_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE upd_rowid (p_materiales_rec IN materiales_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row
   * in the materiales table whith optimistic lock validation
   *
   * @param      p_materiales_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE web_upd (p_materiales_rec IN materiales_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row
   * in the materiales table whith optimistic lock validation
   * access directly to the row by rowid
   *
   * @param      p_materiales_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE web_upd_rowid (p_materiales_rec IN materiales_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to delete a row from the materiales table.
   *
   * @param    p_id        must be NOT NULL
   */
   PROCEDURE del (
                  p_id IN materiales.id%TYPE
                );

   /**
   * This is a table encapsulation function designed to delete a row from the materiales table
   * access directly to the row by rowid
   *
   * @param      p_rowid      must be NOT NULL
   */
    PROCEDURE del_rowid (p_rowid IN VARCHAR2);

   /**
   * This is a table encapsulation function designed to delete a row from the materiales table
   * whith optimistic lock validation
   *
   * @param      p_id      must be NOT NULL
   * @param      p_hash       must be NOT NULL
   */
    PROCEDURE web_del (
                      p_id IN materiales.id%TYPE,
                      p_hash IN varchar2
                      );

   /**
   * This is a table encapsulation function designed to delete a row from the materiales table
   * whith optimistic lock validation, access directly to the row by rowid
   *
   * @param      p_rowid      must be NOT NULL
   * @param      p_hash       must be NOT NULL
   */
    PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2);

END tapi_materiales;

/
--------------------------------------------------------
--  DDL for Package TAPI_PRECIOS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "FUNDAUC"."TAPI_PRECIOS" 
IS
   /**
   * TAPI_PRECIOS
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: 25-FEB-2020 17:08
   * Created By: FUNDAUC
   */

   --Scalar/Column types
   SUBTYPE hash_t IS varchar2 (40);
   SUBTYPE tipo_item IS precios.tipo_item%TYPE;
   SUBTYPE fecha IS precios.fecha%TYPE;
   SUBTYPE precio1 IS precios.precio1%TYPE;
   SUBTYPE precio2 IS precios.precio2%TYPE;
   SUBTYPE precio3 IS precios.precio3%TYPE;
   SUBTYPE status IS precios.status%TYPE;
   SUBTYPE precio4 IS precios.precio4%TYPE;
   SUBTYPE precio5 IS precios.precio5%TYPE;
   SUBTYPE id IS precios.id%TYPE;

   --Record type
   TYPE precios_rt
   IS
      RECORD (
            tipo_item precios.tipo_item%TYPE,
            fecha precios.fecha%TYPE,
            precio1 precios.precio1%TYPE,
            precio2 precios.precio2%TYPE,
            precio3 precios.precio3%TYPE,
            status precios.status%TYPE,
            precio4 precios.precio4%TYPE,
            precio5 precios.precio5%TYPE,
            id precios.id%TYPE,
            hash               hash_t,
            row_id            VARCHAR2(64)
      );
   --Collection types (record)
   TYPE precios_tt IS TABLE OF precios_rt;

   --Global exceptions
   e_ol_check_failed EXCEPTION; --Optimistic lock check failed
   e_row_missing     EXCEPTION; --The cursor failed to get a row
   e_upd_failed      EXCEPTION; --The update operation failed
   e_del_failed      EXCEPTION; --The delete operation failed

   /**
   * Generates a SHA1 hash for optimistic locking purposes.
   *
   * @param    p_id        must be NOT NULL
   */
   FUNCTION hash (
                  p_id IN precios.id%TYPE
                 )
    RETURN VARCHAR2;

   /**
   * This function generates a SHA1 hash for optimistic locking purposes.
   * Access directly to the row by rowid
   *
   * @param  p_rowid  must be NOT NULL
   */
   FUNCTION hash_rowid (p_rowid IN varchar2)
   RETURN varchar2;

   /**
   * This is a table encapsulation function designed to retrieve information from the precios table.
   *
   * @param      p_id      must be NOT NULL
   * @return     precios Record Type
   */
   FUNCTION rt (
                p_id IN precios.id%TYPE 
               )
    RETURN precios_rt RESULT_CACHE;

   /**
   * This is a table encapsulation function designed to retrieve information
   * from the precios table while placing a lock on it for a potential
   * update/delete. Do not use this for updates in web based apps, instead use the
   * rt_for_web_update function to get a FOR_WEB_UPDATE_RT record which
   * includes all of the tables columns along with an md5 checksum for use in the
   * web_upd and web_del procedures.
   *
   * @param      p_id      must be NOT NULL
   * @return     precios Record Type
   */
   FUNCTION rt_for_update (
                          p_id IN precios.id%TYPE 
                          )
    RETURN precios_rt RESULT_CACHE;

   /**
   * This is a table encapsulation function designed to retrieve information from the precios table.
   * This function return Record Table as PIPELINED Function
   *
   * @param      p_id      must be NOT NULL
   * @return     precios Table Record Type
   */
   FUNCTION tt (
                p_id IN precios.id%TYPE DEFAULT NULL
               )
   RETURN precios_tt
   PIPELINED;

   /**
   * This is a table encapsulation function designed to insert a row into the precios table.
   *
   * @param      p_precios_rec       Record Type
   * @return     p_precios_rec       Record Type
   */
   PROCEDURE ins (p_precios_rec IN OUT precios_rt);

   /**
   * This is a table encapsulation function designed to update a row in the precios table.
   *
   * @param      p_precios_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE upd (p_precios_rec IN precios_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row in the precios table,
   * access directly to the row by rowid
   *
   * @param      p_precios_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE upd_rowid (p_precios_rec IN precios_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row
   * in the precios table whith optimistic lock validation
   *
   * @param      p_precios_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE web_upd (p_precios_rec IN precios_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row
   * in the precios table whith optimistic lock validation
   * access directly to the row by rowid
   *
   * @param      p_precios_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE web_upd_rowid (p_precios_rec IN precios_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to delete a row from the precios table.
   *
   * @param    p_id        must be NOT NULL
   */
   PROCEDURE del (
                  p_id IN precios.id%TYPE
                );

   /**
   * This is a table encapsulation function designed to delete a row from the precios table
   * access directly to the row by rowid
   *
   * @param      p_rowid      must be NOT NULL
   */
    PROCEDURE del_rowid (p_rowid IN VARCHAR2);

   /**
   * This is a table encapsulation function designed to delete a row from the precios table
   * whith optimistic lock validation
   *
   * @param      p_id      must be NOT NULL
   * @param      p_hash       must be NOT NULL
   */
    PROCEDURE web_del (
                      p_id IN precios.id%TYPE,
                      p_hash IN varchar2
                      );

   /**
   * This is a table encapsulation function designed to delete a row from the precios table
   * whith optimistic lock validation, access directly to the row by rowid
   *
   * @param      p_rowid      must be NOT NULL
   * @param      p_hash       must be NOT NULL
   */
    PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2);

END tapi_precios;

/
--------------------------------------------------------
--  DDL for Package TAPI_SECCIONES
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "FUNDAUC"."TAPI_SECCIONES" 
IS
   /**
   * TAPI_SECCIONES
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: 01-OCT-2019 11:06
   * Created By: FUNDAUC
   */

   --Scalar/Column types
   SUBTYPE hash_t IS varchar2 (40);
   SUBTYPE id_seccion IS secciones.id_seccion%TYPE;
   SUBTYPE id_metodo IS secciones.id_metodo%TYPE;
   SUBTYPE nivel IS secciones.nivel%TYPE;
   SUBTYPE id_salon IS secciones.id_salon%TYPE;
   SUBTYPE tope IS secciones.tope%TYPE;
   SUBTYPE status IS secciones.status%TYPE;
   SUBTYPE id_edif IS secciones.id_edif%TYPE;
   SUBTYPE horario IS secciones.horario%TYPE;
   SUBTYPE cedula_prof IS secciones.cedula_prof%TYPE;
   SUBTYPE modalidad IS secciones.modalidad%TYPE;
   SUBTYPE fec_inicio IS secciones.fec_inicio%TYPE;
   SUBTYPE periodo IS secciones.periodo%TYPE;
   SUBTYPE id_horario IS secciones.id_horario%TYPE;
   SUBTYPE id_calendario IS secciones.id_calendario%TYPE;
   SUBTYPE id IS secciones.id%TYPE;
   SUBTYPE creado_por IS secciones.creado_por%TYPE;
   SUBTYPE creado_el IS secciones.creado_el%TYPE;
   SUBTYPE modificado_por IS secciones.modificado_por%TYPE;
   SUBTYPE modificado_el IS secciones.modificado_el%TYPE;

   --Record type
   TYPE secciones_rt
   IS
      RECORD (
            id_seccion secciones.id_seccion%TYPE,
            id_metodo secciones.id_metodo%TYPE,
            nivel secciones.nivel%TYPE,
            id_salon secciones.id_salon%TYPE,
            tope secciones.tope%TYPE,
            status secciones.status%TYPE,
            id_edif secciones.id_edif%TYPE,
            horario secciones.horario%TYPE,
            cedula_prof secciones.cedula_prof%TYPE,
            modalidad secciones.modalidad%TYPE,
            fec_inicio secciones.fec_inicio%TYPE,
            periodo secciones.periodo%TYPE,
            id_horario secciones.id_horario%TYPE,
            id_calendario secciones.id_calendario%TYPE,
            id secciones.id%TYPE,
            creado_por secciones.creado_por%TYPE,
            creado_el secciones.creado_el%TYPE,
            modificado_por secciones.modificado_por%TYPE,
            modificado_el secciones.modificado_el%TYPE,
            hash               hash_t,
            row_id            VARCHAR2(64)
      );
   --Collection types (record)
   TYPE secciones_tt IS TABLE OF secciones_rt;

   --Global exceptions
   e_ol_check_failed EXCEPTION; --Optimistic lock check failed
   e_row_missing     EXCEPTION; --The cursor failed to get a row
   e_upd_failed      EXCEPTION; --The update operation failed
   e_del_failed      EXCEPTION; --The delete operation failed

   /**
   * Generates a SHA1 hash for optimistic locking purposes.
   *
   * @param    p_id        must be NOT NULL
   */
   FUNCTION hash (
                  p_id IN secciones.id%TYPE
                 )
    RETURN VARCHAR2;

   /**
   * This function generates a SHA1 hash for optimistic locking purposes.
   * Access directly to the row by rowid
   *
   * @param  p_rowid  must be NOT NULL
   */
   FUNCTION hash_rowid (p_rowid IN varchar2)
   RETURN varchar2;

   /**
   * This is a table encapsulation function designed to retrieve information from the secciones table.
   *
   * @param      p_id      must be NOT NULL
   * @return     secciones Record Type
   */
   FUNCTION rt (
                p_id IN secciones.id%TYPE 
               )
    RETURN secciones_rt RESULT_CACHE;

   /**
   * This is a table encapsulation function designed to retrieve information
   * from the secciones table while placing a lock on it for a potential
   * update/delete. Do not use this for updates in web based apps, instead use the
   * rt_for_web_update function to get a FOR_WEB_UPDATE_RT record which
   * includes all of the tables columns along with an md5 checksum for use in the
   * web_upd and web_del procedures.
   *
   * @param      p_id      must be NOT NULL
   * @return     secciones Record Type
   */
   FUNCTION rt_for_update (
                          p_id IN secciones.id%TYPE 
                          )
    RETURN secciones_rt RESULT_CACHE;

   /**
   * This is a table encapsulation function designed to retrieve information from the secciones table.
   * This function return Record Table as PIPELINED Function
   *
   * @param      p_id      must be NOT NULL
   * @return     secciones Table Record Type
   */
   FUNCTION tt (
                p_id IN secciones.id%TYPE DEFAULT NULL
               )
   RETURN secciones_tt
   PIPELINED;

   /**
   * This is a table encapsulation function designed to insert a row into the secciones table.
   *
   * @param      p_secciones_rec       Record Type
   * @return     p_secciones_rec       Record Type
   */
   PROCEDURE ins (p_secciones_rec IN OUT secciones_rt);

   /**
   * This is a table encapsulation function designed to update a row in the secciones table.
   *
   * @param      p_secciones_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE upd (p_secciones_rec IN secciones_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row in the secciones table,
   * access directly to the row by rowid
   *
   * @param      p_secciones_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE upd_rowid (p_secciones_rec IN secciones_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row
   * in the secciones table whith optimistic lock validation
   *
   * @param      p_secciones_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE web_upd (p_secciones_rec IN secciones_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row
   * in the secciones table whith optimistic lock validation
   * access directly to the row by rowid
   *
   * @param      p_secciones_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE web_upd_rowid (p_secciones_rec IN secciones_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to delete a row from the secciones table.
   *
   * @param    p_id        must be NOT NULL
   */
   PROCEDURE del (
                  p_id IN secciones.id%TYPE
                );

   /**
   * This is a table encapsulation function designed to delete a row from the secciones table
   * access directly to the row by rowid
   *
   * @param      p_rowid      must be NOT NULL
   */
    PROCEDURE del_rowid (p_rowid IN VARCHAR2);

   /**
   * This is a table encapsulation function designed to delete a row from the secciones table
   * whith optimistic lock validation
   *
   * @param      p_id      must be NOT NULL
   * @param      p_hash       must be NOT NULL
   */
    PROCEDURE web_del (
                      p_id IN secciones.id%TYPE,
                      p_hash IN varchar2
                      );

   /**
   * This is a table encapsulation function designed to delete a row from the secciones table
   * whith optimistic lock validation, access directly to the row by rowid
   *
   * @param      p_rowid      must be NOT NULL
   * @param      p_hash       must be NOT NULL
   */
    PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2);

END tapi_secciones;

/
--------------------------------------------------------
--  DDL for Package TAPI_USUARIOS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "FUNDAUC"."TAPI_USUARIOS" 
IS
   /**
   * TAPI_USUARIOS
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: 18-AGO-2019 18:18
   * Created By: FUNDAUC
   */

   --Scalar/Column types
   SUBTYPE hash_t IS varchar2 (40);
   SUBTYPE cedula IS usuarios.cedula%TYPE;
   SUBTYPE nombre_usuario IS usuarios.nombre_usuario%TYPE;
   SUBTYPE contrasena IS usuarios.contrasena%TYPE;
   SUBTYPE id_rol IS usuarios.id_rol%TYPE;
   SUBTYPE email IS usuarios.email%TYPE;
   SUBTYPE nombre IS usuarios.nombre%TYPE;
   SUBTYPE cia IS usuarios.cia%TYPE;
   SUBTYPE prog_academico IS usuarios.prog_academico%TYPE;
   SUBTYPE activo IS usuarios.activo%TYPE;
   SUBTYPE bloqueado IS usuarios.bloqueado%TYPE;
   SUBTYPE creado_por IS usuarios.creado_por%TYPE;
   SUBTYPE creado_el IS usuarios.creado_el%TYPE;
   SUBTYPE modificado_por IS usuarios.modificado_por%TYPE;
   SUBTYPE modificado_el IS usuarios.modificado_el%TYPE;

   --Record type
   TYPE usuarios_rt
   IS
      RECORD (
            cedula usuarios.cedula%TYPE,
            nombre_usuario usuarios.nombre_usuario%TYPE,
            contrasena usuarios.contrasena%TYPE,
            id_rol usuarios.id_rol%TYPE,
            email usuarios.email%TYPE,
            nombre usuarios.nombre%TYPE,
            cia usuarios.cia%TYPE,
            prog_academico usuarios.prog_academico%TYPE,
            activo usuarios.activo%TYPE,
            bloqueado usuarios.bloqueado%TYPE,
            creado_por usuarios.creado_por%TYPE,
            creado_el usuarios.creado_el%TYPE,
            modificado_por usuarios.modificado_por%TYPE,
            modificado_el usuarios.modificado_el%TYPE,
            hash               hash_t,
            row_id            VARCHAR2(64)
      );
   --Collection types (record)
   TYPE usuarios_tt IS TABLE OF usuarios_rt;

   --Global exceptions
   e_ol_check_failed EXCEPTION; --Optimistic lock check failed
   e_row_missing     EXCEPTION; --The cursor failed to get a row
   e_upd_failed      EXCEPTION; --The update operation failed
   e_del_failed      EXCEPTION; --The delete operation failed

   /**
   * Generates a SHA1 hash for optimistic locking purposes.
   *
   * @param    p_cedula        must be NOT NULL
   */
   FUNCTION hash (
                  p_cedula IN usuarios.cedula%TYPE
                 )
    RETURN VARCHAR2;

   /**
   * This function generates a SHA1 hash for optimistic locking purposes.
   * Access directly to the row by rowid
   *
   * @param  p_rowid  must be NOT NULL
   */
   FUNCTION hash_rowid (p_rowid IN varchar2)
   RETURN varchar2;

   /**
   * This is a table encapsulation function designed to retrieve information from the usuarios table.
   *
   * @param      p_cedula      must be NOT NULL
   * @return     usuarios Record Type
   */
   FUNCTION rt (
                p_cedula IN usuarios.cedula%TYPE 
               )
    RETURN usuarios_rt RESULT_CACHE;

   /**
   * This is a table encapsulation function designed to retrieve information
   * from the usuarios table while placing a lock on it for a potential
   * update/delete. Do not use this for updates in web based apps, instead use the
   * rt_for_web_update function to get a FOR_WEB_UPDATE_RT record which
   * includes all of the tables columns along with an md5 checksum for use in the
   * web_upd and web_del procedures.
   *
   * @param      p_cedula      must be NOT NULL
   * @return     usuarios Record Type
   */
   FUNCTION rt_for_update (
                          p_cedula IN usuarios.cedula%TYPE 
                          )
    RETURN usuarios_rt RESULT_CACHE;

   /**
   * This is a table encapsulation function designed to retrieve information from the usuarios table.
   * This function return Record Table as PIPELINED Function
   *
   * @param      p_cedula      must be NOT NULL
   * @return     usuarios Table Record Type
   */
   FUNCTION tt (
                p_cedula IN usuarios.cedula%TYPE DEFAULT NULL
               )
   RETURN usuarios_tt
   PIPELINED;

   /**
   * This is a table encapsulation function designed to insert a row into the usuarios table.
   *
   * @param      p_usuarios_rec       Record Type
   * @return     p_usuarios_rec       Record Type
   */
   PROCEDURE ins (p_usuarios_rec IN OUT usuarios_rt);

   /**
   * This is a table encapsulation function designed to update a row in the usuarios table.
   *
   * @param      p_usuarios_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE upd (p_usuarios_rec IN usuarios_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row in the usuarios table,
   * access directly to the row by rowid
   *
   * @param      p_usuarios_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE upd_rowid (p_usuarios_rec IN usuarios_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row
   * in the usuarios table whith optimistic lock validation
   *
   * @param      p_usuarios_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE web_upd (p_usuarios_rec IN usuarios_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to update a row
   * in the usuarios table whith optimistic lock validation
   * access directly to the row by rowid
   *
   * @param      p_usuarios_rec      Record Type
   * @param      p_ignore_nulls      IF TRUE then null values are ignored in the update
   */
   PROCEDURE web_upd_rowid (p_usuarios_rec IN usuarios_rt, p_ignore_nulls IN boolean := FALSE);

   /**
   * This is a table encapsulation function designed to delete a row from the usuarios table.
   *
   * @param    p_cedula        must be NOT NULL
   */
   PROCEDURE del (
                  p_cedula IN usuarios.cedula%TYPE
                );

   /**
   * This is a table encapsulation function designed to delete a row from the usuarios table
   * access directly to the row by rowid
   *
   * @param      p_rowid      must be NOT NULL
   */
    PROCEDURE del_rowid (p_rowid IN VARCHAR2);

   /**
   * This is a table encapsulation function designed to delete a row from the usuarios table
   * whith optimistic lock validation
   *
   * @param      p_cedula      must be NOT NULL
   * @param      p_hash       must be NOT NULL
   */
    PROCEDURE web_del (
                      p_cedula IN usuarios.cedula%TYPE,
                      p_hash IN varchar2
                      );

   /**
   * This is a table encapsulation function designed to delete a row from the usuarios table
   * whith optimistic lock validation, access directly to the row by rowid
   *
   * @param      p_rowid      must be NOT NULL
   * @param      p_hash       must be NOT NULL
   */
    PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2);

END tapi_usuarios;


/
--------------------------------------------------------
--  DDL for Package TEPLSQL
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "FUNDAUC"."TEPLSQL" 
AS
   --Define Associative Array
   TYPE t_assoc_array
   IS
      TABLE OF VARCHAR2 (32767)
         INDEX BY VARCHAR2 (255);

   null_assoc_array   t_assoc_array;

   /**
   * Output CLOB data to the DBMS_OUTPUT.PUT_LINE
   *
   * @param  p_clob     the CLOB to print to the DBMS_OUTPUT
   */
   PROCEDURE output_clob(p_clob in CLOB);

   /**
   * Prints received data into the buffer
   *
   * @param  p_data     the data to print into buffer
   */
   PROCEDURE PRINT (p_data IN CLOB);

   PROCEDURE p (p_data IN CLOB);

   PROCEDURE PRINT (p_data IN VARCHAR2);

   PROCEDURE p (p_data IN VARCHAR2);

   PROCEDURE PRINT (p_data IN NUMBER);

   PROCEDURE p (p_data IN NUMBER);

   /**
   * Renders the template received as parameter.
   *
   * @param  p_vars      the template's arguments.
   * @param  p_template  the template's body.
   * @return             the processed template.
   */
   FUNCTION render (p_vars IN t_assoc_array DEFAULT null_assoc_array, p_template IN CLOB)
      RETURN CLOB;

   /**
   * Receives the name of the object, usually a package,
   * which contains an embedded template.
   * The template is extracted and is rendered with `render` function
   *
   * @param  p_vars             the template's arguments.
   * @param  p_template_name    the name of the template
   * @param  p_object_name      the name of the object (usually the name of the package)
   * @param  p_object_type      the type of the object (PACKAGE, PROCEDURE, FUNCTION...)
   * @param  p_schema           the object's schema name.
   * @return                    the processed template.
   */
   FUNCTION process (p_vars            IN t_assoc_array DEFAULT null_assoc_array
                   , p_template_name   IN VARCHAR2 DEFAULT NULL
                   , p_object_name     IN VARCHAR2 DEFAULT 'TE_TEMPLATES'
                   , p_object_type     IN VARCHAR2 DEFAULT 'PACKAGE'
                   , p_schema          IN VARCHAR2 DEFAULT NULL )
      RETURN CLOB;
END teplsql;

/
--------------------------------------------------------
--  DDL for Package TOOLKIT
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "FUNDAUC"."TOOLKIT" AS

  FUNCTION encrypt (p_text  IN  VARCHAR2) RETURN RAW;

  FUNCTION decrypt (p_raw  IN  RAW) RETURN VARCHAR2;

  FUNCTION LOGIN (p_username IN VARCHAR2, p_password VARCHAR2) RETURN BOOLEAN;

  FUNCTION get_tipo_acceso (p_usr IN VARCHAR2, p_app VARCHAR2) RETURN CHAR;

END toolkit;

/
--------------------------------------------------------
--  DDL for Package UTL_CALENDARIOS_DETALLES
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "FUNDAUC"."UTL_CALENDARIOS_DETALLES" AS 

    FUNCTION getTotalPeriodosCal (
        vid_calendario NUMBER
    ) RETURN NUMBER;

    FUNCTION getTotalPeriodosCalMod (
        vid_calendario NUMBER,
        vid_modalidad NUMBER
    ) RETURN NUMBER;

    FUNCTION getSiguentePeriodoMod (
        vid_calendario NUMBER,
        vid_modalidad NUMBER
    ) RETURN NUMBER;
    
    FUNCTION getCalendario (
        vid_calendario NUMBER
    ) RETURN VARCHAR2;

END UTL_CALENDARIOS_DETALLES;

/
--------------------------------------------------------
--  DDL for Package UTL_CONFIGURACION
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "FUNDAUC"."UTL_CONFIGURACION" AS 

    FUNCTION getConfIva RETURN NUMBER;

    FUNCTION getConfUltFactura RETURN NUMBER;

    PROCEDURE actConfUltFactura(numero IN number);

    FUNCTION getConfPorTDC RETURN NUMBER;

    FUNCTION getConfPorTDB RETURN NUMBER;

END UTL_CONFIGURACION;

/
--------------------------------------------------------
--  DDL for Package UTL_ESTUDIANTES
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "FUNDAUC"."UTL_ESTUDIANTES" AS 
    
    FUNCTION getTipoEstudiante (
        vid_tipoest NUMBER
    ) RETURN VARCHAR2;

END UTL_ESTUDIANTES;

/
--------------------------------------------------------
--  DDL for Package UTL_FACTURA
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "FUNDAUC"."UTL_FACTURA" AS 
    
    FUNCTION getTotal (
        vid IN NUMBER
    ) RETURN NUMBER;

    PROCEDURE insIngDiferido (
        vfid IN NUMBER, 
        vmonto IN NUMBER,
        vresp OUT NUMBER);

END UTL_FACTURA;

/
--------------------------------------------------------
--  DDL for Package UTL_FACTURA_DEPOSITO
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "FUNDAUC"."UTL_FACTURA_DEPOSITO" AS 
    
    PROCEDURE ins_multi (
        v_jsonfac IN varchar2,
        vid_deposito IN number
    );

END UTL_FACTURA_DEPOSITO;

/
--------------------------------------------------------
--  DDL for Package UTL_HORARIOS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "FUNDAUC"."UTL_HORARIOS" AS 

    FUNCTION getTotalHorarios (
        vid_modalidad NUMBER
    ) RETURN NUMBER;

    FUNCTION getHorario (
        vid_horario NUMBER
    ) RETURN VARCHAR2;
    
    FUNCTION getHorarioMin (
        vid_horario NUMBER
    ) RETURN VARCHAR2;

    FUNCTION getIdHorario (
        vdes_horario VARCHAR2,
        vid_modalidad NUMBER
    ) RETURN NUMBER;

END UTL_HORARIOS;

/
--------------------------------------------------------
--  DDL for Package UTL_INSCRIPCIONES
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "FUNDAUC"."UTL_INSCRIPCIONES" AS 
    --Record type
    TYPE seccion_rt IS RECORD ( seccion_id secciones.id_seccion%TYPE,
    id_metodo secciones.id_metodo%TYPE,
    nivel secciones.nivel%TYPE,
    id_horario secciones.id_horario%TYPE,
    id_modalidad secciones.modalidad%TYPE,
    id_periodo secciones.periodo%TYPE );
   --Collection types (record)
    TYPE seccion_tt IS
        TABLE OF seccion_rt;
    FUNCTION getinscripcionesseccion (
        vid_seccion NUMBER,
        vid_periodo NUMBER
    ) RETURN NUMBER;

    FUNCTION getinscripcionescohorte (
        vid_cohorte NUMBER,
        vid_periodo NUMBER
    ) RETURN NUMBER;

    FUNCTION getdesstatus (
        v_status VARCHAR2
    ) RETURN VARCHAR2;

    FUNCTION getstatusfac (
        vid_insc NUMBER
    ) RETURN VARCHAR2;

    PROCEDURE elimina_inscripciones;

    PROCEDURE actualiza_estatus;

    PROCEDURE actualiza_est_ins (
        facturas IN VARCHAR2
    );

    FUNCTION log_message (
        message IN VARCHAR2
    ) RETURN NUMBER;

    FUNCTION getseccionrec (
        p_renglon   IN detalle_factura.renglon%TYPE
    ) RETURN seccion_rt
        RESULT_CACHE;

    FUNCTION getsecciondes (
        p_id_seccion   IN secciones.id%TYPE
    ) RETURN VARCHAR2;

    FUNCTION getseccioncod (
        p_id_secc   IN secciones.id%TYPE
    ) RETURN VARCHAR2;

    FUNCTION getcohortedes (
        p_id_cohorte   IN cohortes.id%TYPE
    ) RETURN VARCHAR2;

    FUNCTION getcodigoseccion (
        metodo_id     IN VARCHAR2,
        nivel         IN NUMBER,
        periodo_id    IN NUMBER,
        modalidad_id  IN NUMBER,
        horario_id    IN NUMBER
    ) RETURN VARCHAR2;

END utl_inscripciones;

/
--------------------------------------------------------
--  DDL for Package UTL_MATERIALES
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "FUNDAUC"."UTL_MATERIALES" AS 

    --Record type
   TYPE detalle_factura_rt
   IS
      RECORD (
            renglon detalle_factura.renglon%TYPE,
            tipo_item detalle_factura.tipo_item%TYPE,
            item detalle_factura.item%TYPE,
            descripcion detalle_factura.descripcion%TYPE,
            cantidad detalle_factura.cantidad%TYPE,
            p_unidad detalle_factura.p_unidad%TYPE,
            bs_descuento detalle_factura.bs_descuento%TYPE,
            subtotal detalle_factura.subtotal%TYPE,
            materiales_id detalle_factura.materiales_id%TYPE,
            factura_id detalle_factura.factura_id%TYPE
      );

    FUNCTION getRecDetalleFac (
        vid_material NUMBER,
        vtipo_mat    VARCHAR2
    ) RETURN detalle_factura_rt RESULT_CACHE;

    FUNCTION getRecDetalleFac (
        vcod_mat    VARCHAR2
    ) RETURN detalle_factura_rt RESULT_CACHE;

    FUNCTION getExentoIva (
        vid_material NUMBER
    ) RETURN CHAR;

END UTL_MATERIALES;


/
--------------------------------------------------------
--  DDL for Package UTL_MODALIDADES
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "FUNDAUC"."UTL_MODALIDADES" AS 
    
    FUNCTION getModalidad (
        vid_modalidad NUMBER
    ) RETURN VARCHAR2;
    
    FUNCTION getSiglas (
        vid_modalidad NUMBER
    ) RETURN VARCHAR2;

    FUNCTION getIdModalidad (
        vdes_modalidad VARCHAR2
    ) RETURN NUMBER;

END UTL_MODALIDADES;

/
--------------------------------------------------------
--  DDL for Package UTL_PERIODOS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "FUNDAUC"."UTL_PERIODOS" AS 

    FUNCTION getTotalperiodos (
        vid_calendario NUMBER
    ) RETURN NUMBER;

    FUNCTION getPeriodo (
        vid_periodo NUMBER
    ) RETURN VARCHAR2;

    FUNCTION getPeriodoFInicio (
        vid_periodo NUMBER
    ) RETURN DATE;
    
    FUNCTION getPeriodoFFin (
        vid_periodo NUMBER
    ) RETURN DATE;

     FUNCTION getPeriodoSec (
        vid_seccion NUMBER
    ) RETURN VARCHAR2;

     FUNCTION getPeriodoCor (
        vid_cohorte NUMBER
    ) RETURN VARCHAR2;

    FUNCTION getStatusPeriodo (
        vid_periodo NUMBER
    ) RETURN VARCHAR2;

    FUNCTION getStatusPeriodoSec (
        vid_seccion NUMBER
    ) RETURN VARCHAR2;
    
    FUNCTION getPeriodoFecIniSec (
        vid_seccion NUMBER
    ) RETURN DATE;

    FUNCTION getPeriodoFecFinSec (
        vid_seccion NUMBER
    ) RETURN DATE;

    FUNCTION getStatusPeriodoCor (
        vid_cohorte NUMBER
    ) RETURN VARCHAR2;
    
    FUNCTION getPeriodoFecIniCor (
        vid_cohorte NUMBER
    ) RETURN DATE;

END UTL_PERIODOS;

/
--------------------------------------------------------
--  DDL for Package Body APEX_ENHANCED_LOV_ITEM
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."APEX_ENHANCED_LOV_ITEM" as

  g_app_id  number default v('APP_ID');
  g_page_id number default v('APP_PAGE_ID');
  g_debug   boolean default case when v('DEBUG') = 'YES' then true else false end;
  g_ajax_mode varchar2(4000);

  g_ajax_search_string varchar2(4000);
  g_ajax_search_column_idx number;

  g_item   apex_plugin.t_page_item;
  g_plugin apex_plugin.t_plugin;

  --
  -- function prepareSqlQuery
  --
  function prepareSqlQuery return varchar2
  is
    v_query varchar2(32767) := g_item.lov_definition;
  begin
    /*
      queries generated by APEX for static inline lov and static shared lov
    */
    --select /*+ cardinality(t 5) no_result_cache */ disp, val from table(wwv_flow_utilities.get_temp_lov_data(1)) t order by disp
    --select /*+ cardinality(t 10) no_result_cache */ disp, val from table(wwv_flow_utilities.get_temp_lov_data(1)) t order by insert_order, disp

    if  instr(v_query, '*/ disp, val from') > 0  then
      v_query := '
        /*1*/
        select disp d, val r from (
          '||v_query||'
        ) /*2*/
      ';
    end if;

    return 'select * from ('||v_query||') where r is not null';
  end prepareSqlQuery;

  --
  -- getBindedRefCursor
  --

  function getBindedRefCursor(
    pi_sql in varchar2
  ) return sys_refcursor as
    v_apex_items_names    DBMS_SQL.VARCHAR2_TABLE;
    v_cursor              pls_integer;
    v_status              number;
  begin
    v_apex_items_names := WWV_FLOW_UTILITIES.GET_BINDS( pi_sql );

    -- open v_cursor;
    v_cursor := dbms_sql.open_cursor;

    dbms_sql.parse (v_cursor, pi_sql, dbms_sql.native);

    -- bind items
    for i in 1..v_apex_items_names.count loop

      if v_apex_items_names(i) = ':SEARCH_STRING' then
        dbms_sql.bind_variable (v_cursor, v_apex_items_names(i), g_ajax_search_string );
      else
        dbms_sql.bind_variable (v_cursor, v_apex_items_names(i), v( trim(both ':' from v_apex_items_names(i)) ) );
      end if;

    end loop;

    v_status := dbms_sql.execute(v_cursor);

    return dbms_sql.to_refcursor(v_cursor);  
  end getBindedRefCursor;

  --
  -- t_item_render_param_to_json
  --

  function t_item_render_param_to_json(
    p_param in apex_plugin.t_item_render_param
  ) return clob is 

    v_clob clob;
  begin
    apex_json.initialize_clob_output;
    apex_json.open_object;

    apex_json.write('value_set_by_controller', p_param.value_set_by_controller);
    apex_json.write('value', p_param.value);
    apex_json.write('is_readonly', p_param.is_readonly);
    apex_json.write('is_printer_friendly', p_param.is_printer_friendly );

    apex_json.close_object;

    v_clob := apex_json.get_clob_output;

    apex_json.free_output;

    return v_clob;
  end t_item_render_param_to_json;

  --
  -- t_plugin_to_json
  --

  function t_plugin_to_json(
    p_plugin in apex_plugin.t_plugin
  ) return clob is 
    v_clob clob;
  begin
    apex_json.initialize_clob_output;
    apex_json.open_object;

    apex_json.write('name', p_plugin.name);
    apex_json.write('file_prefix', p_plugin.file_prefix);
    apex_json.write('ajaxIdentifier', apex_plugin.get_ajax_identifier);
    apex_json.write('attribute_01', p_plugin.attribute_01);
    apex_json.write('attribute_02', p_plugin.attribute_02);
    apex_json.write('attribute_03', p_plugin.attribute_03);
    apex_json.write('attribute_04', p_plugin.attribute_04);
    apex_json.write('attribute_05', p_plugin.attribute_05);
    apex_json.write('attribute_06', p_plugin.attribute_06);
    apex_json.write('attribute_07', p_plugin.attribute_07);
    apex_json.write('attribute_08', p_plugin.attribute_08);
    apex_json.write('attribute_09', p_plugin.attribute_09);
    apex_json.write('attribute_10', p_plugin.attribute_10);
    apex_json.write('attribute_11', p_plugin.attribute_11);
    apex_json.write('attribute_12', p_plugin.attribute_12);
    apex_json.write('attribute_13', p_plugin.attribute_13);
    apex_json.write('attribute_14', p_plugin.attribute_14);
    apex_json.write('attribute_15', p_plugin.attribute_15);

    apex_json.close_object;

    v_clob := apex_json.get_clob_output;

    apex_json.free_output;

    return v_clob;
  end t_plugin_to_json;
  --
  -- t_page_item_to_json
  --
  function t_page_item_to_json(
    p_item in apex_plugin.t_item
  ) return clob
  is
    v_clob clob;
  begin

    apex_json.initialize_clob_output;
    apex_json.open_object;

    apex_json.write('id', p_item.id);
    apex_json.write('name', p_item.name);
    apex_json.write('label', p_item.label);
    apex_json.write('plain_label', p_item.plain_label);
    apex_json.write('label_id', p_item.label_id);
    apex_json.write('placeholder', p_item.placeholder);
    apex_json.write('format_mask', p_item.format_mask);
    apex_json.write('is_required', p_item.is_required);
    apex_json.write('lov_definition', p_item.lov_definition);
    apex_json.write('lov_display_extra', p_item.lov_display_extra);
    apex_json.write('lov_display_null', p_item.lov_display_null);
    apex_json.write('lov_null_text', p_item.lov_null_text);
    apex_json.write('lov_null_value', p_item.lov_null_value);
    apex_json.write('lov_cascade_parent_items', p_item.lov_cascade_parent_items);
    apex_json.write('ajax_items_to_submit', p_item.ajax_items_to_submit);
    apex_json.write('ajax_optimize_refresh', p_item.ajax_optimize_refresh);
    apex_json.write('element_width', p_item.element_width);
    apex_json.write('element_max_length', p_item.element_max_length);
    apex_json.write('element_height', p_item.element_height);
    apex_json.write('element_css_classes', p_item.element_css_classes);
    apex_json.write('element_attributes', p_item.element_attributes);
    apex_json.write('element_option_attributes', p_item.element_option_attributes);
    apex_json.write('escape_output', p_item.escape_output);
    apex_json.write('attribute_01', p_item.attribute_01);
    apex_json.write('attribute_02', p_item.attribute_02);
    apex_json.write('attribute_03', p_item.attribute_03);
    apex_json.write('attribute_04', p_item.attribute_04);
    apex_json.write('attribute_05', p_item.attribute_05);
    apex_json.write('attribute_06', p_item.attribute_06);
    apex_json.write('attribute_07', p_item.attribute_07);
    apex_json.write('attribute_08', p_item.attribute_08);
    apex_json.write('attribute_09', p_item.attribute_09);
    apex_json.write('attribute_10', p_item.attribute_10);
    apex_json.write('attribute_11', p_item.attribute_11);
    apex_json.write('attribute_12', p_item.attribute_12);
    apex_json.write('attribute_13', p_item.attribute_13);
    apex_json.write('attribute_14', p_item.attribute_14);
    apex_json.write('attribute_15', p_item.attribute_15);

    apex_json.close_object;

    v_clob := apex_json.get_clob_output;

    apex_json.free_output;

    return v_clob;
  end t_page_item_to_json;

  --
  -- function f_queryGetColumnType
  --
  function f_queryGetColumnType(
    p_col_type in number
  ) return varchar2 is 
    l_col_type varchar2(50);
  begin
    if p_col_type = 1 then
      l_col_type := 'VARCHAR2';

    elsif p_col_type = 2 then
      l_col_type := 'NUMBER';

    elsif p_col_type = 12 then
      l_col_type := 'DATE';

    elsif p_col_type in (180,181,231) then
      l_col_type := 'TIMESTAMP';

      if p_col_type = 231 then
          l_col_type := 'TIMESTAMP_LTZ';
      end if;

    elsif p_col_type = 112 then
      l_col_type := 'CLOB';

    elsif p_col_type = 113 then

      l_col_type := 'BLOB';

    elsif p_col_type = 96 then
      l_col_type := 'CHAR';

    else
        l_col_type := 'OTHER';
    end if;

    return l_col_type;

  end f_queryGetColumnType;

  --
  -- procedure p_queryDescribeColumns
  --
  procedure p_queryDescribeColumns(
    pi_sql              in  varchar2,
    po_columns_no       out number,
    po_columns_info_arr out sys.dbms_sql.desc_tab2
  ) 
  is
    v_apex_items_names  DBMS_SQL.VARCHAR2_TABLE := WWV_FLOW_UTILITIES.GET_BINDS( pi_sql );
    v_cursor            pls_integer;
    v_desc_col_no       number          := 0;
    v_desc_col_info     sys.dbms_sql.desc_tab2;  
    v_status            number;

  begin
    v_cursor := dbms_sql.open_cursor;

    dbms_sql.parse ( v_cursor, pi_sql, dbms_sql.native);

    --bind items
    for i in 1..v_apex_items_names.count loop
      dbms_sql.bind_variable (v_cursor, v_apex_items_names(i), v( trim(both ':' from v_apex_items_names(i)) ) );
    end loop;

    sys.dbms_sql.describe_columns2( v_cursor, v_desc_col_no, v_desc_col_info);

    v_status := dbms_sql.execute(v_cursor);

    po_columns_no       := v_desc_col_no;
    po_columns_info_arr := v_desc_col_info;

  end p_queryDescribeColumns;

  --
  -- function f_queryPrepareConditions
  --
  function f_queryPrepareConditions(
    pi_sql in varchar2
  ) return varchar2
  is
    v_desc_col_no   number          := 0;
    v_desc_col_info sys.dbms_sql.desc_tab2;  
    v_return        varchar2(32767);
  begin
    p_queryDescribeColumns(
      pi_sql              => pi_sql,
      po_columns_no       => v_desc_col_no,
      po_columns_info_arr => v_desc_col_info
    );

    if g_ajax_search_column_idx is not null then
      --search by specific column
      v_return := 'where upper('||v_desc_col_info(g_ajax_search_column_idx).col_name||') like upper(''%''||:SEARCH_STRING||''%'')';
    else
      --search by every column from query
      v_return := 'where ';

      for i in 1..v_desc_col_no loop
        v_return := v_return||' upper('||v_desc_col_info(i).col_name||') like upper(''%''||:SEARCH_STRING||''%'') or';
      end loop;

      v_return := rtrim(v_return, ' or');

    end if;

    return v_return;
  end f_queryPrepareConditions;

  --
  -- f_queryGetColumnsJson
  --

  function f_queryGetColumnsJson return clob is
    v_return        CLOB;
    v_desc_col_no   number          := 0;
    v_desc_col_info sys.dbms_sql.desc_tab2;  
  begin
    p_queryDescribeColumns(
      pi_sql              => prepareSqlQuery,
      po_columns_no       => v_desc_col_no,
      po_columns_info_arr => v_desc_col_info
    );

    apex_json.initialize_clob_output;
    apex_json.open_array;

    for i in 1..v_desc_col_no loop
      apex_json.open_object;
      apex_json.write('COLUMN_NAME', v_desc_col_info(i).col_name);
      apex_json.write('COLUMN_TYPE', f_queryGetColumnType( v_desc_col_info(i).col_type ) );
      apex_json.write('SHEMA_NAME', v_desc_col_info(i).col_schema_name, true );
      apex_json.write('IDX', i );

      apex_json.close_object;
    end loop;

    apex_json.close_array;

    v_return := apex_json.get_clob_output;

    apex_json.free_output;

    return v_return;
  end f_queryGetColumnsJson;

  --
  -- f_getDisplayValues
  --
  function f_getDisplayValues(
    pi_value in varchar2
  ) return varchar2
  is
    v_cursor sys_refcursor;
    v_result varchar2(32767);
    v_query  varchar2(32767);
  begin
    v_query := '
      select 
        listagg(d, '', '') within group( order by d asc )
      from (
        '||prepareSqlQuery||'
      ) 
      where
        r in ('||''''||replace(pi_value, ':', ''',''')||''''||')
    ';

    v_cursor := getBindedRefCursor( v_query );

    FETCH v_cursor INTO v_result;

    CLOSE v_cursor;

    return v_result;
  end f_getDisplayValues;

  --
  -- f_autocompleteGetDefaulsSearch
  --

  function f_autocompleteGetDefaulsSearch return varchar2
  is 
    v_attr_autocomplete_d_search  APEX_APPLICATION_PAGE_ITEMS.attribute_04%type := g_item.attribute_04;
    v_conditions                  varchar2(32767);
  begin

    if v_attr_autocomplete_d_search = 'D%' then
      v_conditions := v_conditions||' 
        and upper(d) like upper(:SEARCH_STRING||''%'') 
      ';
    end if;

    if v_attr_autocomplete_d_search = '%D' then
      v_conditions := v_conditions||' 
        and upper(d) like upper(''%''||:SEARCH_STRING) 
      ';
    end if;

    if v_attr_autocomplete_d_search = '%D%' then
      v_conditions := v_conditions||' 
        and upper(d) like upper(''%''||:SEARCH_STRING||''%'') 
      ';
    end if;

    if v_attr_autocomplete_d_search = 'D' then
      v_conditions := v_conditions||' 
        and upper(d) = upper(:SEARCH_STRING) 
      ';
    end if;

    if v_attr_autocomplete_d_search = 'R%' then
      v_conditions := v_conditions||' 
        and upper(r) like upper(:SEARCH_STRING||''%'') 
      ';
    end if;

    if v_attr_autocomplete_d_search = '%R' then
      v_conditions := v_conditions||' 
        and upper(r) like upper(''%''||:SEARCH_STRING) 
      ';
    end if;

    if v_attr_autocomplete_d_search = '%R%' then
      v_conditions := v_conditions||' 
        and upper(r) like upper(''%''||:SEARCH_STRING||''%'') 
      ';
    end if;

    if v_attr_autocomplete_d_search = 'R' then
      v_conditions := v_conditions||' 
        and upper(R) = upper(:SEARCH_STRING) 
      ';
    end if;

    if v_attr_autocomplete_d_search = 'DR%' then
      v_conditions := v_conditions||' 
        and (
          upper(r) like upper(:SEARCH_STRING||''%'')
          or upper(d) like upper(:SEARCH_STRING||''%'')
        )
      ';
    end if;

    if v_attr_autocomplete_d_search = '%DR' then
      v_conditions := v_conditions||' 
        and (
          upper(r) like upper(''%''||:SEARCH_STRING)
          or upper(d) like upper(''%''||:SEARCH_STRING)
        )
      ';
    end if;

    if v_attr_autocomplete_d_search = '%DR%' then
      v_conditions := v_conditions||' 
        and (
          upper(r) like upper(''%''||:SEARCH_STRING||''%'')
          or upper(d) like upper(''%''||:SEARCH_STRING||''%'')
        )
      ';
    end if;

    if v_attr_autocomplete_d_search = 'DR' then
      v_conditions := v_conditions||' 
        and (
          upper(r) = upper(:SEARCH_STRING)
          or upper(d) = upper(:SEARCH_STRING)
        )
      ';
    end if;  

    return v_conditions;
  end f_autocompleteGetDefaulsSearch;

  --
  -- function f_getRownumLimiterStart
  --
  function f_getRownumLimiterStart(
    p_page          in number,
    p_rows_per_page in number
  ) return number
  is
    v_start_rownum_with number;
    v_start_rownum      number;
  begin
    v_start_rownum_with := (p_page-1)*p_rows_per_page+1;

    if v_start_rownum_with = 0 then
      v_start_rownum := 1;
    else
      v_start_rownum := v_start_rownum_with;
    end if;

    return v_start_rownum;

  end f_getRownumLimiterStart;

  --
  -- f_popupGetCurrentPageDataCount
  --

  function f_popupGetCurrentPageDataCount(
    pi_where in varchar2
  ) return number 
  is
    v_cursor  sys_refcursor;
    v_result  number;
    v_query   varchar2(4000);
  begin
    v_cursor :=  getBindedRefCursor( 'select count(1) from ( '||prepareSqlQuery||' )'||pi_where );

    FETCH v_cursor INTO v_result;

    CLOSE v_cursor;

    return v_result;
  end f_popupGetCurrentPageDataCount;

  --
  -- f_queryRemoveOrderBy
  --
  function f_queryRemoveOrderBy(
    pi_sql_query in varchar2
  ) return varchar2 is
  begin
    return REGEXP_REPLACE(pi_sql_query, '(\s{0,})order(\s{1,})by(\s{1,})([^\sdecode])(.*)|(\s{1,})(order(\s{1,})by(\s{1,})decode\([^\)]*\))', '');
  end f_queryRemoveOrderBy;

  --
  -- p_ajax_getReturnValues
  --

  procedure p_ajax_getReturnValues is
    v_query      varchar2(32767) := g_item.lov_definition;
    v_where      varchar2(32767);
    v_ref_cursor sys_refcursor;
  begin

    if g_ajax_search_string is not null then
      v_where := f_queryPrepareConditions( v_query );
    end if;


    v_query := '
      select
        r
      from (
        '||v_query||'
      )
      '||v_where||'
    ';

    v_ref_cursor := getBindedRefCursor(v_query);

    apex_json.open_object;

    if g_debug then
      apex_json.write( 'query', v_query, true );
    end if;

    apex_json.write( 'searchString', g_ajax_search_string, true );
    apex_json.write( 'searchColumnIdx', g_ajax_search_column_idx, true );
    apex_json.write( 'data', v_ref_cursor );    

    apex_json.close_object;  

  end p_ajax_getReturnValues;

  --
  -- f_queryAutocomplete
  --
  function f_queryAutocomplete(
    pi_rownum_start in varchar2 default 0,
    pi_rownum_end   in varchar2 default 0
  ) return varchar2 is
    v_lov_query varchar2(32767);  
    v_query     varchar2(32767);

    v_attr_autocomplete_settings APEX_APPLICATION_PAGE_ITEMS.attribute_01%type := g_item.attribute_01;
    v_attr_autocomplete_search   APEX_APPLICATION_PAGE_ITEMS.attribute_02%type := g_item.attribute_02;

  begin
    v_lov_query := f_queryRemoveOrderBy( prepareSqlQuery );

    v_query := '
      select 
        * 
      from ( 
        '||v_lov_query||' 
      ) 
      where
        1=1
    ';

    if instr(v_attr_autocomplete_settings, 'UCSL') > 0 then
      --custom search
      v_query := v_query ||' '||v_attr_autocomplete_search||'';
    else
      --default search
      v_query := v_query ||f_autocompleteGetDefaulsSearch();
    end if;

    if pi_rownum_start = 0 and pi_rownum_end = 0 then
      return v_query;
    end if;

    return '
      select 
        *
      from (
        select 
          a.*, 
          rownum pretius_rnum
        from (
          /**/
          '||v_query||'
          /**/
        ) a
        where rownum < '||pi_rownum_end||'
      )
      where pretius_rnum >= '||pi_rownum_start||'
    ';
  end f_queryAutocomplete;



  --
  -- f_query_popupSelected
  --
  function f_query_popupSelected(
    pi_collection_name in varchar2,
    pi_query           in varchar2
  ) return varchar2 is
  begin
   return '
      select
        query.* 
      from 
        apex_collections
      join (
        '||pi_query||'
      ) query
      on
        c001 = r
      where
        collection_name = '''||pi_collection_name||'''
    ';
  end f_query_popupSelected;


  --
  -- p_ajax_getSessionState
  --    
  procedure p_ajax_getSessionState is
    v_selected_arr    APEX_APPLICATION_GLOBAL.VC_ARR2;
    v_collection_name APEX_COLLECTIONS.COLLECTION_NAME%TYPE := g_item.name||'_SHOWSELECTED';

    v_session_value   varchar2(4000) := v(g_item.name);
    v_query           varchar2(32767);

    v_ref_cursor      sys_refcursor;
  begin

    v_selected_arr := APEX_UTIL.STRING_TO_TABLE (
      p_string    => v_session_value,
      p_separator => ':'
    );

    APEX_COLLECTION.CREATE_OR_TRUNCATE_COLLECTION( v_collection_name );

    APEX_COLLECTION.ADD_MEMBERS(
      p_collection_name => v_collection_name,
      p_c001            => v_selected_arr
    );

    v_query := f_queryRemoveOrderBy( prepareSqlQuery );

    v_query := f_query_popupSelected(
      pi_collection_name => v_collection_name,
      pi_query           => v_query
    );

    open v_ref_cursor for v_query;

    apex_json.open_object;

    if g_debug then
      apex_json.write( 'query', v_query, true );
    end if;

    apex_json.write( 'request', g_ajax_mode, true );
    apex_json.write( 'data', v_ref_cursor );
    apex_json.write( 'session', v_session_value);

    apex_json.close_object;
  end p_ajax_getSessionState;

  --
  --  p_ajax_autocomplete
  --
  procedure p_ajax_autocomplete 
  is
    v_ref_cursor     sys_refcursor;
    v_ref_cursor_cnt sys_refcursor;

    v_rows_per_page number default to_number(v('APP_AJAX_X02'));
    v_page          number default to_number(v('APP_AJAX_X04'));
    v_start_rownum  number;
    v_end_rownum    number;

    v_query         varchar2(32767);
  begin

    v_start_rownum := f_getRownumLimiterStart(
      p_page => v_page,
      p_rows_per_page => v_rows_per_page
    );

    v_end_rownum := v_start_rownum + v_rows_per_page;

    v_query := f_queryAutocomplete(
      pi_rownum_start => v_start_rownum,
      pi_rownum_end   => v_end_rownum
    );

    v_ref_cursor := getBindedRefCursor(v_query);

    v_ref_cursor_cnt := getBindedRefCursor('select count(1) cnt from ('||f_queryAutocomplete||')');


    apex_json.open_object;

    if g_debug then
      apex_json.write( 'query', v_query, true );
    end if;

    apex_json.write( 'request',       g_ajax_mode, true );
    apex_json.write( 'searchString',  g_ajax_search_string, true );
    apex_json.write( 'rownumStart',   v_start_rownum, true );
    apex_json.write( 'rownumEnd',     v_end_rownum , true );
    apex_json.write( 'requestedPage', v_page , true );
    apex_json.write( 'rowsPerPage',   v_rows_per_page , true );
    apex_json.write( 'data',          v_ref_cursor );
    apex_json.write( 'dataVolume',    v_ref_cursor_cnt );


    apex_json.close_object;

  end p_ajax_autocomplete;  

  --
  -- p_ajax_popup_report
  --
  procedure p_ajax_popup_report is
    v_rows_per_page       number default to_number(v('APP_AJAX_X02'));
    v_page                number default to_number(v('APP_AJAX_X04'));
    v_sortColumnIdx       number default to_number(v('APP_AJAX_X05'));
    v_start_rownum        number;
    v_end_rownum          number;

    v_sortColumnDirection varchar2(4) default v('APP_AJAX_X06');
    v_query               varchar2(32767);
    v_order_by            varchar2(4000);
    v_where               varchar2(32767);
    e_msg                 varchar2(4000);

    v_ref_cursor          sys_refcursor;
    e_open_ref_cursor     exception;
  begin
    v_start_rownum := f_getRownumLimiterStart(
      p_page => v_page,
      p_rows_per_page => v_rows_per_page
    );

    v_end_rownum := v_start_rownum + v_rows_per_page -1;

    v_query := prepareSqlQuery;

    v_query := replace(v_query, chr(9), ' ');
    v_query := replace(v_query, chr(10)||chr(13), ' ');
    v_query := replace(v_query, chr(10), ' ');
    v_query := replace(v_query, chr(13), ' ');

    if  instr(v_query, '*/ disp, val from') = 0  then
      v_query := f_queryRemoveOrderBy( v_query );
    end if;

    if v_sortColumnIdx is not null then
      v_order_by := 'order by '||v_sortColumnIdx||' '||v_sortColumnDirection||'';
    end if;

    if g_ajax_search_string is not null then
      v_where := f_queryPrepareConditions( v_query );
    end if;

    v_query := '
      select 
        *
      from (
        select 
          a.*, 
          rownum pretius_rnum
        from (
          select
            *
          from (
            '||v_query||'
          )
          '||v_where||'
          '||v_order_by||'
        ) a
        where rownum <= '||v_end_rownum||'
      )
      where 
        pretius_rnum >= '||v_start_rownum||'
    ';

    v_ref_cursor := getBindedRefCursor(v_query);

    apex_json.open_object;

    if g_debug then
      apex_json.write( 'query', v_query, true );
    end if;

    apex_json.write( 'request', g_ajax_mode, true );
    apex_json.write( 'searchString', g_ajax_search_string, true );
    apex_json.write( 'rownumStart', v_start_rownum, true );
    apex_json.write( 'rownumEnd', v_end_rownum, true );
    apex_json.write( 'requestedPage', v_page, true );
    apex_json.write( 'rowsPerPage', v_rows_per_page, true );
    apex_json.write( 'sortByColumnIdx', v_sortColumnIdx, true );
    apex_json.write( 'sortByColumnDirection', v_sortColumnDirection, true );
    apex_json.write( 'searchColumnIdx', g_ajax_search_column_idx, true );
    apex_json.write( 'totalCount', f_popupGetCurrentPageDataCount( v_where ) );
    apex_json.write( 'data', v_ref_cursor );  

    apex_json.close_object;

  end p_ajax_popup_report;  

  --
  -- p_ajax_popup_selected
  --    
  procedure p_ajax_popup_selected is
    v_selected_arr    APEX_APPLICATION_GLOBAL.VC_ARR2 default APEX_APPLICATION.G_F01;
    v_collection_name APEX_COLLECTIONS.COLLECTION_NAME%TYPE := g_item.name||'_SHOWSELECTED';

    v_ref_cursor sys_refcursor;
    v_query      varchar2(32000);
  begin
    APEX_COLLECTION.CREATE_OR_TRUNCATE_COLLECTION( v_collection_name );

    APEX_COLLECTION.ADD_MEMBERS(
      p_collection_name => v_collection_name,
      p_c001 => v_selected_arr
    );

    v_query := f_queryRemoveOrderBy( prepareSqlQuery );

    v_query := f_query_popupSelected(
      pi_collection_name => v_collection_name,
      pi_query           => v_query
    );

    open v_ref_cursor for v_query;

    apex_json.open_object;

    if g_debug then
      apex_json.write( 'query', v_query, true );
    end if;

    apex_json.write( 'request', g_ajax_mode, true );
    apex_json.write( 'data', v_ref_cursor );  

    apex_json.close_object;

  end p_ajax_popup_selected;


  --
  -- procedure render
  --

  procedure render (
    p_item   in            apex_plugin.t_item,
    p_plugin in            apex_plugin.t_plugin,
    p_param  in            apex_plugin.t_item_render_param,
    p_result in out nocopy apex_plugin.t_item_render_result 
  ) is
    v_debug_prefix        varchar2(100)   := '# '||p_plugin.name;
    v_item_name           varchar2(4000)  := p_item.name;
    v_is_required         varchar2(8)     := case when p_item.is_required then 'required' else null end;
    v_item_value          varchar2(32767) := p_param.value;
    v_popup_default_icon  varchar2(50)    := 'fa-list-ul';
    v_item_name_attr      varchar2(32767);    
    v_item_attributes     clob;
    v_translations_ref    sys_refcursor;

    v_attr_autocomplete_settings   APEX_APPLICATION_PAGE_ITEMS.attribute_01%type := p_item.attribute_01;
    v_attr_autocomplete_search     APEX_APPLICATION_PAGE_ITEMS.attribute_02%type := p_item.attribute_02;
    v_attr_autocomplete_template   APEX_APPLICATION_PAGE_ITEMS.attribute_03%type := p_item.attribute_03;
    v_attr_autocomplete_d_search   APEX_APPLICATION_PAGE_ITEMS.attribute_04%type := p_item.attribute_04;
    v_attr_settings                APEX_APPLICATION_PAGE_ITEMS.attribute_05%type := p_item.attribute_05;
    v_attr_popup_settings          APEX_APPLICATION_PAGE_ITEMS.attribute_06%type := p_item.attribute_06;
    v_attr_popup_columns_settings  APEX_APPLICATION_PAGE_ITEMS.attribute_07%type := p_item.attribute_07;
    v_attr_autocomplete_tags_no    APEX_APPLICATION_PAGE_ITEMS.attribute_08%type := p_item.attribute_08;
    v_attr_autocomplete_min_length APEX_APPLICATION_PAGE_ITEMS.attribute_09%type := p_item.attribute_09;
    v_attr_popup_report_basic_conf APEX_APPLICATION_PAGE_ITEMS.attribute_10%type := p_item.attribute_10;
    v_attr_popup_title_text        APEX_APPLICATION_PAGE_ITEMS.attribute_11%type := p_item.attribute_11;
    v_attr_popup_width             APEX_APPLICATION_PAGE_ITEMS.attribute_12%type := p_item.attribute_12;
    v_attr_popup_height            APEX_APPLICATION_PAGE_ITEMS.attribute_13%type := p_item.attribute_13;
    v_attr_autocomplete_maxHeight  APEX_APPLICATION_PAGE_ITEMS.attribute_14%type := p_item.attribute_14;
    v_attr_autocomplete_rows2show  APEX_APPLICATION_PAGE_ITEMS.attribute_15%type := p_item.attribute_15;
    v_item_icon_class              APEX_APPLICATION_PAGE_ITEMS.ITEM_ICON_CSS_CLASSES%TYPE ;
    v_apex_version                 APEX_RELEASE.VERSION_NO%TYPE;    
  begin

    g_item := p_item;
    g_plugin := p_plugin;
    g_debug := case when v('DEBUG') = 'YES' then true else false end;

    SELECT 
      VERSION_NO 
    into
      v_apex_version
    FROM 
      APEX_RELEASE;

    v_item_name_attr := apex_plugin.get_input_name_for_page_item(
      p_is_multi_value => true
    );

    if g_debug then
      apex_javascript.add_onload_code (
        p_code => 'apex.debug.log("'||v_debug_prefix||'", "p_item", '||t_page_item_to_json(p_item)||');'
      );

      apex_javascript.add_onload_code (
        p_code => 'apex.debug.log("'||v_debug_prefix||'", "p_plugin", '||t_plugin_to_json(p_plugin)||');'
      );

      apex_javascript.add_onload_code (
        p_code => 'apex.debug.log("'||v_debug_prefix||'", "p_params", '||t_item_render_param_to_json(p_param)||');'
      );    
    end if;

    apex_plugin_util.print_hidden_if_readonly (
      p_item_name           => p_item.name,
      p_value               => v_item_value,
      p_is_readonly         => p_param.is_readonly,
      p_is_printer_friendly => p_param.is_printer_friendly
    );

    if p_param.is_printer_friendly or p_param.is_readonly then
      apex_plugin_util.print_display_only (
        p_item_name        => p_item.name,
        p_display_value    => f_getDisplayValues(v_item_value),
        p_show_line_breaks => false,
        p_escape           => p_item.escape_output,
        p_attributes       => p_item.element_attributes
      );
    else 
      htp.p(''                                        ||
        '<input'                                      ||
        ' type="text"'                                ||
        ' id="'||p_item.name||'"'                     ||
        ' name="'||v_item_name_attr||'"'              ||
        ' class="text_field apex-item-text '|| p_item.element_css_classes ||'"' ||
        ' maxlength="'||p_item.element_max_length||'"'||
        ' size="'||p_item.element_width||'"'          ||
        ' autocomplete="off"'                         ||
        ' placeholder="'||p_item.placeholder||'"'     ||
        ' value="'                                    ||
      '');


      APEX_PLUGIN_UTIL.PRINT_ESCAPED_VALUE(
        APEX_ESCAPE.HTML( v_item_value )
      );

      htp.p(''                                        ||
        '"'                                           || --closing of value attr
        ' data-return-value=""'                       ||
        ' '||v_is_required                            ||
        '>'                                           ||
      '');

      --fetch icon
      begin
        select 
          NVL(ITEM_ICON_CSS_CLASSES, v_popup_default_icon)
        into
          v_item_icon_class
        from 
          apex_application_page_items 
        where 
          application_id = g_app_id
          and page_id = g_page_id
          and item_name = p_item.name;
      exception
        when others then
          v_item_icon_class := v_popup_default_icon;
      end;

      apex_json.initialize_clob_output;
      apex_json.open_object;

      apex_json.write('autoCompleteSettings',             v_attr_autocomplete_settings,   true);
      apex_json.write('autoCompleteSettingsSearchLogic',  v_attr_autocomplete_search,     true);
      apex_json.write('autoCompleteSettingsTemplate',     v_attr_autocomplete_template,   true);
      apex_json.write('autoCompleteTagsNo',               v_attr_autocomplete_tags_no,    true);
      apex_json.write('autoCompleteMinInputLength',       v_attr_autocomplete_min_length, true);
      apex_json.write('autoCompleteMaxHeight',            v_attr_autocomplete_maxHeight,  true);
      apex_json.write('autoCompleteRows2Show',            v_attr_autocomplete_rows2show,  true);

      apex_json.write('settings',                         NVL(v_attr_settings, ''), true);
      apex_json.write('popupSettings',                    v_attr_popup_settings, true);
      apex_json.write('popupColumnSettings',              v_attr_popup_columns_settings, true);
      apex_json.write('popupReportBasicConf',             v_attr_popup_report_basic_conf, true);
      apex_json.write('popupTitleText',                   v_attr_popup_title_text, true);
      apex_json.write('popupWidth',                       v_attr_popup_width, true);
      apex_json.write('popupHeight',                      v_attr_popup_height, true);

      open v_translations_ref for
        select 
          TRANSLATABLE_MESSAGE,
          MESSAGE_TEXT
        from
          APEX_APPLICATION_TRANSLATIONS aat
        where
          APPLICATION_ID = g_app_id
          and LANGUAGE_CODE = (
            select APPLICATION_PRIMARY_LANGUAGE from APEX_APPLICATIONS where application_id = aat.application_id
          )
          and TRANSLATABLE_MESSAGE like 'PAELI%'
      ;

      apex_json.write('translations', v_translations_ref);

      apex_json.close_object;

      v_item_attributes := apex_json.get_clob_output;

      apex_json.free_output;

      apex_javascript.add_onload_code(''                                                                ||
        '$("#' ||v_item_name || '").enhancedLovItem({'                                                  ||
        '  "item":  $.extend('||t_page_item_to_json(p_item)||', {"icon": "'||v_item_icon_class||'"}),'  ||
        '  "param": '||  t_item_render_param_to_json(p_param)||','                                      ||
        '  "plugin": '|| t_plugin_to_json(p_plugin)          ||','                                      ||
        '  "columns": '||f_queryGetColumnsJson||','                                                   ||
        '  "attributes": '||v_item_attributes||','                                                      ||
        '  "apexVersion": "'||v_apex_version||'",'                                                      ||
        '  "debug": "'||v('DEBUG')||'" == "YES" ? true : false '                                        ||
        '});'                                                                                           ||
      '');

    end if;  

  end render;

  --
  -- procedure ajax
  --
  procedure ajax(
    p_item   in            apex_plugin.t_item,
    p_plugin in            apex_plugin.t_plugin,
    p_param  in            apex_plugin.t_item_ajax_param,
    p_result in out nocopy apex_plugin.t_item_ajax_result 
  ) is

    v_ajax_mode     varchar2(100)   default v('APP_AJAX_X01');
    v_search_string varchar2(4000)  default APEX_ESCAPE.HTML(v('APP_AJAX_X03'));
    v_search_column number          default v('APP_AJAX_X07');

  begin

    g_item      := p_item;
    g_plugin    := p_plugin;
    g_debug     := case when v('DEBUG') = 'YES' then true else false end;
    g_ajax_mode := v_ajax_mode;

    g_ajax_search_string := replace(v_search_string, '''', '''''');
    g_ajax_search_column_idx := v('APP_AJAX_X07');

    if g_ajax_mode = 'AUTOCOMPLETE' then
      p_ajax_autocomplete;
    elsif g_ajax_mode = 'POPUP' then
      p_ajax_popup_report;
    elsif g_ajax_mode = 'GETONLYSELECTED' then
      p_ajax_popup_selected;
    elsif g_ajax_mode = 'GETSESSIONSTATE' then
      p_ajax_getSessionState;
    elsif g_ajax_mode = 'DEBUG' then
      null;
    elsif g_ajax_mode = 'CASCADINGLOV' then
      apex_json.open_object;
      apex_json.write( 'request', g_ajax_mode, true );
      apex_json.close_object;  
    else
      p_ajax_getReturnValues;
    end if;

  end ajax;  
end;

/
--------------------------------------------------------
--  DDL for Package Body AS_PDF3_MOD
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."AS_PDF3_MOD" 
is
--
  type tHex is table of pls_integer index by VARCHAR2(2);

  lHex tHex;

  type tp_pls_tab is table of pls_integer index by pls_integer;
  type tp_objects_tab is table of number(10) index by pls_integer;
  type tp_pages_tab is table of blob index by pls_integer;
  type tp_settings is record
    ( page_width number
    , page_height number
    , margin_left number
    , margin_right number
    , margin_top number
    , margin_bottom number
    );
  type tp_settings_tab is table of tp_settings index by pls_integer;

  type tp_font is record
    ( standard boolean
    , family varchar2(100)
    , style varchar2(2)  -- N Normal
                         -- I Italic
                         -- B Bold
                         -- BI Bold Italic
    , subtype varchar2(15)
    , name varchar2(100)
    , fontname varchar2(100)
    , char_width_tab tp_pls_tab
    , encoding varchar2(100)    , charset varchar2(1000)
    , compress_font boolean := true
    , fontsize number
    , unit_norm number
    , bb_xmin pls_integer
    , bb_ymin pls_integer
    , bb_xmax pls_integer
    , bb_ymax pls_integer
    , flags pls_integer
    , first_char pls_integer
    , last_char pls_integer
    , italic_angle number
    , ascent pls_integer
    , descent pls_integer
    , capheight pls_integer
    , stemv pls_integer
    , diff varchar2(32767)
    , cid boolean := false
    , fontfile2 blob
    , ttf_offset pls_integer
    , used_chars tp_pls_tab
    , numGlyphs pls_integer
    , indexToLocFormat pls_integer
    , loca tp_pls_tab
    , code2glyph tp_pls_tab
    , hmetrics tp_pls_tab
    );
  type tp_font_tab is table of tp_font index by pls_integer;
  type tp_img is record
    ( adler32 varchar2(8)
    , width pls_integer
    , height pls_integer
    , color_res pls_integer
    , color_tab raw(768)
    , greyscale boolean
    , pixels blob
    , type varchar2(5)
    , nr_colors pls_integer
    , transparancy_index pls_integer
    );
  type tp_img_tab is table of tp_img index by pls_integer;
  type tp_info is record
    ( title varchar2(1024)
    , author varchar2(1024)
    , subject varchar2(1024)
    , keywords varchar2(32767)
    );
  type tp_page_prcs is table of clob index by pls_integer;
--
-- globals
  g_pdf_doc blob; -- the PDF-document being constructed
  g_objects tp_objects_tab;
  g_pages tp_pages_tab;
  g_settings_per_page tp_settings_tab;
  g_settings tp_settings;
  g_fonts tp_font_tab;
  g_used_fonts tp_pls_tab;
  g_current_font pls_integer;
  g_current_font_record tp_font;
  g_images tp_img_tab;
  g_x number;  -- current x-location of the "cursor"
  g_y number;  -- current y-location of the "cursor"
  g_info tp_info;
  g_page_nr pls_integer;
  g_page_prcs tp_page_prcs;
--
-- constants
  c_nl constant varchar2(2) := chr(13) || chr(10);
--
  function num2raw( p_value number )
  return raw
  is
  begin
    return hextoraw( to_char( p_value, 'FM0XXXXXXX' ) );
  end;
--
  function raw2num( p_value raw )
  return number
  is
  begin
    return to_number( rawtohex( p_value ), 'XXXXXXXX' );
  end;
--
  function raw2num( p_value raw, p_pos pls_integer, p_len pls_integer )
  return pls_integer
  is
  begin
    return to_number( rawtohex( utl_raw.substr( p_value, p_pos, p_len ) ), 'XXXXXXXX' );
  end;
--
  function to_short( p_val raw, p_factor number := 1 )
  return number
  is
    t_rv number;
  begin
    t_rv := to_number( rawtohex( p_val ), 'XXXXXXXXXX' );
    if t_rv > 32767
    then
      t_rv := t_rv - 65536;
    end if;
    return t_rv * p_factor;
  end;
--
  function blob2num( p_blob blob, p_len integer, p_pos integer )
  return number
  is
  begin
    return to_number( rawtohex( dbms_lob.substr( p_blob, p_len, p_pos ) ), 'xxxxxxxx' );
  end;
--
  function file2blob( p_dir varchar2, p_file_name varchar2 )
  return blob
  is
    t_raw raw(32767);
    t_blob blob;
    fh utl_file.file_type;
  begin
    fh := utl_file.fopen( p_dir, p_file_name, 'rb' );
    dbms_lob.createtemporary( t_blob, true );
    loop
      begin
        utl_file.get_raw( fh, t_raw );
        dbms_lob.append( t_blob, t_raw );
      exception
        when no_data_found
        then
          exit;
      end;
    end loop;
    utl_file.fclose( fh );
    return t_blob;
  exception
    when others
    then
      if utl_file.is_open( fh )
      then
        utl_file.fclose( fh );
      end if;
      raise;
  end;
--
  procedure init_core_fonts
  is
    function uncompress_withs( p_compressed_tab varchar2 )
    return tp_pls_tab
    is
      t_rv tp_pls_tab;
      t_tmp raw(32767);
    begin
      if p_compressed_tab is not null
      then
        t_tmp := utl_compress.lz_uncompress
          ( utl_encode.base64_decode( utl_raw.cast_to_raw( p_compressed_tab ) ) );
        for i in 0 .. 255
        loop
          t_rv( i ) := to_number( utl_raw.substr( t_tmp, i * 4 + 1, 4 ), '0xxxxxxx' );
        end loop;
      end if;
      return t_rv;
    end;
--
    procedure init_core_font
      ( p_ind pls_integer
      , p_family varchar2
      , p_style varchar2
      , p_name varchar2
      , p_compressed_tab varchar2
      )
    is
    begin
      g_fonts( p_ind ).family := p_family;
      g_fonts( p_ind ).style := p_style;
      g_fonts( p_ind ).name := p_name;
      g_fonts( p_ind ).fontname := p_name;
      g_fonts( p_ind ).standard := true;
      g_fonts( p_ind ).encoding := 'WE8MSWIN1252';
      g_fonts( p_ind ).charset := sys_context( 'userenv', 'LANGUAGE' );
      g_fonts( p_ind ).charset := substr( g_fonts( p_ind ).charset
                                        , 1
                                        , instr( g_fonts( p_ind ).charset, '.' )
                                        ) || g_fonts( p_ind ).encoding;
      g_fonts( p_ind ).char_width_tab := uncompress_withs( p_compressed_tab );
    end;
  begin
    init_core_font( 1, 'helvetica', 'N', 'Helvetica'
      ,  'H4sIAAAAAAAAC81Tuw3CMBC94FQMgMQOLAGVGzNCGtc0dAxAT+8lsgE7RKJFomOA'
      || 'SLT4frHjBEFJ8XSX87372C8A1Qr+Ax5gsWGYU7QBAK4x7gTnGLOS6xJPOd8w5NsM'
      || '2OvFvQidAP04j1nyN3F7iSNny3E6DylPeeqbNqvti31vMpfLZuzH86oPdwaeo6X+'
      || '5X6Oz5VHtTqJKfYRNVu6y0ZyG66rdcxzXJe+Q/KJ59kql+bTt5K6lKucXvxWeHKf'
      || '+p6Tfersfh7RHuXMZjHsdUkxBeWtM60gDjLTLoHeKsyDdu6m8VK3qhnUQAmca9BG'
      || 'Dq3nP+sV/4FcD6WOf9K/ne+hdav+DTuNLeYABAAA' );
--
    init_core_font( 2, 'helvetica', 'I', 'Helvetica-Oblique'
      ,  'H4sIAAAAAAAAC81Tuw3CMBC94FQMgMQOLAGVGzNCGtc0dAxAT+8lsgE7RKJFomOA'
      || 'SLT4frHjBEFJ8XSX87372C8A1Qr+Ax5gsWGYU7QBAK4x7gTnGLOS6xJPOd8w5NsM'
      || '2OvFvQidAP04j1nyN3F7iSNny3E6DylPeeqbNqvti31vMpfLZuzH86oPdwaeo6X+'
      || '5X6Oz5VHtTqJKfYRNVu6y0ZyG66rdcxzXJe+Q/KJ59kql+bTt5K6lKucXvxWeHKf'
      || '+p6Tfersfh7RHuXMZjHsdUkxBeWtM60gDjLTLoHeKsyDdu6m8VK3qhnUQAmca9BG'
      || 'Dq3nP+sV/4FcD6WOf9K/ne+hdav+DTuNLeYABAAA' );
--
    init_core_font( 3, 'helvetica', 'B', 'Helvetica-Bold'
      ,  'H4sIAAAAAAAAC8VSsRHCMAx0SJcBcgyRJaBKkxXSqKahYwB6+iyRTbhLSUdHRZUB'
      || 'sOWXLF8SKCn+ZL/0kizZuaJ2/0fn8XBu10SUF28n59wbvoCr51oTD61ofkHyhBwK'
      || '8rXusVaGAb4q3rXOBP4Qz+wfUpzo5FyO4MBr39IH+uLclFvmCTrz1mB5PpSD52N1'
      || 'DfqS988xptibWfbw9Sa/jytf+dz4PqQz6wi63uxxBpCXY7uUj88jNDNy1mYGdl97'
      || '856nt2f4WsOFed4SpzumNCvlT+jpmKC7WgH3PJn9DaZfA42vlgh96d+wkHy0/V95'
      || 'xyv8oj59QbvBN2I/iAuqEAAEAAA=' );
--
    init_core_font( 4, 'helvetica', 'BI', 'Helvetica-BoldOblique'
      ,  'H4sIAAAAAAAAC8VSsRHCMAx0SJcBcgyRJaBKkxXSqKahYwB6+iyRTbhLSUdHRZUB'
      || 'sOWXLF8SKCn+ZL/0kizZuaJ2/0fn8XBu10SUF28n59wbvoCr51oTD61ofkHyhBwK'
      || '8rXusVaGAb4q3rXOBP4Qz+wfUpzo5FyO4MBr39IH+uLclFvmCTrz1mB5PpSD52N1'
      || 'DfqS988xptibWfbw9Sa/jytf+dz4PqQz6wi63uxxBpCXY7uUj88jNDNy1mYGdl97'
      || '856nt2f4WsOFed4SpzumNCvlT+jpmKC7WgH3PJn9DaZfA42vlgh96d+wkHy0/V95'
      || 'xyv8oj59QbvBN2I/iAuqEAAEAAA=' );
--
    init_core_font( 5, 'times', 'N', 'Times-Roman'
      ,  'H4sIAAAAAAAAC8WSKxLCQAyG+3Bopo4bVHbwHGCvUNNT9AB4JEwvgUBimUF3wCNR'
      || 'qAoGRZL9twlQikR8kzTvZBtF0SP6O7Ej1kTnSRfEhHw7+Jy3J4XGi8w05yeZh2sE'
      || '4j312ZDeEg1gvSJy6C36L9WX1urr4xrolfrSrYmrUCeDPGMu5+cQ3Ur3OXvQ+TYf'
      || '+2FGexOZvTM1L3S3o5fJjGQJX2n68U2ur3X5m3cTvfbxsk9pcsMee60rdTjnhNkc'
      || 'Zip9HOv9+7/tI3Oif3InOdV/oLdx3gq2HIRaB1Ob7XPk35QwwxDyxg3e09Dv6nSf'
      || 'rxQjvty8ywDce9CXvdF9R+4y4o+7J1P/I9sABAAA' );
--
    init_core_font( 6, 'times', 'I', 'Times-Italic'
      ,  'H4sIAAAAAAAAC8WSPQ6CQBCFF+i01NB5g63tPcBegYZTeAB6SxNLjLUH4BTEeAYr'
      || 'Kwpj5ezsW2YgoKXFl2Hnb9+wY4x5m7+TOOJMdIFsRywodkfMBX9aSz7bXGp+gj6+'
      || 'R4TvOtJ3CU5Eq85tgGsbxG3QN8iFZY1WzpxXwkckFTR7e1G6osZGWT1bDuBnTeP5'
      || 'KtW/E71c0yB2IFbBphuyBXIL9Y/9fPvhf8se6vsa8nmeQtU6NSf6ch9fc8P9DpqK'
      || 'cPa5/I7VxDwruTN9kV3LDvQ+h1m8z4I4x9LIbnn/Fv6nwOdyGq+d33jk7/cxztyq'
      || 'XRhTz/it7Mscg7fT5CO+9ahnYk20Hww5IrwABAAA' );
--
    init_core_font( 7, 'times', 'B', 'Times-Bold'
      , 'H4sIAAAAAAAAC8VSuw3CQAy9XBqUAVKxAZkgHQUNEiukySxpqOjTMQEDZIrUDICE'
      || 'RHUVVfy9c0IQJcWTfbafv+ece7u/Izs553cgAyN/APagl+wjgN3XKZ5kmTg/IXkw'
      || 'h4JqXUEfAb1I1VvwFYysk9iCffmN4+gtccSr5nlwDpuTepCZ/MH0FZibDUnO7MoR'
      || 'HXdDuvgjpzNxgevG+dF/hr3dWfoNyEZ8Taqn+7d7ozmqpGM8zdMYruFrXopVjvY2'
      || 'in9gXe+5vBf1KfX9E6TOVBsb8i5iqwQyv9+a3Gg/Cv+VoDtaQ7xdPwfNYRDji09g'
      || 'X/FvLNGmO62B9jSsoFwgfM+jf1z/SPwrkTMBOkCTBQAEAAA=' );
--
    init_core_font( 8, 'times', 'BI', 'Times-BoldItalic'
      ,  'H4sIAAAAAAAAC8WSuw2DMBCGHegYwEuECajIAGwQ0TBFBnCfPktkAKagzgCRIqWi'
      || 'oso9fr+Qo5RB+nT2ve+wMWYzf+fgjKmOJFelPhENnS0xANJXHfwHSBtjfoI8nMMj'
      || 'tXo63xKW/Cx9ONRn3US6C/wWvYeYNr+LH2IY6cHGPkJfvsc5kX7mFjF+Vqs9iT6d'
      || 'zwEL26y1Qz62nWlvD5VSf4R9zPuon/ne+C45+XxXf5lnTGLTOZCXPx8v9Qfdjdid'
      || '5vD/f/+/pE/Ur14kG+xjTHRc84pZWsC2Hjk2+Hgbx78j4Z8W4DlL+rBnEN5Bie6L'
      || 'fsL+1u/InuYCdsdaeAs+RxftKfGdfQDlDF/kAAQAAA==' );
--
    init_core_font( 9, 'courier', 'N', 'Courier', null );
    for i in 0 .. 255
    loop
      g_fonts( 9 ).char_width_tab( i ) := 600;
    end loop;
--
    init_core_font( 10, 'courier', 'I', 'Courier-Oblique', null );
    g_fonts( 10 ).char_width_tab := g_fonts( 9 ).char_width_tab;
--
    init_core_font( 11, 'courier', 'B', 'Courier-Bold', null );
    g_fonts( 11 ).char_width_tab := g_fonts( 9 ).char_width_tab;
--
    init_core_font( 12, 'courier', 'BI', 'Courier-BoldOblique', null );
    g_fonts( 12 ).char_width_tab := g_fonts( 9 ).char_width_tab;
--
    init_core_font( 13, 'symbol', 'N', 'Symbol'
      ,  'H4sIAAAAAAAAC82SIU8DQRCFZ28xIE+cqcbha4tENKk/gQCJJ6AweIK9H1CHqKnp'
      || 'D2gTFBaDIcFwCQkJSTG83fem7SU0qYNLvry5nZ25t7NnZkv7c8LQrFhAP6GHZvEY'
      || 'HOB9ylxGubTfNVRc34mKpFonzBQ/gUZ6Ds7AN6i5lv1dKv8Ab1eKQYSV4hUcgZFq'
      || 'J/Sec7fQHtdTn3iqfvdrb7m3e2pZW+xDG3oIJ/Li3gfMr949rlU74DyT1/AuTX1f'
      || 'YGhOzTP8B0/RggsEX/I03vgXPrrslZjfM8/pGu40t2ZjHgud97F7337mXP/GO4h9'
      || '3WmPPaOJ/jrOs9yC52MlrtUzfWupfTX51X/L+13Vl/J/s4W2S3pSfSh5DmeXerMf'
      || '+LXhWQAEAAA=' );
--
    init_core_font( 14, 'zapfdingbats', 'N', 'ZapfDingbats'
      ,  'H4sIAAAAAAAAC83ROy9EQRjG8TkzjdJl163SSHR0EpdsVkSi2UahFhUljUKUIgoq'
      || 'CrvJCtFQyG6EbSSERGxhC0ofQAQFxbIi8T/7PoUPIOEkvzxzzsycdy7O/fUTtToX'
      || 'bnCuvHPOV8gk4r423ovkGQ5od5OTWMeesmBz/RuZIWv4wCAY4z/xjipeqflC9qAD'
      || 'aRwxrxkJievSFzrRh36tZ1zttL6nkGX+A27xrLnttE/IBji9x7UvcIl9nPJ9AL36'
      || 'd1L9hyihoDW10L62cwhNyhntryZVExYl3kMj+zym+CrJv6M8VozPmfr5L8uwJORL'
      || 'tox7NFHG/Obj79FlwhqZ1X292xn6CbAXP/fjjv6rJYyBtUdl1vxEO6fcRB7bMmJ3'
      || 'GYZsTN0GdrDL/Ao5j1GZNr5kwqydX5z1syoiYEq5gCtlSrXi+mVbi3PfVAuhoQAE'
      || 'AAA=' );
--
  end;
--
  function to_char_round
    ( p_value number
    , p_precision pls_integer := 2
    )
  return varchar2
  is
  begin
    return to_char( round( p_value, p_precision ), 'TM9', 'NLS_NUMERIC_CHARACTERS=.,' );
  end;
--
  procedure raw2pdfdoc( p_raw blob )
  is
  begin
    dbms_lob.append( g_pdf_doc, p_raw );
  end;
--
  procedure txt2pdfdoc( p_txt varchar2 )
  is
  begin
    raw2pdfdoc( utl_raw.cast_to_raw( p_txt || c_nl ) );
  end;
--
  function add_object( p_txt varchar2 := null )
  return number
  is
    t_self number(10);
  begin
    t_self := g_objects.count( );
    g_objects( t_self ) := dbms_lob.getlength( g_pdf_doc );
--
    if p_txt is null
    then
      txt2pdfdoc( t_self || ' 0 obj' );
    else
      txt2pdfdoc( t_self || ' 0 obj' || c_nl || '<<' || p_txt || '>>' || c_nl || 'endobj' );
    end if;
--
    return t_self;
  end;
--
  procedure add_object( p_txt varchar2 := null )
  is
    t_dummy number(10) := add_object( p_txt );
  begin
    null;
  end;
--
  function adler32( p_src in blob )
  return varchar2
  is
    s1 pls_integer := 1;
    s2 pls_integer := 0;
    n  pls_integer;
    step_size number;
    tmp varchar2(32766);
    c65521 constant pls_integer := 65521;
  begin
    step_size := trunc( 16383 / dbms_lob.getchunksize( p_src ) ) * dbms_lob.getchunksize( p_src );
    -- AW Bugfix for Chunksizes > 16383
    if step_size=0 then
      step_size:=16383;
    end if;
    for j in 0 .. trunc( ( dbms_lob.getlength( p_src ) - 1 ) / step_size )
    loop
      tmp := rawtohex( dbms_lob.substr( p_src, step_size, j * step_size + 1 ) );
      for i in 1 .. length( tmp ) / 2
      loop
        n:=lHex(substr( tmp, i * 2 - 1, 2 ));--n := to_number( substr( tmp, i * 2 - 1, 2 ), 'xx' );
        s1 := s1 + n;
        if s1 >= c65521
        then
          s1 := s1 - c65521;
        end if;
        s2 := s2 + s1;
        if s2 >= c65521
        then
          s2 := s2 - c65521;
        end if;
      end loop;
    end loop;
    return to_char( s2, 'fm0XXX' ) || to_char( s1, 'fm0XXX' );
  end;
--
  function flate_encode( p_val blob )
  return blob
  is
    t_blob blob;
  begin
    t_blob := hextoraw( '789C' );
    dbms_lob.copy( t_blob
                 , utl_compress.lz_compress( p_val )
                 , dbms_lob.lobmaxsize
                 , 3
                 , 11
                 );
    dbms_lob.trim( t_blob, dbms_lob.getlength( t_blob ) - 8 );
    dbms_lob.append( t_blob, hextoraw( adler32( p_val ) ) );
    return t_blob;
  end;
--
  procedure put_stream
    ( p_stream blob
    , p_compress boolean := true
    , p_extra varchar2 := ''
    , p_tag boolean := true
    )
  is
    t_blob blob;
    t_compress boolean := false;
  begin
    if p_compress and nvl( dbms_lob.getlength( p_stream ), 0 ) > 0
    then
      t_compress := true;
      t_blob := flate_encode( p_stream );
    else
      t_blob := p_stream;
    end if;
    txt2pdfdoc( case when p_tag then '<<' end
                || case when t_compress then '/Filter /FlateDecode ' end
                || '/Length ' || nvl( length( t_blob ), 0 )
                || p_extra
                || '>>' );
    txt2pdfdoc( 'stream' );
    raw2pdfdoc( t_blob );
    txt2pdfdoc( 'endstream' );
    if dbms_lob.istemporary( t_blob ) = 1
    then
      dbms_lob.freetemporary( t_blob );
    end if;
  end;
--
  function add_stream
    ( p_stream blob
    , p_extra varchar2 := ''
    , p_compress boolean := true
    )
  return number
  is
    t_self number(10);
  begin
    t_self := add_object;
    put_stream( p_stream
              , p_compress
              , p_extra
              );
    txt2pdfdoc( 'endobj' );
    return t_self;
  end;
--
  function subset_font( p_index pls_integer )
  return blob
  is
    t_tmp blob;
    t_header blob;
    t_tables blob;
    t_len pls_integer;
    t_code pls_integer;
    t_glyph pls_integer;
    t_offset pls_integer;
    t_factor pls_integer;
    t_unicode pls_integer;
    t_used_glyphs tp_pls_tab;
    t_fmt varchar2(10);
    t_utf16_charset varchar2(1000);
    t_raw raw(32767);
    t_v varchar2(32767);
    t_table_records raw(32767);
  begin
    if g_fonts( p_index ).cid
    then
      t_used_glyphs := g_fonts( p_index ).used_chars;
      t_used_glyphs( 0 ) := 0;
    else
      t_utf16_charset := substr( g_fonts( p_index ).charset, 1, instr( g_fonts( p_index ).charset, '.' ) ) || 'AL16UTF16';
      t_used_glyphs( 0 ) := 0;
      t_code := g_fonts( p_index ).used_chars.first;
      while t_code is not null
      loop
        t_unicode := to_number( rawtohex( utl_raw.convert( hextoraw( to_char( t_code, 'fm0x' ) )
                                                                    , t_utf16_charset
                                                                    , g_fonts( p_index ).charset  -- ???? database characterset ?????
                                                                    )
                                        ), 'XXXXXXXX' );
        if g_fonts( p_index ).flags = 4 -- a symbolic font
        then
-- assume code 32, space maps to the first code from the font
          t_used_glyphs( g_fonts( p_index ).code2glyph( g_fonts( p_index ).code2glyph.first + t_unicode - 32 ) ) := 0;
        else
          t_used_glyphs( g_fonts( p_index ).code2glyph( t_unicode ) ) := 0;
        end if;
        t_code := g_fonts( p_index ).used_chars.next( t_code );
      end loop;
    end if;
--
    dbms_lob.createtemporary( t_tables, true );
    t_header := utl_raw.concat( hextoraw( '00010000' )
                              , dbms_lob.substr( g_fonts( p_index ).fontfile2, 8, g_fonts( p_index ).ttf_offset + 4 )
                              );
    t_offset := 12 + blob2num( g_fonts( p_index ).fontfile2, 2, g_fonts( p_index ).ttf_offset + 4 ) * 16;
    t_table_records := dbms_lob.substr( g_fonts( p_index ).fontfile2
                                      , blob2num( g_fonts( p_index ).fontfile2, 2, g_fonts( p_index ).ttf_offset + 4 ) * 16
                                      , g_fonts( p_index ).ttf_offset + 12
                                      );
    for i in 1 .. blob2num( g_fonts( p_index ).fontfile2, 2, g_fonts( p_index ).ttf_offset + 4 )
    loop
      case utl_raw.cast_to_varchar2( utl_raw.substr( t_table_records, i * 16 - 15, 4 ) )
        when 'post'
        then
          dbms_lob.append( t_header
                         , utl_raw.concat( utl_raw.substr( t_table_records, i * 16 - 15, 4 ) -- tag
                                         , hextoraw( '00000000' ) -- checksum
                                         , num2raw( t_offset + dbms_lob.getlength( t_tables ) ) -- offset
                                         , num2raw( 32 ) -- length
                                         )
                         );
          dbms_lob.append( t_tables
                         , utl_raw.concat( hextoraw( '00030000' )
                                         , dbms_lob.substr( g_fonts( p_index ).fontfile2
                                                          , 28
                                                          , raw2num( t_table_records, i * 16 - 7, 4 ) + 5
                                                          )
                                         )
                         );
        when 'loca'
        then
          if g_fonts( p_index ).indexToLocFormat = 0
          then
            t_fmt := 'fm0XXX';
          else
            t_fmt := 'fm0XXXXXXX';
          end if;
          t_raw := null;
          dbms_lob.createtemporary( t_tmp, true );
          t_len := 0;
          for g in 0 .. g_fonts( p_index ).numGlyphs - 1
          loop
            t_raw := utl_raw.concat( t_raw, hextoraw( to_char( t_len, t_fmt ) ) );
            if utl_raw.length( t_raw ) > 32770
            then
              dbms_lob.append( t_tmp, t_raw );
              t_raw := null;
            end if;
            if t_used_glyphs.exists( g )
            then
              t_len := t_len + g_fonts( p_index ).loca( g + 1 ) - g_fonts( p_index ).loca( g );
            end if;
          end loop;
          t_raw := utl_raw.concat( t_raw, hextoraw( to_char( t_len, t_fmt ) ) );
          dbms_lob.append( t_tmp, t_raw );
          dbms_lob.append( t_header
                         , utl_raw.concat( utl_raw.substr( t_table_records, i * 16 - 15, 4 ) -- tag
                                         , hextoraw( '00000000' ) -- checksum
                                         , num2raw( t_offset + dbms_lob.getlength( t_tables ) ) -- offset
                                         , num2raw( dbms_lob.getlength( t_tmp ) ) -- length
                                         )
                         );
          dbms_lob.append( t_tables, t_tmp );
          dbms_lob.freetemporary( t_tmp );
        when 'glyf'
        then
          if g_fonts( p_index ).indexToLocFormat = 0
          then
            t_factor := 2;
          else
            t_factor := 1;
          end if;
          t_raw := null;
          dbms_lob.createtemporary( t_tmp, true );
          for g in 0 .. g_fonts( p_index ).numGlyphs - 1
          loop
            if (   t_used_glyphs.exists( g )
               and g_fonts( p_index ).loca( g + 1 ) > g_fonts( p_index ).loca( g )
               )
            then
              t_raw := utl_raw.concat( t_raw
                                     , dbms_lob.substr( g_fonts( p_index ).fontfile2
                                                      , ( g_fonts( p_index ).loca( g + 1 ) - g_fonts( p_index ).loca( g ) ) * t_factor
                                                      , g_fonts( p_index ).loca( g ) * t_factor + raw2num( t_table_records, i * 16 - 7, 4 ) + 1
                                                      )
                                     );
              if utl_raw.length( t_raw ) > 32000
              then
                dbms_lob.append( t_tmp, t_raw );
                t_raw := null;
              end if;
            end if;
          end loop;
          if utl_raw.length( t_raw ) > 0
          then
            dbms_lob.append( t_tmp, t_raw );
          end if;
          dbms_lob.append( t_header
                         , utl_raw.concat( utl_raw.substr( t_table_records, i * 16 - 15, 4 ) -- tag
                                         , hextoraw( '00000000' ) -- checksum
                                         , num2raw( t_offset + dbms_lob.getlength( t_tables ) ) -- offset
                                         , num2raw( dbms_lob.getlength( t_tmp ) ) -- length
                                         )
                         );
          dbms_lob.append( t_tables, t_tmp );
          dbms_lob.freetemporary( t_tmp );
        else
          dbms_lob.append( t_header
                         , utl_raw.concat( utl_raw.substr( t_table_records, i * 16 - 15, 4 )    -- tag
                                         , utl_raw.substr( t_table_records, i * 16 - 11, 4 )    -- checksum
                                         , num2raw( t_offset + dbms_lob.getlength( t_tables ) ) -- offset
                                         , utl_raw.substr( t_table_records, i * 16 - 3, 4 )     -- length
                                         )
                         );
          dbms_lob.copy( t_tables
                       , g_fonts( p_index ).fontfile2
                       , raw2num( t_table_records, i * 16 - 3, 4 )
                       , dbms_lob.getlength( t_tables ) + 1
                       , raw2num( t_table_records, i * 16 - 7, 4 ) + 1
                       );
      end case;
    end loop;
    dbms_lob.append( t_header, t_tables );
    dbms_lob.freetemporary( t_tables );
    return t_header;
  end;
--
  function add_font( p_index pls_integer )
  return number
  is
    t_self number(10);
    t_fontfile number(10);
    t_font_subset blob;
    t_used pls_integer;
    t_used_glyphs tp_pls_tab;
    t_w varchar2(32767);
    t_unicode pls_integer;
    t_utf16_charset varchar2(1000);
    t_width number;
  begin
    if g_fonts( p_index ).standard
    then
      return add_object( '/Type/Font'
                       || '/Subtype/Type1'
                       || '/BaseFont/' || g_fonts( p_index ).name
                       || '/Encoding/WinAnsiEncoding' -- code page 1252
                       );
    end if;
--
    if g_fonts( p_index ).cid
    then
      t_self := add_object;
      txt2pdfdoc( '<</Type/Font/Subtype/Type0/Encoding/Identity-H'
                || '/BaseFont/' || g_fonts( p_index ).name
                || '/DescendantFonts ' || to_char( t_self + 1 ) || ' 0 R'
                || '/ToUnicode ' || to_char( t_self + 8 ) || ' 0 R'
                || '>>' );
      txt2pdfdoc( 'endobj' );
      add_object;
      txt2pdfdoc( '[' || to_char( t_self + 2 ) || ' 0 R]' );
      txt2pdfdoc( 'endobj' );
      add_object( '/Type/Font/Subtype/CIDFontType2/CIDToGIDMap/Identity/DW 1000'
                || '/BaseFont/' || g_fonts( p_index ).name
                || '/CIDSystemInfo ' || to_char( t_self + 3 ) || ' 0 R'
                || '/W ' || to_char( t_self + 4 ) || ' 0 R'
                || '/FontDescriptor ' || to_char( t_self + 5 ) || ' 0 R' );
      add_object( '/Ordering(Identity) /Registry(Adobe) /Supplement 0' );
--
      t_utf16_charset := substr( g_fonts( p_index ).charset, 1, instr( g_fonts( p_index ).charset, '.' ) ) || 'AL16UTF16';
      t_used_glyphs := g_fonts( p_index ).used_chars;
      t_used_glyphs( 0 ) := 0;
      t_used := t_used_glyphs.first();
      while t_used is not null
      loop
        if g_fonts( p_index ).hmetrics.exists( t_used )
        then
          t_width := g_fonts( p_index ).hmetrics( t_used );
        else
          t_width := g_fonts( p_index ).hmetrics( g_fonts( p_index ).hmetrics.last() );
        end if;
        t_width := trunc( t_width * g_fonts( p_index ).unit_norm );
        if t_used_glyphs.prior( t_used ) = t_used - 1
        then
          t_w := t_w || ' ' || t_width;
        else
          t_w := t_w || '] ' || t_used || ' [' || t_width;
        end if;
        t_used := t_used_glyphs.next( t_used );
      end loop;
      t_w := '[' || ltrim( t_w, '] ' ) || ']]';
      add_object;
      txt2pdfdoc( t_w );
      txt2pdfdoc( 'endobj' );
      add_object
        (    '/Type/FontDescriptor'
          || '/FontName/' || g_fonts( p_index ).name
          || '/Flags ' || g_fonts( p_index ).flags
          || '/FontBBox [' || g_fonts( p_index ).bb_xmin
          || ' ' || g_fonts( p_index ).bb_ymin
          || ' ' || g_fonts( p_index ).bb_xmax
          || ' ' || g_fonts( p_index ).bb_ymax
          || ']'
          || '/ItalicAngle ' || to_char_round( g_fonts( p_index ).italic_angle )
          || '/Ascent ' || g_fonts( p_index ).ascent
          || '/Descent ' || g_fonts( p_index ).descent
          || '/CapHeight ' || g_fonts( p_index ).capheight
          || '/StemV ' || g_fonts( p_index ).stemv
          || '/FontFile2 ' || to_char( t_self + 6 ) || ' 0 R' );
      t_fontfile := add_stream( g_fonts( p_index ).fontfile2
                              , '/Length1 ' || dbms_lob.getlength( g_fonts( p_index ).fontfile2 )
                              , g_fonts( p_index ).compress_font
                              );
      t_font_subset := subset_font( p_index );
      t_fontfile := add_stream( t_font_subset
                              , '/Length1 ' || dbms_lob.getlength( t_font_subset )
                              , g_fonts( p_index ).compress_font
                              );
      declare
        t_g2c tp_pls_tab;
        t_code     pls_integer;
        t_c_start  pls_integer;
        t_map varchar2(32767);
        t_cmap varchar2(32767);
        t_cor pls_integer;
        t_cnt pls_integer;
      begin
        t_code := g_fonts( p_index ).code2glyph.first;
        if g_fonts( p_index ).flags = 4 -- a symbolic font
        then
-- assume code 32, space maps to the first code from the font
          t_cor := t_code - 32;
        else
          t_cor := 0;
        end if;
        while t_code is not null
        loop
          t_g2c( g_fonts( p_index ).code2glyph( t_code ) ) := t_code - t_cor;
          t_code := g_fonts( p_index ).code2glyph.next( t_code );
        end loop;
        t_cnt := 0;
        t_used_glyphs := g_fonts( p_index ).used_chars;
        t_used := t_used_glyphs.first();
        while t_used is not null
        loop
          t_map := t_map || '<' || to_char( t_used, 'FM0XXX' )
                 || '> <' || to_char( t_g2c( t_used ), 'FM0XXX' )
                 || '>' || chr( 10 );
          if t_cnt = 99
          then
            t_cnt := 0;
            t_cmap := t_cmap || chr( 10 ) || '100 beginbfchar' || chr( 10 ) || t_map || 'endbfchar';
            t_map := '';
          else
            t_cnt := t_cnt + 1;
          end if;
          t_used := t_used_glyphs.next( t_used );
        end loop;
        if t_cnt > 0
        then
          t_cmap := t_cnt || ' beginbfchar' || chr( 10 ) || t_map || 'endbfchar';
        end if;
        t_fontfile := add_stream( utl_raw.cast_to_raw(
'/CIDInit /ProcSet findresource begin 12 dict begin
begincmap
/CIDSystemInfo
<< /Registry (Adobe) /Ordering (UCS) /Supplement 0 >> def
/CMapName /Adobe-Identity-UCS def /CMapType 2 def
1 begincodespacerange
<0000> <FFFF>
endcodespacerange
' || t_cmap || '
endcmap
CMapName currentdict /CMap defineresource pop
end
end' ) );
      end;
      return t_self;
    end if;
--
    g_fonts( p_index ).first_char := g_fonts( p_index ).used_chars.first();
    g_fonts( p_index ).last_char := g_fonts( p_index ).used_chars.last();
    t_self := add_object;
    txt2pdfdoc( '<</Type /Font '
              || '/Subtype /' || g_fonts( p_index ).subtype
              || ' /BaseFont /' || g_fonts( p_index ).name
              || ' /FirstChar ' || g_fonts( p_index ).first_char
              || ' /LastChar ' || g_fonts( p_index ).last_char
              || ' /Widths ' || to_char( t_self + 1 ) || ' 0 R'
              || ' /FontDescriptor ' || to_char( t_self + 2 ) || ' 0 R'
              || ' /Encoding ' || to_char( t_self + 3 ) || ' 0 R'
              || ' >>' );
    txt2pdfdoc( 'endobj' );
    add_object;
    txt2pdfdoc( '[' );
      begin
        for i in g_fonts( p_index ).first_char .. g_fonts( p_index ).last_char
        loop
          txt2pdfdoc( g_fonts( p_index ).char_width_tab( i ) );
        end loop;
      exception
        when others
        then
          dbms_output.put_line( '**** ' || g_fonts( p_index ).name );
      end;
      txt2pdfdoc( ']' );
      txt2pdfdoc( 'endobj' );
      add_object
        (    '/Type /FontDescriptor'
          || ' /FontName /' || g_fonts( p_index ).name
          || ' /Flags ' || g_fonts( p_index ).flags
          || ' /FontBBox [' || g_fonts( p_index ).bb_xmin
          || ' ' || g_fonts( p_index ).bb_ymin
          || ' ' || g_fonts( p_index ).bb_xmax
          || ' ' || g_fonts( p_index ).bb_ymax
          || ']'
          || ' /ItalicAngle ' || to_char_round( g_fonts( p_index ).italic_angle )
          || ' /Ascent ' || g_fonts( p_index ).ascent
          || ' /Descent ' || g_fonts( p_index ).descent
          || ' /CapHeight ' || g_fonts( p_index ).capheight
          || ' /StemV ' || g_fonts( p_index ).stemv
          || case
               when g_fonts( p_index ).fontfile2 is not null
                 then ' /FontFile2 ' || to_char( t_self + 4 ) || ' 0 R'
             end );
      add_object(    '/Type /Encoding /BaseEncoding /WinAnsiEncoding '
                         || g_fonts( p_index ).diff
                         || ' ' );
      if g_fonts( p_index ).fontfile2 is not null
      then
        t_font_subset := subset_font( p_index );
        t_fontfile :=
          add_stream( t_font_subset
                    , '/Length1 ' || dbms_lob.getlength( t_font_subset )
                    , g_fonts( p_index ).compress_font
                    );
    end if;
    return t_self;
  end;
--
  procedure add_image( p_img tp_img )
  is
    t_pallet number(10);
  begin
    if p_img.color_tab is not null
    then
      t_pallet := add_stream( p_img.color_tab );
    else
      t_pallet := add_object;  -- add an empty object
      txt2pdfdoc( 'endobj' );
    end if;
    add_object;
    txt2pdfdoc( '<</Type /XObject /Subtype /Image'
              ||  ' /Width ' || to_char( p_img.width )
              || ' /Height ' || to_char( p_img.height )
              || ' /BitsPerComponent ' || to_char( p_img.color_res )
              );
--
    if p_img.transparancy_index is not null
    then
      txt2pdfdoc( '/Mask [' || p_img.transparancy_index || ' ' || p_img.transparancy_index || ']' );
    end if;
    if p_img.color_tab is null
    then
      if p_img.greyscale
      then
        txt2pdfdoc( '/ColorSpace /DeviceGray' );
      else
        txt2pdfdoc( '/ColorSpace /DeviceRGB' );
      end if;
    else
      txt2pdfdoc(    '/ColorSpace [/Indexed /DeviceRGB '
                || to_char( utl_raw.length( p_img.color_tab ) / 3 - 1 )
                || ' ' || to_char( t_pallet ) || ' 0 R]'
                );
    end if;
--
    if p_img.type = 'jpg'
    then
      put_stream( p_img.pixels, false, '/Filter /DCTDecode', false );
    elsif p_img.type = 'png'
    then
      put_stream( p_img.pixels, false
                ,  ' /Filter /FlateDecode /DecodeParms <</Predictor 15 '
                || '/Colors ' || p_img.nr_colors
                || '/BitsPerComponent ' || p_img.color_res
                || ' /Columns ' || p_img.width
                || ' >> '
                , false );
    else
      put_stream( p_img.pixels, p_tag => false );
    end if;
    txt2pdfdoc( 'endobj' );
  end;
--
  function add_resources
  return number
  is
    t_ind pls_integer;
    t_self number(10);
    t_fonts tp_objects_tab;
  begin
--
    t_ind := g_used_fonts.first;
    while t_ind is not null
    loop
      t_fonts( t_ind ) := add_font( t_ind );
      t_ind := g_used_fonts.next( t_ind );
    end loop;
--
    t_self := add_object;
    txt2pdfdoc( '<</ProcSet [/PDF /Text]' );
--
    if g_used_fonts.count() > 0
    then
      txt2pdfdoc( '/Font <<' );
      t_ind := g_used_fonts.first;
      while t_ind is not null
      loop
        txt2pdfdoc( '/F'|| to_char( t_ind ) || ' '
                  || to_char( t_fonts( t_ind ) ) || ' 0 R'
                  );
        t_ind := g_used_fonts.next( t_ind );
      end loop;
      txt2pdfdoc( '>>' );
    end if;
--
    if g_images.count( ) > 0
    then
      txt2pdfdoc( '/XObject <<' );
      for i in g_images.first .. g_images.last
      loop
        txt2pdfdoc( '/I' || to_char( i ) || ' ' || to_char( t_self + 2 * i ) || ' 0 R' );
      end loop;
      txt2pdfdoc( '>>' );
    end if;
--
    txt2pdfdoc( '>>' );
    txt2pdfdoc( 'endobj' );
--
    if g_images.count( ) > 0
    then
      for i in g_images.first .. g_images.last
      loop
        add_image( g_images( i ) );
      end loop;
    end if;
    return t_self;
  end;
--
  procedure add_page
    ( p_page_ind pls_integer
    , p_parent number
    , p_resources number
    )
  is
    t_content number(10);
  begin
    t_content := add_stream( g_pages( p_page_ind ) );
    add_object;
    txt2pdfdoc( '<< /Type /Page' );
    txt2pdfdoc( '/Parent ' || to_char( p_parent ) || ' 0 R' );
    -- AW: Add a mediabox to each page
    txt2pdfdoc(    '/MediaBox [0 0 '
                || to_char_round( g_settings_per_page( p_page_ind ).page_width
                                , 0
                                )
                || ' '
                || to_char_round( g_settings_per_page( p_page_ind ).page_height
                                , 0
                                )
                || ']' );

    txt2pdfdoc( '/Contents ' || to_char( t_content ) || ' 0 R' );
    txt2pdfdoc( '/Resources ' || to_char( p_resources ) || ' 0 R' );
    txt2pdfdoc( '>>' );
    txt2pdfdoc( 'endobj' );
  end;
--
  function add_pages
  return number
  is
    t_self number(10);
    t_resources number(10);
  begin
    t_resources := add_resources;
    t_self := add_object;
    txt2pdfdoc( '<</Type/Pages/Kids [' );
--
    for i in g_pages.first .. g_pages.last
    loop
      txt2pdfdoc( to_char( t_self + i * 2 + 2 ) || ' 0 R' );
    end loop;
--
    -- AW: take the settings from page 1 as global settings
    if g_settings_per_page.EXISTS(0) THEN
      g_settings:=g_settings_per_page(0);
    end if;
    txt2pdfdoc( ']' );
    txt2pdfdoc( '/Count ' || g_pages.count() );
    txt2pdfdoc(    '/MediaBox [0 0 '
                || to_char_round( g_settings.page_width
                                , 0
                                )
                || ' '
                || to_char_round( g_settings.page_height
                                , 0
                                )
                || ']' );
    txt2pdfdoc( '>>' );
    txt2pdfdoc( 'endobj' );
--
    if g_pages.count() > 0
    then
      for i in g_pages.first .. g_pages.last
      loop
        add_page( i, t_self, t_resources );
      end loop;
    end if;
--
    return t_self;
  end;
--
  function add_catalogue
  return number
  is
  begin
    return add_object( '/Type/Catalog'
                     || '/Pages ' || to_char( add_pages ) || ' 0 R'
                     || '/OpenAction [0 /XYZ null null 0.77]'
                     );
  end;
--
  function add_info
  return number
  is
    t_banner varchar2( 1000 );
  begin
    begin
      select    'running on '
             || replace( replace( replace( substr( banner
                                                 , 1
                                                 , 950
                                                 )
                                         , '\'
                                         , '\\'
                                         )
                                , '('
                                , '\('
                                )
                       , ')'
                       , '\)'
                       )
      into t_banner
      from v$version
      where instr( upper( banner )
                 , 'DATABASE'
                 ) > 0;
      t_banner := '/Producer (' || t_banner || ')';
    exception
      when others
      then
        null;
    end;
--
    return add_object( to_char( sysdate, '"/CreationDate (D:"YYYYMMDDhh24miss")"' )
                     || '/Creator (AS-PDF 0.3.0 by Anton Scheffer)'
                     || t_banner
                     || '/Title <FEFF' || utl_i18n.string_to_raw( g_info.title, 'AL16UTF16' ) || '>'
                     || '/Author <FEFF' || utl_i18n.string_to_raw( g_info.author, 'AL16UTF16' ) || '>'
                     || '/Subject <FEFF' || utl_i18n.string_to_raw( g_info.subject, 'AL16UTF16' ) || '>'
                     || '/Keywords <FEFF' || utl_i18n.string_to_raw( g_info.keywords, 'AL16UTF16' ) || '>'
                     );
  end;
--
  procedure finish_pdf
  is
    t_xref number;
    t_info number(10);
    t_catalogue number(10);
  begin
    if g_pages.count = 0
    then
      new_page;
    end if;
    if g_page_prcs.count > 0
    then
      for i in g_pages.first .. g_pages.last
      loop
        g_page_nr := i;
        for p in g_page_prcs.first .. g_page_prcs.last
        loop
          begin
            execute immediate replace( replace( g_page_prcs( p ), '#PAGE_NR#', i + 1 ), '"PAGE_COUNT#', g_pages.count );
          exception
            when others then null;
          end;
        end loop;
      end loop;
    end if;
    dbms_lob.createtemporary( g_pdf_doc, true );
    txt2pdfdoc( '%PDF-1.3' );
    raw2pdfdoc( hextoraw( '25E2E3CFD30D0A' ) );          -- add a hex comment
    t_info := add_info;
    t_catalogue := add_catalogue;
    t_xref := dbms_lob.getlength( g_pdf_doc );
    txt2pdfdoc( 'xref' );
    txt2pdfdoc( '0 ' || to_char( g_objects.count() ) );
    txt2pdfdoc( '0000000000 65535 f ' );
    for i in 1 .. g_objects.count( ) - 1
    loop
      txt2pdfdoc( to_char( g_objects( i ), 'fm0000000000' ) || ' 00000 n' );
                        -- this line should be exactly 20 bytes, including EOL
    end loop;
    txt2pdfdoc( 'trailer' );
    txt2pdfdoc( '<< /Root ' || to_char( t_catalogue ) || ' 0 R' );
    txt2pdfdoc( '/Info ' || to_char( t_info ) || ' 0 R' );
    txt2pdfdoc( '/Size ' || to_char( g_objects.count() ) );
    txt2pdfdoc( '>>' );
    txt2pdfdoc( 'startxref' );
    txt2pdfdoc( to_char( t_xref ) );
    txt2pdfdoc( '%%EOF' );
--
    g_objects.delete;
    for i in g_pages.first .. g_pages.last
    loop
      dbms_lob.freetemporary( g_pages( i ) );
    end loop;
    g_objects.delete;
    g_pages.delete;
    -- AW: Page-settings
    g_settings_per_page.delete;
    g_fonts.delete;
    g_used_fonts.delete;
    g_page_prcs.delete;
    if g_images.count() > 0
    then
      for i in g_images.first .. g_images.last
      loop
        if dbms_lob.istemporary( g_images( i ).pixels ) = 1
        then
          dbms_lob.freetemporary( g_images( i ).pixels );
        end if;
      end loop;
      g_images.delete;
    end if;
  end;
--
  function conv2uu( p_value number, p_unit varchar2 )
  return number
  is
   c_inch constant number := 25.40025;
  begin
    return round( case lower( p_unit )
                    when 'mm' then p_value * 72 / c_inch
                    when 'cm' then p_value * 720 / c_inch
                    when 'pt' then p_value          -- also point
                    when 'point' then p_value
                    when 'inch'  then p_value * 72
                    when 'in'    then p_value * 72  -- also inch
                    when 'pica'  then p_value * 12
                    when 'p'     then p_value * 12  -- also pica
                    when 'pc'    then p_value * 12  -- also pica
                    when 'em'    then p_value * 12  -- also pica
                    when 'px'    then p_value       -- pixel voorlopig op point zetten
                    when 'px'    then p_value * 0.8 -- pixel
                    else null
                  end
                , 3
                );
  end;
--
  procedure set_page_size
    ( p_width number
    , p_height number
    , p_unit varchar2 := 'cm'
    )
  is
  begin
    g_settings.page_width := conv2uu( p_width, p_unit );
    g_settings.page_height := conv2uu( p_height, p_unit );
  end;
--
  procedure set_page_format( p_format varchar2 := 'A4' )
  is
  begin
    case upper( p_format )
      when 'A3'
      then
        set_page_size( 420, 297, 'mm' );
      when 'A4'
      then
        set_page_size( 297, 210, 'mm' );
      when 'A5'
      then
        set_page_size( 210, 148, 'mm' );
      when 'A6'
      then
        set_page_size( 148, 105, 'mm' );
      when 'LEGAL'
      then
        set_page_size( 14, 8.5, 'in' );
      when 'LETTER'
      then
        set_page_size( 11, 8.5, 'in' );
      when 'QUARTO'
      then
        set_page_size( 11, 9, 'in' );
      when 'EXECUTIVE'
      then
        set_page_size( 10.5, 7.25, 'in' );
      else
        null;
    end case;
  end;
--
  procedure set_page_orientation( p_orientation varchar2 := 'PORTRAIT' )
  is
    t_tmp number;
  begin
    if (  (   upper( p_orientation ) in ( 'L', 'LANDSCAPE' )
          and g_settings.page_height > g_settings.page_width
          )
       or ( upper( p_orientation ) in( 'P', 'PORTRAIT' )
          and g_settings.page_height < g_settings.page_width
          )
       )
    then
      t_tmp := g_settings.page_width;
      g_settings.page_width := g_settings.page_height;
      g_settings.page_height := t_tmp;
    end if;
  end;
--
  procedure set_margins
    ( p_top number := null
    , p_left number := null
    , p_bottom number := null
    , p_right number := null
    , p_unit varchar2 := 'cm'
    )
  is
    t_tmp number;
  begin
    t_tmp := nvl( conv2uu( p_top, p_unit ), -1 );
    if t_tmp < 0 or t_tmp > g_settings.page_height
    then
      t_tmp := conv2uu( 3, 'cm' );
    end if;
    g_settings.margin_top := t_tmp;
    t_tmp := nvl( conv2uu( p_bottom, p_unit ), -1 );
    if t_tmp < 0 or t_tmp > g_settings.page_height
    then
      t_tmp := conv2uu( 4, 'cm' );
    end if;
    g_settings.margin_bottom := t_tmp;
    t_tmp := nvl( conv2uu( p_left, p_unit ), -1 );
    if t_tmp < 0 or t_tmp > g_settings.page_width
    then
      t_tmp := conv2uu( 1, 'cm' );
    end if;
    g_settings.margin_left := t_tmp;
    t_tmp := nvl( conv2uu( p_right, p_unit ), -1 );
    if t_tmp < 0 or t_tmp > g_settings.page_width
    then
      t_tmp := conv2uu( 1, 'cm' );
    end if;
    g_settings.margin_right := t_tmp;
--
    if g_settings.margin_top + g_settings.margin_bottom + conv2uu( 1, 'cm' )> g_settings.page_height
    then
      g_settings.margin_top := 0;
      g_settings.margin_bottom := 0;
    end if;
    if g_settings.margin_left + g_settings.margin_right + conv2uu( 1, 'cm' )> g_settings.page_width
    then
      g_settings.margin_left := 0;
      g_settings.margin_right := 0;
    end if;
  end;
--
  procedure set_info
    ( p_title varchar2 := null
    , p_author varchar2 := null
    , p_subject varchar2 := null
    , p_keywords varchar2 := null
    )
  is
  begin
    g_info.title := substr( p_title, 1, 1024 );
    g_info.author := substr( p_author, 1, 1024 );
    g_info.subject := substr( p_subject, 1, 1024 );
    g_info.keywords := substr( p_keywords, 1, 16383 );
  end;
--
  procedure init
  is
  begin
    g_objects.delete;
    g_pages.delete;
    -- AW: Page-settings
    g_settings_per_page.delete;
    g_fonts.delete;
    g_used_fonts.delete;
    g_page_prcs.delete;
    g_images.delete;
    g_settings := null;
    g_current_font := null;
    g_x := null;
    g_y := null;
    g_info := null;
    g_page_nr := null;
    g_objects( 0 ) := 0;
    init_core_fonts;
    set_page_format;
    set_page_orientation;
    set_margins;
  end;
--
  function get_pdf
  return blob
  is
  begin
    finish_pdf;
    return g_pdf_doc;
  end;
--
  procedure save_pdf
    ( p_dir varchar2 := 'MY_DIR'
    , p_filename varchar2 := 'my.pdf'
    , p_freeblob boolean := true
    )
  is
    t_fh utl_file.file_type;
    t_len pls_integer := 32767;
  begin
    finish_pdf;
    t_fh := utl_file.fopen( p_dir, p_filename, 'wb' );
    for i in 0 .. trunc( ( dbms_lob.getlength( g_pdf_doc ) - 1 ) / t_len )
    loop
      utl_file.put_raw( t_fh
                      , dbms_lob.substr( g_pdf_doc
                                       , t_len
                                       , i * t_len + 1
                                       )
                      );
    end loop;
    utl_file.fclose( t_fh );
    if p_freeblob
    then
      dbms_lob.freetemporary( g_pdf_doc );
    end if;
  end;
--
  procedure raw2page( p_txt raw )
  is
  begin
    if g_pages.count() = 0
    then
      new_page;
    end if;
    dbms_lob.append( g_pages( coalesce( g_page_nr, g_pages.count( ) - 1 ) )
                   , utl_raw.concat( p_txt, hextoraw( '0D0A' ) )
                   );
  end;
--
  procedure txt2page( p_txt varchar2 )
  is
  begin
    raw2page( utl_raw.cast_to_raw( p_txt ) );
  end;
--
  procedure output_font_to_doc( p_output_to_doc boolean )
  is
  begin
    if p_output_to_doc
    then
      txt2page( 'BT /F' || g_current_font || ' '
              || to_char_round( g_fonts( g_current_font ).fontsize ) || ' Tf ET'
              );
    end if;
  end;
--
  procedure set_font
    ( p_index pls_integer
    , p_fontsize_pt number
    , p_output_to_doc boolean := true
    )
  is
  begin
    if p_index is not null
    then
      g_used_fonts( p_index ) := 0;
      g_fonts( p_index ).fontsize := p_fontsize_pt;
      g_current_font_record.fontsize := p_fontsize_pt;
      if NVL(g_current_font,-1) != p_index then -- aw set only if different
        g_current_font := p_index;
        g_current_font_record:=g_fonts( p_index );
      end if;
      output_font_to_doc( p_output_to_doc );
    end if;
  end;
--
  function set_font
    ( p_fontname varchar2
    , p_fontsize_pt number
    , p_output_to_doc boolean := true
    )
  return pls_integer
  is
    t_fontname varchar2(100);
  begin
    if p_fontname is null
    then
      if (  g_current_font is not null
         and p_fontsize_pt != g_fonts( g_current_font ).fontsize
         )
      then
        g_fonts( g_current_font ).fontsize := p_fontsize_pt;
        g_current_font_record:=g_fonts( g_current_font );
        output_font_to_doc( p_output_to_doc );
      end if;
      return g_current_font;
    end if;
--
    t_fontname := lower( p_fontname );
    for i in g_fonts.first .. g_fonts.last
    loop
      if lower( g_fonts( i ).fontname ) = t_fontname
      then
        exit when g_current_font = i and g_fonts( i ).fontsize = p_fontsize_pt and g_page_nr is null;
        g_fonts( i ).fontsize := coalesce( p_fontsize_pt
                                         , g_fonts( nvl( g_current_font, i ) ).fontsize
                                         , 12
                                         );
        g_current_font := i;
        g_current_font_record:=g_fonts(i);
        g_used_fonts( i ) := 0;
        output_font_to_doc( p_output_to_doc );
        return g_current_font;
      end if;
    end loop;
    return null;
  end;
--
  procedure set_font
    ( p_fontname varchar2
    , p_fontsize_pt number
    , p_output_to_doc boolean := true
    )
  is
    t_dummy pls_integer;
  begin
    t_dummy := set_font( p_fontname, p_fontsize_pt, p_output_to_doc );
  end;
--
  function set_font
    ( p_family varchar2
    , p_style varchar2 := 'N'
    , p_fontsize_pt number := null
    , p_output_to_doc boolean := true
    )
  return pls_integer
  is
    t_family varchar2(100);
    t_style varchar2(100);
  begin
    if p_family is null and g_current_font is null
    then
      return null;
    end if;
    if p_family is null and  p_style is null and p_fontsize_pt is null
    then
      return null;
    end if;
    t_family := coalesce( lower( p_family )
                        , g_fonts( g_current_font ).family
                        );
    t_style := upper( p_style );

    t_style := case t_style
                 when 'NORMAL' then 'N'
                 when 'REGULAR' then 'N'
                 when 'BOLD' then 'B'
                 when 'ITALIC' then 'I'
                 when 'OBLIQUE' then 'I'
                 else t_style
               end;
    t_style := coalesce( t_style
                       , case when g_current_font is null then 'N' else g_fonts( g_current_font ).style end
                       );
--
    for i in g_fonts.first .. g_fonts.last
    loop
      if (   g_fonts( i ).family = t_family
         and g_fonts( i ).style = t_style
         )
      then
        return set_font( g_fonts( i ).fontname, p_fontsize_pt, p_output_to_doc );
      end if;
    end loop;
    return null;
  end;
--
  procedure set_font
    ( p_family varchar2
    , p_style varchar2 := 'N'
    , p_fontsize_pt number := null
    , p_output_to_doc boolean := true
    )
  is
    t_dummy pls_integer;
  begin
    t_dummy := set_font( p_family, p_style, p_fontsize_pt, p_output_to_doc );
  end;
--
  procedure new_page
  is
  begin
    g_pages( g_pages.count() ) := null;
    g_settings_per_page(g_settings_per_page.count()):=g_settings;
    dbms_lob.createtemporary( g_pages( g_pages.count() - 1 ), true );
    if g_current_font is not null and g_pages.count() > 0
    then
      txt2page( 'BT /F' || g_current_font || ' '
              || to_char_round( g_fonts( g_current_font ).fontsize )
              || ' Tf ET'
              );
    end if;
    g_x := null;
    g_y := null;
  end;
--
  function pdf_string( p_txt in blob )
  return blob
  is
    t_rv blob;
    t_ind integer;
    type tp_tab_raw is table of raw(1);
    tab_raw tp_tab_raw
      := tp_tab_raw( utl_raw.cast_to_raw( '\' )
                   , utl_raw.cast_to_raw( '(' )
                   , utl_raw.cast_to_raw( ')' )
                   );
  begin
    t_rv := p_txt;
    for i in tab_raw.first .. tab_raw.last
    loop
      t_ind := -1;
      loop
        t_ind := dbms_lob.instr( t_rv
                               , tab_raw( i )
                               , t_ind + 2
                               );
        exit when t_ind <= 0;
        dbms_lob.copy( t_rv
                     , t_rv
                     , dbms_lob.lobmaxsize
                     , t_ind + 1
                     , t_ind
                     );
        dbms_lob.copy( t_rv
                     , utl_raw.cast_to_raw( '\' )
                     , 1
                     , t_ind
                     , 1
                     );
      end loop;
    end loop;
    return t_rv;
  end;
--
  function txt2raw( p_txt varchar2 )
  return raw
  is
    t_rv raw(32767);
    t_unicode pls_integer;
  begin
    if g_current_font is null
    then
      set_font( 'helvetica' );
    end if;
    if g_fonts( g_current_font ).cid
    then
      for i in 1 .. length( p_txt )
      loop
        t_unicode := utl_raw.cast_to_binary_integer( utl_raw.convert( utl_raw.cast_to_raw( substr( p_txt, i, 1 ) )
                                                                    , 'AMERICAN_AMERICA.AL16UTF16'
                                                                    , sys_context( 'userenv', 'LANGUAGE' )  -- ???? font characterset ?????
                                                                    )
                                                 );
        if g_fonts( g_current_font ).flags = 4 -- a symbolic font
        then
-- assume code 32, space maps to the first code from the font
          t_unicode := g_fonts( g_current_font ).code2glyph.first + t_unicode - 32;
        end if;
        if g_current_font_record.code2glyph.exists( t_unicode )
        then
          g_fonts( g_current_font ).used_chars( g_current_font_record.code2glyph( t_unicode ) ) := 0;
          t_rv := utl_raw.concat( t_rv
                                , utl_raw.cast_to_raw( to_char( g_current_font_record.code2glyph( t_unicode ), 'FM0XXX' ) )
                                );
        else
          t_rv := utl_raw.concat( t_rv, utl_raw.cast_to_raw( '0000' ) );

        end if;
      end loop;
      t_rv := utl_raw.concat( utl_raw.cast_to_raw( '<' )
                            , t_rv
                            , utl_raw.cast_to_raw( '>' )
                            );
    else
      t_rv := utl_raw.convert( utl_raw.cast_to_raw( p_txt )
                             , g_fonts( g_current_font ).charset
                             , sys_context( 'userenv', 'LANGUAGE' )
                             );
      for i in 1 .. utl_raw.length( t_rv )
      loop
        g_fonts( g_current_font ).used_chars( raw2num( t_rv, i, 1 ) ) := 0;
      end loop;
      t_rv := utl_raw.concat( utl_raw.cast_to_raw( '(' )
                            , pdf_string( t_rv )
                            , utl_raw.cast_to_raw( ')' )
                            );
    end if;
    return t_rv;
  end;
--
  procedure put_raw( p_x number, p_y number, p_txt raw, p_degrees_rotation number := null )
  is
    c_pi constant number := 3.14159265358979323846264338327950288419716939937510;
    t_tmp varchar2(32767);
    t_sin number;
    t_cos number;
  begin
    t_tmp := to_char_round( p_x ) || ' ' || to_char_round( p_y );
    if p_degrees_rotation is null
    then
      t_tmp := t_tmp || ' Td ';
    else
      t_sin := sin( p_degrees_rotation / 180 * c_pi );
      t_cos := cos( p_degrees_rotation / 180 * c_pi );
      t_tmp := to_char_round( t_cos, 5 ) || ' ' || t_tmp;
      t_tmp := to_char_round( - t_sin, 5 ) || ' ' || t_tmp;
      t_tmp := to_char_round( t_sin, 5 ) || ' ' || t_tmp;
      t_tmp := to_char_round( t_cos, 5 ) || ' ' || t_tmp;
      t_tmp := t_tmp || ' Tm ';
    end if;
    raw2page( utl_raw.concat( utl_raw.cast_to_raw( 'BT ' || t_tmp )
                            , p_txt
                            , utl_raw.cast_to_raw( ' Tj ET' )
                            )
              );
  end;
--
  procedure put_txt( p_x number, p_y number, p_txt varchar2, p_degrees_rotation number := null )
  is
  begin
    if p_txt is not null
    then
      put_raw( p_x, p_y, txt2raw( p_txt ), p_degrees_rotation );
    end if;
  end;
--
  function str_len( p_txt in varchar2 )
  return number
  is
    t_width number;
    t_char pls_integer;
    t_rtxt raw(32767);
    t_tmp number;
    --t_font tp_font;
  begin
    if p_txt is null
    then
      return 0;
    end if;
--
    t_width := 0;
    if g_current_font_record.cid
    then
      t_rtxt := utl_raw.convert( utl_raw.cast_to_raw( p_txt )
                               , 'AMERICAN_AMERICA.AL16UTF16' -- 16 bit font => 2 bytes per char
                               , sys_context( 'userenv', 'LANGUAGE' )  -- ???? font characterset ?????
                               );
      for i in 1 .. utl_raw.length( t_rtxt ) / 2
      loop
        t_char := to_number( utl_raw.substr( t_rtxt, i * 2 - 1, 2 ), 'xxxx' );
        if g_current_font_record.flags = 4
        then
-- assume code 32, space maps to the first code from the font
          t_char := g_current_font_record.code2glyph.first + t_char - 32;
        end if;
        if (   g_current_font_record.code2glyph.exists( t_char )
           and g_current_font_record.hmetrics.exists( g_current_font_record.code2glyph( t_char ) )
           )
        then
          t_tmp := g_current_font_record.hmetrics( g_current_font_record.code2glyph( t_char ) );
        else
          t_tmp := g_current_font_record.hmetrics( g_current_font_record.hmetrics.last() );
        end if;
        t_width := t_width + t_tmp;
      end loop;
      t_width := t_width * g_current_font_record.unit_norm;
      t_width := t_width * g_current_font_record.fontsize / 1000;
    else
      t_rtxt := utl_raw.convert( utl_raw.cast_to_raw( p_txt )
                               , g_current_font_record.charset  -- should be an 8 bit font
                               , sys_context( 'userenv', 'LANGUAGE' )
                               );
      for i in 1 .. utl_raw.length( t_rtxt )
      loop
        t_char := to_number( utl_raw.substr( t_rtxt, i, 1 ), 'xx' );
        t_width := t_width + g_current_font_record.char_width_tab( t_char );
      end loop;
      t_width := t_width * g_current_font_record.fontsize / 1000;
    end if;
    return t_width;
  end;
--
  procedure write
    ( p_txt in varchar2
    , p_x in number := null
    , p_y in number := null
    , p_line_height in number := null
    , p_start in number := null  -- left side of the available text box
    , p_width in number := null  -- width of the available text box
    , p_alignment in varchar2 := null
    )
  is
    t_line_height number;
    t_x number;
    t_y number;
    t_start number;
    t_width number;
    t_len number;
    t_cnt pls_integer;
    t_ind pls_integer;
    t_alignment varchar2(100);
  begin
    if p_txt is null
    then
      return;
    end if;
--
    if g_current_font is null
    then
      set_font( 'helvetica' );
    end if;
--
    t_line_height := nvl( p_line_height, g_fonts( g_current_font ).fontsize );
    if (  t_line_height < g_fonts( g_current_font ).fontsize
       or t_line_height > ( g_settings.page_height - g_settings.margin_top - t_line_height ) / 4
       )
    then
      t_line_height := g_fonts( g_current_font ).fontsize;
    end if;
    t_start := nvl( p_start, g_settings.margin_left );
    if (  t_start < g_settings.margin_left
       or t_start > g_settings.page_width - g_settings.margin_right - g_settings.margin_left
       )
    then
      t_start := g_settings.margin_left;
    end if;
    t_width := nvl( p_width
                  , g_settings.page_width - g_settings.margin_right - g_settings.margin_left
                  );
    if (  t_width < str_len( '   ' )
       or t_width > g_settings.page_width - g_settings.margin_right - g_settings.margin_left
       )
    then
      t_width := g_settings.page_width - g_settings.margin_right - g_settings.margin_left;
    end if;
    t_x := coalesce( p_x, g_x, g_settings.margin_left );
    t_y := coalesce( p_y
                   , g_y
                   , g_settings.page_height - g_settings.margin_top - t_line_height
                   );
    if t_y < 0
    then
      t_y := coalesce( g_y
                     , g_settings.page_height - g_settings.margin_top - t_line_height
                     ) - t_line_height;
    end if;
    if t_x > t_start + t_width
    then
      t_x := t_start;
      t_y := t_y - t_line_height;
    elsif t_x < t_start
    then
      t_x := t_start;
    end if;
    if t_y < g_settings.margin_bottom
    then
      new_page;
      t_x := t_start;
      t_y := g_settings.page_height - g_settings.margin_top - t_line_height;
    end if;
--
    t_ind := instr( p_txt, chr(10) );
    if t_ind > 0
    then
      g_x := t_x;
      g_y := t_y;
      write( rtrim( substr( p_txt, 1, t_ind - 1 ), chr(13) ), t_x, t_y, t_line_height, t_start, t_width, p_alignment );
      t_y := g_y - t_line_height;
      if t_y < g_settings.margin_bottom
      then
        new_page;
        t_y := g_settings.page_height - g_settings.margin_top - t_line_height;
      end if;
      g_x := t_start;
      g_y := t_y;
      write( substr( p_txt, t_ind + 1 ), t_start, t_y, t_line_height, t_start, t_width, p_alignment );
      return;
    end if;
--
    t_len := str_len( p_txt );
    if t_len <= t_width - t_x + t_start
    then
      t_alignment := lower( substr( p_alignment, 1, 100 ) );
      if instr( t_alignment, 'right' ) > 0 or instr( t_alignment, 'end' ) > 0
      then
        t_x := t_start + t_width - t_len;
      elsif instr( t_alignment, 'center' ) > 0
      then
        t_x := ( t_width + t_x + t_start - t_len ) / 2;
      end if;
      put_txt( t_x, t_y, p_txt );
      g_x := t_x + t_len + str_len( ' ' );
      g_y := t_y;
      return;
    end if;
--
    t_cnt := 0;
    while (   instr( p_txt, ' ', 1, t_cnt + 1 ) > 0
          and str_len( substr( p_txt, 1, instr( p_txt, ' ', 1, t_cnt + 1 ) - 1 ) ) <= t_width - t_x + t_start
          )
    loop
      t_cnt := t_cnt + 1;
    end loop;
    if t_cnt > 0
    then
      t_ind := instr( p_txt, ' ', 1, t_cnt );
      write( substr( p_txt, 1, t_ind - 1 ), t_x, t_y, t_line_height, t_start, t_width, p_alignment );
      t_y := t_y - t_line_height;
      if t_y < g_settings.margin_bottom
      then
        new_page;
        t_y := g_settings.page_height - g_settings.margin_top - t_line_height;
      end if;
      write( substr( p_txt, t_ind + 1 ), t_start, t_y, t_line_height, t_start, t_width, p_alignment );
      return;
    end if;
--
    if t_x > t_start and t_len < t_width
    then
      t_y := t_y - t_line_height;
      if t_y < g_settings.margin_bottom
      then
        new_page;
        t_y := g_settings.page_height - g_settings.margin_top - t_line_height;
      end if;
      write( p_txt, t_start, t_y, t_line_height, t_start, t_width, p_alignment );
    else
      if length( p_txt ) = 1
      then
        if t_x > t_start
        then
          t_y := t_y - t_line_height;
          if t_y < g_settings.margin_bottom
          then
            new_page;
            t_y := g_settings.page_height - g_settings.margin_top - t_line_height;
          end if;
        end if;
        write( p_txt, t_x, t_y, t_line_height, t_start, t_len );
      else
        t_ind := 2; -- start with 2 to make sure we get amaller string!
        while str_len( substr( p_txt, 1, t_ind ) ) <= t_width - t_x + t_start
        loop
          t_ind := t_ind + 1;
        end loop;
        write( substr( p_txt, 1, t_ind - 1 ), t_x, t_y, t_line_height, t_start, t_width, p_alignment );
        t_y := t_y - t_line_height;
        if t_y < g_settings.margin_bottom
        then
          new_page;
          t_y := g_settings.page_height - g_settings.margin_top - t_line_height;
        end if;
        write( substr( p_txt, t_ind ), t_start, t_y, t_line_height, t_start, t_width, p_alignment );
      end if;
    end if;
  end;
--
  function load_ttf_font
    ( p_font blob
    , p_encoding varchar2 := 'WINDOWS-1252'
    , p_embed boolean := false
    , p_compress boolean := true
    , p_offset number := 1
    )
  return pls_integer
  is
    this_font tp_font;
    type tp_font_table is record
      ( offset pls_integer
      , length pls_integer
      );
    type tp_tables is table of tp_font_table index by varchar2(4);
    t_tables tp_tables;
    t_tag varchar2(4);
    t_blob blob;
    t_offset pls_integer;
    nr_hmetrics pls_integer;
    subtype tp_glyphname is varchar2(250);
    type tp_glyphnames is table of tp_glyphname index by pls_integer;
    t_glyphnames tp_glyphnames;
    t_glyph2name tp_pls_tab;
    t_font_ind pls_integer;
  begin
    if dbms_lob.substr( p_font, 4, p_offset ) != hextoraw( '00010000' ) --  OpenType Font
    then
      return null;
    end if;
    for i in 1 .. blob2num( p_font, 2, p_offset + 4 )
    loop
      t_tag :=
        utl_raw.cast_to_varchar2( dbms_lob.substr( p_font, 4, p_offset - 4 + i * 16 ) );
      t_tables( t_tag ).offset := blob2num( p_font, 4, p_offset + 4 + i * 16 ) + 1;
      t_tables( t_tag ).length := blob2num( p_font, 4, p_offset + 8 + i * 16 );
    end loop;
--
    if (  not t_tables.exists( 'cmap' )
       or not t_tables.exists( 'glyf' )
       or not t_tables.exists( 'head' )
       or not t_tables.exists( 'hhea' )
       or not t_tables.exists( 'hmtx' )
       or not t_tables.exists( 'loca' )
       or not t_tables.exists( 'maxp' )
       or not t_tables.exists( 'name' )
       or not t_tables.exists( 'post' )
       )
    then
      return null;
    end if;
--
    dbms_lob.createtemporary( t_blob, true );
    dbms_lob.copy( t_blob, p_font, t_tables( 'maxp' ).length, 1, t_tables( 'maxp' ).offset );
    this_font.numGlyphs := blob2num( t_blob, 2, 5 );
--
    dbms_lob.copy( t_blob, p_font, t_tables( 'cmap' ).length, 1, t_tables( 'cmap' ).offset );
    for i in 0 .. blob2num( t_blob, 2, 3 ) - 1
    loop
      if (   dbms_lob.substr( t_blob, 2, 5 + i * 8 ) = hextoraw( '0003' ) -- Windows
         and dbms_lob.substr( t_blob, 2, 5 + i * 8 + 2 )
               in ( hextoraw( '0000' ) -- Symbol
                  , hextoraw( '0001' ) -- Unicode BMP (UCS-2)
                  )
         )
      then
        if dbms_lob.substr( t_blob, 2, 5 + i * 8 + 2 ) = hextoraw( '0000' ) -- Symbol
        then
          this_font.flags := 4; -- symbolic
        else
          this_font.flags := 32; -- non-symbolic
        end if;
        t_offset := blob2num( t_blob, 4, 5 + i * 8 + 4 ) + 1;
        if dbms_lob.substr( t_blob, 2, t_offset ) != hextoraw( '0004' )
        then
          return null;
        end if;
        declare
          t_seg_cnt pls_integer;
          t_end_offs pls_integer;
          t_start_offs pls_integer;
          t_idDelta_offs pls_integer;
          t_idRangeOffset_offs pls_integer;
          t_tmp pls_integer;
          t_start pls_integer;
        begin
          t_seg_cnt := blob2num( t_blob, 2, t_offset + 6 ) / 2;
          t_end_offs := t_offset + 14;
          t_start_offs := t_end_offs + t_seg_cnt * 2 + 2;
          t_idDelta_offs := t_start_offs + t_seg_cnt * 2;
          t_idRangeOffset_offs := t_idDelta_offs + t_seg_cnt * 2;
          for seg in 0 .. t_seg_cnt - 1
          loop
            t_tmp := blob2num( t_blob, 2, t_idRangeOffset_offs + seg * 2 );
            if t_tmp = 0
            then
              t_tmp := blob2num( t_blob, 2, t_idDelta_offs + seg * 2 );
              for c in blob2num( t_blob, 2, t_start_offs + seg * 2 )
                    .. blob2num( t_blob, 2, t_end_offs + seg * 2 )
              loop
                this_font.code2glyph( c ) := mod( c + t_tmp, 65536 );
              end loop;
            else
              t_start := blob2num( t_blob, 2, t_start_offs + seg * 2 );
              for c in t_start .. blob2num( t_blob, 2, t_end_offs + seg * 2 )
              loop
                this_font.code2glyph( c ) := blob2num( t_blob, 2, t_idRangeOffset_offs + t_tmp + ( seg + c - t_start ) * 2 );
              end loop;
            end if;
          end loop;
        end;
        exit;
      end if;
    end loop;
--
    t_glyphnames( 0 ) := '.notdef';
    t_glyphnames( 1 ) := '.null';
    t_glyphnames( 2 ) := 'nonmarkingreturn';
    t_glyphnames( 3 ) := 'space';
    t_glyphnames( 4 ) := 'exclam';
    t_glyphnames( 5 ) := 'quotedbl';
    t_glyphnames( 6 ) := 'numbersign';
    t_glyphnames( 7 ) := 'dollar';
    t_glyphnames( 8 ) := 'percent';
    t_glyphnames( 9 ) := 'ampersand';
    t_glyphnames( 10 ) := 'quotesingle';
    t_glyphnames( 11 ) := 'parenleft';
    t_glyphnames( 12 ) := 'parenright';
    t_glyphnames( 13 ) := 'asterisk';
    t_glyphnames( 14 ) := 'plus';
    t_glyphnames( 15 ) := 'comma';
    t_glyphnames( 16 ) := 'hyphen';
    t_glyphnames( 17 ) := 'period';
    t_glyphnames( 18 ) := 'slash';
    t_glyphnames( 19 ) := 'zero';
    t_glyphnames( 20 ) := 'one';
    t_glyphnames( 21 ) := 'two';
    t_glyphnames( 22 ) := 'three';
    t_glyphnames( 23 ) := 'four';
    t_glyphnames( 24 ) := 'five';
    t_glyphnames( 25 ) := 'six';
    t_glyphnames( 26 ) := 'seven';
    t_glyphnames( 27 ) := 'eight';
    t_glyphnames( 28 ) := 'nine';
    t_glyphnames( 29 ) := 'colon';
    t_glyphnames( 30 ) := 'semicolon';
    t_glyphnames( 31 ) := 'less';
    t_glyphnames( 32 ) := 'equal';
    t_glyphnames( 33 ) := 'greater';
    t_glyphnames( 34 ) := 'question';
    t_glyphnames( 35 ) := 'at';
    t_glyphnames( 36 ) := 'A';
    t_glyphnames( 37 ) := 'B';
    t_glyphnames( 38 ) := 'C';
    t_glyphnames( 39 ) := 'D';
    t_glyphnames( 40 ) := 'E';
    t_glyphnames( 41 ) := 'F';
    t_glyphnames( 42 ) := 'G';
    t_glyphnames( 43 ) := 'H';
    t_glyphnames( 44 ) := 'I';
    t_glyphnames( 45 ) := 'J';
    t_glyphnames( 46 ) := 'K';
    t_glyphnames( 47 ) := 'L';
    t_glyphnames( 48 ) := 'M';
    t_glyphnames( 49 ) := 'N';
    t_glyphnames( 50 ) := 'O';
    t_glyphnames( 51 ) := 'P';
    t_glyphnames( 52 ) := 'Q';
    t_glyphnames( 53 ) := 'R';
    t_glyphnames( 54 ) := 'S';
    t_glyphnames( 55 ) := 'T';
    t_glyphnames( 56 ) := 'U';
    t_glyphnames( 57 ) := 'V';
    t_glyphnames( 58 ) := 'W';
    t_glyphnames( 59 ) := 'X';
    t_glyphnames( 60 ) := 'Y';
    t_glyphnames( 61 ) := 'Z';
    t_glyphnames( 62 ) := 'bracketleft';
    t_glyphnames( 63 ) := 'backslash';
    t_glyphnames( 64 ) := 'bracketright';
    t_glyphnames( 65 ) := 'asciicircum';
    t_glyphnames( 66 ) := 'underscore';
    t_glyphnames( 67 ) := 'grave';
    t_glyphnames( 68 ) := 'a';
    t_glyphnames( 69 ) := 'b';
    t_glyphnames( 70 ) := 'c';
    t_glyphnames( 71 ) := 'd';
    t_glyphnames( 72 ) := 'e';
    t_glyphnames( 73 ) := 'f';
    t_glyphnames( 74 ) := 'g';
    t_glyphnames( 75 ) := 'h';
    t_glyphnames( 76 ) := 'i';
    t_glyphnames( 77 ) := 'j';
    t_glyphnames( 78 ) := 'k';
    t_glyphnames( 79 ) := 'l';
    t_glyphnames( 80 ) := 'm';
    t_glyphnames( 81 ) := 'n';
    t_glyphnames( 82 ) := 'o';
    t_glyphnames( 83 ) := 'p';
    t_glyphnames( 84 ) := 'q';
    t_glyphnames( 85 ) := 'r';
    t_glyphnames( 86 ) := 's';
    t_glyphnames( 87 ) := 't';
    t_glyphnames( 88 ) := 'u';
    t_glyphnames( 89 ) := 'v';
    t_glyphnames( 90 ) := 'w';
    t_glyphnames( 91 ) := 'x';
    t_glyphnames( 92 ) := 'y';
    t_glyphnames( 93 ) := 'z';
    t_glyphnames( 94 ) := 'braceleft';
    t_glyphnames( 95 ) := 'bar';
    t_glyphnames( 96 ) := 'braceright';
    t_glyphnames( 97 ) := 'asciitilde';
    t_glyphnames( 98 ) := 'Adieresis';
    t_glyphnames( 99 ) := 'Aring';
    t_glyphnames( 100 ) := 'Ccedilla';
    t_glyphnames( 101 ) := 'Eacute';
    t_glyphnames( 102 ) := 'Ntilde';
    t_glyphnames( 103 ) := 'Odieresis';
    t_glyphnames( 104 ) := 'Udieresis';
    t_glyphnames( 105 ) := 'aacute';
    t_glyphnames( 106 ) := 'agrave';
    t_glyphnames( 107 ) := 'acircumflex';
    t_glyphnames( 108 ) := 'adieresis';
    t_glyphnames( 109 ) := 'atilde';
    t_glyphnames( 110 ) := 'aring';
    t_glyphnames( 111 ) := 'ccedilla';
    t_glyphnames( 112 ) := 'eacute';
    t_glyphnames( 113 ) := 'egrave';
    t_glyphnames( 114 ) := 'ecircumflex';
    t_glyphnames( 115 ) := 'edieresis';
    t_glyphnames( 116 ) := 'iacute';
    t_glyphnames( 117 ) := 'igrave';
    t_glyphnames( 118 ) := 'icircumflex';
    t_glyphnames( 119 ) := 'idieresis';
    t_glyphnames( 120 ) := 'ntilde';
    t_glyphnames( 121 ) := 'oacute';
    t_glyphnames( 122 ) := 'ograve';
    t_glyphnames( 123 ) := 'ocircumflex';
    t_glyphnames( 124 ) := 'odieresis';
    t_glyphnames( 125 ) := 'otilde';
    t_glyphnames( 126 ) := 'uacute';
    t_glyphnames( 127 ) := 'ugrave';
    t_glyphnames( 128 ) := 'ucircumflex';
    t_glyphnames( 129 ) := 'udieresis';
    t_glyphnames( 130 ) := 'dagger';
    t_glyphnames( 131 ) := 'degree';
    t_glyphnames( 132 ) := 'cent';
    t_glyphnames( 133 ) := 'sterling';
    t_glyphnames( 134 ) := 'section';
    t_glyphnames( 135 ) := 'bullet';
    t_glyphnames( 136 ) := 'paragraph';
    t_glyphnames( 137 ) := 'germandbls';
    t_glyphnames( 138 ) := 'registered';
    t_glyphnames( 139 ) := 'copyright';
    t_glyphnames( 140 ) := 'trademark';
    t_glyphnames( 141 ) := 'acute';
    t_glyphnames( 142 ) := 'dieresis';
    t_glyphnames( 143 ) := 'notequal';
    t_glyphnames( 144 ) := 'AE';
    t_glyphnames( 145 ) := 'Oslash';
    t_glyphnames( 146 ) := 'infinity';
    t_glyphnames( 147 ) := 'plusminus';
    t_glyphnames( 148 ) := 'lessequal';
    t_glyphnames( 149 ) := 'greaterequal';
    t_glyphnames( 150 ) := 'yen';
    t_glyphnames( 151 ) := 'mu';
    t_glyphnames( 152 ) := 'partialdiff';
    t_glyphnames( 153 ) := 'summation';
    t_glyphnames( 154 ) := 'product';
    t_glyphnames( 155 ) := 'pi';
    t_glyphnames( 156 ) := 'integral';
    t_glyphnames( 157 ) := 'ordfeminine';
    t_glyphnames( 158 ) := 'ordmasculine';
    t_glyphnames( 159 ) := 'Omega';
    t_glyphnames( 160 ) := 'ae';
    t_glyphnames( 161 ) := 'oslash';
    t_glyphnames( 162 ) := 'questiondown';
    t_glyphnames( 163 ) := 'exclamdown';
    t_glyphnames( 164 ) := 'logicalnot';
    t_glyphnames( 165 ) := 'radical';
    t_glyphnames( 166 ) := 'florin';
    t_glyphnames( 167 ) := 'approxequal';
    t_glyphnames( 168 ) := 'Delta';
    t_glyphnames( 169 ) := 'guillemotleft';
    t_glyphnames( 170 ) := 'guillemotright';
    t_glyphnames( 171 ) := 'ellipsis';
    t_glyphnames( 172 ) := 'nonbreakingspace';
    t_glyphnames( 173 ) := 'Agrave';
    t_glyphnames( 174 ) := 'Atilde';
    t_glyphnames( 175 ) := 'Otilde';
    t_glyphnames( 176 ) := 'OE';
    t_glyphnames( 177 ) := 'oe';
    t_glyphnames( 178 ) := 'endash';
    t_glyphnames( 179 ) := 'emdash';
    t_glyphnames( 180 ) := 'quotedblleft';
    t_glyphnames( 181 ) := 'quotedblright';
    t_glyphnames( 182 ) := 'quoteleft';
    t_glyphnames( 183 ) := 'quoteright';
    t_glyphnames( 184 ) := 'divide';
    t_glyphnames( 185 ) := 'lozenge';
    t_glyphnames( 186 ) := 'ydieresis';
    t_glyphnames( 187 ) := 'Ydieresis';
    t_glyphnames( 188 ) := 'fraction';
    t_glyphnames( 189 ) := 'currency';
    t_glyphnames( 190 ) := 'guilsinglleft';
    t_glyphnames( 191 ) := 'guilsinglright';
    t_glyphnames( 192 ) := 'fi';
    t_glyphnames( 193 ) := 'fl';
    t_glyphnames( 194 ) := 'daggerdbl';
    t_glyphnames( 195 ) := 'periodcentered';
    t_glyphnames( 196 ) := 'quotesinglbase';
    t_glyphnames( 197 ) := 'quotedblbase';
    t_glyphnames( 198 ) := 'perthousand';
    t_glyphnames( 199 ) := 'Acircumflex';
    t_glyphnames( 200 ) := 'Ecircumflex';
    t_glyphnames( 201 ) := 'Aacute';
    t_glyphnames( 202 ) := 'Edieresis';
    t_glyphnames( 203 ) := 'Egrave';
    t_glyphnames( 204 ) := 'Iacute';
    t_glyphnames( 205 ) := 'Icircumflex';
    t_glyphnames( 206 ) := 'Idieresis';
    t_glyphnames( 207 ) := 'Igrave';
    t_glyphnames( 208 ) := 'Oacute';
    t_glyphnames( 209 ) := 'Ocircumflex';
    t_glyphnames( 210 ) := 'apple';
    t_glyphnames( 211 ) := 'Ograve';
    t_glyphnames( 212 ) := 'Uacute';
    t_glyphnames( 213 ) := 'Ucircumflex';
    t_glyphnames( 214 ) := 'Ugrave';
    t_glyphnames( 215 ) := 'dotlessi';
    t_glyphnames( 216 ) := 'circumflex';
    t_glyphnames( 217 ) := 'tilde';
    t_glyphnames( 218 ) := 'macron';
    t_glyphnames( 219 ) := 'breve';
    t_glyphnames( 220 ) := 'dotaccent';
    t_glyphnames( 221 ) := 'ring';
    t_glyphnames( 222 ) := 'cedilla';
    t_glyphnames( 223 ) := 'hungarumlaut';
    t_glyphnames( 224 ) := 'ogonek';
    t_glyphnames( 225 ) := 'caron';
    t_glyphnames( 226 ) := 'Lslash';
    t_glyphnames( 227 ) := 'lslash';
    t_glyphnames( 228 ) := 'Scaron';
    t_glyphnames( 229 ) := 'scaron';
    t_glyphnames( 230 ) := 'Zcaron';
    t_glyphnames( 231 ) := 'zcaron';
    t_glyphnames( 232 ) := 'brokenbar';
    t_glyphnames( 233 ) := 'Eth';
    t_glyphnames( 234 ) := 'eth';
    t_glyphnames( 235 ) := 'Yacute';
    t_glyphnames( 236 ) := 'yacute';
    t_glyphnames( 237 ) := 'Thorn';
    t_glyphnames( 238 ) := 'thorn';
    t_glyphnames( 239 ) := 'minus';
    t_glyphnames( 240 ) := 'multiply';
    t_glyphnames( 241 ) := 'onesuperior';
    t_glyphnames( 242 ) := 'twosuperior';
    t_glyphnames( 243 ) := 'threesuperior';
    t_glyphnames( 244 ) := 'onehalf';
    t_glyphnames( 245 ) := 'onequarter';
    t_glyphnames( 246 ) := 'threequarters';
    t_glyphnames( 247 ) := 'franc';
    t_glyphnames( 248 ) := 'Gbreve';
    t_glyphnames( 249 ) := 'gbreve';
    t_glyphnames( 250 ) := 'Idotaccent';
    t_glyphnames( 251 ) := 'Scedilla';
    t_glyphnames( 252 ) := 'scedilla';
    t_glyphnames( 253 ) := 'Cacute';
    t_glyphnames( 254 ) := 'cacute';
    t_glyphnames( 255 ) := 'Ccaron';
    t_glyphnames( 256 ) := 'ccaron';
    t_glyphnames( 257 ) := 'dcroat';
--
    dbms_lob.copy( t_blob, p_font, t_tables( 'post' ).length, 1, t_tables( 'post' ).offset );
    this_font.italic_angle := to_short( dbms_lob.substr( t_blob, 2, 5 ) )
                            + to_short( dbms_lob.substr( t_blob, 2, 7 ) ) / 65536;
    case rawtohex( dbms_lob.substr( t_blob, 4, 1 ) )
      when '00010000'
      then
        for g in 0 .. 257
        loop
          t_glyph2name( g ) := g;
        end loop;
      when '00020000'
      then
        t_offset := blob2num( t_blob, 2, 33 ) * 2 + 35;
        while nvl( blob2num( t_blob, 1, t_offset ), 0 ) > 0
        loop
          t_glyphnames( t_glyphnames.count ) := utl_raw.cast_to_varchar2( dbms_lob.substr( t_blob, blob2num( t_blob, 1, t_offset ), t_offset + 1 ) );
          t_offset := t_offset + blob2num( t_blob, 1, t_offset ) + 1;
        end loop;
        for g in 0 .. blob2num( t_blob, 2, 33 ) - 1
        loop
          t_glyph2name( g ) := blob2num( t_blob, 2, 35 + 2 * g );
        end loop;
      when '00025000'
      then
        for g in 0 .. blob2num( t_blob, 2, 33 ) - 1
        loop
          t_offset := blob2num( t_blob, 1, 35 + g );
          if t_offset > 127
          then
            t_glyph2name( g ) := g - t_offset;
          else
            t_glyph2name( g ) := g + t_offset;
          end if;
        end loop;
      when '00030000'
      then
        t_glyphnames.delete;
      else
        dbms_output.put_line( 'no post ' || dbms_lob.substr( t_blob, 4, 1 ) );
    end case;
--
    dbms_lob.copy( t_blob, p_font, t_tables( 'head' ).length, 1, t_tables( 'head' ).offset );
    if dbms_lob.substr( t_blob, 4, 13 ) = hextoraw( '5F0F3CF5' )  -- magic
    then
      declare
        t_tmp pls_integer := blob2num( t_blob, 2, 45 );
      begin
        if bitand( t_tmp, 1 ) = 1
        then
          this_font.style := 'B';
        end if;
        if bitand( t_tmp, 2 ) = 2
        then
          this_font.style := this_font.style || 'I';
          this_font.flags := this_font.flags + 64;
        end if;
        this_font.style := nvl( this_font.style, 'N' );
        this_font.unit_norm := 1000 / blob2num( t_blob, 2, 19 );
        this_font.bb_xmin := to_short( dbms_lob.substr( t_blob, 2, 37 ), this_font.unit_norm );
        this_font.bb_ymin := to_short( dbms_lob.substr( t_blob, 2, 39 ), this_font.unit_norm );
        this_font.bb_xmax := to_short( dbms_lob.substr( t_blob, 2, 41 ), this_font.unit_norm );
        this_font.bb_ymax := to_short( dbms_lob.substr( t_blob, 2, 43 ), this_font.unit_norm );
        this_font.indexToLocFormat := blob2num( t_blob, 2, 51 ); -- 0 for short offsets, 1 for long
      end;
    end if;
--
    dbms_lob.copy( t_blob, p_font, t_tables( 'hhea' ).length, 1, t_tables( 'hhea' ).offset );
    if dbms_lob.substr( t_blob, 4, 1 ) = hextoraw( '00010000' ) -- version 1.0
    then
      this_font.ascent := to_short( dbms_lob.substr( t_blob, 2, 5 ), this_font.unit_norm );
      this_font.descent := to_short( dbms_lob.substr( t_blob, 2, 7 ), this_font.unit_norm );
      this_font.capheight := this_font.ascent;
      nr_hmetrics := blob2num( t_blob, 2, 35 );
    end if;
--
    dbms_lob.copy( t_blob, p_font, t_tables( 'hmtx' ).length, 1, t_tables( 'hmtx' ).offset );
    for j in 0 .. nr_hmetrics - 1
    loop
      this_font.hmetrics( j ) := blob2num( t_blob, 2, 1 + 4 * j );
    end loop;
--
    dbms_lob.copy( t_blob, p_font, t_tables( 'name' ).length, 1, t_tables( 'name' ).offset );
    if dbms_lob.substr( t_blob, 2, 1 ) = hextoraw( '0000' ) -- format 0
    then
      t_offset := blob2num( t_blob, 2, 5 ) + 1;
      for j in 0 .. blob2num( t_blob, 2, 3 ) - 1
      loop
        if (   dbms_lob.substr( t_blob, 2, 7  + j * 12 ) = hextoraw( '0003' ) -- Windows
           and dbms_lob.substr( t_blob, 2, 11 + j * 12 ) = hextoraw( '0409' ) -- English United States
           )
        then
          case rawtohex( dbms_lob.substr( t_blob, 2, 13 + j * 12 ) )
            when '0001'
            then
              this_font.family := utl_i18n.raw_to_char( dbms_lob.substr( t_blob, blob2num( t_blob, 2, 15 + j * 12 ), t_offset + blob2num( t_blob, 2, 17 + j * 12 ) ), 'AL16UTF16' );
            when '0006'
            then
              this_font.name := utl_i18n.raw_to_char( dbms_lob.substr( t_blob, blob2num( t_blob, 2, 15 + j * 12 ), t_offset + blob2num( t_blob, 2, 17 + j * 12 ) ), 'AL16UTF16' );
            else
              null;
          end case;
        end if;
      end loop;
    end if;
--
    if this_font.italic_angle != 0
    then
      this_font.flags := this_font.flags + 64;
    end if;
    this_font.subtype := 'TrueType';
    this_font.stemv := 50;
    this_font.family := lower( this_font.family );
    this_font.encoding := utl_i18n.map_charset( p_encoding
                                              , utl_i18n.generic_context
                                              , utl_i18n.iana_to_oracle
                                              );
    this_font.encoding := nvl( this_font.encoding, upper( p_encoding ) );
    this_font.charset := sys_context( 'userenv', 'LANGUAGE' );
    this_font.charset := substr( this_font.charset
                               , 1
                               , instr( this_font.charset, '.' )
                               ) || this_font.encoding;
    this_font.cid := upper( p_encoding ) in ( 'CID', 'AL16UTF16', 'UTF', 'UNICODE' );
    this_font.fontname := this_font.name;
    this_font.compress_font := p_compress;
--
    if ( p_embed or this_font.cid ) and t_tables.exists( 'OS/2' )
    then
      dbms_lob.copy( t_blob, p_font, t_tables( 'OS/2' ).length, 1, t_tables( 'OS/2' ).offset );
      if blob2num( t_blob, 2, 9 ) != 2
      then
        this_font.fontfile2 := p_font;
        this_font.ttf_offset := p_offset;
        this_font.name := dbms_random.string( 'u', 6 ) || '+' || this_font.name;
--
        t_blob := dbms_lob.substr( p_font, t_tables( 'loca' ).length, t_tables( 'loca' ).offset );
        declare
          t_size pls_integer := 2 + this_font.indexToLocFormat * 2; -- 0 for short offsets, 1 for long
        begin
          for i in 0 .. this_font.numGlyphs
          loop
            this_font.loca( i ) := blob2num( t_blob, t_size, 1 + i * t_size );
          end loop;
        end;
      end if;
    end if;
--
    if not this_font.cid
    then
      if this_font.flags = 4 -- a symbolic font
      then
        declare
          t_real pls_integer;
        begin
          for t_code in 32 .. 255
          loop
            t_real := this_font.code2glyph.first + t_code - 32; -- assume code 32, space maps to the first code from the font
            if this_font.code2glyph.exists( t_real )
            then
              this_font.first_char := least( nvl( this_font.first_char, 255 ), t_code );
              this_font.last_char := t_code;
              if this_font.hmetrics.exists( this_font.code2glyph( t_real ) )
              then
                this_font.char_width_tab( t_code ) := trunc( this_font.hmetrics( this_font.code2glyph( t_real ) ) * this_font.unit_norm );
              else
                this_font.char_width_tab( t_code ) := trunc( this_font.hmetrics( this_font.hmetrics.last() ) * this_font.unit_norm );
              end if;
            else
              this_font.char_width_tab( t_code ) := trunc( this_font.hmetrics( 0 ) * this_font.unit_norm );
            end if;
          end loop;
        end;
      else
        declare
          t_unicode pls_integer;
          t_prv_diff pls_integer;
          t_utf16_charset varchar2(1000);
          t_winansi_charset varchar2(1000);
          t_glyphname tp_glyphname;
        begin
          t_prv_diff := -1;
          t_utf16_charset := substr( this_font.charset, 1, instr( this_font.charset, '.' ) ) || 'AL16UTF16';
          t_winansi_charset := substr( this_font.charset, 1, instr( this_font.charset, '.' ) ) || 'WE8MSWIN1252';
          for t_code in 32 .. 255
          loop
            t_unicode := utl_raw.cast_to_binary_integer( utl_raw.convert( hextoraw( to_char( t_code, 'fm0x' ) )
                                                                        , t_utf16_charset
                                                                        , this_font.charset
                                                                        )
                                                       );
            t_glyphname := '';
            this_font.char_width_tab( t_code ) := trunc( this_font.hmetrics( this_font.hmetrics.last() ) * this_font.unit_norm );
            if this_font.code2glyph.exists( t_unicode )
            then
              this_font.first_char := least( nvl( this_font.first_char, 255 ), t_code );
              this_font.last_char := t_code;
              if this_font.hmetrics.exists( this_font.code2glyph( t_unicode ) )
              then
                this_font.char_width_tab( t_code ) := trunc( this_font.hmetrics( this_font.code2glyph( t_unicode ) ) * this_font.unit_norm );
              end if;
              if t_glyph2name.exists( this_font.code2glyph( t_unicode ) )
              then
                if t_glyphnames.exists( t_glyph2name( this_font.code2glyph( t_unicode ) ) )
                then
                  t_glyphname := t_glyphnames( t_glyph2name( this_font.code2glyph( t_unicode ) ) );
                end if;
              end if;
            end if;
--
            if (   t_glyphname is not null
               and t_unicode != utl_raw.cast_to_binary_integer( utl_raw.convert( hextoraw( to_char( t_code, 'fm0x' ) )
                                                                               , t_winansi_charset
                                                                               , this_font.charset
                                                                               )
                                                              )
               )
            then
              this_font.diff := this_font.diff || case when t_prv_diff != t_code - 1 then ' ' || t_code end || ' /' || t_glyphname;
              t_prv_diff := t_code;
            end if;
          end loop;
        end;
        if this_font.diff is not null
        then
          this_font.diff := '/Differences [' || this_font.diff || ']';
        end if;
      end if;
    end if;
--
    t_font_ind := g_fonts.count( ) + 1;
    g_fonts( t_font_ind ) := this_font;
/*
--
dbms_output.put_line( this_font.fontname || ' ' || this_font.family || ' ' || this_font.style
|| ' ' || this_font.flags
|| ' ' || this_font.code2glyph.first
|| ' ' || this_font.code2glyph.prior( this_font.code2glyph.last )
|| ' ' || this_font.code2glyph.last
|| ' nr glyphs: ' || this_font.numGlyphs
 ); */
--
    return t_font_ind;
  end;
--
  procedure load_ttf_font
    ( p_font blob
    , p_encoding varchar2 := 'WINDOWS-1252'
    , p_embed boolean := false
    , p_compress boolean := true
    , p_offset number := 1
    )
  is
    t_tmp pls_integer;
  begin
    t_tmp := load_ttf_font( p_font, p_encoding, p_embed, p_compress );
  end;
--
  function load_ttf_font
    ( p_dir varchar2 := 'MY_FONTS'
    , p_filename varchar2 := 'BAUHS93.TTF'
    , p_encoding varchar2 := 'WINDOWS-1252'
    , p_embed boolean := false
    , p_compress boolean := true
    )
  return pls_integer
  is
  begin
    return load_ttf_font( file2blob( p_dir, p_filename ), p_encoding, p_embed, p_compress );
  end;
--
  procedure load_ttf_font
    ( p_dir varchar2 := 'MY_FONTS'
    , p_filename varchar2 := 'BAUHS93.TTF'
    , p_encoding varchar2 := 'WINDOWS-1252'
    , p_embed boolean := false
    , p_compress boolean := true
    )
  is
  begin
    load_ttf_font( file2blob( p_dir, p_filename ), p_encoding, p_embed, p_compress );
  end;
--
  procedure load_ttc_fonts
    ( p_ttc blob
    , p_encoding varchar2 := 'WINDOWS-1252'
    , p_embed boolean := false
    , p_compress boolean := true
    )
  is
    type tp_font_table is record
      ( offset pls_integer
      , length pls_integer
      );
    type tp_tables is table of tp_font_table index by varchar2(4);
    t_tables tp_tables;
    t_tag varchar2(4);
    t_blob blob;
    t_offset pls_integer;
    t_font_ind pls_integer;
  begin
    if utl_raw.cast_to_varchar2( dbms_lob.substr( p_ttc, 4, 1 ) ) != 'ttcf'
    then
      return;
    end if;
    for f in 0 .. blob2num( p_ttc, 4, 9 ) - 1
    loop
      t_font_ind := load_ttf_font( p_ttc, p_encoding, p_embed, p_compress, blob2num( p_ttc, 4, 13 + f * 4 ) + 1 );
    end loop;
  end;
--
  procedure load_ttc_fonts
    ( p_dir varchar2 := 'MY_FONTS'
    , p_filename varchar2 := 'CAMBRIA.TTC'
    , p_encoding varchar2 := 'WINDOWS-1252'
    , p_embed boolean := false
    , p_compress boolean := true
    )
  is
  begin
    load_ttc_fonts( file2blob( p_dir, p_filename ), p_encoding, p_embed, p_compress );
  end;
--
  function rgb( p_hex_rgb varchar2 )
  return varchar2
  is
  begin
    return to_char_round( nvl( to_number( substr( ltrim( p_hex_rgb, '#' )
                                                , 1, 2 )
                                        , 'xx' ) / 255
                              , 0 )
                         , 5 ) || ' '
        || to_char_round( nvl(   to_number( substr( ltrim( p_hex_rgb, '#' )
                                                , 3, 2 )
                                        , 'xx' ) / 255
                              , 0 )
                         , 5 ) || ' '
        || to_char_round( nvl(   to_number( substr( ltrim( p_hex_rgb, '#' )
                                                , 5, 2 )
                                        , 'xx' ) / 255
                              , 0 )
                         , 5 ) || ' ';
  end;
--
  procedure set_color( p_rgb varchar2 := '000000', p_backgr boolean )
  is
  begin
    txt2page( rgb( p_rgb ) || case when p_backgr then 'RG' else 'rg' end );
  end;
--
  procedure set_color( p_rgb varchar2 := '000000' )
  is
  begin
    set_color( p_rgb, false );
  end;
--
  procedure set_color
    ( p_red number := 0
    , p_green number := 0
    , p_blue number := 0
    )
  is
  begin
    if (     p_red between 0 and 255
       and p_blue  between 0 and 255
       and p_green between 0 and 255
       )
    then
      set_color(  to_char( p_red, 'fm0x' )
               || to_char( p_green, 'fm0x' )
               || to_char( p_blue, 'fm0x' )
               , false
               );
    end if;
  end;
--
  procedure set_bk_color( p_rgb varchar2 := 'ffffff' )
  is
  begin
    set_color( p_rgb, true );
  end;
--
  procedure set_bk_color
    ( p_red number := 0
    , p_green number := 0
    , p_blue number := 0
    )
  is
  begin
    if (     p_red between 0 and 255
       and p_blue  between 0 and 255
       and p_green between 0 and 255
       )
    then
      set_color(  to_char( p_red, 'fm0x' )
               || to_char( p_green, 'fm0x' )
               || to_char( p_blue, 'fm0x' )
               , true
               );
    end if;
  end;
--
  procedure horizontal_line
    ( p_x number
    , p_y number
    , p_width number
    , p_line_width number := 0.5
    , p_line_color varchar2 := '000000'
    )
  is
    t_use_color boolean;
  begin
    txt2page( 'q ' || to_char_round( p_line_width, 5 ) || ' w' );
    t_use_color := substr( p_line_color
                         , -6
                         ) != '000000';
    if t_use_color
    then
      set_color( p_line_color );
      set_bk_color( p_line_color );
    else
      txt2page( '0 g' );
    end if;
    txt2page(  to_char_round( p_x, 5 ) || ' '
            || to_char_round( p_y, 5 ) || ' m '
            || to_char_round( p_x + p_width, 5 ) || ' '
            || to_char_round( p_y, 5 ) || ' l b'
            );
    txt2page( 'Q' );
  end;
--
  procedure vertical_line
    ( p_x number
    , p_y number
    , p_height number
    , p_line_width number := 0.5
    , p_line_color varchar2 := '000000'
    )
  is
    t_use_color boolean;
  begin
    txt2page( 'q ' || to_char_round( p_line_width, 5 ) || ' w' );
    t_use_color := substr( p_line_color
                         , -6
                         ) != '000000';
    if t_use_color
    then
      set_color( p_line_color );
      set_bk_color( p_line_color );
    else
      txt2page( '0 g' );
    end if;
    txt2page(  to_char_round( p_x, 5 ) || ' '
            || to_char_round( p_y, 5 ) || ' m '
            || to_char_round( p_x, 5 ) || ' '
            || to_char_round( p_y + p_height, 5 ) || ' l b'
            );
    txt2page( 'Q' );
  end;
--
  procedure rect
    ( p_x number
    , p_y number
    , p_width number
    , p_height number
    , p_line_color varchar2 := null
    , p_fill_color varchar2 := null
    , p_line_width number := 0.5
    )
  is
  begin
    txt2page( 'q' );
    if substr( p_line_color, -6 ) != substr( p_fill_color, -6 )
    then
      txt2page( to_char_round( p_line_width, 5 ) || ' w' );
    end if;
    if substr( p_line_color, -6 ) != '000000'
    then
      set_bk_color( p_line_color );
    else
      txt2page( '0 g' );
    end if;
    if p_fill_color is not null
    then
      set_color( p_fill_color );
    end if;
    txt2page(  to_char_round( p_x, 5 ) || ' ' || to_char_round( p_y, 5 ) || ' '
            || to_char_round( p_width, 5 ) || ' ' || to_char_round( p_height, 5 ) || ' re '
            || case
                 when p_fill_color is null
                 then 'S'
                 else case when p_line_color is null then 'f' else 'b' end
               end
            );
    txt2page( 'Q' );
  end;
--
  function get( p_what pls_integer )
  return number
  is
  begin
    return case p_what
             when c_get_page_width    then g_settings.page_width
             when c_get_page_height   then g_settings.page_height
             when c_get_margin_top    then g_settings.margin_top
             when c_get_margin_right  then g_settings.margin_right
             when c_get_margin_bottom then g_settings.margin_bottom
             when c_get_margin_left   then g_settings.margin_left
             when c_get_x             then g_x
             when c_get_y             then g_y
             when c_get_fontsize      then g_fonts( g_current_font ).fontsize
             when c_get_current_font  then g_current_font
           end;
  end;
--
  function parse_jpg( p_img_blob blob )
  return tp_img
  is
    buf raw(4);
    t_img tp_img;
    t_ind integer;
  begin
    if (  dbms_lob.substr( p_img_blob, 2, 1 ) != hextoraw( 'FFD8' )                                      -- SOI Start of Image
       or dbms_lob.substr( p_img_blob, 2, dbms_lob.getlength( p_img_blob ) - 1 ) != hextoraw( 'FFD9' )   -- EOI End of Image
       )
    then  -- this is not a jpg I can handle
      return null;
    end if;
--
    t_img.pixels := p_img_blob;
    t_img.type := 'jpg';
    if dbms_lob.substr( t_img.pixels, 2, 3 ) in ( hextoraw( 'FFE0' )  -- a APP0 jpg
                                                , hextoraw( 'FFE1' )  -- a APP1 jpg
                                                )
    then
      t_img.color_res := 8;
      t_img.height := 1;
      t_img.width := 1;
--
      t_ind := 3;
      t_ind := t_ind + 2 + blob2num( t_img.pixels, 2, t_ind + 2 );
      loop
        buf := dbms_lob.substr( t_img.pixels, 2, t_ind );
        exit when buf = hextoraw( 'FFDA' );  -- SOS Start of Scan
        exit when buf = hextoraw( 'FFD9' );  -- EOI End Of Image
        exit when substr( rawtohex( buf ), 1, 2 ) != 'FF';
        if rawtohex( buf ) in ( 'FFD0'                                                          -- RSTn
                              , 'FFD1', 'FFD2', 'FFD3', 'FFD4', 'FFD5', 'FFD6', 'FFD7', 'FF01'  -- TEM
                              )
        then
          t_ind := t_ind + 2;
        else
          if buf = hextoraw( 'FFC0' )       -- SOF0 (Start Of Frame 0) marker
          then
            t_img.color_res := blob2num( t_img.pixels, 1, t_ind + 4 );
            t_img.height    := blob2num( t_img.pixels, 2, t_ind + 5 );
            t_img.width     := blob2num( t_img.pixels, 2, t_ind + 7 );
          end if;
          t_ind := t_ind + 2 + blob2num( t_img.pixels, 2, t_ind + 2 );
        end if;
      end loop;
    end if;
--
    return t_img;
  end;
--
  function parse_png( p_img_blob blob )
  return tp_img
  is
    t_img tp_img;
    buf raw(32767);
    len integer;
    ind integer;
    color_type pls_integer;
  begin
    if rawtohex( dbms_lob.substr( p_img_blob, 8, 1 ) ) != '89504E470D0A1A0A'  -- not the right signature
    then
      return null;
    end if;
    dbms_lob.createtemporary( t_img.pixels, true );
    ind := 9;
    loop
      len := blob2num( p_img_blob, 4, ind );  -- length
      exit when len is null or ind > dbms_lob.getlength( p_img_blob );
      case utl_raw.cast_to_varchar2( dbms_lob.substr( p_img_blob, 4, ind + 4 ) )  -- Chunk type
        when 'IHDR'
        then
          t_img.width     := blob2num( p_img_blob, 4, ind + 8 );
          t_img.height    := blob2num( p_img_blob, 4, ind + 12 );
          t_img.color_res := blob2num( p_img_blob, 1, ind + 16 );
          color_type      := blob2num( p_img_blob, 1, ind + 17 );
          t_img.greyscale := color_type in ( 0, 4 );
        when 'PLTE'
        then
          t_img.color_tab := dbms_lob.substr( p_img_blob, len, ind + 8 );
        when 'IDAT'
        then
          dbms_lob.copy( t_img.pixels, p_img_blob, len, dbms_lob.getlength( t_img.pixels ) + 1, ind + 8 );
        when 'IEND'
        then
          exit;
        else
          null;
      end case;
      ind := ind + 4 + 4 + len + 4;  -- Length + Chunk type + Chunk data + CRC
    end loop;
--
    t_img.type := 'png';
    t_img.nr_colors := case color_type
                         when 0 then 1
                         when 2 then 3
                         when 3 then 1
                         when 4 then 2
                         else 4
                       end;
--
    return t_img;
  end;
--
  function lzw_decompress
    ( p_blob blob
    , p_bits pls_integer
    )
  return blob
  is
    powers tp_pls_tab;
--
    g_lzw_ind pls_integer;
    g_lzw_bits pls_integer;
    g_lzw_buffer pls_integer;
    g_lzw_bits_used pls_integer;
--
    type tp_lzw_dict is table of raw(1000) index by pls_integer;
    t_lzw_dict tp_lzw_dict;
    t_clr_code pls_integer;
    t_nxt_code pls_integer;
    t_new_code pls_integer;
    t_old_code pls_integer;
    t_blob blob;
--
    function get_lzw_code
    return pls_integer
    is
      t_rv pls_integer;
    begin
      while g_lzw_bits_used < g_lzw_bits
      loop
        g_lzw_ind := g_lzw_ind + 1;
        g_lzw_buffer := blob2num( p_blob, 1, g_lzw_ind ) * powers( g_lzw_bits_used ) + g_lzw_buffer;
        g_lzw_bits_used := g_lzw_bits_used + 8;
      end loop;
      t_rv := bitand( g_lzw_buffer, powers( g_lzw_bits ) - 1 );
      g_lzw_bits_used := g_lzw_bits_used - g_lzw_bits;
      g_lzw_buffer := trunc( g_lzw_buffer / powers( g_lzw_bits ) );
      return t_rv;
    end;
--
  begin
    for i in 0 .. 30
    loop
      powers( i ) := power( 2, i );
    end loop;
--
    t_clr_code := powers( p_bits - 1 );
    t_nxt_code := t_clr_code + 2;
    for i in 0 .. least( t_clr_code - 1, 255 )
    loop
      t_lzw_dict( i ) := hextoraw( to_char( i, 'fm0X' ) );
    end loop;
    dbms_lob.createtemporary( t_blob, true );
    g_lzw_ind := 0;
    g_lzw_bits := p_bits;
    g_lzw_buffer := 0;
    g_lzw_bits_used := 0;
--
    t_old_code := null;
    t_new_code := get_lzw_code( );
    loop
      case nvl( t_new_code, t_clr_code + 1 )
        when t_clr_code + 1
        then
          exit;
        when t_clr_code
        then
          t_new_code := null;
          g_lzw_bits := p_bits;
          t_nxt_code := t_clr_code + 2;
        else
          if t_new_code = t_nxt_code
          then
            t_lzw_dict( t_nxt_code ) :=
              utl_raw.concat( t_lzw_dict( t_old_code )
                            , utl_raw.substr( t_lzw_dict( t_old_code ), 1, 1 )
                            );
            dbms_lob.append( t_blob, t_lzw_dict( t_nxt_code ) );
            t_nxt_code := t_nxt_code + 1;
          elsif t_new_code > t_nxt_code
          then
            exit;
          else
            dbms_lob.append( t_blob, t_lzw_dict( t_new_code ) );
            if t_old_code is not null
            then
              t_lzw_dict( t_nxt_code ) := utl_raw.concat( t_lzw_dict( t_old_code )
                                                        , utl_raw.substr( t_lzw_dict( t_new_code ), 1, 1 )
                                                        );
              t_nxt_code := t_nxt_code + 1;
            end if;
          end if;
          if     bitand( t_nxt_code, powers( g_lzw_bits ) - 1 ) = 0
             and g_lzw_bits < 12
          then
            g_lzw_bits := g_lzw_bits + 1;
          end if;
      end case;
      t_old_code := t_new_code;
      t_new_code := get_lzw_code( );
    end loop;
    t_lzw_dict.delete;
--
    return t_blob;
  end;
--
  function parse_gif( p_img_blob blob )
  return tp_img
  is
    img tp_img;
    buf raw(4000);
    ind integer;
    t_len pls_integer;
  begin
    if dbms_lob.substr( p_img_blob, 3, 1 ) != utl_raw.cast_to_raw( 'GIF' )
    then
      return null;
    end if;
    ind := 7;
    buf := dbms_lob.substr( p_img_blob, 7, 7 );  --  Logical Screen Descriptor
    ind := ind + 7;
    img.color_res := raw2num( utl_raw.bit_and( utl_raw.substr( buf, 5, 1 ), hextoraw( '70' ) ) ) / 16 + 1;
    img.color_res := 8;
    if raw2num( buf, 5, 1 ) > 127
    then
      t_len := 3 * power( 2, raw2num( utl_raw.bit_and( utl_raw.substr( buf, 5, 1 ), hextoraw( '07' ) ) ) + 1 );
      img.color_tab := dbms_lob.substr( p_img_blob, t_len, ind  ); -- Global Color Table
      ind := ind + t_len;
    end if;
--
    loop
      case dbms_lob.substr( p_img_blob, 1, ind )
        when hextoraw( '3B' ) -- trailer
        then
          exit;
        when hextoraw( '21' ) -- extension
        then
          if dbms_lob.substr( p_img_blob, 1, ind + 1 ) = hextoraw( 'F9' )
          then -- Graphic Control Extension
            if utl_raw.bit_and( dbms_lob.substr( p_img_blob, 1, ind + 3 ), hextoraw( '01' ) ) = hextoraw( '01' )
            then -- Transparent Color Flag set
              img.transparancy_index := blob2num( p_img_blob, 1, ind + 6 );
            end if;
          end if;
          ind := ind + 2; -- skip sentinel + label
          loop
            t_len := blob2num( p_img_blob, 1, ind ); -- Block Size
            exit when t_len = 0;
            ind := ind + 1 + t_len; -- skip Block Size + Data Sub-block
          end loop;
          ind := ind + 1;           -- skip last Block Size
        when hextoraw( '2C' )       -- image
        then
          declare
            img_blob blob;
            min_code_size pls_integer;
            code_size pls_integer;
            flags raw(1);
          begin
            img.width := utl_raw.cast_to_binary_integer( dbms_lob.substr( p_img_blob, 2, ind + 5 )
                                                       , utl_raw.little_endian
                                                       );
            img.height := utl_raw.cast_to_binary_integer( dbms_lob.substr( p_img_blob, 2, ind + 7 )
                                                        , utl_raw.little_endian
                                                        );
            img.greyscale := false;
            ind := ind + 1 + 8;                   -- skip sentinel + img sizes
            flags := dbms_lob.substr( p_img_blob, 1, ind );
            if utl_raw.bit_and( flags, hextoraw( '80' ) ) = hextoraw( '80' )
            then
              t_len := 3 * power( 2, raw2num( utl_raw.bit_and( flags, hextoraw( '07' ) ) ) + 1 );
              img.color_tab := dbms_lob.substr( p_img_blob, t_len, ind + 1 );          -- Local Color Table
            end if;
            ind := ind + 1;                                -- skip image Flags
            min_code_size := blob2num( p_img_blob, 1, ind );
            ind := ind + 1;                      -- skip LZW Minimum Code Size
            dbms_lob.createtemporary( img_blob, true );
            loop
              t_len := blob2num( p_img_blob, 1, ind ); -- Block Size
              exit when t_len = 0;
              dbms_lob.append( img_blob, dbms_lob.substr( p_img_blob, t_len, ind + 1 ) ); -- Data Sub-block
              ind := ind + 1 + t_len;      -- skip Block Size + Data Sub-block
            end loop;
            ind := ind + 1;                            -- skip last Block Size
            img.pixels := lzw_decompress( img_blob, min_code_size + 1 );
--
            if utl_raw.bit_and( flags, hextoraw( '40' ) ) = hextoraw( '40' )
            then                                        --  interlaced
              declare
                pass pls_integer;
                pass_ind tp_pls_tab;
              begin
                dbms_lob.createtemporary( img_blob, true );
                pass_ind( 1 ) := 1;
                pass_ind( 2 ) := trunc( ( img.height - 1 ) / 8 ) + 1;
                pass_ind( 3 ) := pass_ind( 2 ) + trunc( ( img.height + 3 ) / 8 );
                pass_ind( 4 ) := pass_ind( 3 ) + trunc( ( img.height + 1 ) / 4 );
                pass_ind( 2 ) := pass_ind( 2 ) * img.width + 1;
                pass_ind( 3 ) := pass_ind( 3 ) * img.width + 1;
                pass_ind( 4 ) := pass_ind( 4 ) * img.width + 1;
                for i in 0 .. img.height - 1
                loop
                  pass := case mod( i, 8 )
                            when 0 then 1
                            when 4 then 2
                            when 2 then 3
                            when 6 then 3
                            else 4
                          end;
                  dbms_lob.append( img_blob, dbms_lob.substr( img.pixels, img.width, pass_ind( pass ) ) );
                  pass_ind( pass ) := pass_ind( pass ) + img.width;
                end loop;
                img.pixels := img_blob;
              end;
            end if;
--
            dbms_lob.freetemporary( img_blob );
          end;
        else
          exit;
      end case;
    end loop;
--
    img.type := 'gif';
    return img;
  end;
--
  function parse_img
    ( p_blob in blob
    , p_adler32 in varchar2 := null
    , p_type in varchar2 := null
    )
  return tp_img
  is
    t_img tp_img;
  begin
    t_img.type := p_type;
    if t_img.type is null
    then
      if rawtohex( dbms_lob.substr( p_blob, 8, 1 ) ) = '89504E470D0A1A0A'
      then
        t_img.type := 'png';
      elsif dbms_lob.substr( p_blob , 3, 1 ) = utl_raw.cast_to_raw( 'GIF' )
      then
        t_img.type := 'gif';
      else
        t_img.type := 'jpg';
      end if;
    end if;
--
    t_img := case lower( t_img.type )
               when 'gif' then parse_gif( p_blob )
               when 'png' then parse_png( p_blob )
               when 'jpg' then parse_jpg( p_blob )
               else null
             end;
--
    if t_img.type is not null
    then
      t_img.adler32 := coalesce( p_adler32, adler32( p_blob ) );
    end if;
    return t_img;
  end;
--
  procedure put_image
    ( p_img blob
    , p_x number
    , p_y number
    , p_width number := null
    , p_height number := null
    , p_align varchar2 := 'center'
    , p_valign varchar2 := 'top'
    , p_adler32 varchar2 := null
  )
  is
    t_x number;
    t_y number;
    t_img tp_img;
    t_ind pls_integer;
    t_adler32 varchar2(8):=p_adler32;
  begin
    if p_img is null
    then
      return;
    end if;
    if t_adler32 is null then
      t_adler32 := adler32( p_img );
    end if;
    t_ind := g_images.first;
    while t_ind is not null
    loop
      exit when g_images( t_ind ).adler32 = t_adler32;
      t_ind := g_images.next( t_ind );
    end loop;
--
    if t_ind is null
    then
      t_img := parse_img( p_img, t_adler32 );
      if t_img.adler32 is null
      then
        return;
      end if;
      t_ind := g_images.count( ) + 1;
      g_images( t_ind ) := t_img;
    end if;
--
    t_x := case substr( upper( p_align ), 1, 1 )
             when 'L' then p_x -- left
             when 'S' then p_x -- start
             when 'R' then p_x + nvl( p_width, 0 ) - g_images( t_ind ).width -- right
             when 'E' then p_x + nvl( p_width, 0 ) - g_images( t_ind ).width -- end
             else ( p_x + nvl( p_width, 0 ) - g_images( t_ind ).width ) / 2       -- center
           end;
    t_y := case substr( upper( p_valign ), 1, 1 )
             when 'C' then ( p_y - nvl( p_height, 0 ) + g_images( t_ind ).height ) / 2  -- center
             when 'B' then p_y - nvl( p_height, 0 ) + g_images( t_ind ).height -- bottom
             else p_y                                          -- top
           end;
--
    txt2page( 'q ' || to_char_round( least( nvl( p_width, g_images( t_ind ).width ), g_images( t_ind ).width ) )
            || ' 0 0 ' || to_char_round( least( nvl( p_height, g_images( t_ind ).height ), g_images( t_ind ).height ) )
            || ' ' || to_char_round( t_x ) || ' ' || to_char_round( t_y )
            || ' cm /I' || to_char( t_ind ) || ' Do Q'
            );
  end;
--
  procedure put_image
    ( p_dir varchar2
    , p_file_name varchar2
    , p_x number
    , p_y number
    , p_width number := null
    , p_height number := null
    , p_align varchar2 := 'center'
    , p_valign varchar2 := 'top'
    , p_adler32 varchar2 := null
  )
  is
    t_blob blob;
  begin
    t_blob := file2blob( p_dir
                       , p_file_name
                       );
    put_image( t_blob
             , p_x
             , p_y
             , p_width
             , p_height
             , p_align
             , p_valign
             , p_adler32
             );
    dbms_lob.freetemporary( t_blob );
  end;
--
  procedure put_image
    ( p_url varchar2
    , p_x number
    , p_y number
    , p_width number := null
    , p_height number := null
    , p_align varchar2 := 'center'
    , p_valign varchar2 := 'top'
    , p_adler32 varchar2 := null
    )
  is
    t_blob blob;
  begin
    t_blob := httpuritype( p_url ).getblob( );
    put_image( t_blob
             , p_x
             , p_y
             , p_width
             , p_height
             , p_align
             , p_valign
             , p_adler32
             );
    dbms_lob.freetemporary( t_blob );
  end;
--
  procedure set_page_proc( p_src clob )
  is
  begin
    g_page_prcs( g_page_prcs.count ) := p_src;
  end;
--
  procedure cursor2table
    ( p_c integer
    , p_widths tp_col_widths := null
    , p_headers tp_headers := null
    )
  is
    t_col_cnt integer;
$IF DBMS_DB_VERSION.VER_LE_10 $THEN
    t_desc_tab dbms_sql.desc_tab2;
$ELSE
    t_desc_tab dbms_sql.desc_tab3;
$END
    d_tab dbms_sql.date_table;
    n_tab dbms_sql.number_table;
    v_tab dbms_sql.varchar2_table;
    t_bulk_size pls_integer := 200;
    t_r integer;
    t_cur_row pls_integer;
    type tp_integer_tab is table of integer;
    t_chars tp_integer_tab := tp_integer_tab( 1, 8, 9, 96, 112 );
    t_dates tp_integer_tab := tp_integer_tab( 12, 178, 179, 180, 181 , 231 );
    t_numerics tp_integer_tab := tp_integer_tab( 2, 100, 101 );
    t_widths tp_col_widths;
    t_tmp number;
    t_x number;
    t_y number;
    t_start_x number;
    t_lineheight number;
    t_padding number := 2;
    t_num_format varchar2(100) := 'tm9';
    t_date_format varchar2(100) := 'dd.mm.yyyy';
    t_txt varchar2(32767);
    c_rf number := 0.2; -- raise factor of text above cell bottom
--
    procedure show_header
    is
    begin
      if p_headers is not null and p_headers.count > 0
      then
        t_x := t_start_x;
        for c in 1 .. t_col_cnt
        loop
          rect( t_x, t_y, t_widths( c ), t_lineheight );
          if c <= p_headers.count
          then
            put_txt( t_x + t_padding, t_y + c_rf * t_lineheight, p_headers( c ) );
          end if;
          t_x := t_x + t_widths( c );
        end loop;
        t_y := t_y - t_lineheight;
      end if;
    end;
--
  begin
$IF DBMS_DB_VERSION.VER_LE_10 $THEN
    dbms_sql.describe_columns2( p_c, t_col_cnt, t_desc_tab );
$ELSE
    dbms_sql.describe_columns3( p_c, t_col_cnt, t_desc_tab );
$END
    if p_widths is null or p_widths.count < t_col_cnt
    then
      t_tmp := get( c_get_page_width ) - get( c_get_margin_left ) - get( c_get_margin_right );
      t_widths := tp_col_widths();
      t_widths.extend( t_col_cnt );
      for c in 1 .. t_col_cnt
      loop
        t_widths( c ) := round( t_tmp / t_col_cnt, 1 );
      end loop;
    else
      t_widths := p_widths;
    end if;
--
    if get( c_get_current_font ) is null
    then
      set_font( 'helvetica', 12 );
    end if;
--
    for c in 1 .. t_col_cnt
    loop
      case
        when t_desc_tab( c ).col_type member of t_numerics
        then
          dbms_sql.define_array( p_c, c, n_tab, t_bulk_size, 1 );
        when t_desc_tab( c ).col_type member of t_dates
        then
          dbms_sql.define_array( p_c, c, d_tab, t_bulk_size, 1 );
        when t_desc_tab( c ).col_type member of t_chars
        then
          dbms_sql.define_array( p_c, c, v_tab, t_bulk_size, 1 );
        else
          null;
      end case;
    end loop;
--
    t_start_x := get( c_get_margin_left );
    t_lineheight := get( c_get_fontsize ) * 1.2;
    t_y := coalesce( get( c_get_y ) - t_lineheight, get( c_get_page_height ) - get( c_get_margin_top ) ) - t_lineheight;
--
    show_header;
--
    loop
      t_r := dbms_sql.fetch_rows( p_c );
      for i in 0 .. t_r - 1
      loop
        if t_y < get( c_get_margin_bottom )
        then
          new_page;
          t_y := get( c_get_page_height ) - get( c_get_margin_top ) - t_lineheight;
          show_header;
        end if;
        t_x := t_start_x;
        for c in 1 .. t_col_cnt
        loop
          case
            when t_desc_tab( c ).col_type member of t_numerics
            then
              n_tab.delete;
              dbms_sql.column_value( p_c, c, n_tab );
              rect( t_x, t_y, t_widths( c ), t_lineheight );
              t_txt := to_char( n_tab( i + n_tab.first() ), t_num_format );
              if t_txt is not null
              then
                put_txt( t_x + t_widths( c ) - t_padding - str_len( t_txt ), t_y + c_rf * t_lineheight, t_txt );
              end if;
              t_x := t_x + t_widths( c );
            when t_desc_tab( c ).col_type member of t_dates
            then
              d_tab.delete;
              dbms_sql.column_value( p_c, c, d_tab );
              rect( t_x, t_y, t_widths( c ), t_lineheight );
              t_txt := to_char( d_tab( i + d_tab.first() ), t_date_format );
              if t_txt is not null
              then
                put_txt( t_x + t_padding, t_y + c_rf * t_lineheight, t_txt );
              end if;
              t_x := t_x + t_widths( c );
            when t_desc_tab( c ).col_type member of t_chars
            then
              v_tab.delete;
              dbms_sql.column_value( p_c, c, v_tab );
              rect( t_x, t_y, t_widths( c ), t_lineheight );
              t_txt := v_tab( i + v_tab.first() );
              if t_txt is not null
              then
                put_txt( t_x + t_padding, t_y + c_rf * t_lineheight, t_txt );
              end if;
              t_x := t_x + t_widths( c );
            else
              null;
          end case;
        end loop;
        t_y := t_y - t_lineheight;
      end loop;
      exit when t_r != t_bulk_size;
    end loop;
    g_y := t_y;
  end;
--
  procedure query2table
    ( p_query varchar2
    , p_widths tp_col_widths := null
    , p_headers tp_headers := null
    )
  is
    t_cx integer;
    t_dummy integer;
  begin
    t_cx := dbms_sql.open_cursor;
    dbms_sql.parse( t_cx, p_query, dbms_sql.native );
    t_dummy := dbms_sql.execute( t_cx );
    cursor2table( t_cx, p_widths, p_headers );
    dbms_sql.close_cursor( t_cx );
  end;

  PROCEDURE PR_GOTO_PAGE(i_nPage IN NUMBER) IS
  BEGIN
    IF i_nPage<=g_pages.count THEN
      g_page_nr:=i_nPage-1;
    END IF;
  END;

  PROCEDURE PR_GOTO_CURRENT_PAGE IS
  BEGIN
    g_page_nr:=NULL;
  END;

  FUNCTION FK_GET_PAGE
  RETURN NUMBER IS
  BEGIN
    RETURN g_page_nr;
  END;

  PROCEDURE PR_LINE(i_nX1         IN NUMBER,
                    i_nY1         IN NUMBER,
                    i_nX2         IN NUMBER,
                    i_nY2         IN NUMBER,
                    i_vcLineColor IN VARCHAR2 DEFAULT NULL,
                    i_nLineWidth  IN NUMBER DEFAULT 0.5,
                    i_vcStroke    IN VARCHAR2 DEFAULT NULL
                   ) IS
  BEGIN
    txt2page('q ' );
    txt2page(to_char_round(i_nLineWidth, 5 ) || ' w' );
    IF SUBSTR(i_vcLineColor, -6 ) != '000000' THEN
      set_bk_color(i_vcLineColor);
    ELSE
      txt2page( '0 g' );
    END IF;

    txt2page('n ');
    IF i_vcStroke IS NOT NULL THEN
      txt2page(i_vcStroke || ' d ');
    END IF;
    txt2page(to_char_round(i_nX1, 5) || ' ' || to_char_round(i_nY1, 5) || ' m ');
    txt2page(to_char_round(i_nX2, 5) || ' ' || to_char_round(i_nY2, 5) || ' l S Q');
  END;

  PROCEDURE PR_POLYGON(i_lXs         IN tVertices,
                       i_lYs         IN tVertices,
                       i_vcLineColor IN VARCHAR2 DEFAULT NULL,
                       i_vcFillColor IN VARCHAR2 DEFAULT NULL,
                       i_nLineWidth  IN NUMBER DEFAULT 0.5
                      ) IS
    vcBuffer VARCHAR2(32767);
  BEGIN
    IF i_lXs.COUNT>0 AND i_lXs.COUNT=i_lYs.COUNT THEN
      txt2page('q ' );
      IF SUBSTR(i_vcLineColor, -6 ) != SUBSTR(i_vcFillColor, -6 ) THEN
        txt2page( to_char_round(i_nLineWidth, 5 ) || ' w' );
      END IF;
      IF SUBSTR(i_vcLineColor, -6 ) != '000000' THEN
        set_bk_color(i_vcLineColor);
      ELSE
        txt2page( '0 g' );
      END IF;
      IF i_vcFillColor IS NOT NULL THEN
        set_color(i_vcFillColor);
      END IF;
      txt2page(' 2.00000 M ');
      txt2page('n ');

      vcBuffer:=to_char_round(i_lXs(1), 5) || ' ' || to_char_round(i_lYs(1), 5) || ' m ';
      FOR i IN 2..i_lXs.COUNT LOOP
        vcBuffer:=vcBuffer || to_char_round(i_lXs(i), 5) || ' ' || to_char_round(i_lYs(i), 5) || ' l ';
      END LOOP;
      vcBuffer:=vcBuffer || to_char_round(i_lXs(1), 5) || ' ' || to_char_round(i_lYs(1), 5) || ' l ';
      vcBuffer:=vcBuffer || CASE WHEN i_vcFillColor IS NULL THEN
                               'S'
                            ELSE CASE WHEN i_vcLineColor IS NULL THEN
                                   'f'
                                 ELSE
                                   'b'
                                 END
                            END;

      txt2page( vcBuffer || ' Q' );
    END IF;
  END;

  PROCEDURE PR_PATH(i_lPath       IN tPath,
                    i_vcLineColor IN VARCHAR2 DEFAULT NULL,
                    i_vcFillColor IN VARCHAR2 DEFAULT NULL,
                    i_nLineWidth  IN NUMBER DEFAULT 0.5
                   ) IS
    vcBuffer VARCHAR2(32767);
  BEGIN
    txt2page('q ' );

    IF SUBSTR(i_vcLineColor, -6) != SUBSTR(i_vcFillColor, -6) THEN
      txt2page(to_char_round(i_nLineWidth, 5) || ' w' );
    END IF;
    IF SUBSTR(i_vcLineColor, -6) != '000000' THEN
      set_bk_color(i_vcLineColor);
    ELSE
      txt2page('0 g');
    END IF;
    IF i_vcFillColor IS NOT NULL THEN
      set_color(i_vcFillColor);
    END IF;

    txt2page('n ');
    FOR i IN 1..i_lPath.COUNT LOOP
      IF i_lPath(i).nType=PATH_MOVE_TO THEN
        vcBuffer:=vcBuffer|| to_char_round( i_lPath(i).nVal1, 5 ) || ' ' ||
                             to_char_round( i_lPath(i).nVal2, 5 ) || ' m ';
      ELSIF i_lPath(i).nType=PATH_LINE_TO THEN
        vcBuffer:=vcBuffer || to_char_round( i_lPath(i).nVal1, 5 ) || ' ' ||
                              to_char_round( i_lPath(i).nVal2, 5 ) || ' l ';
      ELSIF i_lPath(i).nType=PATH_CURVE_TO THEN
        vcBuffer:=vcBuffer || to_char_round( i_lPath(i).nVal1,5)  || ' ' ||
                              to_char_round( i_lPath(i).nVal2,5)  || ' ' ||
                              to_char_round( i_lPath(i).nVal3,5)  || ' ' ||
                              to_char_round( i_lPath(i).nVal4,5)  || ' ' ||
                              to_char_round( i_lPath(i).nVal5,5)  || ' ' ||
                              to_char_round( i_lPath(i).nVal6,5)  || ' c ';
      ELSIF i_lPath(i).nType=PATH_CLOSE THEN
        vcBuffer:=vcBuffer || CASE WHEN i_vcFillColor IS NULL THEN
                                'S'
                               ELSE CASE WHEN i_vcLineColor IS NULL THEN
                                      'f'
                                    ELSE
                                      'b'
                                    END
                               END;
      END IF;
    END LOOP;

    txt2page( vcBuffer || ' Q' );
  END;

$IF not DBMS_DB_VERSION.VER_LE_10 $THEN
--
  procedure refcursor2table
    ( p_rc sys_refcursor
    , p_widths tp_col_widths := null
    , p_headers tp_headers := null
    )
  is
    t_cx integer;
    t_rc sys_refcursor;
  begin
    t_rc := p_rc;
    t_cx := dbms_sql.to_cursor_number( t_rc );
    cursor2table( t_cx, p_widths, p_headers );
    dbms_sql.close_cursor( t_cx );
  end;
$END

begin
  for i IN 0..255 LOOP
    lHex(TO_CHAR(i, 'FM0X')):=i;
  end loop;
end;

/
--------------------------------------------------------
--  DDL for Package Body DIALOG_DEMO
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."DIALOG_DEMO" as
-- use $0$, $1$ ... for client side value substitutions
function prepare_dialog_url (
    p_url in varchar2 )
    return varchar2
is
begin
    return regexp_substr(
           apex_util.prepare_url( p_url ), 'f\?p=[^'']*');
end prepare_dialog_url;
end dialog_demo;

/
--------------------------------------------------------
--  DDL for Package Body FUNDAUC_PKG
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."FUNDAUC_PKG" 
as
    procedure setSede(sede varchar2) is
    begin
        dbms_session.set_context('fundauc_ctx','sede',sede);
    end;

    procedure setProgAcad(prog number) is
    begin
        dbms_session.set_context('fundauc_ctx','prog',prog);
    end;
end fundauc_pkg;

/
--------------------------------------------------------
--  DDL for Package Body GLOBAL
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."GLOBAL" AS

    FUNCTION getval (
        pvar VARCHAR2
    ) RETURN VARCHAR2 AS
        l_val VARCHAR2(255);
    BEGIN
        SELECT
            value
        INTO l_val
        FROM
            global_value
        where upper(var) = upper(pvar);

        RETURN l_val;
    EXCEPTION
        WHEN no_data_found THEN
            raise_application_error(-20000, 'No Existe la variable ' || pvar);
    END;

    PROCEDURE setval (
        pvar   IN     VARCHAR2,
        pval   IN     VARCHAR2
    ) AS
        PRAGMA autonomous_transaction;
        l_val VARCHAR2(255); 
    BEGIN
        SELECT
            value
        INTO l_val
        FROM
            global_value
        WHERE
            upper(var) = upper(pvar);

        UPDATE global_value
        SET
            value = pval
        WHERE
            upper(var) = upper(pvar);

        COMMIT;
    EXCEPTION
        WHEN no_data_found THEN
            INSERT INTO global_value VALUES (
                coalesce(sys_context('APEX$SESSION', 'app_user'), regexp_substr(sys_context('userenv', 'client_identifier'), '^[^:]*'
                ), sys_context('userenv', 'session_user')),
                pvar,
                pval
            );
            commit;

    END;

END;

/
--------------------------------------------------------
--  DDL for Package Body PRETIUS_APEX_NESTED_REPORTS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."PRETIUS_APEX_NESTED_REPORTS" is

  ------------------------
  function printAttributes(
    p_dynamic_action_render_result in apex_plugin.t_dynamic_action_render_result
  ) return clob is
    
  begin

    apex_json.initialize_clob_output;

    apex_json.open_object;
    apex_json.write( 'type', 'apex_plugin.t_dynamic_action_render_result' );

    apex_json.write( 'javascript_function'  , p_dynamic_action_render_result.javascript_function  );
    apex_json.write( 'ajax_identifier'      , p_dynamic_action_render_result.ajax_identifier  );
    apex_json.write( 'attribute_01'         , p_dynamic_action_render_result.attribute_01 );
    apex_json.write( 'attribute_02'         , p_dynamic_action_render_result.attribute_02 );
    apex_json.write( 'attribute_03'         , p_dynamic_action_render_result.attribute_03 );
    apex_json.write( 'attribute_04'         , p_dynamic_action_render_result.attribute_04 );
    apex_json.write( 'attribute_05'         , p_dynamic_action_render_result.attribute_05 );
    apex_json.write( 'attribute_06'         , p_dynamic_action_render_result.attribute_06 );
    apex_json.write( 'attribute_07'         , p_dynamic_action_render_result.attribute_07 );
    apex_json.write( 'attribute_08'         , p_dynamic_action_render_result.attribute_08 );
    apex_json.write( 'attribute_09'         , p_dynamic_action_render_result.attribute_09 );
    apex_json.write( 'attribute_10'         , p_dynamic_action_render_result.attribute_10 );
    apex_json.write( 'attribute_11'         , p_dynamic_action_render_result.attribute_11 );
    apex_json.write( 'attribute_12'         , p_dynamic_action_render_result.attribute_12 );
    apex_json.write( 'attribute_13'         , p_dynamic_action_render_result.attribute_13 );
    apex_json.write( 'attribute_14'         , p_dynamic_action_render_result.attribute_14 );
    apex_json.write( 'attribute_15'         , p_dynamic_action_render_result.attribute_15 );

    apex_json.close_object;

    return apex_json.get_clob_output;

  end printAttributes;


  ------------------------
  function printAttributes(
    p_plugin in apex_plugin.t_plugin
  ) return clob is

  begin

    apex_json.initialize_clob_output;

    apex_json.open_object;
    apex_json.write( 'type', 'apex_plugin.t_plugin' );

    apex_json.write( 'name'        , p_plugin.name         );
    apex_json.write( 'file_prefix' , p_plugin.file_prefix  );
    apex_json.write( 'attribute_01', p_plugin.attribute_01 );
    apex_json.write( 'attribute_02', p_plugin.attribute_02 );
    apex_json.write( 'attribute_03', p_plugin.attribute_03 );
    apex_json.write( 'attribute_04', p_plugin.attribute_04 );
    apex_json.write( 'attribute_05', p_plugin.attribute_05 );
    apex_json.write( 'attribute_06', p_plugin.attribute_06 );
    apex_json.write( 'attribute_07', p_plugin.attribute_07 );
    apex_json.write( 'attribute_08', p_plugin.attribute_08 );
    apex_json.write( 'attribute_09', p_plugin.attribute_09 );
    apex_json.write( 'attribute_10', p_plugin.attribute_10 );
    apex_json.write( 'attribute_11', p_plugin.attribute_11 );
    apex_json.write( 'attribute_12', p_plugin.attribute_12 );
    apex_json.write( 'attribute_13', p_plugin.attribute_13 );
    apex_json.write( 'attribute_14', p_plugin.attribute_14 );
    apex_json.write( 'attribute_15', p_plugin.attribute_15 );

    apex_json.close_object;

    return apex_json.get_clob_output;

  end printAttributes;

  ------------------------
  function printAttributes(
    p_dynamic_action in apex_plugin.t_dynamic_action
  ) return clob is

  begin

    apex_json.initialize_clob_output;

    apex_json.open_object;
    apex_json.write( 'type', 'apex_plugin.t_dynamic_action' );

    apex_json.write( 'id'          , p_dynamic_action.id          , false );
    apex_json.write( 'action'      , p_dynamic_action.action      , false );
    apex_json.write( 'attribute_01', p_dynamic_action.attribute_01, true );
    apex_json.write( 'attribute_02', p_dynamic_action.attribute_02, true );
    apex_json.write( 'attribute_03', p_dynamic_action.attribute_03, true );
    apex_json.write( 'attribute_04', p_dynamic_action.attribute_04, true );
    apex_json.write( 'attribute_05', p_dynamic_action.attribute_05, true );
    apex_json.write( 'attribute_06', p_dynamic_action.attribute_06, true );
    apex_json.write( 'attribute_07', p_dynamic_action.attribute_07, true );
    apex_json.write( 'attribute_08', p_dynamic_action.attribute_08, true );
    apex_json.write( 'attribute_09', p_dynamic_action.attribute_09, true );
    apex_json.write( 'attribute_10', p_dynamic_action.attribute_10, true );
    apex_json.write( 'attribute_11', p_dynamic_action.attribute_11, true );
    apex_json.write( 'attribute_12', p_dynamic_action.attribute_12, true );
    apex_json.write( 'attribute_13', p_dynamic_action.attribute_13, true );
    apex_json.write( 'attribute_14', p_dynamic_action.attribute_14, true );
    apex_json.write( 'attribute_15', p_dynamic_action.attribute_15, true );

    apex_json.close_object;

    return apex_json.get_clob_output;

  end printAttributes;

  --------------------------------
  function getColumnNamesFromQuery(
    p_string in varchar2
  ) return clob is
    v_count   number;
    v_pattern varchar2(50) := '#.+?#';

  begin
    apex_json.initialize_clob_output;

    v_count := regexp_count(p_string, v_pattern, 1, 'm');

    apex_json.open_object;
    apex_json.open_array('queryColumns');

    for i in 1..v_count loop
      apex_json.write( trim(both '#' from regexp_substr(p_string, v_pattern, 1, i, 'm') ) );
    end loop;  

    apex_json.close_array;
    apex_json.close_object;

    return apex_json.get_clob_output;
  end;

  -------------------------
  function getBindVariables(
    p_string in varchar2
  ) return clob is
    l_names DBMS_SQL.VARCHAR2_TABLE;
  begin
    l_names := WWV_FLOW_UTILITIES.GET_BINDS( p_string );

    apex_json.initialize_clob_output;

    apex_json.open_object;
    apex_json.open_array('queryItems');

    for i in 1..l_names.count loop
      apex_json.write( trim(both ':' from  l_names(i) ) );
    end loop;  

    apex_json.close_array;
    apex_json.close_object;

    return apex_json.get_clob_output;

  end getBindVariables;

  -------------------------------
  function getPluginAppAttributes(
    p_plugin in apex_plugin.t_plugin
  ) return varchar2 is
    attr_app_expand_time   number  := NVL(p_plugin.attribute_01, 200);
    attr_app_collapse_time number  := NVL(p_plugin.attribute_02, 400);
  begin
    apex_json.initialize_clob_output;

    apex_json.open_object;
    apex_json.open_object('plugin');
    apex_json.write('animationTime',      attr_app_expand_time   );
    apex_json.write('closeOtherDuration', attr_app_collapse_time );
    apex_json.close_object;
    apex_json.close_object;

    return apex_json.get_clob_output;

  end getPluginAppAttributes;

  ----------------------------
  function pretius_row_details (
    p_dynamic_action in apex_plugin.t_dynamic_action,
    p_plugin         in apex_plugin.t_plugin 
  ) return apex_plugin.t_dynamic_action_render_result
  is
    l_result apex_plugin.t_dynamic_action_render_result;

    l_attr_nestedQuery      varchar2(32767) := p_dynamic_action.attribute_01;
    l_attr_dc_settings      varchar2(100)   := p_dynamic_action.attribute_02;

    l_attr_mode             varchar2(100)   := p_dynamic_action.attribute_03;
    l_attr_customTemplate   varchar2(32767) := p_dynamic_action.attribute_04;
    l_attr_customCallback   varchar2(32767) := p_dynamic_action.attribute_05;
    l_attr_bgColor          varchar2(20)    := NVL( p_dynamic_action.attribute_06, '#EBEBEB' );
    l_attr_setMaxHeight     number          := p_dynamic_action.attribute_07;
    l_attr_borderColor      varchar2(20)    := NVL( p_dynamic_action.attribute_08, '#c5c5c5' );
    l_attr_highlightColor   varchar2(20)    := NVL( p_dynamic_action.attribute_09, '#F2F2F2' );
    l_attr_cc_settings      varchar2(100)   := p_dynamic_action.attribute_10;
    l_attr_noDataFound      varchar2(32767) := p_dynamic_action.attribute_11;
    l_attr_spinnerOptions   varchar2(100)   := NVL( p_dynamic_action.attribute_12, 'ATR' );
    l_attr_defaultTemplate  varchar2(4000)  := NVL(p_dynamic_action.attribute_13,  '#DEFAULT_TEMPLATE#');
    l_attr_dt_settings      varchar2(100)   := p_dynamic_action.attribute_14;
    /*
    p_dynamic_action.attribute_12;
    p_dynamic_action.attribute_13;
    p_dynamic_action.attribute_14;
    p_dynamic_action.attribute_15;  
    */
    attr_app_embedMustache boolean := CASE WHEN p_plugin.attribute_03 = 'Y' then true else false end;

  begin
    l_result.ajax_identifier     := wwv_flow_plugin.get_ajax_identifier;
    l_result.javascript_function := '
      function(){
        pretiusNestedReport(this, '||getColumnNamesFromQuery( l_attr_nestedQuery )||', '||getBindVariables( l_attr_nestedQuery )||', true, '||getPluginAppAttributes( p_plugin )||');
      }
    ';
    --l_result.attribute_01        := p_dynamic_action.attribute_01; --tajne, bo to zapytaie SQL, ktore mogloby byc dostepne przez this.options
    l_result.attribute_02        := l_attr_dc_settings;
    l_result.attribute_03        := l_attr_mode;
    l_result.attribute_04        := l_attr_customTemplate;
    l_result.attribute_05        := l_attr_customCallback;
    l_result.attribute_06        := l_attr_bgColor;
    l_result.attribute_07        := l_attr_setMaxHeight;
    l_result.attribute_08        := l_attr_borderColor;
    l_result.attribute_09        := l_attr_highlightColor;
    l_result.attribute_10        := l_attr_cc_settings;
    l_result.attribute_11        := l_attr_noDataFound;
    l_result.attribute_12        := l_attr_spinnerOptions;
    l_result.attribute_13        := l_attr_defaultTemplate;
    l_result.attribute_14        := l_attr_dt_settings;
    --l_result.attribute_15        := p_dynamic_action.attribute_15;

    --add mustache library
    if attr_app_embedMustache then

      apex_javascript.add_library(
        p_name => 'mustache', 
        p_directory => p_plugin.file_prefix, 
        p_version => null 
      );

    end if;

    if apex_application.G_DEBUG then

      APEX_PLUGIN_UTIL.DEBUG_DYNAMIC_ACTION (
        p_plugin         => p_plugin,
        p_dynamic_action => p_dynamic_action
      );

      apex_javascript.add_onload_code ('
        apex.debug.info("p_dynamic_action", '||printAttributes( p_dynamic_action )||');
        apex.debug.info("p_plugin",         '||printAttributes( p_plugin )||');
        apex.debug.info("l_result",         '||printAttributes( l_result )||');
      ');

    end if;

    return l_result;

  end pretius_row_details;

  --------------------
  function clean_query( 
    p_query in varchar2 
  ) return varchar2 is
    l_query varchar2(32767) := p_query;
  begin
    loop
      if substr(l_query,-1) in (chr(10),chr(13),';',' ','/') then
        l_query := substr(l_query,1,length(l_query)-1);
      else
        exit;
      end if;
    end loop;

    return l_query;

  end clean_query;

  -----------------------
  function is_valid_query( 
    p_query in varchar2 
  ) return varchar2 is
    l_source_query  varchar2(32767) := p_query;
    l_source_queryv varchar2(32767);
    l_report_cursor integer;
  begin
    if l_source_query is not null then
      if 
        substr(upper(ltrim(l_source_query)),1,6) != 'SELECT'
        and substr(upper(ltrim(l_source_query)),1,4) != 'WITH' 
      then
        return 'Query must begin with SELECT or WITH';
      end if;

      l_source_query := clean_query( l_source_query );
      l_source_queryv := sys.dbms_assert.noop( str => l_source_query );

      begin
        l_report_cursor := sys.dbms_sql.open_cursor;
        sys.dbms_sql.parse( l_report_cursor, l_source_queryv, SYS.DBMS_SQL.NATIVE );
        sys.dbms_sql.close_cursor(l_report_cursor);
      exception 
        when others then
          if sys.dbms_sql.is_open( l_report_cursor ) then
            sys.dbms_sql.close_cursor( l_report_cursor );
          end if;
          return sqlerrm;--||': '||chr(10)||chr(10)||l_source_query;
      end;
    end if;

    return null;
  exception
    when others then
      return SQLERRM;--||':'||chr(10)||chr(10)||p_query;
  end is_valid_query;

  ----------------------------
  function getColumnTypeString(
    p_col_type in number
  ) return varchar2 is 
    l_col_type varchar2(50);
  begin
    if p_col_type = 1 then
      l_col_type := 'VARCHAR2';

    elsif p_col_type = 2 then
      l_col_type := 'NUMBER';

    elsif p_col_type = 12 then
      l_col_type := 'DATE';

    elsif p_col_type in (180,181,231) then
      l_col_type := 'TIMESTAMP';

      if p_col_type = 231 then
          l_col_type := 'TIMESTAMP_LTZ';
      end if;

    elsif p_col_type = 112 then
      l_col_type := 'CLOB';

    elsif p_col_type = 113 then

      l_col_type := 'BLOB';

    elsif p_col_type = 96 then
      l_col_type := 'CHAR';

    else
        l_col_type := 'OTHER';
    end if;

    return l_col_type;

  end getColumnTypeString;

  ---------------------------------
  function pretius_row_details_ajax(
    p_dynamic_action in apex_plugin.t_dynamic_action,
    p_plugin         in apex_plugin.t_plugin 
  ) return apex_plugin.t_dynamic_action_ajax_result
  is
    l_status              number;
    l_desc_col_no         number          := 0;

    l_ajax_column_name    varchar2(4000);
    l_ajax_column_values  varchar2(4000);

    l_sql                 varchar2(32767);
    l_delimeter           varchar2(1)     := ':';
    l_parseResult         varchar2(4000);

    l_result              apex_plugin.t_dynamic_action_ajax_result;

    l_columnNames         apex_application_global.vc_arr2;
    l_columnValues        apex_application_global.vc_arr2;

    l_sys_cursor          sys_refcursor;

    l_cursor              pls_integer;

    l_desc_col_info       sys.dbms_sql.desc_tab2;

    l_apex_items_names    DBMS_SQL.VARCHAR2_TABLE;
  begin

    l_ajax_column_name    := apex_application.g_x01;
    l_ajax_column_values  := apex_application.g_x02;

    l_sql                 := p_dynamic_action.attribute_01;
    l_apex_items_names    := WWV_FLOW_UTILITIES.GET_BINDS( l_sql );

    l_columnNames         := apex_util.string_to_table( l_ajax_column_name  , l_delimeter );
    l_columnValues        := apex_util.string_to_table( l_ajax_column_values, l_delimeter );

    if l_columnNames.count <> l_columnValues.count then
      apex_json.open_object;
      apex_json.write('addInfo', 'The number of column names must be equal to the number of column values.</br>Check whether the query columns exist in parent report.');
      apex_json.write('error', 'Column names = "'||l_ajax_column_name||'"'||chr(10)||'Column values = "'||l_ajax_column_values||'"');
      apex_json.close_object;
      return null;      
    end if;

    --replacing space within column name is required to work with column aliases
    for i in 1..l_columnNames.count loop
      l_sql := replace( l_sql, chr(39)||'#'||l_columnNames(i)||'#'||chr(39) , ':' || replace(l_columnNames(i), ' ', '') );  
      l_sql := replace( l_sql, '#'||l_columnNames(i)||'#'                   , ':' || replace(l_columnNames(i), ' ', '') );  
    end loop;

    l_parseResult := is_valid_query( l_sql );

    if l_parseResult is not null then
      apex_json.open_object;
      apex_json.write('addInfo', 'Nested report SQL query is not valid');
      apex_json.write('error', l_parseResult);
      --apex_json.write('query', l_sql);
      apex_json.close_object;
      return null;
    end if;

    -- open l_cursor;
    l_cursor := dbms_sql.open_cursor;
    dbms_sql.parse (l_cursor, l_sql, dbms_sql.native);

    -- bind items
    begin

      for i in 1..l_apex_items_names.count loop
        dbms_sql.bind_variable (l_cursor, l_apex_items_names(i), v( trim(both ':' from l_apex_items_names(i)) ) );
      end loop;

    exception
      when others then
        apex_json.open_object;
        apex_json.write('addInfo', 'While binding APEX items error occured');
        apex_json.write('error', SQLERRM);
        apex_json.close_object;
        return null;      
    end;

    --bind all the values
    --replacing space within column name is required to work with column aliases
    begin
      for i in 1 .. l_columnNames.count loop
        dbms_sql.bind_variable (l_cursor, replace(l_columnNames(i), ' ', ''), l_columnValues(i));
      end loop;
    exception
      when others then
        apex_json.open_object;
        apex_json.write('addInfo', 'While binding query variables error occured');
        apex_json.write('error', SQLERRM);
        apex_json.close_object;
        return null;      
    end;

    -- describe columns
    sys.dbms_sql.describe_columns2( l_cursor, l_desc_col_no , l_desc_col_info);

    begin
      l_status := dbms_sql.execute(l_cursor);
    exception
      when others then
        apex_json.open_object;
        apex_json.write('addInfo', 'While executing query error occured ');
        apex_json.write('error', SQLERRM);
        apex_json.close_object;
        return null;      
    end;

    l_sys_cursor := dbms_sql.to_refcursor(l_cursor);  

    --apex_json.initialize_clob_output;

    apex_json.open_object;
    apex_json.write( 'data', l_sys_cursor );
    apex_json.open_array('headers');

    for i in 1..l_desc_col_no loop
      apex_json.open_object;
      apex_json.write('COLUMN_NAME', l_desc_col_info(i).col_name);
      apex_json.write('COLUMN_TYPE', getColumnTypeString( l_desc_col_info(i).col_type ) );
      apex_json.close_object;
    end loop;

    apex_json.close_array;

    apex_json.write( 'x01', l_ajax_column_name, true );
    apex_json.write( 'x02', l_ajax_column_values, true );

    apex_json.close_object;

    --htp.p( apex_json.get_clob_output );

    return l_result;
  exception
    when others then
      apex_json.open_object;
      apex_json.write('addInfo', 'Unknown ajax error');
      apex_json.write('error', SQLERRM);
      apex_json.close_object;
      htp.p( apex_json.get_clob_output );
      return l_result;
  end pretius_row_details_ajax;

end "PRETIUS_APEX_NESTED_REPORTS";

/
--------------------------------------------------------
--  DDL for Package Body TAPI_CALENDARIOS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."TAPI_CALENDARIOS" IS

   /**
   * TAPI_CALENDARIOS
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: 24-OCT-2019 11:06
   * Created By: FUNDAUC
   */


   --GLOBAL_PRIVATE_CURSORS
   --By PK
   CURSOR calendarios_cur (
                       p_id_calendario IN calendarios.id_calendario%TYPE
                       )
   IS
      SELECT
            id_calendario,
            descripcion,
            activo,
            tipo_cal,
            tapi_calendarios.hash(id_calendario),
            ROWID
      FROM calendarios
      WHERE
           id_calendario = calendarios_cur.p_id_calendario
      FOR UPDATE;

    --By Rowid
    CURSOR calendarios_rowid_cur (p_rowid IN VARCHAR2)
    IS
      SELECT
             id_calendario,
             descripcion,
             activo,
             tipo_cal,
             tapi_calendarios.hash(id_calendario),
             ROWID
      FROM calendarios
      WHERE ROWID = p_rowid
      FOR UPDATE;


    FUNCTION hash (
                  p_id_calendario IN calendarios.id_calendario%TYPE
                  )
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format VARCHAR2(64);
   BEGIN


     --Get actual NLS_DATE_FORMAT
     SELECT   VALUE
       INTO   l_date_format
       FROM   v$nls_parameters
      WHERE   parameter = 'NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            id_calendario||
            descripcion||
            activo||
            tipo_cal
      INTO l_string
      FROM calendarios
      WHERE
           id_calendario = hash.p_id_calendario
           ;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash;

    FUNCTION hash_rowid (p_rowid IN varchar2)
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format varchar2(64);
   BEGIN

      --Get actual NLS_DATE_FORMAT
      SELECT VALUE INTO l_date_format  FROM v$nls_parameters WHERE parameter ='NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            id_calendario||
            descripcion||
            activo||
            tipo_cal
      INTO l_string
      FROM calendarios
      WHERE  ROWID = hash_rowid.p_rowid;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash_rowid;

   FUNCTION rt (
               p_id_calendario IN calendarios.id_calendario%TYPE
               )
      RETURN calendarios_rt RESULT_CACHE
   IS
      l_calendarios_rec calendarios_rt;
   BEGIN

      SELECT a.*,
             tapi_calendarios.hash(id_calendario),
             rowid
      INTO l_calendarios_rec
      FROM calendarios a
      WHERE
           id_calendario = rt.p_id_calendario
           ;


      RETURN l_calendarios_rec;

   END rt;

   FUNCTION rt_for_update (
                          p_id_calendario IN calendarios.id_calendario%TYPE
                          )
      RETURN calendarios_rt RESULT_CACHE
   IS
      l_calendarios_rec calendarios_rt;
   BEGIN


      SELECT a.*,
             tapi_calendarios.hash(id_calendario),
             rowid
      INTO l_calendarios_rec
      FROM calendarios a
      WHERE
           id_calendario = rt_for_update.p_id_calendario
      FOR UPDATE;


      RETURN l_calendarios_rec;

   END rt_for_update;

    FUNCTION tt (
                p_id_calendario IN calendarios.id_calendario%TYPE DEFAULT NULL
                )
       RETURN calendarios_tt
       PIPELINED
    IS
       l_calendarios_rec   calendarios_rt;
    BEGIN

       FOR c1 IN (SELECT   a.*, ROWID
                    FROM   calendarios a
                   WHERE
                        id_calendario = NVL(tt.p_id_calendario,id_calendario)
                        )
       LOOP
              l_calendarios_rec.id_calendario := c1.id_calendario;
              l_calendarios_rec.descripcion := c1.descripcion;
              l_calendarios_rec.activo := c1.activo;
              l_calendarios_rec.tipo_cal := c1.tipo_cal;
              l_calendarios_rec.hash := tapi_calendarios.hash( c1.id_calendario);
              l_calendarios_rec.row_id := c1.ROWID;
              PIPE ROW (l_calendarios_rec);
       END LOOP;

       RETURN;

    END tt;


    PROCEDURE ins (p_calendarios_rec IN OUT calendarios_rt)
    IS
        l_rowtype     calendarios%ROWTYPE;

    BEGIN


        l_rowtype.id_calendario := ins.p_calendarios_rec.id_calendario;
        l_rowtype.descripcion := ins.p_calendarios_rec.descripcion;
        l_rowtype.activo := ins.p_calendarios_rec.activo;
        l_rowtype.tipo_cal := ins.p_calendarios_rec.tipo_cal;

       INSERT INTO calendarios
          VALUES   l_rowtype
       RETURNING
                   id_calendario ,
                   descripcion ,
                   activo ,
                   tipo_cal 
            INTO   l_rowtype;

         ins.p_calendarios_rec.id_calendario := l_rowtype.id_calendario;
         ins.p_calendarios_rec.descripcion := l_rowtype.descripcion;
         ins.p_calendarios_rec.activo := l_rowtype.activo;
         ins.p_calendarios_rec.tipo_cal := l_rowtype.tipo_cal;



    END ins;

    PROCEDURE upd (
                  p_calendarios_rec         IN calendarios_rt,
                  p_ignore_nulls         IN boolean := FALSE
                  )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   calendarios
             SET id_calendario = NVL(p_calendarios_rec.id_calendario,id_calendario),
                descripcion = NVL(p_calendarios_rec.descripcion,descripcion),
                activo = NVL(p_calendarios_rec.activo,activo),
                tipo_cal = NVL(p_calendarios_rec.tipo_cal,tipo_cal)
           WHERE
                id_calendario = upd.p_calendarios_rec.id_calendario
                ;
       ELSE
          UPDATE   calendarios
             SET id_calendario = p_calendarios_rec.id_calendario,
                descripcion = p_calendarios_rec.descripcion,
                activo = p_calendarios_rec.activo,
                tipo_cal = p_calendarios_rec.tipo_cal
           WHERE
                id_calendario = upd.p_calendarios_rec.id_calendario
                ;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd;


    PROCEDURE upd_rowid (
                         p_calendarios_rec         IN calendarios_rt,
                         p_ignore_nulls         IN boolean := FALSE
                        )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   calendarios
             SET id_calendario = NVL(p_calendarios_rec.id_calendario,id_calendario),
                descripcion = NVL(p_calendarios_rec.descripcion,descripcion),
                activo = NVL(p_calendarios_rec.activo,activo),
                tipo_cal = NVL(p_calendarios_rec.tipo_cal,tipo_cal)
           WHERE  ROWID = p_calendarios_rec.row_id;
       ELSE
          UPDATE   calendarios
             SET id_calendario = p_calendarios_rec.id_calendario,
                descripcion = p_calendarios_rec.descripcion,
                activo = p_calendarios_rec.activo,
                tipo_cal = p_calendarios_rec.tipo_cal
           WHERE  ROWID = p_calendarios_rec.row_id;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd_rowid;

   PROCEDURE web_upd (
                  p_calendarios_rec         IN calendarios_rt,
                  p_ignore_nulls         IN boolean := FALSE
                )
   IS
      l_calendarios_rec calendarios_rt;
   BEGIN

      OPEN calendarios_cur(
                             web_upd.p_calendarios_rec.id_calendario
                        );

      FETCH calendarios_cur INTO l_calendarios_rec;

      IF calendarios_cur%NOTFOUND THEN
         CLOSE calendarios_cur;
         RAISE e_row_missing;
      ELSE
         IF p_calendarios_rec.hash != l_calendarios_rec.hash THEN
            CLOSE calendarios_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(p_ignore_nulls, FALSE)
            THEN

                UPDATE   calendarios
                   SET id_calendario = NVL(p_calendarios_rec.id_calendario,id_calendario),
                       descripcion = NVL(p_calendarios_rec.descripcion,descripcion),
                       activo = NVL(p_calendarios_rec.activo,activo),
                       tipo_cal = NVL(p_calendarios_rec.tipo_cal,tipo_cal)
               WHERE CURRENT OF calendarios_cur;
            ELSE
                UPDATE   calendarios
                   SET id_calendario = p_calendarios_rec.id_calendario,
                       descripcion = p_calendarios_rec.descripcion,
                       activo = p_calendarios_rec.activo,
                       tipo_cal = p_calendarios_rec.tipo_cal
               WHERE CURRENT OF calendarios_cur;
            END IF;

            CLOSE calendarios_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd;

   PROCEDURE web_upd_rowid (
                            p_calendarios_rec    IN calendarios_rt,
                            p_ignore_nulls         IN boolean := FALSE
                           )
   IS
      l_calendarios_rec calendarios_rt;
   BEGIN

      OPEN calendarios_rowid_cur(web_upd_rowid.p_calendarios_rec.row_id);

      FETCH calendarios_rowid_cur INTO l_calendarios_rec;

      IF calendarios_rowid_cur%NOTFOUND THEN
         CLOSE calendarios_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_upd_rowid.p_calendarios_rec.hash != l_calendarios_rec.hash THEN
            CLOSE calendarios_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(web_upd_rowid.p_ignore_nulls, FALSE)
            THEN
                UPDATE   calendarios
                   SET id_calendario = NVL(p_calendarios_rec.id_calendario,id_calendario),
                       descripcion = NVL(p_calendarios_rec.descripcion,descripcion),
                       activo = NVL(p_calendarios_rec.activo,activo),
                       tipo_cal = NVL(p_calendarios_rec.tipo_cal,tipo_cal)
               WHERE CURRENT OF calendarios_rowid_cur;
            ELSE
                UPDATE   calendarios
                   SET id_calendario = p_calendarios_rec.id_calendario,
                       descripcion = p_calendarios_rec.descripcion,
                       activo = p_calendarios_rec.activo,
                       tipo_cal = p_calendarios_rec.tipo_cal
               WHERE CURRENT OF calendarios_rowid_cur;
            END IF;

            CLOSE calendarios_rowid_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd_rowid;

    PROCEDURE del (
                  p_id_calendario IN calendarios.id_calendario%TYPE
                  )
    IS
    BEGIN

       DELETE FROM   calendarios
             WHERE
                  id_calendario = del.p_id_calendario
                   ;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del;

    PROCEDURE del_rowid (p_rowid IN varchar2)
    IS
    BEGIN

       DELETE FROM   calendarios
             WHERE   ROWID = del_rowid.p_rowid;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del_rowid;

    PROCEDURE web_del (
                      p_id_calendario IN calendarios.id_calendario%TYPE,
                      p_hash IN varchar2
                      )
   IS
      l_calendarios_rec calendarios_rt;
   BEGIN


      OPEN calendarios_cur(
                            web_del.p_id_calendario
                            );

      FETCH calendarios_cur INTO l_calendarios_rec;

      IF calendarios_cur%NOTFOUND THEN
         CLOSE calendarios_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del.p_hash != l_calendarios_rec.hash THEN
            CLOSE calendarios_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM calendarios
            WHERE CURRENT OF calendarios_cur;

            CLOSE calendarios_cur;
         END IF;
      END IF;



   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del;

   PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2)
   IS
      l_calendarios_rec calendarios_rt;
   BEGIN


      OPEN calendarios_rowid_cur(web_del_rowid.p_rowid);

      FETCH calendarios_rowid_cur INTO l_calendarios_rec;

      IF calendarios_rowid_cur%NOTFOUND THEN
         CLOSE calendarios_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del_rowid.p_hash != l_calendarios_rec.hash THEN
            CLOSE calendarios_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM calendarios
            WHERE CURRENT OF calendarios_rowid_cur;

            CLOSE calendarios_rowid_cur;
         END IF;
      END IF;

   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del_rowid;

END tapi_calendarios;

/
--------------------------------------------------------
--  DDL for Package Body TAPI_CALENDARIOS_DETALLE
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."TAPI_CALENDARIOS_DETALLE" IS

   /**
   * TAPI_CALENDARIOS_DETALLE
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: 30-JUL-2019 17:33
   * Created By: FUNDAUC
   */


   --GLOBAL_PRIVATE_CURSORS
   --By PK
   CURSOR calendarios_detalle_cur (
                       p_id IN calendarios_detalle.id%TYPE
                       )
   IS
      SELECT
            id_calendario,
            periodo,
            fecha_ini,
            fecha_fin,
            modalidad,
            periodo_activo,
            id,
            tapi_calendarios_detalle.hash(id),
            ROWID
      FROM calendarios_detalle
      WHERE
           id = calendarios_detalle_cur.p_id
      FOR UPDATE;

    --By Rowid
    CURSOR calendarios_detalle_rowid_cur (p_rowid IN VARCHAR2)
    IS
      SELECT
             id_calendario,
             periodo,
             fecha_ini,
             fecha_fin,
             modalidad,
             periodo_activo,
             id,
             tapi_calendarios_detalle.hash(id),
             ROWID
      FROM calendarios_detalle
      WHERE ROWID = p_rowid
      FOR UPDATE;


    FUNCTION hash (
                  p_id IN calendarios_detalle.id%TYPE
                  )
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format VARCHAR2(64);
   BEGIN


     --Get actual NLS_DATE_FORMAT
     SELECT   VALUE
       INTO   l_date_format
       FROM   v$nls_parameters
      WHERE   parameter = 'NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            id_calendario||
            periodo||
            fecha_ini||
            fecha_fin||
            modalidad||
            periodo_activo||
            id
      INTO l_string
      FROM calendarios_detalle
      WHERE
           id = hash.p_id
           ;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash;

    FUNCTION hash_rowid (p_rowid IN varchar2)
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format varchar2(64);
   BEGIN

      --Get actual NLS_DATE_FORMAT
      SELECT VALUE INTO l_date_format  FROM v$nls_parameters WHERE parameter ='NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            id_calendario||
            periodo||
            fecha_ini||
            fecha_fin||
            modalidad||
            periodo_activo||
            id
      INTO l_string
      FROM calendarios_detalle
      WHERE  ROWID = hash_rowid.p_rowid;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash_rowid;

   FUNCTION rt (
               p_id IN calendarios_detalle.id%TYPE
               )
      RETURN calendarios_detalle_rt RESULT_CACHE
   IS
      l_calendarios_detalle_rec calendarios_detalle_rt;
   BEGIN

      SELECT a.*,
             tapi_calendarios_detalle.hash(id),
             rowid
      INTO l_calendarios_detalle_rec
      FROM calendarios_detalle a
      WHERE
           id = rt.p_id
           ;


      RETURN l_calendarios_detalle_rec;

   END rt;

   FUNCTION rt_for_update (
                          p_id IN calendarios_detalle.id%TYPE
                          )
      RETURN calendarios_detalle_rt RESULT_CACHE
   IS
      l_calendarios_detalle_rec calendarios_detalle_rt;
   BEGIN


      SELECT a.*,
             tapi_calendarios_detalle.hash(id),
             rowid
      INTO l_calendarios_detalle_rec
      FROM calendarios_detalle a
      WHERE
           id = rt_for_update.p_id
      FOR UPDATE;


      RETURN l_calendarios_detalle_rec;

   END rt_for_update;

    FUNCTION tt (
                p_id IN calendarios_detalle.id%TYPE DEFAULT NULL
                )
       RETURN calendarios_detalle_tt
       PIPELINED
    IS
       l_calendarios_detalle_rec   calendarios_detalle_rt;
    BEGIN

       FOR c1 IN (SELECT   a.*, ROWID
                    FROM   calendarios_detalle a
                   WHERE
                        id = NVL(tt.p_id,id)
                        )
       LOOP
              l_calendarios_detalle_rec.id_calendario := c1.id_calendario;
              l_calendarios_detalle_rec.periodo := c1.periodo;
              l_calendarios_detalle_rec.fecha_ini := c1.fecha_ini;
              l_calendarios_detalle_rec.fecha_fin := c1.fecha_fin;
              l_calendarios_detalle_rec.modalidad := c1.modalidad;
              l_calendarios_detalle_rec.periodo_activo := c1.periodo_activo;
              l_calendarios_detalle_rec.id := c1.id;
              l_calendarios_detalle_rec.hash := tapi_calendarios_detalle.hash( c1.id);
              l_calendarios_detalle_rec.row_id := c1.ROWID;
              PIPE ROW (l_calendarios_detalle_rec);
       END LOOP;

       RETURN;

    END tt;


    PROCEDURE ins (p_calendarios_detalle_rec IN OUT calendarios_detalle_rt)
    IS
        l_rowtype     calendarios_detalle%ROWTYPE;

    BEGIN


        l_rowtype.id_calendario := ins.p_calendarios_detalle_rec.id_calendario;
        l_rowtype.periodo := ins.p_calendarios_detalle_rec.periodo;
        l_rowtype.fecha_ini := ins.p_calendarios_detalle_rec.fecha_ini;
        l_rowtype.fecha_fin := ins.p_calendarios_detalle_rec.fecha_fin;
        l_rowtype.modalidad := ins.p_calendarios_detalle_rec.modalidad;
        l_rowtype.periodo_activo := ins.p_calendarios_detalle_rec.periodo_activo;
        l_rowtype.id := ins.p_calendarios_detalle_rec.id;

       INSERT INTO calendarios_detalle
          VALUES   l_rowtype
       RETURNING
                   id_calendario ,
                   periodo ,
                   fecha_ini ,
                   fecha_fin ,
                   modalidad ,
                   periodo_activo ,
                   id 
            INTO   l_rowtype;

         ins.p_calendarios_detalle_rec.id_calendario := l_rowtype.id_calendario;
         ins.p_calendarios_detalle_rec.periodo := l_rowtype.periodo;
         ins.p_calendarios_detalle_rec.fecha_ini := l_rowtype.fecha_ini;
         ins.p_calendarios_detalle_rec.fecha_fin := l_rowtype.fecha_fin;
         ins.p_calendarios_detalle_rec.modalidad := l_rowtype.modalidad;
         ins.p_calendarios_detalle_rec.periodo_activo := l_rowtype.periodo_activo;
         ins.p_calendarios_detalle_rec.id := l_rowtype.id;



    END ins;

    PROCEDURE upd (
                  p_calendarios_detalle_rec         IN calendarios_detalle_rt,
                  p_ignore_nulls         IN boolean := FALSE
                  )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   calendarios_detalle
             SET id_calendario = NVL(p_calendarios_detalle_rec.id_calendario,id_calendario),
                periodo = NVL(p_calendarios_detalle_rec.periodo,periodo),
                fecha_ini = NVL(p_calendarios_detalle_rec.fecha_ini,fecha_ini),
                fecha_fin = NVL(p_calendarios_detalle_rec.fecha_fin,fecha_fin),
                modalidad = NVL(p_calendarios_detalle_rec.modalidad,modalidad),
                periodo_activo = NVL(p_calendarios_detalle_rec.periodo_activo,periodo_activo),
                id = NVL(p_calendarios_detalle_rec.id,id)
           WHERE
                id = upd.p_calendarios_detalle_rec.id
                ;
       ELSE
          UPDATE   calendarios_detalle
             SET id_calendario = p_calendarios_detalle_rec.id_calendario,
                periodo = p_calendarios_detalle_rec.periodo,
                fecha_ini = p_calendarios_detalle_rec.fecha_ini,
                fecha_fin = p_calendarios_detalle_rec.fecha_fin,
                modalidad = p_calendarios_detalle_rec.modalidad,
                periodo_activo = p_calendarios_detalle_rec.periodo_activo,
                id = p_calendarios_detalle_rec.id
           WHERE
                id = upd.p_calendarios_detalle_rec.id
                ;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd;


    PROCEDURE upd_rowid (
                         p_calendarios_detalle_rec         IN calendarios_detalle_rt,
                         p_ignore_nulls         IN boolean := FALSE
                        )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   calendarios_detalle
             SET id_calendario = NVL(p_calendarios_detalle_rec.id_calendario,id_calendario),
                periodo = NVL(p_calendarios_detalle_rec.periodo,periodo),
                fecha_ini = NVL(p_calendarios_detalle_rec.fecha_ini,fecha_ini),
                fecha_fin = NVL(p_calendarios_detalle_rec.fecha_fin,fecha_fin),
                modalidad = NVL(p_calendarios_detalle_rec.modalidad,modalidad),
                periodo_activo = NVL(p_calendarios_detalle_rec.periodo_activo,periodo_activo),
                id = NVL(p_calendarios_detalle_rec.id,id)
           WHERE  ROWID = p_calendarios_detalle_rec.row_id;
       ELSE
          UPDATE   calendarios_detalle
             SET id_calendario = p_calendarios_detalle_rec.id_calendario,
                periodo = p_calendarios_detalle_rec.periodo,
                fecha_ini = p_calendarios_detalle_rec.fecha_ini,
                fecha_fin = p_calendarios_detalle_rec.fecha_fin,
                modalidad = p_calendarios_detalle_rec.modalidad,
                periodo_activo = p_calendarios_detalle_rec.periodo_activo,
                id = p_calendarios_detalle_rec.id
           WHERE  ROWID = p_calendarios_detalle_rec.row_id;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd_rowid;

   PROCEDURE web_upd (
                  p_calendarios_detalle_rec         IN calendarios_detalle_rt,
                  p_ignore_nulls         IN boolean := FALSE
                )
   IS
      l_calendarios_detalle_rec calendarios_detalle_rt;
   BEGIN

      OPEN calendarios_detalle_cur(
                             web_upd.p_calendarios_detalle_rec.id
                        );

      FETCH calendarios_detalle_cur INTO l_calendarios_detalle_rec;

      IF calendarios_detalle_cur%NOTFOUND THEN
         CLOSE calendarios_detalle_cur;
         RAISE e_row_missing;
      ELSE
         IF p_calendarios_detalle_rec.hash != l_calendarios_detalle_rec.hash THEN
            CLOSE calendarios_detalle_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(p_ignore_nulls, FALSE)
            THEN

                UPDATE   calendarios_detalle
                   SET id_calendario = NVL(p_calendarios_detalle_rec.id_calendario,id_calendario),
                       periodo = NVL(p_calendarios_detalle_rec.periodo,periodo),
                       fecha_ini = NVL(p_calendarios_detalle_rec.fecha_ini,fecha_ini),
                       fecha_fin = NVL(p_calendarios_detalle_rec.fecha_fin,fecha_fin),
                       modalidad = NVL(p_calendarios_detalle_rec.modalidad,modalidad),
                       periodo_activo = NVL(p_calendarios_detalle_rec.periodo_activo,periodo_activo),
                       id = NVL(p_calendarios_detalle_rec.id,id)
               WHERE CURRENT OF calendarios_detalle_cur;
            ELSE
                UPDATE   calendarios_detalle
                   SET id_calendario = p_calendarios_detalle_rec.id_calendario,
                       periodo = p_calendarios_detalle_rec.periodo,
                       fecha_ini = p_calendarios_detalle_rec.fecha_ini,
                       fecha_fin = p_calendarios_detalle_rec.fecha_fin,
                       modalidad = p_calendarios_detalle_rec.modalidad,
                       periodo_activo = p_calendarios_detalle_rec.periodo_activo,
                       id = p_calendarios_detalle_rec.id
               WHERE CURRENT OF calendarios_detalle_cur;
            END IF;

            CLOSE calendarios_detalle_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd;

   PROCEDURE web_upd_rowid (
                            p_calendarios_detalle_rec    IN calendarios_detalle_rt,
                            p_ignore_nulls         IN boolean := FALSE
                           )
   IS
      l_calendarios_detalle_rec calendarios_detalle_rt;
   BEGIN

      OPEN calendarios_detalle_rowid_cur(web_upd_rowid.p_calendarios_detalle_rec.row_id);

      FETCH calendarios_detalle_rowid_cur INTO l_calendarios_detalle_rec;

      IF calendarios_detalle_rowid_cur%NOTFOUND THEN
         CLOSE calendarios_detalle_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_upd_rowid.p_calendarios_detalle_rec.hash != l_calendarios_detalle_rec.hash THEN
            CLOSE calendarios_detalle_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(web_upd_rowid.p_ignore_nulls, FALSE)
            THEN
                UPDATE   calendarios_detalle
                   SET id_calendario = NVL(p_calendarios_detalle_rec.id_calendario,id_calendario),
                       periodo = NVL(p_calendarios_detalle_rec.periodo,periodo),
                       fecha_ini = NVL(p_calendarios_detalle_rec.fecha_ini,fecha_ini),
                       fecha_fin = NVL(p_calendarios_detalle_rec.fecha_fin,fecha_fin),
                       modalidad = NVL(p_calendarios_detalle_rec.modalidad,modalidad),
                       periodo_activo = NVL(p_calendarios_detalle_rec.periodo_activo,periodo_activo),
                       id = NVL(p_calendarios_detalle_rec.id,id)
               WHERE CURRENT OF calendarios_detalle_rowid_cur;
            ELSE
                UPDATE   calendarios_detalle
                   SET id_calendario = p_calendarios_detalle_rec.id_calendario,
                       periodo = p_calendarios_detalle_rec.periodo,
                       fecha_ini = p_calendarios_detalle_rec.fecha_ini,
                       fecha_fin = p_calendarios_detalle_rec.fecha_fin,
                       modalidad = p_calendarios_detalle_rec.modalidad,
                       periodo_activo = p_calendarios_detalle_rec.periodo_activo,
                       id = p_calendarios_detalle_rec.id
               WHERE CURRENT OF calendarios_detalle_rowid_cur;
            END IF;

            CLOSE calendarios_detalle_rowid_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd_rowid;

    PROCEDURE del (
                  p_id IN calendarios_detalle.id%TYPE
                  )
    IS
    BEGIN

       DELETE FROM   calendarios_detalle
             WHERE
                  id = del.p_id
                   ;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del;

    PROCEDURE del_rowid (p_rowid IN varchar2)
    IS
    BEGIN

       DELETE FROM   calendarios_detalle
             WHERE   ROWID = del_rowid.p_rowid;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del_rowid;

    PROCEDURE web_del (
                      p_id IN calendarios_detalle.id%TYPE,
                      p_hash IN varchar2
                      )
   IS
      l_calendarios_detalle_rec calendarios_detalle_rt;
   BEGIN


      OPEN calendarios_detalle_cur(
                            web_del.p_id
                            );

      FETCH calendarios_detalle_cur INTO l_calendarios_detalle_rec;

      IF calendarios_detalle_cur%NOTFOUND THEN
         CLOSE calendarios_detalle_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del.p_hash != l_calendarios_detalle_rec.hash THEN
            CLOSE calendarios_detalle_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM calendarios_detalle
            WHERE CURRENT OF calendarios_detalle_cur;

            CLOSE calendarios_detalle_cur;
         END IF;
      END IF;



   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del;

   PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2)
   IS
      l_calendarios_detalle_rec calendarios_detalle_rt;
   BEGIN


      OPEN calendarios_detalle_rowid_cur(web_del_rowid.p_rowid);

      FETCH calendarios_detalle_rowid_cur INTO l_calendarios_detalle_rec;

      IF calendarios_detalle_rowid_cur%NOTFOUND THEN
         CLOSE calendarios_detalle_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del_rowid.p_hash != l_calendarios_detalle_rec.hash THEN
            CLOSE calendarios_detalle_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM calendarios_detalle
            WHERE CURRENT OF calendarios_detalle_rowid_cur;

            CLOSE calendarios_detalle_rowid_cur;
         END IF;
      END IF;

   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del_rowid;

END tapi_calendarios_detalle;



/
--------------------------------------------------------
--  DDL for Package Body TAPI_COHORTES
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."TAPI_COHORTES" IS

   /**
   * TAPI_COHORTES
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: 25-FEB-2020 18:34
   * Created By: FUNDAUC
   */


   --GLOBAL_PRIVATE_CURSORS
   --By PK
   CURSOR cohortes_cur (
                       p_id IN cohortes.id%TYPE
                       )
   IS
      SELECT
            codigo,
            id_horario,
            id_modalidad,
            cohorte,
            cupo,
            costo,
            inicial,
            costo_cuota,
            cuotas,
            status,
            id_ciudad,
            id,
            tipo_diplo,
            creado_por,
            creado_el,
            modificado_por,
            modificado_el,
            diplomado_id,
            periodo,
            id_calendario,
            nivel,
            id_metodo,
            empresa,
            facilitador,
            tapi_cohortes.hash(id),
            ROWID
      FROM cohortes
      WHERE
           id = cohortes_cur.p_id
      FOR UPDATE;

    --By Rowid
    CURSOR cohortes_rowid_cur (p_rowid IN VARCHAR2)
    IS
      SELECT
             codigo,
             id_horario,
             id_modalidad,
             cohorte,
             cupo,
             costo,
             inicial,
             costo_cuota,
             cuotas,
             status,
             id_ciudad,
             id,
             tipo_diplo,
             creado_por,
             creado_el,
             modificado_por,
             modificado_el,
             diplomado_id,
             periodo,
             id_calendario,
             nivel,
             id_metodo,
             empresa,
             facilitador,
             tapi_cohortes.hash(id),
             ROWID
      FROM cohortes
      WHERE ROWID = p_rowid
      FOR UPDATE;


    FUNCTION hash (
                  p_id IN cohortes.id%TYPE
                  )
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format VARCHAR2(64);
   BEGIN


     --Get actual NLS_DATE_FORMAT
     SELECT   VALUE
       INTO   l_date_format
       FROM   v$nls_parameters
      WHERE   parameter = 'NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            codigo||
            id_horario||
            id_modalidad||
            cohorte||
            cupo||
            costo||
            inicial||
            costo_cuota||
            cuotas||
            status||
            id_ciudad||
            id||
            tipo_diplo||
            creado_por||
            creado_el||
            modificado_por||
            modificado_el||
            diplomado_id||
            periodo||
            id_calendario||
            nivel||
            id_metodo||
            empresa||
            facilitador
      INTO l_string
      FROM cohortes
      WHERE
           id = hash.p_id
           ;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash;

    FUNCTION hash_rowid (p_rowid IN varchar2)
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format varchar2(64);
   BEGIN

      --Get actual NLS_DATE_FORMAT
      SELECT VALUE INTO l_date_format  FROM v$nls_parameters WHERE parameter ='NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            codigo||
            id_horario||
            id_modalidad||
            cohorte||
            cupo||
            costo||
            inicial||
            costo_cuota||
            cuotas||
            status||
            id_ciudad||
            id||
            tipo_diplo||
            creado_por||
            creado_el||
            modificado_por||
            modificado_el||
            diplomado_id||
            periodo||
            id_calendario||
            nivel||
            id_metodo||
            empresa||
            facilitador
      INTO l_string
      FROM cohortes
      WHERE  ROWID = hash_rowid.p_rowid;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash_rowid;

   FUNCTION rt (
               p_id IN cohortes.id%TYPE
               )
      RETURN cohortes_rt RESULT_CACHE
   IS
      l_cohortes_rec cohortes_rt;
   BEGIN

      SELECT a.*,
             tapi_cohortes.hash(id),
             rowid
      INTO l_cohortes_rec
      FROM cohortes a
      WHERE
           id = rt.p_id
           ;


      RETURN l_cohortes_rec;

   END rt;

   FUNCTION rt_for_update (
                          p_id IN cohortes.id%TYPE
                          )
      RETURN cohortes_rt RESULT_CACHE
   IS
      l_cohortes_rec cohortes_rt;
   BEGIN


      SELECT a.*,
             tapi_cohortes.hash(id),
             rowid
      INTO l_cohortes_rec
      FROM cohortes a
      WHERE
           id = rt_for_update.p_id
      FOR UPDATE;


      RETURN l_cohortes_rec;

   END rt_for_update;

    FUNCTION tt (
                p_id IN cohortes.id%TYPE DEFAULT NULL
                )
       RETURN cohortes_tt
       PIPELINED
    IS
       l_cohortes_rec   cohortes_rt;
    BEGIN

       FOR c1 IN (SELECT   a.*, ROWID
                    FROM   cohortes a
                   WHERE
                        id = NVL(tt.p_id,id)
                        )
       LOOP
              l_cohortes_rec.codigo := c1.codigo;
              l_cohortes_rec.id_horario := c1.id_horario;
              l_cohortes_rec.id_modalidad := c1.id_modalidad;
              l_cohortes_rec.cohorte := c1.cohorte;
              l_cohortes_rec.cupo := c1.cupo;
              l_cohortes_rec.costo := c1.costo;
              l_cohortes_rec.inicial := c1.inicial;
              l_cohortes_rec.costo_cuota := c1.costo_cuota;
              l_cohortes_rec.cuotas := c1.cuotas;
              l_cohortes_rec.status := c1.status;
              l_cohortes_rec.id_ciudad := c1.id_ciudad;
              l_cohortes_rec.id := c1.id;
              l_cohortes_rec.tipo_diplo := c1.tipo_diplo;
              l_cohortes_rec.creado_por := c1.creado_por;
              l_cohortes_rec.creado_el := c1.creado_el;
              l_cohortes_rec.modificado_por := c1.modificado_por;
              l_cohortes_rec.modificado_el := c1.modificado_el;
              l_cohortes_rec.diplomado_id := c1.diplomado_id;
              l_cohortes_rec.periodo := c1.periodo;
              l_cohortes_rec.id_calendario := c1.id_calendario;
              l_cohortes_rec.nivel := c1.nivel;
              l_cohortes_rec.id_metodo := c1.id_metodo;
              l_cohortes_rec.empresa := c1.empresa;
              l_cohortes_rec.facilitador := c1.facilitador;
              l_cohortes_rec.hash := tapi_cohortes.hash( c1.id);
              l_cohortes_rec.row_id := c1.ROWID;
              PIPE ROW (l_cohortes_rec);
       END LOOP;

       RETURN;

    END tt;


    PROCEDURE ins (p_cohortes_rec IN OUT cohortes_rt)
    IS
        l_rowtype     cohortes%ROWTYPE;

    BEGIN


        l_rowtype.codigo := ins.p_cohortes_rec.codigo;
        l_rowtype.id_horario := ins.p_cohortes_rec.id_horario;
        l_rowtype.id_modalidad := ins.p_cohortes_rec.id_modalidad;
        l_rowtype.cohorte := ins.p_cohortes_rec.cohorte;
        l_rowtype.cupo := ins.p_cohortes_rec.cupo;
        l_rowtype.costo := ins.p_cohortes_rec.costo;
        l_rowtype.inicial := ins.p_cohortes_rec.inicial;
        l_rowtype.costo_cuota := ins.p_cohortes_rec.costo_cuota;
        l_rowtype.cuotas := ins.p_cohortes_rec.cuotas;
        l_rowtype.status := ins.p_cohortes_rec.status;
        l_rowtype.id_ciudad := ins.p_cohortes_rec.id_ciudad;
        l_rowtype.id := ins.p_cohortes_rec.id;
        l_rowtype.tipo_diplo := ins.p_cohortes_rec.tipo_diplo;
        l_rowtype.creado_por := ins.p_cohortes_rec.creado_por;
        l_rowtype.creado_el := ins.p_cohortes_rec.creado_el;
        l_rowtype.modificado_por := ins.p_cohortes_rec.modificado_por;
        l_rowtype.modificado_el := ins.p_cohortes_rec.modificado_el;
        l_rowtype.diplomado_id := ins.p_cohortes_rec.diplomado_id;
        l_rowtype.periodo := ins.p_cohortes_rec.periodo;
        l_rowtype.id_calendario := ins.p_cohortes_rec.id_calendario;
        l_rowtype.nivel := ins.p_cohortes_rec.nivel;
        l_rowtype.id_metodo := ins.p_cohortes_rec.id_metodo;
        l_rowtype.empresa := ins.p_cohortes_rec.empresa;
        l_rowtype.facilitador := ins.p_cohortes_rec.facilitador;

       INSERT INTO cohortes
          VALUES   l_rowtype
       RETURNING
                   codigo ,
                   id_horario ,
                   id_modalidad ,
                   cohorte ,
                   cupo ,
                   costo ,
                   inicial ,
                   costo_cuota ,
                   cuotas ,
                   status ,
                   id_ciudad ,
                   id ,
                   tipo_diplo ,
                   creado_por ,
                   creado_el ,
                   modificado_por ,
                   modificado_el ,
                   diplomado_id ,
                   periodo ,
                   id_calendario ,
                   nivel ,
                   id_metodo ,
                   empresa ,
                   facilitador 
            INTO   l_rowtype;

         ins.p_cohortes_rec.codigo := l_rowtype.codigo;
         ins.p_cohortes_rec.id_horario := l_rowtype.id_horario;
         ins.p_cohortes_rec.id_modalidad := l_rowtype.id_modalidad;
         ins.p_cohortes_rec.cohorte := l_rowtype.cohorte;
         ins.p_cohortes_rec.cupo := l_rowtype.cupo;
         ins.p_cohortes_rec.costo := l_rowtype.costo;
         ins.p_cohortes_rec.inicial := l_rowtype.inicial;
         ins.p_cohortes_rec.costo_cuota := l_rowtype.costo_cuota;
         ins.p_cohortes_rec.cuotas := l_rowtype.cuotas;
         ins.p_cohortes_rec.status := l_rowtype.status;
         ins.p_cohortes_rec.id_ciudad := l_rowtype.id_ciudad;
         ins.p_cohortes_rec.id := l_rowtype.id;
         ins.p_cohortes_rec.tipo_diplo := l_rowtype.tipo_diplo;
         ins.p_cohortes_rec.creado_por := l_rowtype.creado_por;
         ins.p_cohortes_rec.creado_el := l_rowtype.creado_el;
         ins.p_cohortes_rec.modificado_por := l_rowtype.modificado_por;
         ins.p_cohortes_rec.modificado_el := l_rowtype.modificado_el;
         ins.p_cohortes_rec.diplomado_id := l_rowtype.diplomado_id;
         ins.p_cohortes_rec.periodo := l_rowtype.periodo;
         ins.p_cohortes_rec.id_calendario := l_rowtype.id_calendario;
         ins.p_cohortes_rec.nivel := l_rowtype.nivel;
         ins.p_cohortes_rec.id_metodo := l_rowtype.id_metodo;
         ins.p_cohortes_rec.empresa := l_rowtype.empresa;
         ins.p_cohortes_rec.facilitador := l_rowtype.facilitador;



    END ins;

    PROCEDURE upd (
                  p_cohortes_rec         IN cohortes_rt,
                  p_ignore_nulls         IN boolean := FALSE
                  )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   cohortes
             SET codigo = NVL(p_cohortes_rec.codigo,codigo),
                id_horario = NVL(p_cohortes_rec.id_horario,id_horario),
                id_modalidad = NVL(p_cohortes_rec.id_modalidad,id_modalidad),
                cohorte = NVL(p_cohortes_rec.cohorte,cohorte),
                cupo = NVL(p_cohortes_rec.cupo,cupo),
                costo = NVL(p_cohortes_rec.costo,costo),
                inicial = NVL(p_cohortes_rec.inicial,inicial),
                costo_cuota = NVL(p_cohortes_rec.costo_cuota,costo_cuota),
                cuotas = NVL(p_cohortes_rec.cuotas,cuotas),
                status = NVL(p_cohortes_rec.status,status),
                id_ciudad = NVL(p_cohortes_rec.id_ciudad,id_ciudad),
                id = NVL(p_cohortes_rec.id,id),
                tipo_diplo = NVL(p_cohortes_rec.tipo_diplo,tipo_diplo),
                creado_por = NVL(p_cohortes_rec.creado_por,creado_por),
                creado_el = NVL(p_cohortes_rec.creado_el,creado_el),
                modificado_por = NVL(p_cohortes_rec.modificado_por,modificado_por),
                modificado_el = NVL(p_cohortes_rec.modificado_el,modificado_el),
                diplomado_id = NVL(p_cohortes_rec.diplomado_id,diplomado_id),
                periodo = NVL(p_cohortes_rec.periodo,periodo),
                id_calendario = NVL(p_cohortes_rec.id_calendario,id_calendario),
                nivel = NVL(p_cohortes_rec.nivel,nivel),
                id_metodo = NVL(p_cohortes_rec.id_metodo,id_metodo),
                empresa = NVL(p_cohortes_rec.empresa,empresa),
                facilitador = NVL(p_cohortes_rec.facilitador,facilitador)
           WHERE
                id = upd.p_cohortes_rec.id
                ;
       ELSE
          UPDATE   cohortes
             SET codigo = p_cohortes_rec.codigo,
                id_horario = p_cohortes_rec.id_horario,
                id_modalidad = p_cohortes_rec.id_modalidad,
                cohorte = p_cohortes_rec.cohorte,
                cupo = p_cohortes_rec.cupo,
                costo = p_cohortes_rec.costo,
                inicial = p_cohortes_rec.inicial,
                costo_cuota = p_cohortes_rec.costo_cuota,
                cuotas = p_cohortes_rec.cuotas,
                status = p_cohortes_rec.status,
                id_ciudad = p_cohortes_rec.id_ciudad,
                id = p_cohortes_rec.id,
                tipo_diplo = p_cohortes_rec.tipo_diplo,
                creado_por = p_cohortes_rec.creado_por,
                creado_el = p_cohortes_rec.creado_el,
                modificado_por = p_cohortes_rec.modificado_por,
                modificado_el = p_cohortes_rec.modificado_el,
                diplomado_id = p_cohortes_rec.diplomado_id,
                periodo = p_cohortes_rec.periodo,
                id_calendario = p_cohortes_rec.id_calendario,
                nivel = p_cohortes_rec.nivel,
                id_metodo = p_cohortes_rec.id_metodo,
                empresa = p_cohortes_rec.empresa,
                facilitador = p_cohortes_rec.facilitador
           WHERE
                id = upd.p_cohortes_rec.id
                ;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd;


    PROCEDURE upd_rowid (
                         p_cohortes_rec         IN cohortes_rt,
                         p_ignore_nulls         IN boolean := FALSE
                        )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   cohortes
             SET codigo = NVL(p_cohortes_rec.codigo,codigo),
                id_horario = NVL(p_cohortes_rec.id_horario,id_horario),
                id_modalidad = NVL(p_cohortes_rec.id_modalidad,id_modalidad),
                cohorte = NVL(p_cohortes_rec.cohorte,cohorte),
                cupo = NVL(p_cohortes_rec.cupo,cupo),
                costo = NVL(p_cohortes_rec.costo,costo),
                inicial = NVL(p_cohortes_rec.inicial,inicial),
                costo_cuota = NVL(p_cohortes_rec.costo_cuota,costo_cuota),
                cuotas = NVL(p_cohortes_rec.cuotas,cuotas),
                status = NVL(p_cohortes_rec.status,status),
                id_ciudad = NVL(p_cohortes_rec.id_ciudad,id_ciudad),
                id = NVL(p_cohortes_rec.id,id),
                tipo_diplo = NVL(p_cohortes_rec.tipo_diplo,tipo_diplo),
                creado_por = NVL(p_cohortes_rec.creado_por,creado_por),
                creado_el = NVL(p_cohortes_rec.creado_el,creado_el),
                modificado_por = NVL(p_cohortes_rec.modificado_por,modificado_por),
                modificado_el = NVL(p_cohortes_rec.modificado_el,modificado_el),
                diplomado_id = NVL(p_cohortes_rec.diplomado_id,diplomado_id),
                periodo = NVL(p_cohortes_rec.periodo,periodo),
                id_calendario = NVL(p_cohortes_rec.id_calendario,id_calendario),
                nivel = NVL(p_cohortes_rec.nivel,nivel),
                id_metodo = NVL(p_cohortes_rec.id_metodo,id_metodo),
                empresa = NVL(p_cohortes_rec.empresa,empresa),
                facilitador = NVL(p_cohortes_rec.facilitador,facilitador)
           WHERE  ROWID = p_cohortes_rec.row_id;
       ELSE
          UPDATE   cohortes
             SET codigo = p_cohortes_rec.codigo,
                id_horario = p_cohortes_rec.id_horario,
                id_modalidad = p_cohortes_rec.id_modalidad,
                cohorte = p_cohortes_rec.cohorte,
                cupo = p_cohortes_rec.cupo,
                costo = p_cohortes_rec.costo,
                inicial = p_cohortes_rec.inicial,
                costo_cuota = p_cohortes_rec.costo_cuota,
                cuotas = p_cohortes_rec.cuotas,
                status = p_cohortes_rec.status,
                id_ciudad = p_cohortes_rec.id_ciudad,
                id = p_cohortes_rec.id,
                tipo_diplo = p_cohortes_rec.tipo_diplo,
                creado_por = p_cohortes_rec.creado_por,
                creado_el = p_cohortes_rec.creado_el,
                modificado_por = p_cohortes_rec.modificado_por,
                modificado_el = p_cohortes_rec.modificado_el,
                diplomado_id = p_cohortes_rec.diplomado_id,
                periodo = p_cohortes_rec.periodo,
                id_calendario = p_cohortes_rec.id_calendario,
                nivel = p_cohortes_rec.nivel,
                id_metodo = p_cohortes_rec.id_metodo,
                empresa = p_cohortes_rec.empresa,
                facilitador = p_cohortes_rec.facilitador
           WHERE  ROWID = p_cohortes_rec.row_id;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd_rowid;

   PROCEDURE web_upd (
                  p_cohortes_rec         IN cohortes_rt,
                  p_ignore_nulls         IN boolean := FALSE
                )
   IS
      l_cohortes_rec cohortes_rt;
   BEGIN

      OPEN cohortes_cur(
                             web_upd.p_cohortes_rec.id
                        );

      FETCH cohortes_cur INTO l_cohortes_rec;

      IF cohortes_cur%NOTFOUND THEN
         CLOSE cohortes_cur;
         RAISE e_row_missing;
      ELSE
         IF p_cohortes_rec.hash != l_cohortes_rec.hash THEN
            CLOSE cohortes_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(p_ignore_nulls, FALSE)
            THEN

                UPDATE   cohortes
                   SET codigo = NVL(p_cohortes_rec.codigo,codigo),
                       id_horario = NVL(p_cohortes_rec.id_horario,id_horario),
                       id_modalidad = NVL(p_cohortes_rec.id_modalidad,id_modalidad),
                       cohorte = NVL(p_cohortes_rec.cohorte,cohorte),
                       cupo = NVL(p_cohortes_rec.cupo,cupo),
                       costo = NVL(p_cohortes_rec.costo,costo),
                       inicial = NVL(p_cohortes_rec.inicial,inicial),
                       costo_cuota = NVL(p_cohortes_rec.costo_cuota,costo_cuota),
                       cuotas = NVL(p_cohortes_rec.cuotas,cuotas),
                       status = NVL(p_cohortes_rec.status,status),
                       id_ciudad = NVL(p_cohortes_rec.id_ciudad,id_ciudad),
                       id = NVL(p_cohortes_rec.id,id),
                       tipo_diplo = NVL(p_cohortes_rec.tipo_diplo,tipo_diplo),
                       creado_por = NVL(p_cohortes_rec.creado_por,creado_por),
                       creado_el = NVL(p_cohortes_rec.creado_el,creado_el),
                       modificado_por = NVL(p_cohortes_rec.modificado_por,modificado_por),
                       modificado_el = NVL(p_cohortes_rec.modificado_el,modificado_el),
                       diplomado_id = NVL(p_cohortes_rec.diplomado_id,diplomado_id),
                       periodo = NVL(p_cohortes_rec.periodo,periodo),
                       id_calendario = NVL(p_cohortes_rec.id_calendario,id_calendario),
                       nivel = NVL(p_cohortes_rec.nivel,nivel),
                       id_metodo = NVL(p_cohortes_rec.id_metodo,id_metodo),
                       empresa = NVL(p_cohortes_rec.empresa,empresa),
                       facilitador = NVL(p_cohortes_rec.facilitador,facilitador)
               WHERE CURRENT OF cohortes_cur;
            ELSE
                UPDATE   cohortes
                   SET codigo = p_cohortes_rec.codigo,
                       id_horario = p_cohortes_rec.id_horario,
                       id_modalidad = p_cohortes_rec.id_modalidad,
                       cohorte = p_cohortes_rec.cohorte,
                       cupo = p_cohortes_rec.cupo,
                       costo = p_cohortes_rec.costo,
                       inicial = p_cohortes_rec.inicial,
                       costo_cuota = p_cohortes_rec.costo_cuota,
                       cuotas = p_cohortes_rec.cuotas,
                       status = p_cohortes_rec.status,
                       id_ciudad = p_cohortes_rec.id_ciudad,
                       id = p_cohortes_rec.id,
                       tipo_diplo = p_cohortes_rec.tipo_diplo,
                       creado_por = p_cohortes_rec.creado_por,
                       creado_el = p_cohortes_rec.creado_el,
                       modificado_por = p_cohortes_rec.modificado_por,
                       modificado_el = p_cohortes_rec.modificado_el,
                       diplomado_id = p_cohortes_rec.diplomado_id,
                       periodo = p_cohortes_rec.periodo,
                       id_calendario = p_cohortes_rec.id_calendario,
                       nivel = p_cohortes_rec.nivel,
                       id_metodo = p_cohortes_rec.id_metodo,
                       empresa = p_cohortes_rec.empresa,
                       facilitador = p_cohortes_rec.facilitador
               WHERE CURRENT OF cohortes_cur;
            END IF;

            CLOSE cohortes_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd;

   PROCEDURE web_upd_rowid (
                            p_cohortes_rec    IN cohortes_rt,
                            p_ignore_nulls         IN boolean := FALSE
                           )
   IS
      l_cohortes_rec cohortes_rt;
   BEGIN

      OPEN cohortes_rowid_cur(web_upd_rowid.p_cohortes_rec.row_id);

      FETCH cohortes_rowid_cur INTO l_cohortes_rec;

      IF cohortes_rowid_cur%NOTFOUND THEN
         CLOSE cohortes_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_upd_rowid.p_cohortes_rec.hash != l_cohortes_rec.hash THEN
            CLOSE cohortes_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(web_upd_rowid.p_ignore_nulls, FALSE)
            THEN
                UPDATE   cohortes
                   SET codigo = NVL(p_cohortes_rec.codigo,codigo),
                       id_horario = NVL(p_cohortes_rec.id_horario,id_horario),
                       id_modalidad = NVL(p_cohortes_rec.id_modalidad,id_modalidad),
                       cohorte = NVL(p_cohortes_rec.cohorte,cohorte),
                       cupo = NVL(p_cohortes_rec.cupo,cupo),
                       costo = NVL(p_cohortes_rec.costo,costo),
                       inicial = NVL(p_cohortes_rec.inicial,inicial),
                       costo_cuota = NVL(p_cohortes_rec.costo_cuota,costo_cuota),
                       cuotas = NVL(p_cohortes_rec.cuotas,cuotas),
                       status = NVL(p_cohortes_rec.status,status),
                       id_ciudad = NVL(p_cohortes_rec.id_ciudad,id_ciudad),
                       id = NVL(p_cohortes_rec.id,id),
                       tipo_diplo = NVL(p_cohortes_rec.tipo_diplo,tipo_diplo),
                       creado_por = NVL(p_cohortes_rec.creado_por,creado_por),
                       creado_el = NVL(p_cohortes_rec.creado_el,creado_el),
                       modificado_por = NVL(p_cohortes_rec.modificado_por,modificado_por),
                       modificado_el = NVL(p_cohortes_rec.modificado_el,modificado_el),
                       diplomado_id = NVL(p_cohortes_rec.diplomado_id,diplomado_id),
                       periodo = NVL(p_cohortes_rec.periodo,periodo),
                       id_calendario = NVL(p_cohortes_rec.id_calendario,id_calendario),
                       nivel = NVL(p_cohortes_rec.nivel,nivel),
                       id_metodo = NVL(p_cohortes_rec.id_metodo,id_metodo),
                       empresa = NVL(p_cohortes_rec.empresa,empresa),
                       facilitador = NVL(p_cohortes_rec.facilitador,facilitador)
               WHERE CURRENT OF cohortes_rowid_cur;
            ELSE
                UPDATE   cohortes
                   SET codigo = p_cohortes_rec.codigo,
                       id_horario = p_cohortes_rec.id_horario,
                       id_modalidad = p_cohortes_rec.id_modalidad,
                       cohorte = p_cohortes_rec.cohorte,
                       cupo = p_cohortes_rec.cupo,
                       costo = p_cohortes_rec.costo,
                       inicial = p_cohortes_rec.inicial,
                       costo_cuota = p_cohortes_rec.costo_cuota,
                       cuotas = p_cohortes_rec.cuotas,
                       status = p_cohortes_rec.status,
                       id_ciudad = p_cohortes_rec.id_ciudad,
                       id = p_cohortes_rec.id,
                       tipo_diplo = p_cohortes_rec.tipo_diplo,
                       creado_por = p_cohortes_rec.creado_por,
                       creado_el = p_cohortes_rec.creado_el,
                       modificado_por = p_cohortes_rec.modificado_por,
                       modificado_el = p_cohortes_rec.modificado_el,
                       diplomado_id = p_cohortes_rec.diplomado_id,
                       periodo = p_cohortes_rec.periodo,
                       id_calendario = p_cohortes_rec.id_calendario,
                       nivel = p_cohortes_rec.nivel,
                       id_metodo = p_cohortes_rec.id_metodo,
                       empresa = p_cohortes_rec.empresa,
                       facilitador = p_cohortes_rec.facilitador
               WHERE CURRENT OF cohortes_rowid_cur;
            END IF;

            CLOSE cohortes_rowid_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd_rowid;

    PROCEDURE del (
                  p_id IN cohortes.id%TYPE
                  )
    IS
    BEGIN

       DELETE FROM   cohortes
             WHERE
                  id = del.p_id
                   ;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del;

    PROCEDURE del_rowid (p_rowid IN varchar2)
    IS
    BEGIN

       DELETE FROM   cohortes
             WHERE   ROWID = del_rowid.p_rowid;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del_rowid;

    PROCEDURE web_del (
                      p_id IN cohortes.id%TYPE,
                      p_hash IN varchar2
                      )
   IS
      l_cohortes_rec cohortes_rt;
   BEGIN


      OPEN cohortes_cur(
                            web_del.p_id
                            );

      FETCH cohortes_cur INTO l_cohortes_rec;

      IF cohortes_cur%NOTFOUND THEN
         CLOSE cohortes_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del.p_hash != l_cohortes_rec.hash THEN
            CLOSE cohortes_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM cohortes
            WHERE CURRENT OF cohortes_cur;

            CLOSE cohortes_cur;
         END IF;
      END IF;



   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del;

   PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2)
   IS
      l_cohortes_rec cohortes_rt;
   BEGIN


      OPEN cohortes_rowid_cur(web_del_rowid.p_rowid);

      FETCH cohortes_rowid_cur INTO l_cohortes_rec;

      IF cohortes_rowid_cur%NOTFOUND THEN
         CLOSE cohortes_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del_rowid.p_hash != l_cohortes_rec.hash THEN
            CLOSE cohortes_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM cohortes
            WHERE CURRENT OF cohortes_rowid_cur;

            CLOSE cohortes_rowid_cur;
         END IF;
      END IF;

   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del_rowid;

END tapi_cohortes;

 

/
--------------------------------------------------------
--  DDL for Package Body TAPI_CONDICIONES_ESPECIALES
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."TAPI_CONDICIONES_ESPECIALES" IS

   /**
   * TAPI_CONDICIONES_ESPECIALES
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: 10-SEP-2019 11:26
   * Created By: FUNDAUC
   */


   --GLOBAL_PRIVATE_CURSORS
   --By PK
   CURSOR condiciones_especiales_cur (
                       p_id_condicion IN condiciones_especiales.id_condicion%TYPE
                       )
   IS
      SELECT
            id_condicion,
            descripcion,
            descuento,
            porcentaje,
            tapi_condiciones_especiales.hash(id_condicion),
            ROWID
      FROM condiciones_especiales
      WHERE
           id_condicion = condiciones_especiales_cur.p_id_condicion
      FOR UPDATE;

    --By Rowid
    CURSOR cond_es_rowid_cur (p_rowid IN VARCHAR2)
    IS
      SELECT
             id_condicion,
             descripcion,
             descuento,
             porcentaje,
             tapi_condiciones_especiales.hash(id_condicion),
             ROWID
      FROM condiciones_especiales
      WHERE ROWID = p_rowid
      FOR UPDATE;


    FUNCTION hash (
                  p_id_condicion IN condiciones_especiales.id_condicion%TYPE
                  )
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format VARCHAR2(64);
   BEGIN


     --Get actual NLS_DATE_FORMAT
     SELECT   VALUE
       INTO   l_date_format
       FROM   v$nls_parameters
      WHERE   parameter = 'NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            id_condicion||
            descripcion||
            descuento||
            porcentaje
      INTO l_string
      FROM condiciones_especiales
      WHERE
           id_condicion = hash.p_id_condicion
           ;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash;

    FUNCTION hash_rowid (p_rowid IN varchar2)
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format varchar2(64);
   BEGIN

      --Get actual NLS_DATE_FORMAT
      SELECT VALUE INTO l_date_format  FROM v$nls_parameters WHERE parameter ='NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            id_condicion||
            descripcion||
            descuento||
            porcentaje
      INTO l_string
      FROM condiciones_especiales
      WHERE  ROWID = hash_rowid.p_rowid;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash_rowid;

   FUNCTION rt (
               p_id_condicion IN condiciones_especiales.id_condicion%TYPE
               )
      RETURN condiciones_especiales_rt RESULT_CACHE
   IS
      l_condiciones_especiales_rec condiciones_especiales_rt;
   BEGIN

      SELECT a.*,
             tapi_condiciones_especiales.hash(id_condicion),
             rowid
      INTO l_condiciones_especiales_rec
      FROM condiciones_especiales a
      WHERE
           id_condicion = rt.p_id_condicion
           ;


      RETURN l_condiciones_especiales_rec;

   END rt;

   FUNCTION rt_for_update (
                          p_id_condicion IN condiciones_especiales.id_condicion%TYPE
                          )
      RETURN condiciones_especiales_rt RESULT_CACHE
   IS
      l_condiciones_especiales_rec condiciones_especiales_rt;
   BEGIN


      SELECT a.*,
             tapi_condiciones_especiales.hash(id_condicion),
             rowid
      INTO l_condiciones_especiales_rec
      FROM condiciones_especiales a
      WHERE
           id_condicion = rt_for_update.p_id_condicion
      FOR UPDATE;


      RETURN l_condiciones_especiales_rec;

   END rt_for_update;

    FUNCTION tt (
                p_id_condicion IN condiciones_especiales.id_condicion%TYPE DEFAULT NULL
                )
       RETURN condiciones_especiales_tt
       PIPELINED
    IS
       l_condiciones_especiales_rec   condiciones_especiales_rt;
    BEGIN

       FOR c1 IN (SELECT   a.*, ROWID
                    FROM   condiciones_especiales a
                   WHERE
                        id_condicion = NVL(tt.p_id_condicion,id_condicion)
                        )
       LOOP
              l_condiciones_especiales_rec.id_condicion := c1.id_condicion;
              l_condiciones_especiales_rec.descripcion := c1.descripcion;
              l_condiciones_especiales_rec.descuento := c1.descuento;
              l_condiciones_especiales_rec.porcentaje := c1.porcentaje;
              l_condiciones_especiales_rec.hash := tapi_condiciones_especiales.hash( c1.id_condicion);
              l_condiciones_especiales_rec.row_id := c1.ROWID;
              PIPE ROW (l_condiciones_especiales_rec);
       END LOOP;

       RETURN;

    END tt;


    PROCEDURE ins (p_condiciones_especiales_rec IN OUT condiciones_especiales_rt)
    IS
        l_rowtype     condiciones_especiales%ROWTYPE;

    BEGIN


        l_rowtype.id_condicion := ins.p_condiciones_especiales_rec.id_condicion;
        l_rowtype.descripcion := ins.p_condiciones_especiales_rec.descripcion;
        l_rowtype.descuento := ins.p_condiciones_especiales_rec.descuento;
        l_rowtype.porcentaje := ins.p_condiciones_especiales_rec.porcentaje;

       INSERT INTO condiciones_especiales
          VALUES   l_rowtype
       RETURNING
                   id_condicion ,
                   descripcion ,
                   descuento ,
                   porcentaje 
            INTO   l_rowtype;

         ins.p_condiciones_especiales_rec.id_condicion := l_rowtype.id_condicion;
         ins.p_condiciones_especiales_rec.descripcion := l_rowtype.descripcion;
         ins.p_condiciones_especiales_rec.descuento := l_rowtype.descuento;
         ins.p_condiciones_especiales_rec.porcentaje := l_rowtype.porcentaje;



    END ins;

    PROCEDURE upd (
                  p_condiciones_especiales_rec         IN condiciones_especiales_rt,
                  p_ignore_nulls         IN boolean := FALSE
                  )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   condiciones_especiales
             SET id_condicion = NVL(p_condiciones_especiales_rec.id_condicion,id_condicion),
                descripcion = NVL(p_condiciones_especiales_rec.descripcion,descripcion),
                descuento = NVL(p_condiciones_especiales_rec.descuento,descuento),
                porcentaje = NVL(p_condiciones_especiales_rec.porcentaje,porcentaje)
           WHERE
                id_condicion = upd.p_condiciones_especiales_rec.id_condicion
                ;
       ELSE
          UPDATE   condiciones_especiales
             SET id_condicion = p_condiciones_especiales_rec.id_condicion,
                descripcion = p_condiciones_especiales_rec.descripcion,
                descuento = p_condiciones_especiales_rec.descuento,
                porcentaje = p_condiciones_especiales_rec.porcentaje
           WHERE
                id_condicion = upd.p_condiciones_especiales_rec.id_condicion
                ;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd;


    PROCEDURE upd_rowid (
                         p_condiciones_especiales_rec         IN condiciones_especiales_rt,
                         p_ignore_nulls         IN boolean := FALSE
                        )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   condiciones_especiales
             SET id_condicion = NVL(p_condiciones_especiales_rec.id_condicion,id_condicion),
                descripcion = NVL(p_condiciones_especiales_rec.descripcion,descripcion),
                descuento = NVL(p_condiciones_especiales_rec.descuento,descuento),
                porcentaje = NVL(p_condiciones_especiales_rec.porcentaje,porcentaje)
           WHERE  ROWID = p_condiciones_especiales_rec.row_id;
       ELSE
          UPDATE   condiciones_especiales
             SET id_condicion = p_condiciones_especiales_rec.id_condicion,
                descripcion = p_condiciones_especiales_rec.descripcion,
                descuento = p_condiciones_especiales_rec.descuento,
                porcentaje = p_condiciones_especiales_rec.porcentaje
           WHERE  ROWID = p_condiciones_especiales_rec.row_id;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd_rowid;

   PROCEDURE web_upd (
                  p_condiciones_especiales_rec         IN condiciones_especiales_rt,
                  p_ignore_nulls         IN boolean := FALSE
                )
   IS
      l_condiciones_especiales_rec condiciones_especiales_rt;
   BEGIN

      OPEN condiciones_especiales_cur(
                             web_upd.p_condiciones_especiales_rec.id_condicion
                        );

      FETCH condiciones_especiales_cur INTO l_condiciones_especiales_rec;

      IF condiciones_especiales_cur%NOTFOUND THEN
         CLOSE condiciones_especiales_cur;
         RAISE e_row_missing;
      ELSE
         IF p_condiciones_especiales_rec.hash != l_condiciones_especiales_rec.hash THEN
            CLOSE condiciones_especiales_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(p_ignore_nulls, FALSE)
            THEN

                UPDATE   condiciones_especiales
                   SET id_condicion = NVL(p_condiciones_especiales_rec.id_condicion,id_condicion),
                       descripcion = NVL(p_condiciones_especiales_rec.descripcion,descripcion),
                       descuento = NVL(p_condiciones_especiales_rec.descuento,descuento),
                       porcentaje = NVL(p_condiciones_especiales_rec.porcentaje,porcentaje)
               WHERE CURRENT OF condiciones_especiales_cur;
            ELSE
                UPDATE   condiciones_especiales
                   SET id_condicion = p_condiciones_especiales_rec.id_condicion,
                       descripcion = p_condiciones_especiales_rec.descripcion,
                       descuento = p_condiciones_especiales_rec.descuento,
                       porcentaje = p_condiciones_especiales_rec.porcentaje
               WHERE CURRENT OF condiciones_especiales_cur;
            END IF;

            CLOSE condiciones_especiales_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd;

   PROCEDURE web_upd_rowid (
                            p_condiciones_especiales_rec    IN condiciones_especiales_rt,
                            p_ignore_nulls         IN boolean := FALSE
                           )
   IS
      l_condiciones_especiales_rec condiciones_especiales_rt;
   BEGIN

      OPEN cond_es_rowid_cur(web_upd_rowid.p_condiciones_especiales_rec.row_id);

      FETCH cond_es_rowid_cur INTO l_condiciones_especiales_rec;

      IF cond_es_rowid_cur%NOTFOUND THEN
         CLOSE cond_es_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_upd_rowid.p_condiciones_especiales_rec.hash != l_condiciones_especiales_rec.hash THEN
            CLOSE cond_es_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(web_upd_rowid.p_ignore_nulls, FALSE)
            THEN
                UPDATE   condiciones_especiales
                   SET id_condicion = NVL(p_condiciones_especiales_rec.id_condicion,id_condicion),
                       descripcion = NVL(p_condiciones_especiales_rec.descripcion,descripcion),
                       descuento = NVL(p_condiciones_especiales_rec.descuento,descuento),
                       porcentaje = NVL(p_condiciones_especiales_rec.porcentaje,porcentaje)
               WHERE CURRENT OF cond_es_rowid_cur;
            ELSE
                UPDATE   condiciones_especiales
                   SET id_condicion = p_condiciones_especiales_rec.id_condicion,
                       descripcion = p_condiciones_especiales_rec.descripcion,
                       descuento = p_condiciones_especiales_rec.descuento,
                       porcentaje = p_condiciones_especiales_rec.porcentaje
               WHERE CURRENT OF cond_es_rowid_cur;
            END IF;

            CLOSE cond_es_rowid_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd_rowid;

    PROCEDURE del (
                  p_id_condicion IN condiciones_especiales.id_condicion%TYPE
                  )
    IS
    BEGIN

       DELETE FROM   condiciones_especiales
             WHERE
                  id_condicion = del.p_id_condicion
                   ;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del;

    PROCEDURE del_rowid (p_rowid IN varchar2)
    IS
    BEGIN

       DELETE FROM   condiciones_especiales
             WHERE   ROWID = del_rowid.p_rowid;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del_rowid;

    PROCEDURE web_del (
                      p_id_condicion IN condiciones_especiales.id_condicion%TYPE,
                      p_hash IN varchar2
                      )
   IS
      l_condiciones_especiales_rec condiciones_especiales_rt;
   BEGIN


      OPEN condiciones_especiales_cur(
                            web_del.p_id_condicion
                            );

      FETCH condiciones_especiales_cur INTO l_condiciones_especiales_rec;

      IF condiciones_especiales_cur%NOTFOUND THEN
         CLOSE condiciones_especiales_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del.p_hash != l_condiciones_especiales_rec.hash THEN
            CLOSE condiciones_especiales_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM condiciones_especiales
            WHERE CURRENT OF condiciones_especiales_cur;

            CLOSE condiciones_especiales_cur;
         END IF;
      END IF;



   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del;

   PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2)
   IS
      l_condiciones_especiales_rec condiciones_especiales_rt;
   BEGIN


      OPEN cond_es_rowid_cur(web_del_rowid.p_rowid);

      FETCH cond_es_rowid_cur INTO l_condiciones_especiales_rec;

      IF cond_es_rowid_cur%NOTFOUND THEN
         CLOSE cond_es_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del_rowid.p_hash != l_condiciones_especiales_rec.hash THEN
            CLOSE cond_es_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM condiciones_especiales
            WHERE CURRENT OF cond_es_rowid_cur;

            CLOSE cond_es_rowid_cur;
         END IF;
      END IF;

   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del_rowid;

END tapi_condiciones_especiales;

/
--------------------------------------------------------
--  DDL for Package Body TAPI_CTAXCOB
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."TAPI_CTAXCOB" IS

   /**
   * TAPI_CTAXCOB
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: 23-OCT-2019 08:56
   * Created By: FUNDAUC
   */


   --GLOBAL_PRIVATE_CURSORS
   --By PK
   CURSOR ctaxcob_cur (
                       p_id IN ctaxcob.id%TYPE
                       )
   IS
      SELECT
            id,
            cliente_id,
            fecha,
            factura_id,
            deposito_id,
            credito,
            monto,
            tapi_ctaxcob.hash(id),
            ROWID
      FROM ctaxcob
      WHERE
           id = ctaxcob_cur.p_id
      FOR UPDATE;

    --By Rowid
    CURSOR ctaxcob_rowid_cur (p_rowid IN VARCHAR2)
    IS
      SELECT
             id,
             cliente_id,
             fecha,
             factura_id,
             deposito_id,
             credito,
             monto,
             tapi_ctaxcob.hash(id),
             ROWID
      FROM ctaxcob
      WHERE ROWID = p_rowid
      FOR UPDATE;


    FUNCTION hash (
                  p_id IN ctaxcob.id%TYPE
                  )
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format VARCHAR2(64);
   BEGIN


     --Get actual NLS_DATE_FORMAT
     SELECT   VALUE
       INTO   l_date_format
       FROM   v$nls_parameters
      WHERE   parameter = 'NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            id||
            cliente_id||
            fecha||
            factura_id||
            deposito_id||
            credito||
            monto
      INTO l_string
      FROM ctaxcob
      WHERE
           id = hash.p_id
           ;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash;

    FUNCTION hash_rowid (p_rowid IN varchar2)
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format varchar2(64);
   BEGIN

      --Get actual NLS_DATE_FORMAT
      SELECT VALUE INTO l_date_format  FROM v$nls_parameters WHERE parameter ='NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            id||
            cliente_id||
            fecha||
            factura_id||
            deposito_id||
            credito||
            monto
      INTO l_string
      FROM ctaxcob
      WHERE  ROWID = hash_rowid.p_rowid;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash_rowid;

   FUNCTION rt (
               p_id IN ctaxcob.id%TYPE
               )
      RETURN ctaxcob_rt RESULT_CACHE
   IS
      l_ctaxcob_rec ctaxcob_rt;
   BEGIN

      SELECT a.*,
             tapi_ctaxcob.hash(id),
             rowid
      INTO l_ctaxcob_rec
      FROM ctaxcob a
      WHERE
           id = rt.p_id
           ;


      RETURN l_ctaxcob_rec;

   END rt;

   FUNCTION rt_for_update (
                          p_id IN ctaxcob.id%TYPE
                          )
      RETURN ctaxcob_rt RESULT_CACHE
   IS
      l_ctaxcob_rec ctaxcob_rt;
   BEGIN


      SELECT a.*,
             tapi_ctaxcob.hash(id),
             rowid
      INTO l_ctaxcob_rec
      FROM ctaxcob a
      WHERE
           id = rt_for_update.p_id
      FOR UPDATE;


      RETURN l_ctaxcob_rec;

   END rt_for_update;

    FUNCTION tt (
                p_id IN ctaxcob.id%TYPE DEFAULT NULL
                )
       RETURN ctaxcob_tt
       PIPELINED
    IS
       l_ctaxcob_rec   ctaxcob_rt;
    BEGIN

       FOR c1 IN (SELECT   a.*, ROWID
                    FROM   ctaxcob a
                   WHERE
                        id = NVL(tt.p_id,id)
                        )
       LOOP
              l_ctaxcob_rec.id := c1.id;
              l_ctaxcob_rec.cliente_id := c1.cliente_id;
              l_ctaxcob_rec.fecha := c1.fecha;
              l_ctaxcob_rec.factura_id := c1.factura_id;
              l_ctaxcob_rec.deposito_id := c1.deposito_id;
              l_ctaxcob_rec.credito := c1.credito;
              l_ctaxcob_rec.monto := c1.monto;
              l_ctaxcob_rec.hash := tapi_ctaxcob.hash( c1.id);
              l_ctaxcob_rec.row_id := c1.ROWID;
              PIPE ROW (l_ctaxcob_rec);
       END LOOP;

       RETURN;

    END tt;


    PROCEDURE ins (p_ctaxcob_rec IN OUT ctaxcob_rt)
    IS
        l_rowtype     ctaxcob%ROWTYPE;

    BEGIN


        l_rowtype.id := ins.p_ctaxcob_rec.id;
        l_rowtype.cliente_id := ins.p_ctaxcob_rec.cliente_id;
        l_rowtype.fecha := ins.p_ctaxcob_rec.fecha;
        l_rowtype.factura_id := ins.p_ctaxcob_rec.factura_id;
        l_rowtype.deposito_id := ins.p_ctaxcob_rec.deposito_id;
        l_rowtype.credito := ins.p_ctaxcob_rec.credito;
        l_rowtype.monto := ins.p_ctaxcob_rec.monto;

       INSERT INTO ctaxcob
          VALUES   l_rowtype
       RETURNING
                   id ,
                   cliente_id ,
                   fecha ,
                   factura_id ,
                   deposito_id ,
                   credito ,
                   monto 
            INTO   l_rowtype;

         ins.p_ctaxcob_rec.id := l_rowtype.id;
         ins.p_ctaxcob_rec.cliente_id := l_rowtype.cliente_id;
         ins.p_ctaxcob_rec.fecha := l_rowtype.fecha;
         ins.p_ctaxcob_rec.factura_id := l_rowtype.factura_id;
         ins.p_ctaxcob_rec.deposito_id := l_rowtype.deposito_id;
         ins.p_ctaxcob_rec.credito := l_rowtype.credito;
         ins.p_ctaxcob_rec.monto := l_rowtype.monto;



    END ins;

    PROCEDURE upd (
                  p_ctaxcob_rec         IN ctaxcob_rt,
                  p_ignore_nulls         IN boolean := FALSE
                  )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   ctaxcob
             SET id = NVL(p_ctaxcob_rec.id,id),
                cliente_id = NVL(p_ctaxcob_rec.cliente_id,cliente_id),
                fecha = NVL(p_ctaxcob_rec.fecha,fecha),
                factura_id = NVL(p_ctaxcob_rec.factura_id,factura_id),
                deposito_id = NVL(p_ctaxcob_rec.deposito_id,deposito_id),
                credito = NVL(p_ctaxcob_rec.credito,credito),
                monto = NVL(p_ctaxcob_rec.monto,monto)
           WHERE
                id = upd.p_ctaxcob_rec.id
                ;
       ELSE
          UPDATE   ctaxcob
             SET id = p_ctaxcob_rec.id,
                cliente_id = p_ctaxcob_rec.cliente_id,
                fecha = p_ctaxcob_rec.fecha,
                factura_id = p_ctaxcob_rec.factura_id,
                deposito_id = p_ctaxcob_rec.deposito_id,
                credito = p_ctaxcob_rec.credito,
                monto = p_ctaxcob_rec.monto
           WHERE
                id = upd.p_ctaxcob_rec.id
                ;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd;


    PROCEDURE upd_rowid (
                         p_ctaxcob_rec         IN ctaxcob_rt,
                         p_ignore_nulls         IN boolean := FALSE
                        )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   ctaxcob
             SET id = NVL(p_ctaxcob_rec.id,id),
                cliente_id = NVL(p_ctaxcob_rec.cliente_id,cliente_id),
                fecha = NVL(p_ctaxcob_rec.fecha,fecha),
                factura_id = NVL(p_ctaxcob_rec.factura_id,factura_id),
                deposito_id = NVL(p_ctaxcob_rec.deposito_id,deposito_id),
                credito = NVL(p_ctaxcob_rec.credito,credito),
                monto = NVL(p_ctaxcob_rec.monto,monto)
           WHERE  ROWID = p_ctaxcob_rec.row_id;
       ELSE
          UPDATE   ctaxcob
             SET id = p_ctaxcob_rec.id,
                cliente_id = p_ctaxcob_rec.cliente_id,
                fecha = p_ctaxcob_rec.fecha,
                factura_id = p_ctaxcob_rec.factura_id,
                deposito_id = p_ctaxcob_rec.deposito_id,
                credito = p_ctaxcob_rec.credito,
                monto = p_ctaxcob_rec.monto
           WHERE  ROWID = p_ctaxcob_rec.row_id;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd_rowid;

   PROCEDURE web_upd (
                  p_ctaxcob_rec         IN ctaxcob_rt,
                  p_ignore_nulls         IN boolean := FALSE
                )
   IS
      l_ctaxcob_rec ctaxcob_rt;
   BEGIN

      OPEN ctaxcob_cur(
                             web_upd.p_ctaxcob_rec.id
                        );

      FETCH ctaxcob_cur INTO l_ctaxcob_rec;

      IF ctaxcob_cur%NOTFOUND THEN
         CLOSE ctaxcob_cur;
         RAISE e_row_missing;
      ELSE
         IF p_ctaxcob_rec.hash != l_ctaxcob_rec.hash THEN
            CLOSE ctaxcob_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(p_ignore_nulls, FALSE)
            THEN

                UPDATE   ctaxcob
                   SET id = NVL(p_ctaxcob_rec.id,id),
                       cliente_id = NVL(p_ctaxcob_rec.cliente_id,cliente_id),
                       fecha = NVL(p_ctaxcob_rec.fecha,fecha),
                       factura_id = NVL(p_ctaxcob_rec.factura_id,factura_id),
                       deposito_id = NVL(p_ctaxcob_rec.deposito_id,deposito_id),
                       credito = NVL(p_ctaxcob_rec.credito,credito),
                       monto = NVL(p_ctaxcob_rec.monto,monto)
               WHERE CURRENT OF ctaxcob_cur;
            ELSE
                UPDATE   ctaxcob
                   SET id = p_ctaxcob_rec.id,
                       cliente_id = p_ctaxcob_rec.cliente_id,
                       fecha = p_ctaxcob_rec.fecha,
                       factura_id = p_ctaxcob_rec.factura_id,
                       deposito_id = p_ctaxcob_rec.deposito_id,
                       credito = p_ctaxcob_rec.credito,
                       monto = p_ctaxcob_rec.monto
               WHERE CURRENT OF ctaxcob_cur;
            END IF;

            CLOSE ctaxcob_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd;

   PROCEDURE web_upd_rowid (
                            p_ctaxcob_rec    IN ctaxcob_rt,
                            p_ignore_nulls         IN boolean := FALSE
                           )
   IS
      l_ctaxcob_rec ctaxcob_rt;
   BEGIN

      OPEN ctaxcob_rowid_cur(web_upd_rowid.p_ctaxcob_rec.row_id);

      FETCH ctaxcob_rowid_cur INTO l_ctaxcob_rec;

      IF ctaxcob_rowid_cur%NOTFOUND THEN
         CLOSE ctaxcob_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_upd_rowid.p_ctaxcob_rec.hash != l_ctaxcob_rec.hash THEN
            CLOSE ctaxcob_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(web_upd_rowid.p_ignore_nulls, FALSE)
            THEN
                UPDATE   ctaxcob
                   SET id = NVL(p_ctaxcob_rec.id,id),
                       cliente_id = NVL(p_ctaxcob_rec.cliente_id,cliente_id),
                       fecha = NVL(p_ctaxcob_rec.fecha,fecha),
                       factura_id = NVL(p_ctaxcob_rec.factura_id,factura_id),
                       deposito_id = NVL(p_ctaxcob_rec.deposito_id,deposito_id),
                       credito = NVL(p_ctaxcob_rec.credito,credito),
                       monto = NVL(p_ctaxcob_rec.monto,monto)
               WHERE CURRENT OF ctaxcob_rowid_cur;
            ELSE
                UPDATE   ctaxcob
                   SET id = p_ctaxcob_rec.id,
                       cliente_id = p_ctaxcob_rec.cliente_id,
                       fecha = p_ctaxcob_rec.fecha,
                       factura_id = p_ctaxcob_rec.factura_id,
                       deposito_id = p_ctaxcob_rec.deposito_id,
                       credito = p_ctaxcob_rec.credito,
                       monto = p_ctaxcob_rec.monto
               WHERE CURRENT OF ctaxcob_rowid_cur;
            END IF;

            CLOSE ctaxcob_rowid_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd_rowid;

    PROCEDURE del (
                  p_id IN ctaxcob.id%TYPE
                  )
    IS
    BEGIN

       DELETE FROM   ctaxcob
             WHERE
                  id = del.p_id
                   ;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del;

    PROCEDURE del_rowid (p_rowid IN varchar2)
    IS
    BEGIN

       DELETE FROM   ctaxcob
             WHERE   ROWID = del_rowid.p_rowid;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del_rowid;

    PROCEDURE web_del (
                      p_id IN ctaxcob.id%TYPE,
                      p_hash IN varchar2
                      )
   IS
      l_ctaxcob_rec ctaxcob_rt;
   BEGIN


      OPEN ctaxcob_cur(
                            web_del.p_id
                            );

      FETCH ctaxcob_cur INTO l_ctaxcob_rec;

      IF ctaxcob_cur%NOTFOUND THEN
         CLOSE ctaxcob_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del.p_hash != l_ctaxcob_rec.hash THEN
            CLOSE ctaxcob_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM ctaxcob
            WHERE CURRENT OF ctaxcob_cur;

            CLOSE ctaxcob_cur;
         END IF;
      END IF;



   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del;

   PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2)
   IS
      l_ctaxcob_rec ctaxcob_rt;
   BEGIN


      OPEN ctaxcob_rowid_cur(web_del_rowid.p_rowid);

      FETCH ctaxcob_rowid_cur INTO l_ctaxcob_rec;

      IF ctaxcob_rowid_cur%NOTFOUND THEN
         CLOSE ctaxcob_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del_rowid.p_hash != l_ctaxcob_rec.hash THEN
            CLOSE ctaxcob_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM ctaxcob
            WHERE CURRENT OF ctaxcob_rowid_cur;

            CLOSE ctaxcob_rowid_cur;
         END IF;
      END IF;

   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del_rowid;

END tapi_ctaxcob;

 

/
--------------------------------------------------------
--  DDL for Package Body TAPI_DEPOSITO
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."TAPI_DEPOSITO" IS

   /**
   * TAPI_DEPOSITO
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: 05-OCT-2019 09:51
   * Created By: FUNDAUC
   */


   --GLOBAL_PRIVATE_CURSORS
   --By PK
   CURSOR deposito_cur (
                       p_id IN deposito.id%TYPE
                       )
   IS
      SELECT
            referencia,
            fecha_emi,
            id_banco,
            monto,
            sede,
            usuario,
            status,
            forma_pago,
            id,
            tapi_deposito.hash(id),
            ROWID
      FROM deposito
      WHERE
           id = deposito_cur.p_id
      FOR UPDATE;

    --By Rowid
    CURSOR deposito_rowid_cur (p_rowid IN VARCHAR2)
    IS
      SELECT
             referencia,
             fecha_emi,
             id_banco,
             monto,
             sede,
             usuario,
             status,
             forma_pago,
             id,
             tapi_deposito.hash(id),
             ROWID
      FROM deposito
      WHERE ROWID = p_rowid
      FOR UPDATE;


    FUNCTION hash (
                  p_id IN deposito.id%TYPE
                  )
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format VARCHAR2(64);
   BEGIN


     --Get actual NLS_DATE_FORMAT
     SELECT   VALUE
       INTO   l_date_format
       FROM   v$nls_parameters
      WHERE   parameter = 'NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            referencia||
            fecha_emi||
            id_banco||
            monto||
            sede||
            usuario||
            status||
            forma_pago||
            id
      INTO l_string
      FROM deposito
      WHERE
           id = hash.p_id
           ;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash;

    FUNCTION hash_rowid (p_rowid IN varchar2)
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format varchar2(64);
   BEGIN

      --Get actual NLS_DATE_FORMAT
      SELECT VALUE INTO l_date_format  FROM v$nls_parameters WHERE parameter ='NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            referencia||
            fecha_emi||
            id_banco||
            monto||
            sede||
            usuario||
            status||
            forma_pago||
            id
      INTO l_string
      FROM deposito
      WHERE  ROWID = hash_rowid.p_rowid;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash_rowid;

   FUNCTION rt (
               p_id IN deposito.id%TYPE
               )
      RETURN deposito_rt RESULT_CACHE
   IS
      l_deposito_rec deposito_rt;
   BEGIN

      SELECT a.*,
             tapi_deposito.hash(id),
             rowid
      INTO l_deposito_rec
      FROM deposito a
      WHERE
           id = rt.p_id
           ;


      RETURN l_deposito_rec;

   END rt;

   FUNCTION rt_for_update (
                          p_id IN deposito.id%TYPE
                          )
      RETURN deposito_rt RESULT_CACHE
   IS
      l_deposito_rec deposito_rt;
   BEGIN


      SELECT a.*,
             tapi_deposito.hash(id),
             rowid
      INTO l_deposito_rec
      FROM deposito a
      WHERE
           id = rt_for_update.p_id
      FOR UPDATE;


      RETURN l_deposito_rec;

   END rt_for_update;

    FUNCTION tt (
                p_id IN deposito.id%TYPE DEFAULT NULL
                )
       RETURN deposito_tt
       PIPELINED
    IS
       l_deposito_rec   deposito_rt;
    BEGIN

       FOR c1 IN (SELECT   a.*, ROWID
                    FROM   deposito a
                   WHERE
                        id = NVL(tt.p_id,id)
                        )
       LOOP
              l_deposito_rec.referencia := c1.referencia;
              l_deposito_rec.fecha_emi := c1.fecha_emi;
              l_deposito_rec.id_banco := c1.id_banco;
              l_deposito_rec.monto := c1.monto;
              l_deposito_rec.sede := c1.sede;
              l_deposito_rec.usuario := c1.usuario;
              l_deposito_rec.status := c1.status;
              l_deposito_rec.forma_pago := c1.forma_pago;
              l_deposito_rec.id := c1.id;
              l_deposito_rec.hash := tapi_deposito.hash( c1.id);
              l_deposito_rec.row_id := c1.ROWID;
              PIPE ROW (l_deposito_rec);
       END LOOP;

       RETURN;

    END tt;


    PROCEDURE ins (p_deposito_rec IN OUT deposito_rt)
    IS
        l_rowtype     deposito%ROWTYPE;

    BEGIN


        l_rowtype.referencia := ins.p_deposito_rec.referencia;
        l_rowtype.fecha_emi := ins.p_deposito_rec.fecha_emi;
        l_rowtype.id_banco := ins.p_deposito_rec.id_banco;
        l_rowtype.monto := ins.p_deposito_rec.monto;
        l_rowtype.sede := ins.p_deposito_rec.sede;
        l_rowtype.usuario := ins.p_deposito_rec.usuario;
        l_rowtype.status := ins.p_deposito_rec.status;
        l_rowtype.forma_pago := ins.p_deposito_rec.forma_pago;
        l_rowtype.id := ins.p_deposito_rec.id;

       INSERT INTO deposito
          VALUES   l_rowtype
       RETURNING
                   referencia ,
                   fecha_emi ,
                   id_banco ,
                   monto ,
                   sede ,
                   usuario ,
                   status ,
                   forma_pago ,
                   id 
            INTO   l_rowtype;

         ins.p_deposito_rec.referencia := l_rowtype.referencia;
         ins.p_deposito_rec.fecha_emi := l_rowtype.fecha_emi;
         ins.p_deposito_rec.id_banco := l_rowtype.id_banco;
         ins.p_deposito_rec.monto := l_rowtype.monto;
         ins.p_deposito_rec.sede := l_rowtype.sede;
         ins.p_deposito_rec.usuario := l_rowtype.usuario;
         ins.p_deposito_rec.status := l_rowtype.status;
         ins.p_deposito_rec.forma_pago := l_rowtype.forma_pago;
         ins.p_deposito_rec.id := l_rowtype.id;



    END ins;

    PROCEDURE upd (
                  p_deposito_rec         IN deposito_rt,
                  p_ignore_nulls         IN boolean := FALSE
                  )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   deposito
             SET referencia = NVL(p_deposito_rec.referencia,referencia),
                fecha_emi = NVL(p_deposito_rec.fecha_emi,fecha_emi),
                id_banco = NVL(p_deposito_rec.id_banco,id_banco),
                monto = NVL(p_deposito_rec.monto,monto),
                sede = NVL(p_deposito_rec.sede,sede),
                usuario = NVL(p_deposito_rec.usuario,usuario),
                status = NVL(p_deposito_rec.status,status),
                forma_pago = NVL(p_deposito_rec.forma_pago,forma_pago),
                id = NVL(p_deposito_rec.id,id)
           WHERE
                id = upd.p_deposito_rec.id
                ;
       ELSE
          UPDATE   deposito
             SET referencia = p_deposito_rec.referencia,
                fecha_emi = p_deposito_rec.fecha_emi,
                id_banco = p_deposito_rec.id_banco,
                monto = p_deposito_rec.monto,
                sede = p_deposito_rec.sede,
                usuario = p_deposito_rec.usuario,
                status = p_deposito_rec.status,
                forma_pago = p_deposito_rec.forma_pago,
                id = p_deposito_rec.id
           WHERE
                id = upd.p_deposito_rec.id
                ;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd;


    PROCEDURE upd_rowid (
                         p_deposito_rec         IN deposito_rt,
                         p_ignore_nulls         IN boolean := FALSE
                        )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   deposito
             SET referencia = NVL(p_deposito_rec.referencia,referencia),
                fecha_emi = NVL(p_deposito_rec.fecha_emi,fecha_emi),
                id_banco = NVL(p_deposito_rec.id_banco,id_banco),
                monto = NVL(p_deposito_rec.monto,monto),
                sede = NVL(p_deposito_rec.sede,sede),
                usuario = NVL(p_deposito_rec.usuario,usuario),
                status = NVL(p_deposito_rec.status,status),
                forma_pago = NVL(p_deposito_rec.forma_pago,forma_pago),
                id = NVL(p_deposito_rec.id,id)
           WHERE  ROWID = p_deposito_rec.row_id;
       ELSE
          UPDATE   deposito
             SET referencia = p_deposito_rec.referencia,
                fecha_emi = p_deposito_rec.fecha_emi,
                id_banco = p_deposito_rec.id_banco,
                monto = p_deposito_rec.monto,
                sede = p_deposito_rec.sede,
                usuario = p_deposito_rec.usuario,
                status = p_deposito_rec.status,
                forma_pago = p_deposito_rec.forma_pago,
                id = p_deposito_rec.id
           WHERE  ROWID = p_deposito_rec.row_id;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd_rowid;

   PROCEDURE web_upd (
                  p_deposito_rec         IN deposito_rt,
                  p_ignore_nulls         IN boolean := FALSE
                )
   IS
      l_deposito_rec deposito_rt;
   BEGIN

      OPEN deposito_cur(
                             web_upd.p_deposito_rec.id
                        );

      FETCH deposito_cur INTO l_deposito_rec;

      IF deposito_cur%NOTFOUND THEN
         CLOSE deposito_cur;
         RAISE e_row_missing;
      ELSE
         IF p_deposito_rec.hash != l_deposito_rec.hash THEN
            CLOSE deposito_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(p_ignore_nulls, FALSE)
            THEN

                UPDATE   deposito
                   SET referencia = NVL(p_deposito_rec.referencia,referencia),
                       fecha_emi = NVL(p_deposito_rec.fecha_emi,fecha_emi),
                       id_banco = NVL(p_deposito_rec.id_banco,id_banco),
                       monto = NVL(p_deposito_rec.monto,monto),
                       sede = NVL(p_deposito_rec.sede,sede),
                       usuario = NVL(p_deposito_rec.usuario,usuario),
                       status = NVL(p_deposito_rec.status,status),
                       forma_pago = NVL(p_deposito_rec.forma_pago,forma_pago),
                       id = NVL(p_deposito_rec.id,id)
               WHERE CURRENT OF deposito_cur;
            ELSE
                UPDATE   deposito
                   SET referencia = p_deposito_rec.referencia,
                       fecha_emi = p_deposito_rec.fecha_emi,
                       id_banco = p_deposito_rec.id_banco,
                       monto = p_deposito_rec.monto,
                       sede = p_deposito_rec.sede,
                       usuario = p_deposito_rec.usuario,
                       status = p_deposito_rec.status,
                       forma_pago = p_deposito_rec.forma_pago,
                       id = p_deposito_rec.id
               WHERE CURRENT OF deposito_cur;
            END IF;

            CLOSE deposito_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd;

   PROCEDURE web_upd_rowid (
                            p_deposito_rec    IN deposito_rt,
                            p_ignore_nulls         IN boolean := FALSE
                           )
   IS
      l_deposito_rec deposito_rt;
   BEGIN

      OPEN deposito_rowid_cur(web_upd_rowid.p_deposito_rec.row_id);

      FETCH deposito_rowid_cur INTO l_deposito_rec;

      IF deposito_rowid_cur%NOTFOUND THEN
         CLOSE deposito_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_upd_rowid.p_deposito_rec.hash != l_deposito_rec.hash THEN
            CLOSE deposito_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(web_upd_rowid.p_ignore_nulls, FALSE)
            THEN
                UPDATE   deposito
                   SET referencia = NVL(p_deposito_rec.referencia,referencia),
                       fecha_emi = NVL(p_deposito_rec.fecha_emi,fecha_emi),
                       id_banco = NVL(p_deposito_rec.id_banco,id_banco),
                       monto = NVL(p_deposito_rec.monto,monto),
                       sede = NVL(p_deposito_rec.sede,sede),
                       usuario = NVL(p_deposito_rec.usuario,usuario),
                       status = NVL(p_deposito_rec.status,status),
                       forma_pago = NVL(p_deposito_rec.forma_pago,forma_pago),
                       id = NVL(p_deposito_rec.id,id)
               WHERE CURRENT OF deposito_rowid_cur;
            ELSE
                UPDATE   deposito
                   SET referencia = p_deposito_rec.referencia,
                       fecha_emi = p_deposito_rec.fecha_emi,
                       id_banco = p_deposito_rec.id_banco,
                       monto = p_deposito_rec.monto,
                       sede = p_deposito_rec.sede,
                       usuario = p_deposito_rec.usuario,
                       status = p_deposito_rec.status,
                       forma_pago = p_deposito_rec.forma_pago,
                       id = p_deposito_rec.id
               WHERE CURRENT OF deposito_rowid_cur;
            END IF;

            CLOSE deposito_rowid_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd_rowid;

    PROCEDURE del (
                  p_id IN deposito.id%TYPE
                  )
    IS
    BEGIN

       DELETE FROM   deposito
             WHERE
                  id = del.p_id
                   ;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del;

    PROCEDURE del_rowid (p_rowid IN varchar2)
    IS
    BEGIN

       DELETE FROM   deposito
             WHERE   ROWID = del_rowid.p_rowid;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del_rowid;

    PROCEDURE web_del (
                      p_id IN deposito.id%TYPE,
                      p_hash IN varchar2
                      )
   IS
      l_deposito_rec deposito_rt;
   BEGIN


      OPEN deposito_cur(
                            web_del.p_id
                            );

      FETCH deposito_cur INTO l_deposito_rec;

      IF deposito_cur%NOTFOUND THEN
         CLOSE deposito_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del.p_hash != l_deposito_rec.hash THEN
            CLOSE deposito_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM deposito
            WHERE CURRENT OF deposito_cur;

            CLOSE deposito_cur;
         END IF;
      END IF;



   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del;

   PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2)
   IS
      l_deposito_rec deposito_rt;
   BEGIN


      OPEN deposito_rowid_cur(web_del_rowid.p_rowid);

      FETCH deposito_rowid_cur INTO l_deposito_rec;

      IF deposito_rowid_cur%NOTFOUND THEN
         CLOSE deposito_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del_rowid.p_hash != l_deposito_rec.hash THEN
            CLOSE deposito_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM deposito
            WHERE CURRENT OF deposito_rowid_cur;

            CLOSE deposito_rowid_cur;
         END IF;
      END IF;

   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del_rowid;

END tapi_deposito;

 

/
--------------------------------------------------------
--  DDL for Package Body TAPI_DETALLE_FACTURA
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."TAPI_DETALLE_FACTURA" IS

   /**
   * TAPI_DETALLE_FACTURA
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: 25-FEB-2020 18:39
   * Created By: FUNDAUC
   */


   --GLOBAL_PRIVATE_CURSORS
   --By PK
   CURSOR detalle_factura_cur (
                       p_renglon IN detalle_factura.renglon%TYPE
                       )
   IS
      SELECT
            renglon,
            tipo_item,
            item,
            descripcion,
            cantidad,
            p_unidad,
            bs_descuento,
            subtotal,
            materiales_id,
            factura_id,
            tapi_detalle_factura.hash(renglon),
            ROWID
      FROM detalle_factura
      WHERE
           renglon = detalle_factura_cur.p_renglon
      FOR UPDATE;

    --By Rowid
    CURSOR detalle_factura_rowid_cur (p_rowid IN VARCHAR2)
    IS
      SELECT
             renglon,
             tipo_item,
             item,
             descripcion,
             cantidad,
             p_unidad,
             bs_descuento,
             subtotal,
             materiales_id,
             factura_id,
             tapi_detalle_factura.hash(renglon),
             ROWID
      FROM detalle_factura
      WHERE ROWID = p_rowid
      FOR UPDATE;


    FUNCTION hash (
                  p_renglon IN detalle_factura.renglon%TYPE
                  )
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format VARCHAR2(64);
   BEGIN


     --Get actual NLS_DATE_FORMAT
     SELECT   VALUE
       INTO   l_date_format
       FROM   v$nls_parameters
      WHERE   parameter = 'NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            renglon||
            tipo_item||
            item||
            descripcion||
            cantidad||
            p_unidad||
            bs_descuento||
            subtotal||
            materiales_id||
            factura_id
      INTO l_string
      FROM detalle_factura
      WHERE
           renglon = hash.p_renglon
           ;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash;

    FUNCTION hash_rowid (p_rowid IN varchar2)
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format varchar2(64);
   BEGIN

      --Get actual NLS_DATE_FORMAT
      SELECT VALUE INTO l_date_format  FROM v$nls_parameters WHERE parameter ='NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            renglon||
            tipo_item||
            item||
            descripcion||
            cantidad||
            p_unidad||
            bs_descuento||
            subtotal||
            materiales_id||
            factura_id
      INTO l_string
      FROM detalle_factura
      WHERE  ROWID = hash_rowid.p_rowid;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash_rowid;

   FUNCTION rt (
               p_renglon IN detalle_factura.renglon%TYPE
               )
      RETURN detalle_factura_rt RESULT_CACHE
   IS
      l_detalle_factura_rec detalle_factura_rt;
   BEGIN

      SELECT a.*,
             tapi_detalle_factura.hash(renglon),
             rowid
      INTO l_detalle_factura_rec
      FROM detalle_factura a
      WHERE
           renglon = rt.p_renglon
           ;


      RETURN l_detalle_factura_rec;

   END rt;

   FUNCTION rt_for_update (
                          p_renglon IN detalle_factura.renglon%TYPE
                          )
      RETURN detalle_factura_rt RESULT_CACHE
   IS
      l_detalle_factura_rec detalle_factura_rt;
   BEGIN


      SELECT a.*,
             tapi_detalle_factura.hash(renglon),
             rowid
      INTO l_detalle_factura_rec
      FROM detalle_factura a
      WHERE
           renglon = rt_for_update.p_renglon
      FOR UPDATE;


      RETURN l_detalle_factura_rec;

   END rt_for_update;

    FUNCTION tt (
                p_renglon IN detalle_factura.renglon%TYPE DEFAULT NULL
                )
       RETURN detalle_factura_tt
       PIPELINED
    IS
       l_detalle_factura_rec   detalle_factura_rt;
    BEGIN

       FOR c1 IN (SELECT   a.*, ROWID
                    FROM   detalle_factura a
                   WHERE
                        renglon = NVL(tt.p_renglon,renglon)
                        )
       LOOP
              l_detalle_factura_rec.renglon := c1.renglon;
              l_detalle_factura_rec.tipo_item := c1.tipo_item;
              l_detalle_factura_rec.item := c1.item;
              l_detalle_factura_rec.descripcion := c1.descripcion;
              l_detalle_factura_rec.cantidad := c1.cantidad;
              l_detalle_factura_rec.p_unidad := c1.p_unidad;
              l_detalle_factura_rec.bs_descuento := c1.bs_descuento;
              l_detalle_factura_rec.subtotal := c1.subtotal;
              l_detalle_factura_rec.materiales_id := c1.materiales_id;
              l_detalle_factura_rec.factura_id := c1.factura_id;
              l_detalle_factura_rec.hash := tapi_detalle_factura.hash( c1.renglon);
              l_detalle_factura_rec.row_id := c1.ROWID;
              PIPE ROW (l_detalle_factura_rec);
       END LOOP;

       RETURN;

    END tt;


    PROCEDURE ins (p_detalle_factura_rec IN OUT detalle_factura_rt)
    IS
        l_rowtype     detalle_factura%ROWTYPE;

    BEGIN


        l_rowtype.renglon := ins.p_detalle_factura_rec.renglon;
        l_rowtype.tipo_item := ins.p_detalle_factura_rec.tipo_item;
        l_rowtype.item := ins.p_detalle_factura_rec.item;
        l_rowtype.descripcion := ins.p_detalle_factura_rec.descripcion;
        l_rowtype.cantidad := ins.p_detalle_factura_rec.cantidad;
        l_rowtype.p_unidad := ins.p_detalle_factura_rec.p_unidad;
        l_rowtype.bs_descuento := ins.p_detalle_factura_rec.bs_descuento;
        l_rowtype.subtotal := ins.p_detalle_factura_rec.subtotal;
        l_rowtype.materiales_id := ins.p_detalle_factura_rec.materiales_id;
        l_rowtype.factura_id := ins.p_detalle_factura_rec.factura_id;

       INSERT INTO detalle_factura
          VALUES   l_rowtype
       RETURNING
                   renglon ,
                   tipo_item ,
                   item ,
                   descripcion ,
                   cantidad ,
                   p_unidad ,
                   bs_descuento ,
                   subtotal ,
                   materiales_id ,
                   factura_id 
            INTO   l_rowtype;

         ins.p_detalle_factura_rec.renglon := l_rowtype.renglon;
         ins.p_detalle_factura_rec.tipo_item := l_rowtype.tipo_item;
         ins.p_detalle_factura_rec.item := l_rowtype.item;
         ins.p_detalle_factura_rec.descripcion := l_rowtype.descripcion;
         ins.p_detalle_factura_rec.cantidad := l_rowtype.cantidad;
         ins.p_detalle_factura_rec.p_unidad := l_rowtype.p_unidad;
         ins.p_detalle_factura_rec.bs_descuento := l_rowtype.bs_descuento;
         ins.p_detalle_factura_rec.subtotal := l_rowtype.subtotal;
         ins.p_detalle_factura_rec.materiales_id := l_rowtype.materiales_id;
         ins.p_detalle_factura_rec.factura_id := l_rowtype.factura_id;



    END ins;

    PROCEDURE upd (
                  p_detalle_factura_rec         IN detalle_factura_rt,
                  p_ignore_nulls         IN boolean := FALSE
                  )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   detalle_factura
             SET renglon = NVL(p_detalle_factura_rec.renglon,renglon),
                tipo_item = NVL(p_detalle_factura_rec.tipo_item,tipo_item),
                item = NVL(p_detalle_factura_rec.item,item),
                descripcion = NVL(p_detalle_factura_rec.descripcion,descripcion),
                cantidad = NVL(p_detalle_factura_rec.cantidad,cantidad),
                p_unidad = NVL(p_detalle_factura_rec.p_unidad,p_unidad),
                bs_descuento = NVL(p_detalle_factura_rec.bs_descuento,bs_descuento),
                subtotal = NVL(p_detalle_factura_rec.subtotal,subtotal),
                materiales_id = NVL(p_detalle_factura_rec.materiales_id,materiales_id),
                factura_id = NVL(p_detalle_factura_rec.factura_id,factura_id)
           WHERE
                renglon = upd.p_detalle_factura_rec.renglon
                ;
       ELSE
          UPDATE   detalle_factura
             SET renglon = p_detalle_factura_rec.renglon,
                tipo_item = p_detalle_factura_rec.tipo_item,
                item = p_detalle_factura_rec.item,
                descripcion = p_detalle_factura_rec.descripcion,
                cantidad = p_detalle_factura_rec.cantidad,
                p_unidad = p_detalle_factura_rec.p_unidad,
                bs_descuento = p_detalle_factura_rec.bs_descuento,
                subtotal = p_detalle_factura_rec.subtotal,
                materiales_id = p_detalle_factura_rec.materiales_id,
                factura_id = p_detalle_factura_rec.factura_id
           WHERE
                renglon = upd.p_detalle_factura_rec.renglon
                ;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd;


    PROCEDURE upd_rowid (
                         p_detalle_factura_rec         IN detalle_factura_rt,
                         p_ignore_nulls         IN boolean := FALSE
                        )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   detalle_factura
             SET renglon = NVL(p_detalle_factura_rec.renglon,renglon),
                tipo_item = NVL(p_detalle_factura_rec.tipo_item,tipo_item),
                item = NVL(p_detalle_factura_rec.item,item),
                descripcion = NVL(p_detalle_factura_rec.descripcion,descripcion),
                cantidad = NVL(p_detalle_factura_rec.cantidad,cantidad),
                p_unidad = NVL(p_detalle_factura_rec.p_unidad,p_unidad),
                bs_descuento = NVL(p_detalle_factura_rec.bs_descuento,bs_descuento),
                subtotal = NVL(p_detalle_factura_rec.subtotal,subtotal),
                materiales_id = NVL(p_detalle_factura_rec.materiales_id,materiales_id),
                factura_id = NVL(p_detalle_factura_rec.factura_id,factura_id)
           WHERE  ROWID = p_detalle_factura_rec.row_id;
       ELSE
          UPDATE   detalle_factura
             SET renglon = p_detalle_factura_rec.renglon,
                tipo_item = p_detalle_factura_rec.tipo_item,
                item = p_detalle_factura_rec.item,
                descripcion = p_detalle_factura_rec.descripcion,
                cantidad = p_detalle_factura_rec.cantidad,
                p_unidad = p_detalle_factura_rec.p_unidad,
                bs_descuento = p_detalle_factura_rec.bs_descuento,
                subtotal = p_detalle_factura_rec.subtotal,
                materiales_id = p_detalle_factura_rec.materiales_id,
                factura_id = p_detalle_factura_rec.factura_id
           WHERE  ROWID = p_detalle_factura_rec.row_id;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd_rowid;

   PROCEDURE web_upd (
                  p_detalle_factura_rec         IN detalle_factura_rt,
                  p_ignore_nulls         IN boolean := FALSE
                )
   IS
      l_detalle_factura_rec detalle_factura_rt;
   BEGIN

      OPEN detalle_factura_cur(
                             web_upd.p_detalle_factura_rec.renglon
                        );

      FETCH detalle_factura_cur INTO l_detalle_factura_rec;

      IF detalle_factura_cur%NOTFOUND THEN
         CLOSE detalle_factura_cur;
         RAISE e_row_missing;
      ELSE
         IF p_detalle_factura_rec.hash != l_detalle_factura_rec.hash THEN
            CLOSE detalle_factura_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(p_ignore_nulls, FALSE)
            THEN

                UPDATE   detalle_factura
                   SET renglon = NVL(p_detalle_factura_rec.renglon,renglon),
                       tipo_item = NVL(p_detalle_factura_rec.tipo_item,tipo_item),
                       item = NVL(p_detalle_factura_rec.item,item),
                       descripcion = NVL(p_detalle_factura_rec.descripcion,descripcion),
                       cantidad = NVL(p_detalle_factura_rec.cantidad,cantidad),
                       p_unidad = NVL(p_detalle_factura_rec.p_unidad,p_unidad),
                       bs_descuento = NVL(p_detalle_factura_rec.bs_descuento,bs_descuento),
                       subtotal = NVL(p_detalle_factura_rec.subtotal,subtotal),
                       materiales_id = NVL(p_detalle_factura_rec.materiales_id,materiales_id),
                       factura_id = NVL(p_detalle_factura_rec.factura_id,factura_id)
               WHERE CURRENT OF detalle_factura_cur;
            ELSE
                UPDATE   detalle_factura
                   SET renglon = p_detalle_factura_rec.renglon,
                       tipo_item = p_detalle_factura_rec.tipo_item,
                       item = p_detalle_factura_rec.item,
                       descripcion = p_detalle_factura_rec.descripcion,
                       cantidad = p_detalle_factura_rec.cantidad,
                       p_unidad = p_detalle_factura_rec.p_unidad,
                       bs_descuento = p_detalle_factura_rec.bs_descuento,
                       subtotal = p_detalle_factura_rec.subtotal,
                       materiales_id = p_detalle_factura_rec.materiales_id,
                       factura_id = p_detalle_factura_rec.factura_id
               WHERE CURRENT OF detalle_factura_cur;
            END IF;

            CLOSE detalle_factura_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd;

   PROCEDURE web_upd_rowid (
                            p_detalle_factura_rec    IN detalle_factura_rt,
                            p_ignore_nulls         IN boolean := FALSE
                           )
   IS
      l_detalle_factura_rec detalle_factura_rt;
   BEGIN

      OPEN detalle_factura_rowid_cur(web_upd_rowid.p_detalle_factura_rec.row_id);

      FETCH detalle_factura_rowid_cur INTO l_detalle_factura_rec;

      IF detalle_factura_rowid_cur%NOTFOUND THEN
         CLOSE detalle_factura_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_upd_rowid.p_detalle_factura_rec.hash != l_detalle_factura_rec.hash THEN
            CLOSE detalle_factura_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(web_upd_rowid.p_ignore_nulls, FALSE)
            THEN
                UPDATE   detalle_factura
                   SET renglon = NVL(p_detalle_factura_rec.renglon,renglon),
                       tipo_item = NVL(p_detalle_factura_rec.tipo_item,tipo_item),
                       item = NVL(p_detalle_factura_rec.item,item),
                       descripcion = NVL(p_detalle_factura_rec.descripcion,descripcion),
                       cantidad = NVL(p_detalle_factura_rec.cantidad,cantidad),
                       p_unidad = NVL(p_detalle_factura_rec.p_unidad,p_unidad),
                       bs_descuento = NVL(p_detalle_factura_rec.bs_descuento,bs_descuento),
                       subtotal = NVL(p_detalle_factura_rec.subtotal,subtotal),
                       materiales_id = NVL(p_detalle_factura_rec.materiales_id,materiales_id),
                       factura_id = NVL(p_detalle_factura_rec.factura_id,factura_id)
               WHERE CURRENT OF detalle_factura_rowid_cur;
            ELSE
                UPDATE   detalle_factura
                   SET renglon = p_detalle_factura_rec.renglon,
                       tipo_item = p_detalle_factura_rec.tipo_item,
                       item = p_detalle_factura_rec.item,
                       descripcion = p_detalle_factura_rec.descripcion,
                       cantidad = p_detalle_factura_rec.cantidad,
                       p_unidad = p_detalle_factura_rec.p_unidad,
                       bs_descuento = p_detalle_factura_rec.bs_descuento,
                       subtotal = p_detalle_factura_rec.subtotal,
                       materiales_id = p_detalle_factura_rec.materiales_id,
                       factura_id = p_detalle_factura_rec.factura_id
               WHERE CURRENT OF detalle_factura_rowid_cur;
            END IF;

            CLOSE detalle_factura_rowid_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd_rowid;

    PROCEDURE del (
                  p_renglon IN detalle_factura.renglon%TYPE
                  )
    IS
    BEGIN

       DELETE FROM   detalle_factura
             WHERE
                  renglon = del.p_renglon
                   ;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del;

    PROCEDURE del_rowid (p_rowid IN varchar2)
    IS
    BEGIN

       DELETE FROM   detalle_factura
             WHERE   ROWID = del_rowid.p_rowid;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del_rowid;

    PROCEDURE web_del (
                      p_renglon IN detalle_factura.renglon%TYPE,
                      p_hash IN varchar2
                      )
   IS
      l_detalle_factura_rec detalle_factura_rt;
   BEGIN


      OPEN detalle_factura_cur(
                            web_del.p_renglon
                            );

      FETCH detalle_factura_cur INTO l_detalle_factura_rec;

      IF detalle_factura_cur%NOTFOUND THEN
         CLOSE detalle_factura_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del.p_hash != l_detalle_factura_rec.hash THEN
            CLOSE detalle_factura_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM detalle_factura
            WHERE CURRENT OF detalle_factura_cur;

            CLOSE detalle_factura_cur;
         END IF;
      END IF;



   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del;

   PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2)
   IS
      l_detalle_factura_rec detalle_factura_rt;
   BEGIN


      OPEN detalle_factura_rowid_cur(web_del_rowid.p_rowid);

      FETCH detalle_factura_rowid_cur INTO l_detalle_factura_rec;

      IF detalle_factura_rowid_cur%NOTFOUND THEN
         CLOSE detalle_factura_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del_rowid.p_hash != l_detalle_factura_rec.hash THEN
            CLOSE detalle_factura_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM detalle_factura
            WHERE CURRENT OF detalle_factura_rowid_cur;

            CLOSE detalle_factura_rowid_cur;
         END IF;
      END IF;

   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del_rowid;

END tapi_detalle_factura;

 

/
--------------------------------------------------------
--  DDL for Package Body TAPI_ESTUDIANTE
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."TAPI_ESTUDIANTE" IS

   /**
   * TAPI_ESTUDIANTE
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: 13-SEP-2019 10:24
   * Created By: FUNDAUC
   */


   --GLOBAL_PRIVATE_CURSORS
   --By PK
   CURSOR estudiante_cur (
                       p_matricula IN estudiante.matricula%TYPE
                       )
   IS
      SELECT
            cedula_est,
            nacionalidad,
            nombre,
            telf_hab,
            telf_cel,
            ciudad,
            estado,
            email,
            sexo,
            edo_civil,
            grado_ins,
            profesion,
            fecha_nac,
            status,
            id_tipo_est,
            rif,
            matricula,
            sede,
            condicion_especial,
            apellido,
            zona,
            cedula_rep,
            direccion,
            creado_por,
            creado_el,
            modificado_por,
            modificado_el,
            tapi_estudiante.hash(matricula),
            ROWID
      FROM estudiante
      WHERE
           matricula = estudiante_cur.p_matricula
      FOR UPDATE;

    --By Rowid
    CURSOR estudiante_rowid_cur (p_rowid IN VARCHAR2)
    IS
      SELECT
             cedula_est,
             nacionalidad,
             nombre,
             telf_hab,
             telf_cel,
             ciudad,
             estado,
             email,
             sexo,
             edo_civil,
             grado_ins,
             profesion,
             fecha_nac,
             status,
             id_tipo_est,
             rif,
             matricula,
             sede,
             condicion_especial,
             apellido,
             zona,
             cedula_rep,
             direccion,
             creado_por,
             creado_el,
             modificado_por,
             modificado_el,
             tapi_estudiante.hash(matricula),
             ROWID
      FROM estudiante
      WHERE ROWID = p_rowid
      FOR UPDATE;


    FUNCTION hash (
                  p_matricula IN estudiante.matricula%TYPE
                  )
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format VARCHAR2(64);
   BEGIN


     --Get actual NLS_DATE_FORMAT
     SELECT   VALUE
       INTO   l_date_format
       FROM   v$nls_parameters
      WHERE   parameter = 'NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            cedula_est||
            nacionalidad||
            nombre||
            telf_hab||
            telf_cel||
            ciudad||
            estado||
            email||
            sexo||
            edo_civil||
            grado_ins||
            profesion||
            fecha_nac||
            status||
            id_tipo_est||
            rif||
            matricula||
            sede||
            condicion_especial||
            apellido||
            zona||
            cedula_rep||
            direccion||
            creado_por||
            creado_el||
            modificado_por||
            modificado_el
      INTO l_string
      FROM estudiante
      WHERE
           matricula = hash.p_matricula
           ;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash;

    FUNCTION hash_rowid (p_rowid IN varchar2)
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format varchar2(64);
   BEGIN

      --Get actual NLS_DATE_FORMAT
      SELECT VALUE INTO l_date_format  FROM v$nls_parameters WHERE parameter ='NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            cedula_est||
            nacionalidad||
            nombre||
            telf_hab||
            telf_cel||
            ciudad||
            estado||
            email||
            sexo||
            edo_civil||
            grado_ins||
            profesion||
            fecha_nac||
            status||
            id_tipo_est||
            rif||
            matricula||
            sede||
            condicion_especial||
            apellido||
            zona||
            cedula_rep||
            direccion||
            creado_por||
            creado_el||
            modificado_por||
            modificado_el
      INTO l_string
      FROM estudiante
      WHERE  ROWID = hash_rowid.p_rowid;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash_rowid;

   FUNCTION rt (
               p_matricula IN estudiante.matricula%TYPE
               )
      RETURN estudiante_rt RESULT_CACHE
   IS
      l_estudiante_rec estudiante_rt;
   BEGIN

      SELECT a.*,
             tapi_estudiante.hash(matricula),
             rowid
      INTO l_estudiante_rec
      FROM estudiante a
      WHERE
           matricula = rt.p_matricula
           ;


      RETURN l_estudiante_rec;

   END rt;

   FUNCTION rt_for_update (
                          p_matricula IN estudiante.matricula%TYPE
                          )
      RETURN estudiante_rt RESULT_CACHE
   IS
      l_estudiante_rec estudiante_rt;
   BEGIN


      SELECT a.*,
             tapi_estudiante.hash(matricula),
             rowid
      INTO l_estudiante_rec
      FROM estudiante a
      WHERE
           matricula = rt_for_update.p_matricula
      FOR UPDATE;


      RETURN l_estudiante_rec;

   END rt_for_update;

    FUNCTION tt (
                p_matricula IN estudiante.matricula%TYPE DEFAULT NULL
                )
       RETURN estudiante_tt
       PIPELINED
    IS
       l_estudiante_rec   estudiante_rt;
    BEGIN

       FOR c1 IN (SELECT   a.*, ROWID
                    FROM   estudiante a
                   WHERE
                        matricula = NVL(tt.p_matricula,matricula)
                        )
       LOOP
              l_estudiante_rec.cedula_est := c1.cedula_est;
              l_estudiante_rec.nacionalidad := c1.nacionalidad;
              l_estudiante_rec.nombre := c1.nombre;
              l_estudiante_rec.telf_hab := c1.telf_hab;
              l_estudiante_rec.telf_cel := c1.telf_cel;
              l_estudiante_rec.ciudad := c1.ciudad;
              l_estudiante_rec.estado := c1.estado;
              l_estudiante_rec.email := c1.email;
              l_estudiante_rec.sexo := c1.sexo;
              l_estudiante_rec.edo_civil := c1.edo_civil;
              l_estudiante_rec.grado_ins := c1.grado_ins;
              l_estudiante_rec.profesion := c1.profesion;
              l_estudiante_rec.fecha_nac := c1.fecha_nac;
              l_estudiante_rec.status := c1.status;
              l_estudiante_rec.id_tipo_est := c1.id_tipo_est;
              l_estudiante_rec.rif := c1.rif;
              l_estudiante_rec.matricula := c1.matricula;
              l_estudiante_rec.sede := c1.sede;
              l_estudiante_rec.condicion_especial := c1.condicion_especial;
              l_estudiante_rec.apellido := c1.apellido;
              l_estudiante_rec.zona := c1.zona;
              l_estudiante_rec.cedula_rep := c1.cedula_rep;
              l_estudiante_rec.direccion := c1.direccion;
              l_estudiante_rec.creado_por := c1.creado_por;
              l_estudiante_rec.creado_el := c1.creado_el;
              l_estudiante_rec.modificado_por := c1.modificado_por;
              l_estudiante_rec.modificado_el := c1.modificado_el;
              l_estudiante_rec.hash := tapi_estudiante.hash( c1.matricula);
              l_estudiante_rec.row_id := c1.ROWID;
              PIPE ROW (l_estudiante_rec);
       END LOOP;

       RETURN;

    END tt;


    PROCEDURE ins (p_estudiante_rec IN OUT estudiante_rt)
    IS
        l_rowtype     estudiante%ROWTYPE;

    BEGIN


        l_rowtype.cedula_est := ins.p_estudiante_rec.cedula_est;
        l_rowtype.nacionalidad := ins.p_estudiante_rec.nacionalidad;
        l_rowtype.nombre := ins.p_estudiante_rec.nombre;
        l_rowtype.telf_hab := ins.p_estudiante_rec.telf_hab;
        l_rowtype.telf_cel := ins.p_estudiante_rec.telf_cel;
        l_rowtype.ciudad := ins.p_estudiante_rec.ciudad;
        l_rowtype.estado := ins.p_estudiante_rec.estado;
        l_rowtype.email := ins.p_estudiante_rec.email;
        l_rowtype.sexo := ins.p_estudiante_rec.sexo;
        l_rowtype.edo_civil := ins.p_estudiante_rec.edo_civil;
        l_rowtype.grado_ins := ins.p_estudiante_rec.grado_ins;
        l_rowtype.profesion := ins.p_estudiante_rec.profesion;
        l_rowtype.fecha_nac := ins.p_estudiante_rec.fecha_nac;
        l_rowtype.status := ins.p_estudiante_rec.status;
        l_rowtype.id_tipo_est := ins.p_estudiante_rec.id_tipo_est;
        l_rowtype.rif := ins.p_estudiante_rec.rif;
        l_rowtype.matricula := ins.p_estudiante_rec.matricula;
        l_rowtype.sede := ins.p_estudiante_rec.sede;
        l_rowtype.condicion_especial := ins.p_estudiante_rec.condicion_especial;
        l_rowtype.apellido := ins.p_estudiante_rec.apellido;
        l_rowtype.zona := ins.p_estudiante_rec.zona;
        l_rowtype.cedula_rep := ins.p_estudiante_rec.cedula_rep;
        l_rowtype.direccion := ins.p_estudiante_rec.direccion;
        l_rowtype.creado_por := ins.p_estudiante_rec.creado_por;
        l_rowtype.creado_el := ins.p_estudiante_rec.creado_el;
        l_rowtype.modificado_por := ins.p_estudiante_rec.modificado_por;
        l_rowtype.modificado_el := ins.p_estudiante_rec.modificado_el;

       INSERT INTO estudiante
          VALUES   l_rowtype
       RETURNING
                   cedula_est ,
                   nacionalidad ,
                   nombre ,
                   telf_hab ,
                   telf_cel ,
                   ciudad ,
                   estado ,
                   email ,
                   sexo ,
                   edo_civil ,
                   grado_ins ,
                   profesion ,
                   fecha_nac ,
                   status ,
                   id_tipo_est ,
                   rif ,
                   matricula ,
                   sede ,
                   condicion_especial ,
                   apellido ,
                   zona ,
                   cedula_rep ,
                   direccion ,
                   creado_por ,
                   creado_el ,
                   modificado_por ,
                   modificado_el 
            INTO   l_rowtype;

         ins.p_estudiante_rec.cedula_est := l_rowtype.cedula_est;
         ins.p_estudiante_rec.nacionalidad := l_rowtype.nacionalidad;
         ins.p_estudiante_rec.nombre := l_rowtype.nombre;
         ins.p_estudiante_rec.telf_hab := l_rowtype.telf_hab;
         ins.p_estudiante_rec.telf_cel := l_rowtype.telf_cel;
         ins.p_estudiante_rec.ciudad := l_rowtype.ciudad;
         ins.p_estudiante_rec.estado := l_rowtype.estado;
         ins.p_estudiante_rec.email := l_rowtype.email;
         ins.p_estudiante_rec.sexo := l_rowtype.sexo;
         ins.p_estudiante_rec.edo_civil := l_rowtype.edo_civil;
         ins.p_estudiante_rec.grado_ins := l_rowtype.grado_ins;
         ins.p_estudiante_rec.profesion := l_rowtype.profesion;
         ins.p_estudiante_rec.fecha_nac := l_rowtype.fecha_nac;
         ins.p_estudiante_rec.status := l_rowtype.status;
         ins.p_estudiante_rec.id_tipo_est := l_rowtype.id_tipo_est;
         ins.p_estudiante_rec.rif := l_rowtype.rif;
         ins.p_estudiante_rec.matricula := l_rowtype.matricula;
         ins.p_estudiante_rec.sede := l_rowtype.sede;
         ins.p_estudiante_rec.condicion_especial := l_rowtype.condicion_especial;
         ins.p_estudiante_rec.apellido := l_rowtype.apellido;
         ins.p_estudiante_rec.zona := l_rowtype.zona;
         ins.p_estudiante_rec.cedula_rep := l_rowtype.cedula_rep;
         ins.p_estudiante_rec.direccion := l_rowtype.direccion;
         ins.p_estudiante_rec.creado_por := l_rowtype.creado_por;
         ins.p_estudiante_rec.creado_el := l_rowtype.creado_el;
         ins.p_estudiante_rec.modificado_por := l_rowtype.modificado_por;
         ins.p_estudiante_rec.modificado_el := l_rowtype.modificado_el;



    END ins;

    PROCEDURE upd (
                  p_estudiante_rec         IN estudiante_rt,
                  p_ignore_nulls         IN boolean := FALSE
                  )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   estudiante
             SET cedula_est = NVL(p_estudiante_rec.cedula_est,cedula_est),
                nacionalidad = NVL(p_estudiante_rec.nacionalidad,nacionalidad),
                nombre = NVL(p_estudiante_rec.nombre,nombre),
                telf_hab = NVL(p_estudiante_rec.telf_hab,telf_hab),
                telf_cel = NVL(p_estudiante_rec.telf_cel,telf_cel),
                ciudad = NVL(p_estudiante_rec.ciudad,ciudad),
                estado = NVL(p_estudiante_rec.estado,estado),
                email = NVL(p_estudiante_rec.email,email),
                sexo = NVL(p_estudiante_rec.sexo,sexo),
                edo_civil = NVL(p_estudiante_rec.edo_civil,edo_civil),
                grado_ins = NVL(p_estudiante_rec.grado_ins,grado_ins),
                profesion = NVL(p_estudiante_rec.profesion,profesion),
                fecha_nac = NVL(p_estudiante_rec.fecha_nac,fecha_nac),
                status = NVL(p_estudiante_rec.status,status),
                id_tipo_est = NVL(p_estudiante_rec.id_tipo_est,id_tipo_est),
                rif = NVL(p_estudiante_rec.rif,rif),
                matricula = NVL(p_estudiante_rec.matricula,matricula),
                sede = NVL(p_estudiante_rec.sede,sede),
                condicion_especial = NVL(p_estudiante_rec.condicion_especial,condicion_especial),
                apellido = NVL(p_estudiante_rec.apellido,apellido),
                zona = NVL(p_estudiante_rec.zona,zona),
                cedula_rep = NVL(p_estudiante_rec.cedula_rep,cedula_rep),
                direccion = NVL(p_estudiante_rec.direccion,direccion),
                creado_por = NVL(p_estudiante_rec.creado_por,creado_por),
                creado_el = NVL(p_estudiante_rec.creado_el,creado_el),
                modificado_por = NVL(p_estudiante_rec.modificado_por,modificado_por),
                modificado_el = NVL(p_estudiante_rec.modificado_el,modificado_el)
           WHERE
                matricula = upd.p_estudiante_rec.matricula
                ;
       ELSE
          UPDATE   estudiante
             SET cedula_est = p_estudiante_rec.cedula_est,
                nacionalidad = p_estudiante_rec.nacionalidad,
                nombre = p_estudiante_rec.nombre,
                telf_hab = p_estudiante_rec.telf_hab,
                telf_cel = p_estudiante_rec.telf_cel,
                ciudad = p_estudiante_rec.ciudad,
                estado = p_estudiante_rec.estado,
                email = p_estudiante_rec.email,
                sexo = p_estudiante_rec.sexo,
                edo_civil = p_estudiante_rec.edo_civil,
                grado_ins = p_estudiante_rec.grado_ins,
                profesion = p_estudiante_rec.profesion,
                fecha_nac = p_estudiante_rec.fecha_nac,
                status = p_estudiante_rec.status,
                id_tipo_est = p_estudiante_rec.id_tipo_est,
                rif = p_estudiante_rec.rif,
                matricula = p_estudiante_rec.matricula,
                sede = p_estudiante_rec.sede,
                condicion_especial = p_estudiante_rec.condicion_especial,
                apellido = p_estudiante_rec.apellido,
                zona = p_estudiante_rec.zona,
                cedula_rep = p_estudiante_rec.cedula_rep,
                direccion = p_estudiante_rec.direccion,
                creado_por = p_estudiante_rec.creado_por,
                creado_el = p_estudiante_rec.creado_el,
                modificado_por = p_estudiante_rec.modificado_por,
                modificado_el = p_estudiante_rec.modificado_el
           WHERE
                matricula = upd.p_estudiante_rec.matricula
                ;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd;


    PROCEDURE upd_rowid (
                         p_estudiante_rec         IN estudiante_rt,
                         p_ignore_nulls         IN boolean := FALSE
                        )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   estudiante
             SET cedula_est = NVL(p_estudiante_rec.cedula_est,cedula_est),
                nacionalidad = NVL(p_estudiante_rec.nacionalidad,nacionalidad),
                nombre = NVL(p_estudiante_rec.nombre,nombre),
                telf_hab = NVL(p_estudiante_rec.telf_hab,telf_hab),
                telf_cel = NVL(p_estudiante_rec.telf_cel,telf_cel),
                ciudad = NVL(p_estudiante_rec.ciudad,ciudad),
                estado = NVL(p_estudiante_rec.estado,estado),
                email = NVL(p_estudiante_rec.email,email),
                sexo = NVL(p_estudiante_rec.sexo,sexo),
                edo_civil = NVL(p_estudiante_rec.edo_civil,edo_civil),
                grado_ins = NVL(p_estudiante_rec.grado_ins,grado_ins),
                profesion = NVL(p_estudiante_rec.profesion,profesion),
                fecha_nac = NVL(p_estudiante_rec.fecha_nac,fecha_nac),
                status = NVL(p_estudiante_rec.status,status),
                id_tipo_est = NVL(p_estudiante_rec.id_tipo_est,id_tipo_est),
                rif = NVL(p_estudiante_rec.rif,rif),
                matricula = NVL(p_estudiante_rec.matricula,matricula),
                sede = NVL(p_estudiante_rec.sede,sede),
                condicion_especial = NVL(p_estudiante_rec.condicion_especial,condicion_especial),
                apellido = NVL(p_estudiante_rec.apellido,apellido),
                zona = NVL(p_estudiante_rec.zona,zona),
                cedula_rep = NVL(p_estudiante_rec.cedula_rep,cedula_rep),
                direccion = NVL(p_estudiante_rec.direccion,direccion),
                creado_por = NVL(p_estudiante_rec.creado_por,creado_por),
                creado_el = NVL(p_estudiante_rec.creado_el,creado_el),
                modificado_por = NVL(p_estudiante_rec.modificado_por,modificado_por),
                modificado_el = NVL(p_estudiante_rec.modificado_el,modificado_el)
           WHERE  ROWID = p_estudiante_rec.row_id;
       ELSE
          UPDATE   estudiante
             SET cedula_est = p_estudiante_rec.cedula_est,
                nacionalidad = p_estudiante_rec.nacionalidad,
                nombre = p_estudiante_rec.nombre,
                telf_hab = p_estudiante_rec.telf_hab,
                telf_cel = p_estudiante_rec.telf_cel,
                ciudad = p_estudiante_rec.ciudad,
                estado = p_estudiante_rec.estado,
                email = p_estudiante_rec.email,
                sexo = p_estudiante_rec.sexo,
                edo_civil = p_estudiante_rec.edo_civil,
                grado_ins = p_estudiante_rec.grado_ins,
                profesion = p_estudiante_rec.profesion,
                fecha_nac = p_estudiante_rec.fecha_nac,
                status = p_estudiante_rec.status,
                id_tipo_est = p_estudiante_rec.id_tipo_est,
                rif = p_estudiante_rec.rif,
                matricula = p_estudiante_rec.matricula,
                sede = p_estudiante_rec.sede,
                condicion_especial = p_estudiante_rec.condicion_especial,
                apellido = p_estudiante_rec.apellido,
                zona = p_estudiante_rec.zona,
                cedula_rep = p_estudiante_rec.cedula_rep,
                direccion = p_estudiante_rec.direccion,
                creado_por = p_estudiante_rec.creado_por,
                creado_el = p_estudiante_rec.creado_el,
                modificado_por = p_estudiante_rec.modificado_por,
                modificado_el = p_estudiante_rec.modificado_el
           WHERE  ROWID = p_estudiante_rec.row_id;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd_rowid;

   PROCEDURE web_upd (
                  p_estudiante_rec         IN estudiante_rt,
                  p_ignore_nulls         IN boolean := FALSE
                )
   IS
      l_estudiante_rec estudiante_rt;
   BEGIN

      OPEN estudiante_cur(
                             web_upd.p_estudiante_rec.matricula
                        );

      FETCH estudiante_cur INTO l_estudiante_rec;

      IF estudiante_cur%NOTFOUND THEN
         CLOSE estudiante_cur;
         RAISE e_row_missing;
      ELSE
         IF p_estudiante_rec.hash != l_estudiante_rec.hash THEN
            CLOSE estudiante_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(p_ignore_nulls, FALSE)
            THEN

                UPDATE   estudiante
                   SET cedula_est = NVL(p_estudiante_rec.cedula_est,cedula_est),
                       nacionalidad = NVL(p_estudiante_rec.nacionalidad,nacionalidad),
                       nombre = NVL(p_estudiante_rec.nombre,nombre),
                       telf_hab = NVL(p_estudiante_rec.telf_hab,telf_hab),
                       telf_cel = NVL(p_estudiante_rec.telf_cel,telf_cel),
                       ciudad = NVL(p_estudiante_rec.ciudad,ciudad),
                       estado = NVL(p_estudiante_rec.estado,estado),
                       email = NVL(p_estudiante_rec.email,email),
                       sexo = NVL(p_estudiante_rec.sexo,sexo),
                       edo_civil = NVL(p_estudiante_rec.edo_civil,edo_civil),
                       grado_ins = NVL(p_estudiante_rec.grado_ins,grado_ins),
                       profesion = NVL(p_estudiante_rec.profesion,profesion),
                       fecha_nac = NVL(p_estudiante_rec.fecha_nac,fecha_nac),
                       status = NVL(p_estudiante_rec.status,status),
                       id_tipo_est = NVL(p_estudiante_rec.id_tipo_est,id_tipo_est),
                       rif = NVL(p_estudiante_rec.rif,rif),
                       matricula = NVL(p_estudiante_rec.matricula,matricula),
                       sede = NVL(p_estudiante_rec.sede,sede),
                       condicion_especial = NVL(p_estudiante_rec.condicion_especial,condicion_especial),
                       apellido = NVL(p_estudiante_rec.apellido,apellido),
                       zona = NVL(p_estudiante_rec.zona,zona),
                       cedula_rep = NVL(p_estudiante_rec.cedula_rep,cedula_rep),
                       direccion = NVL(p_estudiante_rec.direccion,direccion),
                       creado_por = NVL(p_estudiante_rec.creado_por,creado_por),
                       creado_el = NVL(p_estudiante_rec.creado_el,creado_el),
                       modificado_por = NVL(p_estudiante_rec.modificado_por,modificado_por),
                       modificado_el = NVL(p_estudiante_rec.modificado_el,modificado_el)
               WHERE CURRENT OF estudiante_cur;
            ELSE
                UPDATE   estudiante
                   SET cedula_est = p_estudiante_rec.cedula_est,
                       nacionalidad = p_estudiante_rec.nacionalidad,
                       nombre = p_estudiante_rec.nombre,
                       telf_hab = p_estudiante_rec.telf_hab,
                       telf_cel = p_estudiante_rec.telf_cel,
                       ciudad = p_estudiante_rec.ciudad,
                       estado = p_estudiante_rec.estado,
                       email = p_estudiante_rec.email,
                       sexo = p_estudiante_rec.sexo,
                       edo_civil = p_estudiante_rec.edo_civil,
                       grado_ins = p_estudiante_rec.grado_ins,
                       profesion = p_estudiante_rec.profesion,
                       fecha_nac = p_estudiante_rec.fecha_nac,
                       status = p_estudiante_rec.status,
                       id_tipo_est = p_estudiante_rec.id_tipo_est,
                       rif = p_estudiante_rec.rif,
                       matricula = p_estudiante_rec.matricula,
                       sede = p_estudiante_rec.sede,
                       condicion_especial = p_estudiante_rec.condicion_especial,
                       apellido = p_estudiante_rec.apellido,
                       zona = p_estudiante_rec.zona,
                       cedula_rep = p_estudiante_rec.cedula_rep,
                       direccion = p_estudiante_rec.direccion,
                       creado_por = p_estudiante_rec.creado_por,
                       creado_el = p_estudiante_rec.creado_el,
                       modificado_por = p_estudiante_rec.modificado_por,
                       modificado_el = p_estudiante_rec.modificado_el
               WHERE CURRENT OF estudiante_cur;
            END IF;

            CLOSE estudiante_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd;

   PROCEDURE web_upd_rowid (
                            p_estudiante_rec    IN estudiante_rt,
                            p_ignore_nulls         IN boolean := FALSE
                           )
   IS
      l_estudiante_rec estudiante_rt;
   BEGIN

      OPEN estudiante_rowid_cur(web_upd_rowid.p_estudiante_rec.row_id);

      FETCH estudiante_rowid_cur INTO l_estudiante_rec;

      IF estudiante_rowid_cur%NOTFOUND THEN
         CLOSE estudiante_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_upd_rowid.p_estudiante_rec.hash != l_estudiante_rec.hash THEN
            CLOSE estudiante_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(web_upd_rowid.p_ignore_nulls, FALSE)
            THEN
                UPDATE   estudiante
                   SET cedula_est = NVL(p_estudiante_rec.cedula_est,cedula_est),
                       nacionalidad = NVL(p_estudiante_rec.nacionalidad,nacionalidad),
                       nombre = NVL(p_estudiante_rec.nombre,nombre),
                       telf_hab = NVL(p_estudiante_rec.telf_hab,telf_hab),
                       telf_cel = NVL(p_estudiante_rec.telf_cel,telf_cel),
                       ciudad = NVL(p_estudiante_rec.ciudad,ciudad),
                       estado = NVL(p_estudiante_rec.estado,estado),
                       email = NVL(p_estudiante_rec.email,email),
                       sexo = NVL(p_estudiante_rec.sexo,sexo),
                       edo_civil = NVL(p_estudiante_rec.edo_civil,edo_civil),
                       grado_ins = NVL(p_estudiante_rec.grado_ins,grado_ins),
                       profesion = NVL(p_estudiante_rec.profesion,profesion),
                       fecha_nac = NVL(p_estudiante_rec.fecha_nac,fecha_nac),
                       status = NVL(p_estudiante_rec.status,status),
                       id_tipo_est = NVL(p_estudiante_rec.id_tipo_est,id_tipo_est),
                       rif = NVL(p_estudiante_rec.rif,rif),
                       matricula = NVL(p_estudiante_rec.matricula,matricula),
                       sede = NVL(p_estudiante_rec.sede,sede),
                       condicion_especial = NVL(p_estudiante_rec.condicion_especial,condicion_especial),
                       apellido = NVL(p_estudiante_rec.apellido,apellido),
                       zona = NVL(p_estudiante_rec.zona,zona),
                       cedula_rep = NVL(p_estudiante_rec.cedula_rep,cedula_rep),
                       direccion = NVL(p_estudiante_rec.direccion,direccion),
                       creado_por = NVL(p_estudiante_rec.creado_por,creado_por),
                       creado_el = NVL(p_estudiante_rec.creado_el,creado_el),
                       modificado_por = NVL(p_estudiante_rec.modificado_por,modificado_por),
                       modificado_el = NVL(p_estudiante_rec.modificado_el,modificado_el)
               WHERE CURRENT OF estudiante_rowid_cur;
            ELSE
                UPDATE   estudiante
                   SET cedula_est = p_estudiante_rec.cedula_est,
                       nacionalidad = p_estudiante_rec.nacionalidad,
                       nombre = p_estudiante_rec.nombre,
                       telf_hab = p_estudiante_rec.telf_hab,
                       telf_cel = p_estudiante_rec.telf_cel,
                       ciudad = p_estudiante_rec.ciudad,
                       estado = p_estudiante_rec.estado,
                       email = p_estudiante_rec.email,
                       sexo = p_estudiante_rec.sexo,
                       edo_civil = p_estudiante_rec.edo_civil,
                       grado_ins = p_estudiante_rec.grado_ins,
                       profesion = p_estudiante_rec.profesion,
                       fecha_nac = p_estudiante_rec.fecha_nac,
                       status = p_estudiante_rec.status,
                       id_tipo_est = p_estudiante_rec.id_tipo_est,
                       rif = p_estudiante_rec.rif,
                       matricula = p_estudiante_rec.matricula,
                       sede = p_estudiante_rec.sede,
                       condicion_especial = p_estudiante_rec.condicion_especial,
                       apellido = p_estudiante_rec.apellido,
                       zona = p_estudiante_rec.zona,
                       cedula_rep = p_estudiante_rec.cedula_rep,
                       direccion = p_estudiante_rec.direccion,
                       creado_por = p_estudiante_rec.creado_por,
                       creado_el = p_estudiante_rec.creado_el,
                       modificado_por = p_estudiante_rec.modificado_por,
                       modificado_el = p_estudiante_rec.modificado_el
               WHERE CURRENT OF estudiante_rowid_cur;
            END IF;

            CLOSE estudiante_rowid_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd_rowid;

    PROCEDURE del (
                  p_matricula IN estudiante.matricula%TYPE
                  )
    IS
    BEGIN

       DELETE FROM   estudiante
             WHERE
                  matricula = del.p_matricula
                   ;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del;

    PROCEDURE del_rowid (p_rowid IN varchar2)
    IS
    BEGIN

       DELETE FROM   estudiante
             WHERE   ROWID = del_rowid.p_rowid;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del_rowid;

    PROCEDURE web_del (
                      p_matricula IN estudiante.matricula%TYPE,
                      p_hash IN varchar2
                      )
   IS
      l_estudiante_rec estudiante_rt;
   BEGIN


      OPEN estudiante_cur(
                            web_del.p_matricula
                            );

      FETCH estudiante_cur INTO l_estudiante_rec;

      IF estudiante_cur%NOTFOUND THEN
         CLOSE estudiante_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del.p_hash != l_estudiante_rec.hash THEN
            CLOSE estudiante_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM estudiante
            WHERE CURRENT OF estudiante_cur;

            CLOSE estudiante_cur;
         END IF;
      END IF;



   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del;

   PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2)
   IS
      l_estudiante_rec estudiante_rt;
   BEGIN


      OPEN estudiante_rowid_cur(web_del_rowid.p_rowid);

      FETCH estudiante_rowid_cur INTO l_estudiante_rec;

      IF estudiante_rowid_cur%NOTFOUND THEN
         CLOSE estudiante_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del_rowid.p_hash != l_estudiante_rec.hash THEN
            CLOSE estudiante_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM estudiante
            WHERE CURRENT OF estudiante_rowid_cur;

            CLOSE estudiante_rowid_cur;
         END IF;
      END IF;

   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del_rowid;

END tapi_estudiante;

/
--------------------------------------------------------
--  DDL for Package Body TAPI_FACTURA
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."TAPI_FACTURA" IS

   /**
   * TAPI_FACTURA
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: 25-SEP-2019 08:27
   * Created By: FUNDAUC
   */


   --GLOBAL_PRIVATE_CURSORS
   --By PK
   CURSOR factura_cur (
                       p_id IN factura.id%TYPE
                       )
   IS
      SELECT
            id_fact,
            tipo,
            cedula_est,
            nombre_cliente,
            fecha_emi,
            monto,
            p_iva,
            monto_iva,
            flete,
            bs_descuento,
            dir_fiscal,
            rif,
            status,
            programa,
            prog_academico,
            creado_por,
            monto_exento,
            base_imponible,
            id,
            creado_el,
            facturado_por,
            observaciones,
            escredito,
            tapi_factura.hash(id),
            ROWID
      FROM factura
      WHERE
           id = factura_cur.p_id
      FOR UPDATE;

    --By Rowid
    CURSOR factura_rowid_cur (p_rowid IN VARCHAR2)
    IS
      SELECT
             id_fact,
             tipo,
             cedula_est,
             nombre_cliente,
             fecha_emi,
             monto,
             p_iva,
             monto_iva,
             flete,
             bs_descuento,
             dir_fiscal,
             rif,
             status,
             programa,
             prog_academico,
             creado_por,
             monto_exento,
             base_imponible,
             id,
             creado_el,
             facturado_por,
             observaciones,
             escredito,
             tapi_factura.hash(id),
             ROWID
      FROM factura
      WHERE ROWID = p_rowid
      FOR UPDATE;


    FUNCTION hash (
                  p_id IN factura.id%TYPE
                  )
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format VARCHAR2(64);
   BEGIN


     --Get actual NLS_DATE_FORMAT
     SELECT   VALUE
       INTO   l_date_format
       FROM   v$nls_parameters
      WHERE   parameter = 'NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            id_fact||
            tipo||
            cedula_est||
            nombre_cliente||
            fecha_emi||
            monto||
            p_iva||
            monto_iva||
            flete||
            bs_descuento||
            dir_fiscal||
            rif||
            status||
            programa||
            prog_academico||
            creado_por||
            monto_exento||
            base_imponible||
            id||
            creado_el||
            facturado_por||
            observaciones||
            escredito
      INTO l_string
      FROM factura
      WHERE
           id = hash.p_id
           ;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash;

    FUNCTION hash_rowid (p_rowid IN varchar2)
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format varchar2(64);
   BEGIN

      --Get actual NLS_DATE_FORMAT
      SELECT VALUE INTO l_date_format  FROM v$nls_parameters WHERE parameter ='NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            id_fact||
            tipo||
            cedula_est||
            nombre_cliente||
            fecha_emi||
            monto||
            p_iva||
            monto_iva||
            flete||
            bs_descuento||
            dir_fiscal||
            rif||
            status||
            programa||
            prog_academico||
            creado_por||
            monto_exento||
            base_imponible||
            id||
            creado_el||
            facturado_por||
            observaciones||
            escredito
      INTO l_string
      FROM factura
      WHERE  ROWID = hash_rowid.p_rowid;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash_rowid;

   FUNCTION rt (
               p_id IN factura.id%TYPE
               )
      RETURN factura_rt RESULT_CACHE
   IS
      l_factura_rec factura_rt;
   BEGIN

      SELECT a.*,
             tapi_factura.hash(id),
             rowid
      INTO l_factura_rec
      FROM factura a
      WHERE
           id = rt.p_id
           ;


      RETURN l_factura_rec;

   END rt;

   FUNCTION rt_for_update (
                          p_id IN factura.id%TYPE
                          )
      RETURN factura_rt RESULT_CACHE
   IS
      l_factura_rec factura_rt;
   BEGIN


      SELECT a.*,
             tapi_factura.hash(id),
             rowid
      INTO l_factura_rec
      FROM factura a
      WHERE
           id = rt_for_update.p_id
      FOR UPDATE;


      RETURN l_factura_rec;

   END rt_for_update;

    FUNCTION tt (
                p_id IN factura.id%TYPE DEFAULT NULL
                )
       RETURN factura_tt
       PIPELINED
    IS
       l_factura_rec   factura_rt;
    BEGIN

       FOR c1 IN (SELECT   a.*, ROWID
                    FROM   factura a
                   WHERE
                        id = NVL(tt.p_id,id)
                        )
       LOOP
              l_factura_rec.id_fact := c1.id_fact;
              l_factura_rec.tipo := c1.tipo;
              l_factura_rec.cedula_est := c1.cedula_est;
              l_factura_rec.nombre_cliente := c1.nombre_cliente;
              l_factura_rec.fecha_emi := c1.fecha_emi;
              l_factura_rec.monto := c1.monto;
              l_factura_rec.p_iva := c1.p_iva;
              l_factura_rec.monto_iva := c1.monto_iva;
              l_factura_rec.flete := c1.flete;
              l_factura_rec.bs_descuento := c1.bs_descuento;
              l_factura_rec.dir_fiscal := c1.dir_fiscal;
              l_factura_rec.rif := c1.rif;
              l_factura_rec.status := c1.status;
              l_factura_rec.programa := c1.programa;
              l_factura_rec.prog_academico := c1.prog_academico;
              l_factura_rec.creado_por := c1.creado_por;
              l_factura_rec.monto_exento := c1.monto_exento;
              l_factura_rec.base_imponible := c1.base_imponible;
              l_factura_rec.id := c1.id;
              l_factura_rec.creado_el := c1.creado_el;
              l_factura_rec.facturado_por := c1.facturado_por;
              l_factura_rec.observaciones := c1.observaciones;
              l_factura_rec.escredito := c1.escredito;
              l_factura_rec.hash := tapi_factura.hash( c1.id);
              l_factura_rec.row_id := c1.ROWID;
              PIPE ROW (l_factura_rec);
       END LOOP;

       RETURN;

    END tt;


    PROCEDURE ins (p_factura_rec IN OUT factura_rt)
    IS
        l_rowtype     factura%ROWTYPE;

    BEGIN


        l_rowtype.id_fact := ins.p_factura_rec.id_fact;
        l_rowtype.tipo := ins.p_factura_rec.tipo;
        l_rowtype.cedula_est := ins.p_factura_rec.cedula_est;
        l_rowtype.nombre_cliente := ins.p_factura_rec.nombre_cliente;
        l_rowtype.fecha_emi := ins.p_factura_rec.fecha_emi;
        l_rowtype.monto := ins.p_factura_rec.monto;
        l_rowtype.p_iva := ins.p_factura_rec.p_iva;
        l_rowtype.monto_iva := ins.p_factura_rec.monto_iva;
        l_rowtype.flete := ins.p_factura_rec.flete;
        l_rowtype.bs_descuento := ins.p_factura_rec.bs_descuento;
        l_rowtype.dir_fiscal := ins.p_factura_rec.dir_fiscal;
        l_rowtype.rif := ins.p_factura_rec.rif;
        l_rowtype.status := ins.p_factura_rec.status;
        l_rowtype.programa := ins.p_factura_rec.programa;
        l_rowtype.prog_academico := ins.p_factura_rec.prog_academico;
        l_rowtype.creado_por := ins.p_factura_rec.creado_por;
        l_rowtype.monto_exento := ins.p_factura_rec.monto_exento;
        l_rowtype.base_imponible := ins.p_factura_rec.base_imponible;
        l_rowtype.id := ins.p_factura_rec.id;
        l_rowtype.creado_el := ins.p_factura_rec.creado_el;
        l_rowtype.facturado_por := ins.p_factura_rec.facturado_por;
        l_rowtype.observaciones := ins.p_factura_rec.observaciones;
        l_rowtype.escredito := ins.p_factura_rec.escredito;

       INSERT INTO factura
          VALUES   l_rowtype
       RETURNING
                   id_fact ,
                   tipo ,
                   cedula_est ,
                   nombre_cliente ,
                   fecha_emi ,
                   monto ,
                   p_iva ,
                   monto_iva ,
                   flete ,
                   bs_descuento ,
                   dir_fiscal ,
                   rif ,
                   status ,
                   programa ,
                   prog_academico ,
                   creado_por ,
                   monto_exento ,
                   base_imponible ,
                   id ,
                   creado_el ,
                   facturado_por ,
                   observaciones ,
                   escredito 
            INTO   l_rowtype;

         ins.p_factura_rec.id_fact := l_rowtype.id_fact;
         ins.p_factura_rec.tipo := l_rowtype.tipo;
         ins.p_factura_rec.cedula_est := l_rowtype.cedula_est;
         ins.p_factura_rec.nombre_cliente := l_rowtype.nombre_cliente;
         ins.p_factura_rec.fecha_emi := l_rowtype.fecha_emi;
         ins.p_factura_rec.monto := l_rowtype.monto;
         ins.p_factura_rec.p_iva := l_rowtype.p_iva;
         ins.p_factura_rec.monto_iva := l_rowtype.monto_iva;
         ins.p_factura_rec.flete := l_rowtype.flete;
         ins.p_factura_rec.bs_descuento := l_rowtype.bs_descuento;
         ins.p_factura_rec.dir_fiscal := l_rowtype.dir_fiscal;
         ins.p_factura_rec.rif := l_rowtype.rif;
         ins.p_factura_rec.status := l_rowtype.status;
         ins.p_factura_rec.programa := l_rowtype.programa;
         ins.p_factura_rec.prog_academico := l_rowtype.prog_academico;
         ins.p_factura_rec.creado_por := l_rowtype.creado_por;
         ins.p_factura_rec.monto_exento := l_rowtype.monto_exento;
         ins.p_factura_rec.base_imponible := l_rowtype.base_imponible;
         ins.p_factura_rec.id := l_rowtype.id;
         ins.p_factura_rec.creado_el := l_rowtype.creado_el;
         ins.p_factura_rec.facturado_por := l_rowtype.facturado_por;
         ins.p_factura_rec.observaciones := l_rowtype.observaciones;
         ins.p_factura_rec.escredito := l_rowtype.escredito;



    END ins;

    PROCEDURE upd (
                  p_factura_rec         IN factura_rt,
                  p_ignore_nulls         IN boolean := FALSE
                  )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   factura
             SET id_fact = NVL(p_factura_rec.id_fact,id_fact),
                tipo = NVL(p_factura_rec.tipo,tipo),
                cedula_est = NVL(p_factura_rec.cedula_est,cedula_est),
                nombre_cliente = NVL(p_factura_rec.nombre_cliente,nombre_cliente),
                fecha_emi = NVL(p_factura_rec.fecha_emi,fecha_emi),
                monto = NVL(p_factura_rec.monto,monto),
                p_iva = NVL(p_factura_rec.p_iva,p_iva),
                monto_iva = NVL(p_factura_rec.monto_iva,monto_iva),
                flete = NVL(p_factura_rec.flete,flete),
                bs_descuento = NVL(p_factura_rec.bs_descuento,bs_descuento),
                dir_fiscal = NVL(p_factura_rec.dir_fiscal,dir_fiscal),
                rif = NVL(p_factura_rec.rif,rif),
                status = NVL(p_factura_rec.status,status),
                programa = NVL(p_factura_rec.programa,programa),
                prog_academico = NVL(p_factura_rec.prog_academico,prog_academico),
                creado_por = NVL(p_factura_rec.creado_por,creado_por),
                monto_exento = NVL(p_factura_rec.monto_exento,monto_exento),
                base_imponible = NVL(p_factura_rec.base_imponible,base_imponible),
                id = NVL(p_factura_rec.id,id),
                creado_el = NVL(p_factura_rec.creado_el,creado_el),
                facturado_por = NVL(p_factura_rec.facturado_por,facturado_por),
                observaciones = NVL(p_factura_rec.observaciones,observaciones),
                escredito = NVL(p_factura_rec.escredito,escredito)
           WHERE
                id = upd.p_factura_rec.id
                ;
       ELSE
          UPDATE   factura
             SET id_fact = p_factura_rec.id_fact,
                tipo = p_factura_rec.tipo,
                cedula_est = p_factura_rec.cedula_est,
                nombre_cliente = p_factura_rec.nombre_cliente,
                fecha_emi = p_factura_rec.fecha_emi,
                monto = p_factura_rec.monto,
                p_iva = p_factura_rec.p_iva,
                monto_iva = p_factura_rec.monto_iva,
                flete = p_factura_rec.flete,
                bs_descuento = p_factura_rec.bs_descuento,
                dir_fiscal = p_factura_rec.dir_fiscal,
                rif = p_factura_rec.rif,
                status = p_factura_rec.status,
                programa = p_factura_rec.programa,
                prog_academico = p_factura_rec.prog_academico,
                creado_por = p_factura_rec.creado_por,
                monto_exento = p_factura_rec.monto_exento,
                base_imponible = p_factura_rec.base_imponible,
                id = p_factura_rec.id,
                creado_el = p_factura_rec.creado_el,
                facturado_por = p_factura_rec.facturado_por,
                observaciones = p_factura_rec.observaciones,
                escredito = p_factura_rec.escredito
           WHERE
                id = upd.p_factura_rec.id
                ;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd;


    PROCEDURE upd_rowid (
                         p_factura_rec         IN factura_rt,
                         p_ignore_nulls         IN boolean := FALSE
                        )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   factura
             SET id_fact = NVL(p_factura_rec.id_fact,id_fact),
                tipo = NVL(p_factura_rec.tipo,tipo),
                cedula_est = NVL(p_factura_rec.cedula_est,cedula_est),
                nombre_cliente = NVL(p_factura_rec.nombre_cliente,nombre_cliente),
                fecha_emi = NVL(p_factura_rec.fecha_emi,fecha_emi),
                monto = NVL(p_factura_rec.monto,monto),
                p_iva = NVL(p_factura_rec.p_iva,p_iva),
                monto_iva = NVL(p_factura_rec.monto_iva,monto_iva),
                flete = NVL(p_factura_rec.flete,flete),
                bs_descuento = NVL(p_factura_rec.bs_descuento,bs_descuento),
                dir_fiscal = NVL(p_factura_rec.dir_fiscal,dir_fiscal),
                rif = NVL(p_factura_rec.rif,rif),
                status = NVL(p_factura_rec.status,status),
                programa = NVL(p_factura_rec.programa,programa),
                prog_academico = NVL(p_factura_rec.prog_academico,prog_academico),
                creado_por = NVL(p_factura_rec.creado_por,creado_por),
                monto_exento = NVL(p_factura_rec.monto_exento,monto_exento),
                base_imponible = NVL(p_factura_rec.base_imponible,base_imponible),
                id = NVL(p_factura_rec.id,id),
                creado_el = NVL(p_factura_rec.creado_el,creado_el),
                facturado_por = NVL(p_factura_rec.facturado_por,facturado_por),
                observaciones = NVL(p_factura_rec.observaciones,observaciones),
                escredito = NVL(p_factura_rec.escredito,escredito)
           WHERE  ROWID = p_factura_rec.row_id;
       ELSE
          UPDATE   factura
             SET id_fact = p_factura_rec.id_fact,
                tipo = p_factura_rec.tipo,
                cedula_est = p_factura_rec.cedula_est,
                nombre_cliente = p_factura_rec.nombre_cliente,
                fecha_emi = p_factura_rec.fecha_emi,
                monto = p_factura_rec.monto,
                p_iva = p_factura_rec.p_iva,
                monto_iva = p_factura_rec.monto_iva,
                flete = p_factura_rec.flete,
                bs_descuento = p_factura_rec.bs_descuento,
                dir_fiscal = p_factura_rec.dir_fiscal,
                rif = p_factura_rec.rif,
                status = p_factura_rec.status,
                programa = p_factura_rec.programa,
                prog_academico = p_factura_rec.prog_academico,
                creado_por = p_factura_rec.creado_por,
                monto_exento = p_factura_rec.monto_exento,
                base_imponible = p_factura_rec.base_imponible,
                id = p_factura_rec.id,
                creado_el = p_factura_rec.creado_el,
                facturado_por = p_factura_rec.facturado_por,
                observaciones = p_factura_rec.observaciones,
                escredito = p_factura_rec.escredito
           WHERE  ROWID = p_factura_rec.row_id;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd_rowid;

   PROCEDURE web_upd (
                  p_factura_rec         IN factura_rt,
                  p_ignore_nulls         IN boolean := FALSE
                )
   IS
      l_factura_rec factura_rt;
   BEGIN

      OPEN factura_cur(
                             web_upd.p_factura_rec.id
                        );

      FETCH factura_cur INTO l_factura_rec;

      IF factura_cur%NOTFOUND THEN
         CLOSE factura_cur;
         RAISE e_row_missing;
      ELSE
         IF p_factura_rec.hash != l_factura_rec.hash THEN
            CLOSE factura_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(p_ignore_nulls, FALSE)
            THEN

                UPDATE   factura
                   SET id_fact = NVL(p_factura_rec.id_fact,id_fact),
                       tipo = NVL(p_factura_rec.tipo,tipo),
                       cedula_est = NVL(p_factura_rec.cedula_est,cedula_est),
                       nombre_cliente = NVL(p_factura_rec.nombre_cliente,nombre_cliente),
                       fecha_emi = NVL(p_factura_rec.fecha_emi,fecha_emi),
                       monto = NVL(p_factura_rec.monto,monto),
                       p_iva = NVL(p_factura_rec.p_iva,p_iva),
                       monto_iva = NVL(p_factura_rec.monto_iva,monto_iva),
                       flete = NVL(p_factura_rec.flete,flete),
                       bs_descuento = NVL(p_factura_rec.bs_descuento,bs_descuento),
                       dir_fiscal = NVL(p_factura_rec.dir_fiscal,dir_fiscal),
                       rif = NVL(p_factura_rec.rif,rif),
                       status = NVL(p_factura_rec.status,status),
                       programa = NVL(p_factura_rec.programa,programa),
                       prog_academico = NVL(p_factura_rec.prog_academico,prog_academico),
                       creado_por = NVL(p_factura_rec.creado_por,creado_por),
                       monto_exento = NVL(p_factura_rec.monto_exento,monto_exento),
                       base_imponible = NVL(p_factura_rec.base_imponible,base_imponible),
                       id = NVL(p_factura_rec.id,id),
                       creado_el = NVL(p_factura_rec.creado_el,creado_el),
                       facturado_por = NVL(p_factura_rec.facturado_por,facturado_por),
                       observaciones = NVL(p_factura_rec.observaciones,observaciones),
                       escredito = NVL(p_factura_rec.escredito,escredito)
               WHERE CURRENT OF factura_cur;
            ELSE
                UPDATE   factura
                   SET id_fact = p_factura_rec.id_fact,
                       tipo = p_factura_rec.tipo,
                       cedula_est = p_factura_rec.cedula_est,
                       nombre_cliente = p_factura_rec.nombre_cliente,
                       fecha_emi = p_factura_rec.fecha_emi,
                       monto = p_factura_rec.monto,
                       p_iva = p_factura_rec.p_iva,
                       monto_iva = p_factura_rec.monto_iva,
                       flete = p_factura_rec.flete,
                       bs_descuento = p_factura_rec.bs_descuento,
                       dir_fiscal = p_factura_rec.dir_fiscal,
                       rif = p_factura_rec.rif,
                       status = p_factura_rec.status,
                       programa = p_factura_rec.programa,
                       prog_academico = p_factura_rec.prog_academico,
                       creado_por = p_factura_rec.creado_por,
                       monto_exento = p_factura_rec.monto_exento,
                       base_imponible = p_factura_rec.base_imponible,
                       id = p_factura_rec.id,
                       creado_el = p_factura_rec.creado_el,
                       facturado_por = p_factura_rec.facturado_por,
                       observaciones = p_factura_rec.observaciones,
                       escredito = p_factura_rec.escredito
               WHERE CURRENT OF factura_cur;
            END IF;

            CLOSE factura_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd;

   PROCEDURE web_upd_rowid (
                            p_factura_rec    IN factura_rt,
                            p_ignore_nulls         IN boolean := FALSE
                           )
   IS
      l_factura_rec factura_rt;
   BEGIN

      OPEN factura_rowid_cur(web_upd_rowid.p_factura_rec.row_id);

      FETCH factura_rowid_cur INTO l_factura_rec;

      IF factura_rowid_cur%NOTFOUND THEN
         CLOSE factura_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_upd_rowid.p_factura_rec.hash != l_factura_rec.hash THEN
            CLOSE factura_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(web_upd_rowid.p_ignore_nulls, FALSE)
            THEN
                UPDATE   factura
                   SET id_fact = NVL(p_factura_rec.id_fact,id_fact),
                       tipo = NVL(p_factura_rec.tipo,tipo),
                       cedula_est = NVL(p_factura_rec.cedula_est,cedula_est),
                       nombre_cliente = NVL(p_factura_rec.nombre_cliente,nombre_cliente),
                       fecha_emi = NVL(p_factura_rec.fecha_emi,fecha_emi),
                       monto = NVL(p_factura_rec.monto,monto),
                       p_iva = NVL(p_factura_rec.p_iva,p_iva),
                       monto_iva = NVL(p_factura_rec.monto_iva,monto_iva),
                       flete = NVL(p_factura_rec.flete,flete),
                       bs_descuento = NVL(p_factura_rec.bs_descuento,bs_descuento),
                       dir_fiscal = NVL(p_factura_rec.dir_fiscal,dir_fiscal),
                       rif = NVL(p_factura_rec.rif,rif),
                       status = NVL(p_factura_rec.status,status),
                       programa = NVL(p_factura_rec.programa,programa),
                       prog_academico = NVL(p_factura_rec.prog_academico,prog_academico),
                       creado_por = NVL(p_factura_rec.creado_por,creado_por),
                       monto_exento = NVL(p_factura_rec.monto_exento,monto_exento),
                       base_imponible = NVL(p_factura_rec.base_imponible,base_imponible),
                       id = NVL(p_factura_rec.id,id),
                       creado_el = NVL(p_factura_rec.creado_el,creado_el),
                       facturado_por = NVL(p_factura_rec.facturado_por,facturado_por),
                       observaciones = NVL(p_factura_rec.observaciones,observaciones),
                       escredito = NVL(p_factura_rec.escredito,escredito)
               WHERE CURRENT OF factura_rowid_cur;
            ELSE
                UPDATE   factura
                   SET id_fact = p_factura_rec.id_fact,
                       tipo = p_factura_rec.tipo,
                       cedula_est = p_factura_rec.cedula_est,
                       nombre_cliente = p_factura_rec.nombre_cliente,
                       fecha_emi = p_factura_rec.fecha_emi,
                       monto = p_factura_rec.monto,
                       p_iva = p_factura_rec.p_iva,
                       monto_iva = p_factura_rec.monto_iva,
                       flete = p_factura_rec.flete,
                       bs_descuento = p_factura_rec.bs_descuento,
                       dir_fiscal = p_factura_rec.dir_fiscal,
                       rif = p_factura_rec.rif,
                       status = p_factura_rec.status,
                       programa = p_factura_rec.programa,
                       prog_academico = p_factura_rec.prog_academico,
                       creado_por = p_factura_rec.creado_por,
                       monto_exento = p_factura_rec.monto_exento,
                       base_imponible = p_factura_rec.base_imponible,
                       id = p_factura_rec.id,
                       creado_el = p_factura_rec.creado_el,
                       facturado_por = p_factura_rec.facturado_por,
                       observaciones = p_factura_rec.observaciones,
                       escredito = p_factura_rec.escredito
               WHERE CURRENT OF factura_rowid_cur;
            END IF;

            CLOSE factura_rowid_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd_rowid;

    PROCEDURE del (
                  p_id IN factura.id%TYPE
                  )
    IS
    BEGIN

       DELETE FROM   factura
             WHERE
                  id = del.p_id
                   ;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del;

    PROCEDURE del_rowid (p_rowid IN varchar2)
    IS
    BEGIN

       DELETE FROM   factura
             WHERE   ROWID = del_rowid.p_rowid;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del_rowid;

    PROCEDURE web_del (
                      p_id IN factura.id%TYPE,
                      p_hash IN varchar2
                      )
   IS
      l_factura_rec factura_rt;
   BEGIN


      OPEN factura_cur(
                            web_del.p_id
                            );

      FETCH factura_cur INTO l_factura_rec;

      IF factura_cur%NOTFOUND THEN
         CLOSE factura_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del.p_hash != l_factura_rec.hash THEN
            CLOSE factura_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM factura
            WHERE CURRENT OF factura_cur;

            CLOSE factura_cur;
         END IF;
      END IF;



   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del;

   PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2)
   IS
      l_factura_rec factura_rt;
   BEGIN


      OPEN factura_rowid_cur(web_del_rowid.p_rowid);

      FETCH factura_rowid_cur INTO l_factura_rec;

      IF factura_rowid_cur%NOTFOUND THEN
         CLOSE factura_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del_rowid.p_hash != l_factura_rec.hash THEN
            CLOSE factura_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM factura
            WHERE CURRENT OF factura_rowid_cur;

            CLOSE factura_rowid_cur;
         END IF;
      END IF;

   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del_rowid;

END tapi_factura;

 

/
--------------------------------------------------------
--  DDL for Package Body TAPI_FACTURA_DEPOSITO
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."TAPI_FACTURA_DEPOSITO" IS

   /**
   * TAPI_FACTURA_DEPOSITO
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: 04-AGO-2019 21:41
   * Created By: FUNDAUC
   */


   --GLOBAL_PRIVATE_CURSORS
   --By PK
   CURSOR factura_deposito_cur (
                       p_deposito_id IN factura_deposito.deposito_id%TYPE,
                       p_factura_id IN factura_deposito.factura_id%TYPE
                       )
   IS
      SELECT
            deposito_id,
            factura_id,
            tapi_factura_deposito.hash(deposito_id,factura_id),
            ROWID
      FROM factura_deposito
      WHERE
           deposito_id = factura_deposito_cur.p_deposito_id AND 
           factura_id = factura_deposito_cur.p_factura_id
      FOR UPDATE;

    --By Rowid
    CURSOR factura_deposito_rowid_cur (p_rowid IN VARCHAR2)
    IS
      SELECT
             deposito_id,
             factura_id,
             tapi_factura_deposito.hash(deposito_id,factura_id),
             ROWID
      FROM factura_deposito
      WHERE ROWID = p_rowid
      FOR UPDATE;


    FUNCTION hash (
                  p_deposito_id IN factura_deposito.deposito_id%TYPE,
                  p_factura_id IN factura_deposito.factura_id%TYPE
                  )
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format VARCHAR2(64);
   BEGIN


     --Get actual NLS_DATE_FORMAT
     SELECT   VALUE
       INTO   l_date_format
       FROM   v$nls_parameters
      WHERE   parameter = 'NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            deposito_id||
            factura_id
      INTO l_string
      FROM factura_deposito
      WHERE
           deposito_id = hash.p_deposito_id AND 
           factura_id = hash.p_factura_id
           ;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash;

    FUNCTION hash_rowid (p_rowid IN varchar2)
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format varchar2(64);
   BEGIN

      --Get actual NLS_DATE_FORMAT
      SELECT VALUE INTO l_date_format  FROM v$nls_parameters WHERE parameter ='NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            deposito_id||
            factura_id
      INTO l_string
      FROM factura_deposito
      WHERE  ROWID = hash_rowid.p_rowid;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash_rowid;

   FUNCTION rt (
               p_deposito_id IN factura_deposito.deposito_id%TYPE,
               p_factura_id IN factura_deposito.factura_id%TYPE
               )
      RETURN factura_deposito_rt RESULT_CACHE
   IS
      l_factura_deposito_rec factura_deposito_rt;
   BEGIN

      SELECT a.*,
             tapi_factura_deposito.hash(deposito_id,factura_id),
             rowid
      INTO l_factura_deposito_rec
      FROM factura_deposito a
      WHERE
           deposito_id = rt.p_deposito_id AND 
           factura_id = rt.p_factura_id
           ;


      RETURN l_factura_deposito_rec;

   END rt;

   FUNCTION rt_for_update (
                          p_deposito_id IN factura_deposito.deposito_id%TYPE,
                          p_factura_id IN factura_deposito.factura_id%TYPE
                          )
      RETURN factura_deposito_rt RESULT_CACHE
   IS
      l_factura_deposito_rec factura_deposito_rt;
   BEGIN


      SELECT a.*,
             tapi_factura_deposito.hash(deposito_id,factura_id),
             rowid
      INTO l_factura_deposito_rec
      FROM factura_deposito a
      WHERE
           deposito_id = rt_for_update.p_deposito_id AND 
           factura_id = rt_for_update.p_factura_id
      FOR UPDATE;


      RETURN l_factura_deposito_rec;

   END rt_for_update;

    FUNCTION tt (
                p_deposito_id IN factura_deposito.deposito_id%TYPE DEFAULT NULL,
                p_factura_id IN factura_deposito.factura_id%TYPE DEFAULT NULL
                )
       RETURN factura_deposito_tt
       PIPELINED
    IS
       l_factura_deposito_rec   factura_deposito_rt;
    BEGIN

       FOR c1 IN (SELECT   a.*, ROWID
                    FROM   factura_deposito a
                   WHERE
                        deposito_id = NVL(tt.p_deposito_id,deposito_id) AND 
                        factura_id = NVL(tt.p_factura_id,factura_id)
                        )
       LOOP
              l_factura_deposito_rec.deposito_id := c1.deposito_id;
              l_factura_deposito_rec.factura_id := c1.factura_id;
              l_factura_deposito_rec.hash := tapi_factura_deposito.hash( c1.deposito_id, c1.factura_id);
              l_factura_deposito_rec.row_id := c1.ROWID;
              PIPE ROW (l_factura_deposito_rec);
       END LOOP;

       RETURN;

    END tt;


    PROCEDURE ins (p_factura_deposito_rec IN OUT factura_deposito_rt)
    IS
        l_rowtype     factura_deposito%ROWTYPE;

    BEGIN


        l_rowtype.deposito_id := ins.p_factura_deposito_rec.deposito_id;
        l_rowtype.factura_id := ins.p_factura_deposito_rec.factura_id;

       INSERT INTO factura_deposito
          VALUES   l_rowtype
       RETURNING
                   deposito_id ,
                   factura_id 
            INTO   l_rowtype;

         ins.p_factura_deposito_rec.deposito_id := l_rowtype.deposito_id;
         ins.p_factura_deposito_rec.factura_id := l_rowtype.factura_id;



    END ins;

    PROCEDURE upd (
                  p_factura_deposito_rec         IN factura_deposito_rt,
                  p_ignore_nulls         IN boolean := FALSE
                  )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   factura_deposito
             SET deposito_id = NVL(p_factura_deposito_rec.deposito_id,deposito_id),
                factura_id = NVL(p_factura_deposito_rec.factura_id,factura_id)
           WHERE
                deposito_id = upd.p_factura_deposito_rec.deposito_id AND 
                factura_id = upd.p_factura_deposito_rec.factura_id
                ;
       ELSE
          UPDATE   factura_deposito
             SET deposito_id = p_factura_deposito_rec.deposito_id,
                factura_id = p_factura_deposito_rec.factura_id
           WHERE
                deposito_id = upd.p_factura_deposito_rec.deposito_id AND 
                factura_id = upd.p_factura_deposito_rec.factura_id
                ;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd;


    PROCEDURE upd_rowid (
                         p_factura_deposito_rec         IN factura_deposito_rt,
                         p_ignore_nulls         IN boolean := FALSE
                        )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   factura_deposito
             SET deposito_id = NVL(p_factura_deposito_rec.deposito_id,deposito_id),
                factura_id = NVL(p_factura_deposito_rec.factura_id,factura_id)
           WHERE  ROWID = p_factura_deposito_rec.row_id;
       ELSE
          UPDATE   factura_deposito
             SET deposito_id = p_factura_deposito_rec.deposito_id,
                factura_id = p_factura_deposito_rec.factura_id
           WHERE  ROWID = p_factura_deposito_rec.row_id;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd_rowid;

   PROCEDURE web_upd (
                  p_factura_deposito_rec         IN factura_deposito_rt,
                  p_ignore_nulls         IN boolean := FALSE
                )
   IS
      l_factura_deposito_rec factura_deposito_rt;
   BEGIN

      OPEN factura_deposito_cur(
                             web_upd.p_factura_deposito_rec.deposito_id,
                             web_upd.p_factura_deposito_rec.factura_id
                        );

      FETCH factura_deposito_cur INTO l_factura_deposito_rec;

      IF factura_deposito_cur%NOTFOUND THEN
         CLOSE factura_deposito_cur;
         RAISE e_row_missing;
      ELSE
         IF p_factura_deposito_rec.hash != l_factura_deposito_rec.hash THEN
            CLOSE factura_deposito_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(p_ignore_nulls, FALSE)
            THEN

                UPDATE   factura_deposito
                   SET deposito_id = NVL(p_factura_deposito_rec.deposito_id,deposito_id),
                       factura_id = NVL(p_factura_deposito_rec.factura_id,factura_id)
               WHERE CURRENT OF factura_deposito_cur;
            ELSE
                UPDATE   factura_deposito
                   SET deposito_id = p_factura_deposito_rec.deposito_id,
                       factura_id = p_factura_deposito_rec.factura_id
               WHERE CURRENT OF factura_deposito_cur;
            END IF;

            CLOSE factura_deposito_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd;

   PROCEDURE web_upd_rowid (
                            p_factura_deposito_rec    IN factura_deposito_rt,
                            p_ignore_nulls         IN boolean := FALSE
                           )
   IS
      l_factura_deposito_rec factura_deposito_rt;
   BEGIN

      OPEN factura_deposito_rowid_cur(web_upd_rowid.p_factura_deposito_rec.row_id);

      FETCH factura_deposito_rowid_cur INTO l_factura_deposito_rec;

      IF factura_deposito_rowid_cur%NOTFOUND THEN
         CLOSE factura_deposito_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_upd_rowid.p_factura_deposito_rec.hash != l_factura_deposito_rec.hash THEN
            CLOSE factura_deposito_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(web_upd_rowid.p_ignore_nulls, FALSE)
            THEN
                UPDATE   factura_deposito
                   SET deposito_id = NVL(p_factura_deposito_rec.deposito_id,deposito_id),
                       factura_id = NVL(p_factura_deposito_rec.factura_id,factura_id)
               WHERE CURRENT OF factura_deposito_rowid_cur;
            ELSE
                UPDATE   factura_deposito
                   SET deposito_id = p_factura_deposito_rec.deposito_id,
                       factura_id = p_factura_deposito_rec.factura_id
               WHERE CURRENT OF factura_deposito_rowid_cur;
            END IF;

            CLOSE factura_deposito_rowid_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd_rowid;

    PROCEDURE del (
                  p_deposito_id IN factura_deposito.deposito_id%TYPE,
                  p_factura_id IN factura_deposito.factura_id%TYPE
                  )
    IS
    BEGIN

       DELETE FROM   factura_deposito
             WHERE
                  deposito_id = del.p_deposito_id AND 
                  factura_id = del.p_factura_id
                   ;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del;

    PROCEDURE del_rowid (p_rowid IN varchar2)
    IS
    BEGIN

       DELETE FROM   factura_deposito
             WHERE   ROWID = del_rowid.p_rowid;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del_rowid;

    PROCEDURE web_del (
                      p_deposito_id IN factura_deposito.deposito_id%TYPE,
                      p_factura_id IN factura_deposito.factura_id%TYPE,
                      p_hash IN varchar2
                      )
   IS
      l_factura_deposito_rec factura_deposito_rt;
   BEGIN


      OPEN factura_deposito_cur(
                            web_del.p_deposito_id,
                            web_del.p_factura_id
                            );

      FETCH factura_deposito_cur INTO l_factura_deposito_rec;

      IF factura_deposito_cur%NOTFOUND THEN
         CLOSE factura_deposito_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del.p_hash != l_factura_deposito_rec.hash THEN
            CLOSE factura_deposito_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM factura_deposito
            WHERE CURRENT OF factura_deposito_cur;

            CLOSE factura_deposito_cur;
         END IF;
      END IF;



   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del;

   PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2)
   IS
      l_factura_deposito_rec factura_deposito_rt;
   BEGIN


      OPEN factura_deposito_rowid_cur(web_del_rowid.p_rowid);

      FETCH factura_deposito_rowid_cur INTO l_factura_deposito_rec;

      IF factura_deposito_rowid_cur%NOTFOUND THEN
         CLOSE factura_deposito_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del_rowid.p_hash != l_factura_deposito_rec.hash THEN
            CLOSE factura_deposito_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM factura_deposito
            WHERE CURRENT OF factura_deposito_rowid_cur;

            CLOSE factura_deposito_rowid_cur;
         END IF;
      END IF;

   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del_rowid;

END tapi_factura_deposito;



/
--------------------------------------------------------
--  DDL for Package Body TAPI_GEN2
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."TAPI_GEN2" 
AS
   --Global private variables
   g_unque_key   dbo_name_t;

   PROCEDURE create_tapi_package (p_table_name               IN VARCHAR2
                                , p_compile_table_api        IN BOOLEAN DEFAULT TRUE
                                , p_unique_key               IN VARCHAR2 DEFAULT NULL
                                , p_created_by_col_name      IN VARCHAR2 DEFAULT NULL
                                , p_created_date_col_name    IN VARCHAR2 DEFAULT NULL
                                , p_modified_by_col_name     IN VARCHAR2 DEFAULT NULL
                                , p_modified_date_col_name   IN VARCHAR2 DEFAULT NULL
                                , p_raise_exceptions         IN BOOLEAN DEFAULT FALSE )
   AS
      l_count        PLS_INTEGER := 0;
      l_table_name   dbo_name_t := LOWER (p_table_name);
      l_vars         teplsql.t_assoc_array;
      l_spec_tapi    CLOB;
      l_body_tapi    CLOB;
   BEGIN
      /*Validations*/

      --check_table_exists
      SELECT   COUNT ( * )
        INTO   l_count
        FROM   user_tables
       WHERE   UPPER (table_name) = UPPER (l_table_name);

      IF l_count = 0
      THEN
         raise_application_error (-20000, 'Table ' || l_table_name || ' does not exist!');
      END IF;

      --Check table hash PK or p_unique_key is not null
      IF p_unique_key IS NULL
      THEN
         SELECT   COUNT ( * )
           INTO   l_count
           FROM   user_constraints
          WHERE   UPPER (table_name) = UPPER (l_table_name) AND constraint_type = 'P';

         IF l_count = 0
         THEN
            raise_application_error (-20000
                                   ,    'Table '
                                     || l_table_name
                                     || ' does not have a Primary Key'
                                     || ' and P_UNIQUE_KEY parameter is null');
         END IF;
      END IF;

      --Init variables for render template
      l_vars ('date') := TO_CHAR (SYSDATE, 'DD-MON-YYYY HH24:MI');
      l_vars ('table_name') := l_table_name;
      l_vars ('user') := USER;
      l_vars ('created_by_col_name') := p_created_by_col_name;
      l_vars ('created_date_col_name') := p_created_date_col_name;
      l_vars ('modified_by_col_name') := p_modified_by_col_name;
      l_vars ('modified_date_col_name') := p_modified_date_col_name;
      l_vars ('result_cache') := 'RESULT_CACHE';

      IF p_raise_exceptions
      THEN
         l_vars ('raise_exceptions') := 'TRUE';
      ELSE
         l_vars ('raise_exceptions') := '';
      END IF;

      --If the table hash LOBS columns, disable result_cache.
      FOR c1 IN (SELECT   *
                   FROM   user_tab_cols
                  WHERE   table_name = UPPER (l_table_name) AND data_type IN ('BLOB', 'CLOB'))
      LOOP
         l_vars ('result_cache') := '';
      END LOOP;

      --Define unique key if table don't hace primary key
      g_unque_key := p_unique_key;

      -- Spec --
      --Process template
      l_spec_tapi := teplsql.process (l_vars, 'spec', 'TAPI_GEN2');

      -- Body --
      --Process template
      l_body_tapi := teplsql.process (l_vars, 'body', 'TAPI_GEN2');

      IF p_compile_table_api
      THEN
         BEGIN
            EXECUTE IMMEDIATE l_spec_tapi;
         EXCEPTION
            WHEN OTHERS
            THEN
               DBMS_OUTPUT.put_line (l_spec_tapi);
               raise_application_error (-20000, 'Spec compiled with error(s)! ' || SQLERRM);
         END;

         BEGIN
            EXECUTE IMMEDIATE l_body_tapi;
         EXCEPTION
            WHEN OTHERS
            THEN
               raise_application_error (-20000, ' Body compiled with error(s)! ' || SQLERRM);
         END;

         DBMS_OUTPUT.put_line('Creation of Table API package for ' || l_table_name || ' table completed successfully!');
      ELSE
         DBMS_OUTPUT.put_line (l_spec_tapi);
         DBMS_OUTPUT.put_line (l_body_tapi);
      END IF;
   END create_tapi_package;


   FUNCTION get_all_columns (p_tab_name VARCHAR2)
      RETURN column_tt
   IS
      l_tt   column_tt;
   BEGIN
        SELECT   c.table_name
               , LOWER (c.column_name)
               , c.nullable
               , '' constraint_type
          BULK   COLLECT
          INTO   l_tt
          FROM   user_tab_columns c
         WHERE   c.table_name = UPPER (p_tab_name)
      ORDER BY   c.column_id;

      RETURN l_tt;
   END;

   FUNCTION get_pk_columns (p_tab_name VARCHAR2)
      RETURN column_tt
   IS
      l_tt   column_tt;
   BEGIN
      IF g_unque_key IS NOT NULL
      THEN
         IF NOT l_tt.EXISTS (1)
         THEN
            l_tt        := column_tt (NULL);
         END IF;

         l_tt (1).table_name := p_tab_name;
         l_tt (1).column_name := LOWER (g_unque_key);
         l_tt (1).nullable := 'N';
         l_tt (1).constraint_type := 'P';
      ELSE
           SELECT   c.table_name
                  , LOWER (c.column_name)
                  , c.nullable
                  , cs.constraint_type
             BULK   COLLECT
             INTO   l_tt
             FROM         user_tab_columns c
                       LEFT JOIN
                          user_cons_columns cc
                       ON c.table_name = cc.table_name AND c.column_name = cc.column_name
                    LEFT JOIN
                       user_constraints cs
                    ON cc.constraint_name = cs.constraint_name
            WHERE   c.table_name = UPPER (p_tab_name) AND cs.constraint_type = 'P'
         ORDER BY   c.column_id;
      END IF;

      RETURN l_tt;
   END;


   FUNCTION get_noblob_columns (p_tab_name VARCHAR2)
      RETURN column_tt
   IS
      l_tt   column_tt;
   BEGIN
        SELECT   c.table_name
               , LOWER (c.column_name)
               , c.nullable
               , '' constraint_type
          BULK   COLLECT
          INTO   l_tt
          FROM   user_tab_columns c
         WHERE   table_name = UPPER (p_tab_name)
                 AND column_name NOT IN (SELECT   column_name
                                           FROM   user_tab_cols
                                          WHERE   table_name = UPPER (p_tab_name) AND data_type = 'BLOB')
      ORDER BY   column_id;

      RETURN l_tt;
   END;
END tapi_gen2;

/
--------------------------------------------------------
--  DDL for Package Body TAPI_HOJA_VIDA_EST
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."TAPI_HOJA_VIDA_EST" IS

   /**
   * TAPI_HOJA_VIDA_EST
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: 16-SEP-2019 13:22
   * Created By: FUNDAUC
   */


   --GLOBAL_PRIVATE_CURSORS
   --By PK
   CURSOR hoja_vida_est_cur (
                       p_id IN hoja_vida_est.id%TYPE
                       )
   IS
      SELECT
            id,
            matricula,
            evento_id,
            fecha,
            metadata,
            observacion,
            tapi_hoja_vida_est.hash(id),
            ROWID
      FROM hoja_vida_est
      WHERE
           id = hoja_vida_est_cur.p_id
      FOR UPDATE;

    --By Rowid
    CURSOR hoja_vida_est_rowid_cur (p_rowid IN VARCHAR2)
    IS
      SELECT
             id,
             matricula,
             evento_id,
             fecha,
             metadata,
             observacion,
             tapi_hoja_vida_est.hash(id),
             ROWID
      FROM hoja_vida_est
      WHERE ROWID = p_rowid
      FOR UPDATE;


    FUNCTION hash (
                  p_id IN hoja_vida_est.id%TYPE
                  )
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format VARCHAR2(64);
   BEGIN


     --Get actual NLS_DATE_FORMAT
     SELECT   VALUE
       INTO   l_date_format
       FROM   v$nls_parameters
      WHERE   parameter = 'NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            id||
            matricula||
            evento_id||
            fecha||
            metadata||
            observacion
      INTO l_string
      FROM hoja_vida_est
      WHERE
           id = hash.p_id
           ;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash;

    FUNCTION hash_rowid (p_rowid IN varchar2)
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format varchar2(64);
   BEGIN

      --Get actual NLS_DATE_FORMAT
      SELECT VALUE INTO l_date_format  FROM v$nls_parameters WHERE parameter ='NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            id||
            matricula||
            evento_id||
            fecha||
            metadata||
            observacion
      INTO l_string
      FROM hoja_vida_est
      WHERE  ROWID = hash_rowid.p_rowid;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash_rowid;

   FUNCTION rt (
               p_id IN hoja_vida_est.id%TYPE
               )
      RETURN hoja_vida_est_rt 
   IS
      l_hoja_vida_est_rec hoja_vida_est_rt;
   BEGIN

      SELECT a.*,
             tapi_hoja_vida_est.hash(id),
             rowid
      INTO l_hoja_vida_est_rec
      FROM hoja_vida_est a
      WHERE
           id = rt.p_id
           ;


      RETURN l_hoja_vida_est_rec;

   END rt;

   FUNCTION rt_for_update (
                          p_id IN hoja_vida_est.id%TYPE
                          )
      RETURN hoja_vida_est_rt 
   IS
      l_hoja_vida_est_rec hoja_vida_est_rt;
   BEGIN


      SELECT a.*,
             tapi_hoja_vida_est.hash(id),
             rowid
      INTO l_hoja_vida_est_rec
      FROM hoja_vida_est a
      WHERE
           id = rt_for_update.p_id
      FOR UPDATE;


      RETURN l_hoja_vida_est_rec;

   END rt_for_update;

    FUNCTION tt (
                p_id IN hoja_vida_est.id%TYPE DEFAULT NULL
                )
       RETURN hoja_vida_est_tt
       PIPELINED
    IS
       l_hoja_vida_est_rec   hoja_vida_est_rt;
    BEGIN

       FOR c1 IN (SELECT   a.*, ROWID
                    FROM   hoja_vida_est a
                   WHERE
                        id = NVL(tt.p_id,id)
                        )
       LOOP
              l_hoja_vida_est_rec.id := c1.id;
              l_hoja_vida_est_rec.matricula := c1.matricula;
              l_hoja_vida_est_rec.evento_id := c1.evento_id;
              l_hoja_vida_est_rec.fecha := c1.fecha;
              l_hoja_vida_est_rec.metadata := c1.metadata;
              l_hoja_vida_est_rec.observacion := c1.observacion;
              l_hoja_vida_est_rec.hash := tapi_hoja_vida_est.hash( c1.id);
              l_hoja_vida_est_rec.row_id := c1.ROWID;
              PIPE ROW (l_hoja_vida_est_rec);
       END LOOP;

       RETURN;

    END tt;


    PROCEDURE ins (p_hoja_vida_est_rec IN OUT hoja_vida_est_rt)
    IS
        l_rowtype     hoja_vida_est%ROWTYPE;

    BEGIN


        l_rowtype.id := ins.p_hoja_vida_est_rec.id;
        l_rowtype.matricula := ins.p_hoja_vida_est_rec.matricula;
        l_rowtype.evento_id := ins.p_hoja_vida_est_rec.evento_id;
        l_rowtype.fecha := ins.p_hoja_vida_est_rec.fecha;
        l_rowtype.metadata := ins.p_hoja_vida_est_rec.metadata;
        l_rowtype.observacion := ins.p_hoja_vida_est_rec.observacion;

       INSERT INTO hoja_vida_est
          VALUES   l_rowtype
       RETURNING
                   id ,
                   matricula ,
                   evento_id ,
                   fecha ,
                   metadata ,
                   observacion 
            INTO   l_rowtype;

         ins.p_hoja_vida_est_rec.id := l_rowtype.id;
         ins.p_hoja_vida_est_rec.matricula := l_rowtype.matricula;
         ins.p_hoja_vida_est_rec.evento_id := l_rowtype.evento_id;
         ins.p_hoja_vida_est_rec.fecha := l_rowtype.fecha;
         ins.p_hoja_vida_est_rec.metadata := l_rowtype.metadata;
         ins.p_hoja_vida_est_rec.observacion := l_rowtype.observacion;



    END ins;

    PROCEDURE upd (
                  p_hoja_vida_est_rec         IN hoja_vida_est_rt,
                  p_ignore_nulls         IN boolean := FALSE
                  )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   hoja_vida_est
             SET id = NVL(p_hoja_vida_est_rec.id,id),
                matricula = NVL(p_hoja_vida_est_rec.matricula,matricula),
                evento_id = NVL(p_hoja_vida_est_rec.evento_id,evento_id),
                fecha = NVL(p_hoja_vida_est_rec.fecha,fecha),
                metadata = NVL(p_hoja_vida_est_rec.metadata,metadata),
                observacion = NVL(p_hoja_vida_est_rec.observacion,observacion)
           WHERE
                id = upd.p_hoja_vida_est_rec.id
                ;
       ELSE
          UPDATE   hoja_vida_est
             SET id = p_hoja_vida_est_rec.id,
                matricula = p_hoja_vida_est_rec.matricula,
                evento_id = p_hoja_vida_est_rec.evento_id,
                fecha = p_hoja_vida_est_rec.fecha,
                metadata = p_hoja_vida_est_rec.metadata,
                observacion = p_hoja_vida_est_rec.observacion
           WHERE
                id = upd.p_hoja_vida_est_rec.id
                ;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd;


    PROCEDURE upd_rowid (
                         p_hoja_vida_est_rec         IN hoja_vida_est_rt,
                         p_ignore_nulls         IN boolean := FALSE
                        )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   hoja_vida_est
             SET id = NVL(p_hoja_vida_est_rec.id,id),
                matricula = NVL(p_hoja_vida_est_rec.matricula,matricula),
                evento_id = NVL(p_hoja_vida_est_rec.evento_id,evento_id),
                fecha = NVL(p_hoja_vida_est_rec.fecha,fecha),
                metadata = NVL(p_hoja_vida_est_rec.metadata,metadata),
                observacion = NVL(p_hoja_vida_est_rec.observacion,observacion)
           WHERE  ROWID = p_hoja_vida_est_rec.row_id;
       ELSE
          UPDATE   hoja_vida_est
             SET id = p_hoja_vida_est_rec.id,
                matricula = p_hoja_vida_est_rec.matricula,
                evento_id = p_hoja_vida_est_rec.evento_id,
                fecha = p_hoja_vida_est_rec.fecha,
                metadata = p_hoja_vida_est_rec.metadata,
                observacion = p_hoja_vida_est_rec.observacion
           WHERE  ROWID = p_hoja_vida_est_rec.row_id;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd_rowid;

   PROCEDURE web_upd (
                  p_hoja_vida_est_rec         IN hoja_vida_est_rt,
                  p_ignore_nulls         IN boolean := FALSE
                )
   IS
      l_hoja_vida_est_rec hoja_vida_est_rt;
   BEGIN

      OPEN hoja_vida_est_cur(
                             web_upd.p_hoja_vida_est_rec.id
                        );

      FETCH hoja_vida_est_cur INTO l_hoja_vida_est_rec;

      IF hoja_vida_est_cur%NOTFOUND THEN
         CLOSE hoja_vida_est_cur;
         RAISE e_row_missing;
      ELSE
         IF p_hoja_vida_est_rec.hash != l_hoja_vida_est_rec.hash THEN
            CLOSE hoja_vida_est_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(p_ignore_nulls, FALSE)
            THEN

                UPDATE   hoja_vida_est
                   SET id = NVL(p_hoja_vida_est_rec.id,id),
                       matricula = NVL(p_hoja_vida_est_rec.matricula,matricula),
                       evento_id = NVL(p_hoja_vida_est_rec.evento_id,evento_id),
                       fecha = NVL(p_hoja_vida_est_rec.fecha,fecha),
                       metadata = NVL(p_hoja_vida_est_rec.metadata,metadata),
                       observacion = NVL(p_hoja_vida_est_rec.observacion,observacion)
               WHERE CURRENT OF hoja_vida_est_cur;
            ELSE
                UPDATE   hoja_vida_est
                   SET id = p_hoja_vida_est_rec.id,
                       matricula = p_hoja_vida_est_rec.matricula,
                       evento_id = p_hoja_vida_est_rec.evento_id,
                       fecha = p_hoja_vida_est_rec.fecha,
                       metadata = p_hoja_vida_est_rec.metadata,
                       observacion = p_hoja_vida_est_rec.observacion
               WHERE CURRENT OF hoja_vida_est_cur;
            END IF;

            CLOSE hoja_vida_est_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd;

   PROCEDURE web_upd_rowid (
                            p_hoja_vida_est_rec    IN hoja_vida_est_rt,
                            p_ignore_nulls         IN boolean := FALSE
                           )
   IS
      l_hoja_vida_est_rec hoja_vida_est_rt;
   BEGIN

      OPEN hoja_vida_est_rowid_cur(web_upd_rowid.p_hoja_vida_est_rec.row_id);

      FETCH hoja_vida_est_rowid_cur INTO l_hoja_vida_est_rec;

      IF hoja_vida_est_rowid_cur%NOTFOUND THEN
         CLOSE hoja_vida_est_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_upd_rowid.p_hoja_vida_est_rec.hash != l_hoja_vida_est_rec.hash THEN
            CLOSE hoja_vida_est_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(web_upd_rowid.p_ignore_nulls, FALSE)
            THEN
                UPDATE   hoja_vida_est
                   SET id = NVL(p_hoja_vida_est_rec.id,id),
                       matricula = NVL(p_hoja_vida_est_rec.matricula,matricula),
                       evento_id = NVL(p_hoja_vida_est_rec.evento_id,evento_id),
                       fecha = NVL(p_hoja_vida_est_rec.fecha,fecha),
                       metadata = NVL(p_hoja_vida_est_rec.metadata,metadata),
                       observacion = NVL(p_hoja_vida_est_rec.observacion,observacion)
               WHERE CURRENT OF hoja_vida_est_rowid_cur;
            ELSE
                UPDATE   hoja_vida_est
                   SET id = p_hoja_vida_est_rec.id,
                       matricula = p_hoja_vida_est_rec.matricula,
                       evento_id = p_hoja_vida_est_rec.evento_id,
                       fecha = p_hoja_vida_est_rec.fecha,
                       metadata = p_hoja_vida_est_rec.metadata,
                       observacion = p_hoja_vida_est_rec.observacion
               WHERE CURRENT OF hoja_vida_est_rowid_cur;
            END IF;

            CLOSE hoja_vida_est_rowid_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd_rowid;

    PROCEDURE del (
                  p_id IN hoja_vida_est.id%TYPE
                  )
    IS
    BEGIN

       DELETE FROM   hoja_vida_est
             WHERE
                  id = del.p_id
                   ;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del;

    PROCEDURE del_rowid (p_rowid IN varchar2)
    IS
    BEGIN

       DELETE FROM   hoja_vida_est
             WHERE   ROWID = del_rowid.p_rowid;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del_rowid;

    PROCEDURE web_del (
                      p_id IN hoja_vida_est.id%TYPE,
                      p_hash IN varchar2
                      )
   IS
      l_hoja_vida_est_rec hoja_vida_est_rt;
   BEGIN


      OPEN hoja_vida_est_cur(
                            web_del.p_id
                            );

      FETCH hoja_vida_est_cur INTO l_hoja_vida_est_rec;

      IF hoja_vida_est_cur%NOTFOUND THEN
         CLOSE hoja_vida_est_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del.p_hash != l_hoja_vida_est_rec.hash THEN
            CLOSE hoja_vida_est_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM hoja_vida_est
            WHERE CURRENT OF hoja_vida_est_cur;

            CLOSE hoja_vida_est_cur;
         END IF;
      END IF;



   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del;

   PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2)
   IS
      l_hoja_vida_est_rec hoja_vida_est_rt;
   BEGIN


      OPEN hoja_vida_est_rowid_cur(web_del_rowid.p_rowid);

      FETCH hoja_vida_est_rowid_cur INTO l_hoja_vida_est_rec;

      IF hoja_vida_est_rowid_cur%NOTFOUND THEN
         CLOSE hoja_vida_est_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del_rowid.p_hash != l_hoja_vida_est_rec.hash THEN
            CLOSE hoja_vida_est_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM hoja_vida_est
            WHERE CURRENT OF hoja_vida_est_rowid_cur;

            CLOSE hoja_vida_est_rowid_cur;
         END IF;
      END IF;

   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del_rowid;

END tapi_hoja_vida_est;

/
--------------------------------------------------------
--  DDL for Package Body TAPI_INSCRIPCIONES
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."TAPI_INSCRIPCIONES" IS

   /**
   * TAPI_INSCRIPCIONES
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: 22-FEB-2020 03:12
   * Created By: FUNDAUC
   */


   --GLOBAL_PRIVATE_CURSORS
   --By PK
   CURSOR inscripciones_cur (
                       p_id IN inscripciones.id%TYPE
                       )
   IS
      SELECT
            id,
            fecha_ins,
            est_matricula,
            fecha_pago,
            estatus,
            seccion_id,
            periodo_id,
            creado_por,
            es_exonerado,
            prog_academico,
            es_suspendido,
            cohorte_id,
            horario_id,
            modificado_por,
            modificado_el,
            tapi_inscripciones.hash(id),
            ROWID
      FROM inscripciones
      WHERE
           id = inscripciones_cur.p_id
      FOR UPDATE;

    --By Rowid
    CURSOR inscripciones_rowid_cur (p_rowid IN VARCHAR2)
    IS
      SELECT
             id,
             fecha_ins,
             est_matricula,
             fecha_pago,
             estatus,
             seccion_id,
             periodo_id,
             creado_por,
             es_exonerado,
             prog_academico,
             es_suspendido,
             cohorte_id,
             horario_id,
             modificado_por,
             modificado_el,
             tapi_inscripciones.hash(id),
             ROWID
      FROM inscripciones
      WHERE ROWID = p_rowid
      FOR UPDATE;


    FUNCTION hash (
                  p_id IN inscripciones.id%TYPE
                  )
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format VARCHAR2(64);
   BEGIN


     --Get actual NLS_DATE_FORMAT
     SELECT   VALUE
       INTO   l_date_format
       FROM   v$nls_parameters
      WHERE   parameter = 'NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            id||
            fecha_ins||
            est_matricula||
            fecha_pago||
            estatus||
            seccion_id||
            periodo_id||
            creado_por||
            es_exonerado||
            prog_academico||
            es_suspendido||
            cohorte_id||
            horario_id||
            modificado_por||
            modificado_el
      INTO l_string
      FROM inscripciones
      WHERE
           id = hash.p_id
           ;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash;

    FUNCTION hash_rowid (p_rowid IN varchar2)
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format varchar2(64);
   BEGIN

      --Get actual NLS_DATE_FORMAT
      SELECT VALUE INTO l_date_format  FROM v$nls_parameters WHERE parameter ='NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            id||
            fecha_ins||
            est_matricula||
            fecha_pago||
            estatus||
            seccion_id||
            periodo_id||
            creado_por||
            es_exonerado||
            prog_academico||
            es_suspendido||
            cohorte_id||
            horario_id||
            modificado_por||
            modificado_el
      INTO l_string
      FROM inscripciones
      WHERE  ROWID = hash_rowid.p_rowid;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash_rowid;

   FUNCTION rt (
               p_id IN inscripciones.id%TYPE
               )
      RETURN inscripciones_rt RESULT_CACHE
   IS
      l_inscripciones_rec inscripciones_rt;
   BEGIN

      SELECT a.*,
             tapi_inscripciones.hash(id),
             rowid
      INTO l_inscripciones_rec
      FROM inscripciones a
      WHERE
           id = rt.p_id
           ;


      RETURN l_inscripciones_rec;

   END rt;

   FUNCTION rt_for_update (
                          p_id IN inscripciones.id%TYPE
                          )
      RETURN inscripciones_rt RESULT_CACHE
   IS
      l_inscripciones_rec inscripciones_rt;
   BEGIN


      SELECT a.*,
             tapi_inscripciones.hash(id),
             rowid
      INTO l_inscripciones_rec
      FROM inscripciones a
      WHERE
           id = rt_for_update.p_id
      FOR UPDATE;


      RETURN l_inscripciones_rec;

   END rt_for_update;

    FUNCTION tt (
                p_id IN inscripciones.id%TYPE DEFAULT NULL
                )
       RETURN inscripciones_tt
       PIPELINED
    IS
       l_inscripciones_rec   inscripciones_rt;
    BEGIN

       FOR c1 IN (SELECT   a.*, ROWID
                    FROM   inscripciones a
                   WHERE
                        id = NVL(tt.p_id,id)
                        )
       LOOP
              l_inscripciones_rec.id := c1.id;
              l_inscripciones_rec.fecha_ins := c1.fecha_ins;
              l_inscripciones_rec.est_matricula := c1.est_matricula;
              l_inscripciones_rec.fecha_pago := c1.fecha_pago;
              l_inscripciones_rec.estatus := c1.estatus;
              l_inscripciones_rec.seccion_id := c1.seccion_id;
              l_inscripciones_rec.periodo_id := c1.periodo_id;
              l_inscripciones_rec.creado_por := c1.creado_por;
              l_inscripciones_rec.es_exonerado := c1.es_exonerado;
              l_inscripciones_rec.prog_academico := c1.prog_academico;
              l_inscripciones_rec.es_suspendido := c1.es_suspendido;
              l_inscripciones_rec.cohorte_id := c1.cohorte_id;
              l_inscripciones_rec.horario_id := c1.horario_id;
              l_inscripciones_rec.modificado_por := c1.modificado_por;
              l_inscripciones_rec.modificado_el := c1.modificado_el;
              l_inscripciones_rec.hash := tapi_inscripciones.hash( c1.id);
              l_inscripciones_rec.row_id := c1.ROWID;
              PIPE ROW (l_inscripciones_rec);
       END LOOP;

       RETURN;

    END tt;


    PROCEDURE ins (p_inscripciones_rec IN OUT inscripciones_rt)
    IS
        l_rowtype     inscripciones%ROWTYPE;

    BEGIN


        l_rowtype.id := ins.p_inscripciones_rec.id;
        l_rowtype.fecha_ins := ins.p_inscripciones_rec.fecha_ins;
        l_rowtype.est_matricula := ins.p_inscripciones_rec.est_matricula;
        l_rowtype.fecha_pago := ins.p_inscripciones_rec.fecha_pago;
        l_rowtype.estatus := ins.p_inscripciones_rec.estatus;
        l_rowtype.seccion_id := ins.p_inscripciones_rec.seccion_id;
        l_rowtype.periodo_id := ins.p_inscripciones_rec.periodo_id;
        l_rowtype.creado_por := ins.p_inscripciones_rec.creado_por;
        l_rowtype.es_exonerado := ins.p_inscripciones_rec.es_exonerado;
        l_rowtype.prog_academico := ins.p_inscripciones_rec.prog_academico;
        l_rowtype.es_suspendido := ins.p_inscripciones_rec.es_suspendido;
        l_rowtype.cohorte_id := ins.p_inscripciones_rec.cohorte_id;
        l_rowtype.horario_id := ins.p_inscripciones_rec.horario_id;
        l_rowtype.modificado_por := ins.p_inscripciones_rec.modificado_por;
        l_rowtype.modificado_el := ins.p_inscripciones_rec.modificado_el;

       INSERT INTO inscripciones
          VALUES   l_rowtype
       RETURNING
                   id ,
                   fecha_ins ,
                   est_matricula ,
                   fecha_pago ,
                   estatus ,
                   seccion_id ,
                   periodo_id ,
                   creado_por ,
                   es_exonerado ,
                   prog_academico ,
                   es_suspendido ,
                   cohorte_id ,
                   horario_id ,
                   modificado_por ,
                   modificado_el 
            INTO   l_rowtype;

         ins.p_inscripciones_rec.id := l_rowtype.id;
         ins.p_inscripciones_rec.fecha_ins := l_rowtype.fecha_ins;
         ins.p_inscripciones_rec.est_matricula := l_rowtype.est_matricula;
         ins.p_inscripciones_rec.fecha_pago := l_rowtype.fecha_pago;
         ins.p_inscripciones_rec.estatus := l_rowtype.estatus;
         ins.p_inscripciones_rec.seccion_id := l_rowtype.seccion_id;
         ins.p_inscripciones_rec.periodo_id := l_rowtype.periodo_id;
         ins.p_inscripciones_rec.creado_por := l_rowtype.creado_por;
         ins.p_inscripciones_rec.es_exonerado := l_rowtype.es_exonerado;
         ins.p_inscripciones_rec.prog_academico := l_rowtype.prog_academico;
         ins.p_inscripciones_rec.es_suspendido := l_rowtype.es_suspendido;
         ins.p_inscripciones_rec.cohorte_id := l_rowtype.cohorte_id;
         ins.p_inscripciones_rec.horario_id := l_rowtype.horario_id;
         ins.p_inscripciones_rec.modificado_por := l_rowtype.modificado_por;
         ins.p_inscripciones_rec.modificado_el := l_rowtype.modificado_el;



    END ins;

    PROCEDURE upd (
                  p_inscripciones_rec         IN inscripciones_rt,
                  p_ignore_nulls         IN boolean := FALSE
                  )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   inscripciones
             SET id = NVL(p_inscripciones_rec.id,id),
                fecha_ins = NVL(p_inscripciones_rec.fecha_ins,fecha_ins),
                est_matricula = NVL(p_inscripciones_rec.est_matricula,est_matricula),
                fecha_pago = NVL(p_inscripciones_rec.fecha_pago,fecha_pago),
                estatus = NVL(p_inscripciones_rec.estatus,estatus),
                seccion_id = NVL(p_inscripciones_rec.seccion_id,seccion_id),
                periodo_id = NVL(p_inscripciones_rec.periodo_id,periodo_id),
                creado_por = NVL(p_inscripciones_rec.creado_por,creado_por),
                es_exonerado = NVL(p_inscripciones_rec.es_exonerado,es_exonerado),
                prog_academico = NVL(p_inscripciones_rec.prog_academico,prog_academico),
                es_suspendido = NVL(p_inscripciones_rec.es_suspendido,es_suspendido),
                cohorte_id = NVL(p_inscripciones_rec.cohorte_id,cohorte_id),
                horario_id = NVL(p_inscripciones_rec.horario_id,horario_id),
                modificado_por = NVL(p_inscripciones_rec.modificado_por,modificado_por),
                modificado_el = NVL(p_inscripciones_rec.modificado_el,modificado_el)
           WHERE
                id = upd.p_inscripciones_rec.id
                ;
       ELSE
          UPDATE   inscripciones
             SET id = p_inscripciones_rec.id,
                fecha_ins = p_inscripciones_rec.fecha_ins,
                est_matricula = p_inscripciones_rec.est_matricula,
                fecha_pago = p_inscripciones_rec.fecha_pago,
                estatus = p_inscripciones_rec.estatus,
                seccion_id = p_inscripciones_rec.seccion_id,
                periodo_id = p_inscripciones_rec.periodo_id,
                creado_por = p_inscripciones_rec.creado_por,
                es_exonerado = p_inscripciones_rec.es_exonerado,
                prog_academico = p_inscripciones_rec.prog_academico,
                es_suspendido = p_inscripciones_rec.es_suspendido,
                cohorte_id = p_inscripciones_rec.cohorte_id,
                horario_id = p_inscripciones_rec.horario_id,
                modificado_por = p_inscripciones_rec.modificado_por,
                modificado_el = p_inscripciones_rec.modificado_el
           WHERE
                id = upd.p_inscripciones_rec.id
                ;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd;


    PROCEDURE upd_rowid (
                         p_inscripciones_rec         IN inscripciones_rt,
                         p_ignore_nulls         IN boolean := FALSE
                        )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   inscripciones
             SET id = NVL(p_inscripciones_rec.id,id),
                fecha_ins = NVL(p_inscripciones_rec.fecha_ins,fecha_ins),
                est_matricula = NVL(p_inscripciones_rec.est_matricula,est_matricula),
                fecha_pago = NVL(p_inscripciones_rec.fecha_pago,fecha_pago),
                estatus = NVL(p_inscripciones_rec.estatus,estatus),
                seccion_id = NVL(p_inscripciones_rec.seccion_id,seccion_id),
                periodo_id = NVL(p_inscripciones_rec.periodo_id,periodo_id),
                creado_por = NVL(p_inscripciones_rec.creado_por,creado_por),
                es_exonerado = NVL(p_inscripciones_rec.es_exonerado,es_exonerado),
                prog_academico = NVL(p_inscripciones_rec.prog_academico,prog_academico),
                es_suspendido = NVL(p_inscripciones_rec.es_suspendido,es_suspendido),
                cohorte_id = NVL(p_inscripciones_rec.cohorte_id,cohorte_id),
                horario_id = NVL(p_inscripciones_rec.horario_id,horario_id),
                modificado_por = NVL(p_inscripciones_rec.modificado_por,modificado_por),
                modificado_el = NVL(p_inscripciones_rec.modificado_el,modificado_el)
           WHERE  ROWID = p_inscripciones_rec.row_id;
       ELSE
          UPDATE   inscripciones
             SET id = p_inscripciones_rec.id,
                fecha_ins = p_inscripciones_rec.fecha_ins,
                est_matricula = p_inscripciones_rec.est_matricula,
                fecha_pago = p_inscripciones_rec.fecha_pago,
                estatus = p_inscripciones_rec.estatus,
                seccion_id = p_inscripciones_rec.seccion_id,
                periodo_id = p_inscripciones_rec.periodo_id,
                creado_por = p_inscripciones_rec.creado_por,
                es_exonerado = p_inscripciones_rec.es_exonerado,
                prog_academico = p_inscripciones_rec.prog_academico,
                es_suspendido = p_inscripciones_rec.es_suspendido,
                cohorte_id = p_inscripciones_rec.cohorte_id,
                horario_id = p_inscripciones_rec.horario_id,
                modificado_por = p_inscripciones_rec.modificado_por,
                modificado_el = p_inscripciones_rec.modificado_el
           WHERE  ROWID = p_inscripciones_rec.row_id;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd_rowid;

   PROCEDURE web_upd (
                  p_inscripciones_rec         IN inscripciones_rt,
                  p_ignore_nulls         IN boolean := FALSE
                )
   IS
      l_inscripciones_rec inscripciones_rt;
   BEGIN

      OPEN inscripciones_cur(
                             web_upd.p_inscripciones_rec.id
                        );

      FETCH inscripciones_cur INTO l_inscripciones_rec;

      IF inscripciones_cur%NOTFOUND THEN
         CLOSE inscripciones_cur;
         RAISE e_row_missing;
      ELSE
         IF p_inscripciones_rec.hash != l_inscripciones_rec.hash THEN
            CLOSE inscripciones_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(p_ignore_nulls, FALSE)
            THEN

                UPDATE   inscripciones
                   SET id = NVL(p_inscripciones_rec.id,id),
                       fecha_ins = NVL(p_inscripciones_rec.fecha_ins,fecha_ins),
                       est_matricula = NVL(p_inscripciones_rec.est_matricula,est_matricula),
                       fecha_pago = NVL(p_inscripciones_rec.fecha_pago,fecha_pago),
                       estatus = NVL(p_inscripciones_rec.estatus,estatus),
                       seccion_id = NVL(p_inscripciones_rec.seccion_id,seccion_id),
                       periodo_id = NVL(p_inscripciones_rec.periodo_id,periodo_id),
                       creado_por = NVL(p_inscripciones_rec.creado_por,creado_por),
                       es_exonerado = NVL(p_inscripciones_rec.es_exonerado,es_exonerado),
                       prog_academico = NVL(p_inscripciones_rec.prog_academico,prog_academico),
                       es_suspendido = NVL(p_inscripciones_rec.es_suspendido,es_suspendido),
                       cohorte_id = NVL(p_inscripciones_rec.cohorte_id,cohorte_id),
                       horario_id = NVL(p_inscripciones_rec.horario_id,horario_id),
                       modificado_por = NVL(p_inscripciones_rec.modificado_por,modificado_por),
                       modificado_el = NVL(p_inscripciones_rec.modificado_el,modificado_el)
               WHERE CURRENT OF inscripciones_cur;
            ELSE
                UPDATE   inscripciones
                   SET id = p_inscripciones_rec.id,
                       fecha_ins = p_inscripciones_rec.fecha_ins,
                       est_matricula = p_inscripciones_rec.est_matricula,
                       fecha_pago = p_inscripciones_rec.fecha_pago,
                       estatus = p_inscripciones_rec.estatus,
                       seccion_id = p_inscripciones_rec.seccion_id,
                       periodo_id = p_inscripciones_rec.periodo_id,
                       creado_por = p_inscripciones_rec.creado_por,
                       es_exonerado = p_inscripciones_rec.es_exonerado,
                       prog_academico = p_inscripciones_rec.prog_academico,
                       es_suspendido = p_inscripciones_rec.es_suspendido,
                       cohorte_id = p_inscripciones_rec.cohorte_id,
                       horario_id = p_inscripciones_rec.horario_id,
                       modificado_por = p_inscripciones_rec.modificado_por,
                       modificado_el = p_inscripciones_rec.modificado_el
               WHERE CURRENT OF inscripciones_cur;
            END IF;

            CLOSE inscripciones_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd;

   PROCEDURE web_upd_rowid (
                            p_inscripciones_rec    IN inscripciones_rt,
                            p_ignore_nulls         IN boolean := FALSE
                           )
   IS
      l_inscripciones_rec inscripciones_rt;
   BEGIN

      OPEN inscripciones_rowid_cur(web_upd_rowid.p_inscripciones_rec.row_id);

      FETCH inscripciones_rowid_cur INTO l_inscripciones_rec;

      IF inscripciones_rowid_cur%NOTFOUND THEN
         CLOSE inscripciones_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_upd_rowid.p_inscripciones_rec.hash != l_inscripciones_rec.hash THEN
            CLOSE inscripciones_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(web_upd_rowid.p_ignore_nulls, FALSE)
            THEN
                UPDATE   inscripciones
                   SET id = NVL(p_inscripciones_rec.id,id),
                       fecha_ins = NVL(p_inscripciones_rec.fecha_ins,fecha_ins),
                       est_matricula = NVL(p_inscripciones_rec.est_matricula,est_matricula),
                       fecha_pago = NVL(p_inscripciones_rec.fecha_pago,fecha_pago),
                       estatus = NVL(p_inscripciones_rec.estatus,estatus),
                       seccion_id = NVL(p_inscripciones_rec.seccion_id,seccion_id),
                       periodo_id = NVL(p_inscripciones_rec.periodo_id,periodo_id),
                       creado_por = NVL(p_inscripciones_rec.creado_por,creado_por),
                       es_exonerado = NVL(p_inscripciones_rec.es_exonerado,es_exonerado),
                       prog_academico = NVL(p_inscripciones_rec.prog_academico,prog_academico),
                       es_suspendido = NVL(p_inscripciones_rec.es_suspendido,es_suspendido),
                       cohorte_id = NVL(p_inscripciones_rec.cohorte_id,cohorte_id),
                       horario_id = NVL(p_inscripciones_rec.horario_id,horario_id),
                       modificado_por = NVL(p_inscripciones_rec.modificado_por,modificado_por),
                       modificado_el = NVL(p_inscripciones_rec.modificado_el,modificado_el)
               WHERE CURRENT OF inscripciones_rowid_cur;
            ELSE
                UPDATE   inscripciones
                   SET id = p_inscripciones_rec.id,
                       fecha_ins = p_inscripciones_rec.fecha_ins,
                       est_matricula = p_inscripciones_rec.est_matricula,
                       fecha_pago = p_inscripciones_rec.fecha_pago,
                       estatus = p_inscripciones_rec.estatus,
                       seccion_id = p_inscripciones_rec.seccion_id,
                       periodo_id = p_inscripciones_rec.periodo_id,
                       creado_por = p_inscripciones_rec.creado_por,
                       es_exonerado = p_inscripciones_rec.es_exonerado,
                       prog_academico = p_inscripciones_rec.prog_academico,
                       es_suspendido = p_inscripciones_rec.es_suspendido,
                       cohorte_id = p_inscripciones_rec.cohorte_id,
                       horario_id = p_inscripciones_rec.horario_id,
                       modificado_por = p_inscripciones_rec.modificado_por,
                       modificado_el = p_inscripciones_rec.modificado_el
               WHERE CURRENT OF inscripciones_rowid_cur;
            END IF;

            CLOSE inscripciones_rowid_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd_rowid;

    PROCEDURE del (
                  p_id IN inscripciones.id%TYPE
                  )
    IS
    BEGIN

       DELETE FROM   inscripciones
             WHERE
                  id = del.p_id
                   ;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del;

    PROCEDURE del_rowid (p_rowid IN varchar2)
    IS
    BEGIN

       DELETE FROM   inscripciones
             WHERE   ROWID = del_rowid.p_rowid;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del_rowid;

    PROCEDURE web_del (
                      p_id IN inscripciones.id%TYPE,
                      p_hash IN varchar2
                      )
   IS
      l_inscripciones_rec inscripciones_rt;
   BEGIN


      OPEN inscripciones_cur(
                            web_del.p_id
                            );

      FETCH inscripciones_cur INTO l_inscripciones_rec;

      IF inscripciones_cur%NOTFOUND THEN
         CLOSE inscripciones_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del.p_hash != l_inscripciones_rec.hash THEN
            CLOSE inscripciones_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM inscripciones
            WHERE CURRENT OF inscripciones_cur;

            CLOSE inscripciones_cur;
         END IF;
      END IF;



   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del;

   PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2)
   IS
      l_inscripciones_rec inscripciones_rt;
   BEGIN


      OPEN inscripciones_rowid_cur(web_del_rowid.p_rowid);

      FETCH inscripciones_rowid_cur INTO l_inscripciones_rec;

      IF inscripciones_rowid_cur%NOTFOUND THEN
         CLOSE inscripciones_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del_rowid.p_hash != l_inscripciones_rec.hash THEN
            CLOSE inscripciones_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM inscripciones
            WHERE CURRENT OF inscripciones_rowid_cur;

            CLOSE inscripciones_rowid_cur;
         END IF;
      END IF;

   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del_rowid;

END tapi_inscripciones;

 

/
--------------------------------------------------------
--  DDL for Package Body TAPI_INSTANCIAS_SECCIONES
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."TAPI_INSTANCIAS_SECCIONES" IS

   /**
   * TAPI_INSTANCIAS_SECCIONES
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: 25-FEB-2020 23:11
   * Created By: FUNDAUC
   */


   --GLOBAL_PRIVATE_CURSORS
   --By PK
   CURSOR instancias_secciones_cur (
                       p_id IN instancias_secciones.id%TYPE
                       )
   IS
      SELECT
            id,
            seccion_id,
            codigo_sec,
            metodo_id,
            nivel,
            periodo_id,
            horario_id,
            modalidad_id,
            cedula_prof,
            f_inicio,
            f_fin,
            estatus,
            tapi_instancias_secciones.hash(id),
            ROWID
      FROM instancias_secciones
      WHERE
           id = instancias_secciones_cur.p_id
      FOR UPDATE;

    --By Rowid
    CURSOR instancias_secciones_rowid_cur (p_rowid IN VARCHAR2)
    IS
      SELECT
             id,
             seccion_id,
             codigo_sec,
             metodo_id,
             nivel,
             periodo_id,
             horario_id,
             modalidad_id,
             cedula_prof,
             f_inicio,
             f_fin,
             estatus,
             tapi_instancias_secciones.hash(id),
             ROWID
      FROM instancias_secciones
      WHERE ROWID = p_rowid
      FOR UPDATE;


    FUNCTION hash (
                  p_id IN instancias_secciones.id%TYPE
                  )
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format VARCHAR2(64);
   BEGIN


     --Get actual NLS_DATE_FORMAT
     SELECT   VALUE
       INTO   l_date_format
       FROM   v$nls_parameters
      WHERE   parameter = 'NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            id||
            seccion_id||
            codigo_sec||
            metodo_id||
            nivel||
            periodo_id||
            horario_id||
            modalidad_id||
            cedula_prof||
            f_inicio||
            f_fin||
            estatus
      INTO l_string
      FROM instancias_secciones
      WHERE
           id = hash.p_id
           ;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash;

    FUNCTION hash_rowid (p_rowid IN varchar2)
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format varchar2(64);
   BEGIN

      --Get actual NLS_DATE_FORMAT
      SELECT VALUE INTO l_date_format  FROM v$nls_parameters WHERE parameter ='NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            id||
            seccion_id||
            codigo_sec||
            metodo_id||
            nivel||
            periodo_id||
            horario_id||
            modalidad_id||
            cedula_prof||
            f_inicio||
            f_fin||
            estatus
      INTO l_string
      FROM instancias_secciones
      WHERE  ROWID = hash_rowid.p_rowid;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash_rowid;

   FUNCTION rt (
               p_id IN instancias_secciones.id%TYPE
               )
      RETURN instancias_secciones_rt RESULT_CACHE
   IS
      l_instancias_secciones_rec instancias_secciones_rt;
   BEGIN

      SELECT a.*,
             tapi_instancias_secciones.hash(id),
             rowid
      INTO l_instancias_secciones_rec
      FROM instancias_secciones a
      WHERE
           id = rt.p_id
           ;


      RETURN l_instancias_secciones_rec;

   END rt;

   FUNCTION rt_for_update (
                          p_id IN instancias_secciones.id%TYPE
                          )
      RETURN instancias_secciones_rt RESULT_CACHE
   IS
      l_instancias_secciones_rec instancias_secciones_rt;
   BEGIN


      SELECT a.*,
             tapi_instancias_secciones.hash(id),
             rowid
      INTO l_instancias_secciones_rec
      FROM instancias_secciones a
      WHERE
           id = rt_for_update.p_id
      FOR UPDATE;


      RETURN l_instancias_secciones_rec;

   END rt_for_update;

    FUNCTION tt (
                p_id IN instancias_secciones.id%TYPE DEFAULT NULL
                )
       RETURN instancias_secciones_tt
       PIPELINED
    IS
       l_instancias_secciones_rec   instancias_secciones_rt;
    BEGIN

       FOR c1 IN (SELECT   a.*, ROWID
                    FROM   instancias_secciones a
                   WHERE
                        id = NVL(tt.p_id,id)
                        )
       LOOP
              l_instancias_secciones_rec.id := c1.id;
              l_instancias_secciones_rec.seccion_id := c1.seccion_id;
              l_instancias_secciones_rec.codigo_sec := c1.codigo_sec;
              l_instancias_secciones_rec.metodo_id := c1.metodo_id;
              l_instancias_secciones_rec.nivel := c1.nivel;
              l_instancias_secciones_rec.periodo_id := c1.periodo_id;
              l_instancias_secciones_rec.horario_id := c1.horario_id;
              l_instancias_secciones_rec.modalidad_id := c1.modalidad_id;
              l_instancias_secciones_rec.cedula_prof := c1.cedula_prof;
              l_instancias_secciones_rec.f_inicio := c1.f_inicio;
              l_instancias_secciones_rec.f_fin := c1.f_fin;
              l_instancias_secciones_rec.estatus := c1.estatus;
              l_instancias_secciones_rec.hash := tapi_instancias_secciones.hash( c1.id);
              l_instancias_secciones_rec.row_id := c1.ROWID;
              PIPE ROW (l_instancias_secciones_rec);
       END LOOP;

       RETURN;

    END tt;


    PROCEDURE ins (p_instancias_secciones_rec IN OUT instancias_secciones_rt)
    IS
        l_rowtype     instancias_secciones%ROWTYPE;

    BEGIN


        l_rowtype.id := ins.p_instancias_secciones_rec.id;
        l_rowtype.seccion_id := ins.p_instancias_secciones_rec.seccion_id;
        l_rowtype.codigo_sec := ins.p_instancias_secciones_rec.codigo_sec;
        l_rowtype.metodo_id := ins.p_instancias_secciones_rec.metodo_id;
        l_rowtype.nivel := ins.p_instancias_secciones_rec.nivel;
        l_rowtype.periodo_id := ins.p_instancias_secciones_rec.periodo_id;
        l_rowtype.horario_id := ins.p_instancias_secciones_rec.horario_id;
        l_rowtype.modalidad_id := ins.p_instancias_secciones_rec.modalidad_id;
        l_rowtype.cedula_prof := ins.p_instancias_secciones_rec.cedula_prof;
        l_rowtype.f_inicio := ins.p_instancias_secciones_rec.f_inicio;
        l_rowtype.f_fin := ins.p_instancias_secciones_rec.f_fin;
        l_rowtype.estatus := ins.p_instancias_secciones_rec.estatus;

       INSERT INTO instancias_secciones
          VALUES   l_rowtype
       RETURNING
                   id ,
                   seccion_id ,
                   codigo_sec ,
                   metodo_id ,
                   nivel ,
                   periodo_id ,
                   horario_id ,
                   modalidad_id ,
                   cedula_prof ,
                   f_inicio ,
                   f_fin ,
                   estatus 
            INTO   l_rowtype;

         ins.p_instancias_secciones_rec.id := l_rowtype.id;
         ins.p_instancias_secciones_rec.seccion_id := l_rowtype.seccion_id;
         ins.p_instancias_secciones_rec.codigo_sec := l_rowtype.codigo_sec;
         ins.p_instancias_secciones_rec.metodo_id := l_rowtype.metodo_id;
         ins.p_instancias_secciones_rec.nivel := l_rowtype.nivel;
         ins.p_instancias_secciones_rec.periodo_id := l_rowtype.periodo_id;
         ins.p_instancias_secciones_rec.horario_id := l_rowtype.horario_id;
         ins.p_instancias_secciones_rec.modalidad_id := l_rowtype.modalidad_id;
         ins.p_instancias_secciones_rec.cedula_prof := l_rowtype.cedula_prof;
         ins.p_instancias_secciones_rec.f_inicio := l_rowtype.f_inicio;
         ins.p_instancias_secciones_rec.f_fin := l_rowtype.f_fin;
         ins.p_instancias_secciones_rec.estatus := l_rowtype.estatus;



    END ins;

    PROCEDURE upd (
                  p_instancias_secciones_rec         IN instancias_secciones_rt,
                  p_ignore_nulls         IN boolean := FALSE
                  )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   instancias_secciones
             SET id = NVL(p_instancias_secciones_rec.id,id),
                seccion_id = NVL(p_instancias_secciones_rec.seccion_id,seccion_id),
                codigo_sec = NVL(p_instancias_secciones_rec.codigo_sec,codigo_sec),
                metodo_id = NVL(p_instancias_secciones_rec.metodo_id,metodo_id),
                nivel = NVL(p_instancias_secciones_rec.nivel,nivel),
                periodo_id = NVL(p_instancias_secciones_rec.periodo_id,periodo_id),
                horario_id = NVL(p_instancias_secciones_rec.horario_id,horario_id),
                modalidad_id = NVL(p_instancias_secciones_rec.modalidad_id,modalidad_id),
                cedula_prof = NVL(p_instancias_secciones_rec.cedula_prof,cedula_prof),
                f_inicio = NVL(p_instancias_secciones_rec.f_inicio,f_inicio),
                f_fin = NVL(p_instancias_secciones_rec.f_fin,f_fin),
                estatus = NVL(p_instancias_secciones_rec.estatus,estatus)
           WHERE
                id = upd.p_instancias_secciones_rec.id
                ;
       ELSE
          UPDATE   instancias_secciones
             SET id = p_instancias_secciones_rec.id,
                seccion_id = p_instancias_secciones_rec.seccion_id,
                codigo_sec = p_instancias_secciones_rec.codigo_sec,
                metodo_id = p_instancias_secciones_rec.metodo_id,
                nivel = p_instancias_secciones_rec.nivel,
                periodo_id = p_instancias_secciones_rec.periodo_id,
                horario_id = p_instancias_secciones_rec.horario_id,
                modalidad_id = p_instancias_secciones_rec.modalidad_id,
                cedula_prof = p_instancias_secciones_rec.cedula_prof,
                f_inicio = p_instancias_secciones_rec.f_inicio,
                f_fin = p_instancias_secciones_rec.f_fin,
                estatus = p_instancias_secciones_rec.estatus
           WHERE
                id = upd.p_instancias_secciones_rec.id
                ;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd;


    PROCEDURE upd_rowid (
                         p_instancias_secciones_rec         IN instancias_secciones_rt,
                         p_ignore_nulls         IN boolean := FALSE
                        )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   instancias_secciones
             SET id = NVL(p_instancias_secciones_rec.id,id),
                seccion_id = NVL(p_instancias_secciones_rec.seccion_id,seccion_id),
                codigo_sec = NVL(p_instancias_secciones_rec.codigo_sec,codigo_sec),
                metodo_id = NVL(p_instancias_secciones_rec.metodo_id,metodo_id),
                nivel = NVL(p_instancias_secciones_rec.nivel,nivel),
                periodo_id = NVL(p_instancias_secciones_rec.periodo_id,periodo_id),
                horario_id = NVL(p_instancias_secciones_rec.horario_id,horario_id),
                modalidad_id = NVL(p_instancias_secciones_rec.modalidad_id,modalidad_id),
                cedula_prof = NVL(p_instancias_secciones_rec.cedula_prof,cedula_prof),
                f_inicio = NVL(p_instancias_secciones_rec.f_inicio,f_inicio),
                f_fin = NVL(p_instancias_secciones_rec.f_fin,f_fin),
                estatus = NVL(p_instancias_secciones_rec.estatus,estatus)
           WHERE  ROWID = p_instancias_secciones_rec.row_id;
       ELSE
          UPDATE   instancias_secciones
             SET id = p_instancias_secciones_rec.id,
                seccion_id = p_instancias_secciones_rec.seccion_id,
                codigo_sec = p_instancias_secciones_rec.codigo_sec,
                metodo_id = p_instancias_secciones_rec.metodo_id,
                nivel = p_instancias_secciones_rec.nivel,
                periodo_id = p_instancias_secciones_rec.periodo_id,
                horario_id = p_instancias_secciones_rec.horario_id,
                modalidad_id = p_instancias_secciones_rec.modalidad_id,
                cedula_prof = p_instancias_secciones_rec.cedula_prof,
                f_inicio = p_instancias_secciones_rec.f_inicio,
                f_fin = p_instancias_secciones_rec.f_fin,
                estatus = p_instancias_secciones_rec.estatus
           WHERE  ROWID = p_instancias_secciones_rec.row_id;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd_rowid;

   PROCEDURE web_upd (
                  p_instancias_secciones_rec         IN instancias_secciones_rt,
                  p_ignore_nulls         IN boolean := FALSE
                )
   IS
      l_instancias_secciones_rec instancias_secciones_rt;
   BEGIN

      OPEN instancias_secciones_cur(
                             web_upd.p_instancias_secciones_rec.id
                        );

      FETCH instancias_secciones_cur INTO l_instancias_secciones_rec;

      IF instancias_secciones_cur%NOTFOUND THEN
         CLOSE instancias_secciones_cur;
         RAISE e_row_missing;
      ELSE
         IF p_instancias_secciones_rec.hash != l_instancias_secciones_rec.hash THEN
            CLOSE instancias_secciones_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(p_ignore_nulls, FALSE)
            THEN

                UPDATE   instancias_secciones
                   SET id = NVL(p_instancias_secciones_rec.id,id),
                       seccion_id = NVL(p_instancias_secciones_rec.seccion_id,seccion_id),
                       codigo_sec = NVL(p_instancias_secciones_rec.codigo_sec,codigo_sec),
                       metodo_id = NVL(p_instancias_secciones_rec.metodo_id,metodo_id),
                       nivel = NVL(p_instancias_secciones_rec.nivel,nivel),
                       periodo_id = NVL(p_instancias_secciones_rec.periodo_id,periodo_id),
                       horario_id = NVL(p_instancias_secciones_rec.horario_id,horario_id),
                       modalidad_id = NVL(p_instancias_secciones_rec.modalidad_id,modalidad_id),
                       cedula_prof = NVL(p_instancias_secciones_rec.cedula_prof,cedula_prof),
                       f_inicio = NVL(p_instancias_secciones_rec.f_inicio,f_inicio),
                       f_fin = NVL(p_instancias_secciones_rec.f_fin,f_fin),
                       estatus = NVL(p_instancias_secciones_rec.estatus,estatus)
               WHERE CURRENT OF instancias_secciones_cur;
            ELSE
                UPDATE   instancias_secciones
                   SET id = p_instancias_secciones_rec.id,
                       seccion_id = p_instancias_secciones_rec.seccion_id,
                       codigo_sec = p_instancias_secciones_rec.codigo_sec,
                       metodo_id = p_instancias_secciones_rec.metodo_id,
                       nivel = p_instancias_secciones_rec.nivel,
                       periodo_id = p_instancias_secciones_rec.periodo_id,
                       horario_id = p_instancias_secciones_rec.horario_id,
                       modalidad_id = p_instancias_secciones_rec.modalidad_id,
                       cedula_prof = p_instancias_secciones_rec.cedula_prof,
                       f_inicio = p_instancias_secciones_rec.f_inicio,
                       f_fin = p_instancias_secciones_rec.f_fin,
                       estatus = p_instancias_secciones_rec.estatus
               WHERE CURRENT OF instancias_secciones_cur;
            END IF;

            CLOSE instancias_secciones_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd;

   PROCEDURE web_upd_rowid (
                            p_instancias_secciones_rec    IN instancias_secciones_rt,
                            p_ignore_nulls         IN boolean := FALSE
                           )
   IS
      l_instancias_secciones_rec instancias_secciones_rt;
   BEGIN

      OPEN instancias_secciones_rowid_cur(web_upd_rowid.p_instancias_secciones_rec.row_id);

      FETCH instancias_secciones_rowid_cur INTO l_instancias_secciones_rec;

      IF instancias_secciones_rowid_cur%NOTFOUND THEN
         CLOSE instancias_secciones_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_upd_rowid.p_instancias_secciones_rec.hash != l_instancias_secciones_rec.hash THEN
            CLOSE instancias_secciones_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(web_upd_rowid.p_ignore_nulls, FALSE)
            THEN
                UPDATE   instancias_secciones
                   SET id = NVL(p_instancias_secciones_rec.id,id),
                       seccion_id = NVL(p_instancias_secciones_rec.seccion_id,seccion_id),
                       codigo_sec = NVL(p_instancias_secciones_rec.codigo_sec,codigo_sec),
                       metodo_id = NVL(p_instancias_secciones_rec.metodo_id,metodo_id),
                       nivel = NVL(p_instancias_secciones_rec.nivel,nivel),
                       periodo_id = NVL(p_instancias_secciones_rec.periodo_id,periodo_id),
                       horario_id = NVL(p_instancias_secciones_rec.horario_id,horario_id),
                       modalidad_id = NVL(p_instancias_secciones_rec.modalidad_id,modalidad_id),
                       cedula_prof = NVL(p_instancias_secciones_rec.cedula_prof,cedula_prof),
                       f_inicio = NVL(p_instancias_secciones_rec.f_inicio,f_inicio),
                       f_fin = NVL(p_instancias_secciones_rec.f_fin,f_fin),
                       estatus = NVL(p_instancias_secciones_rec.estatus,estatus)
               WHERE CURRENT OF instancias_secciones_rowid_cur;
            ELSE
                UPDATE   instancias_secciones
                   SET id = p_instancias_secciones_rec.id,
                       seccion_id = p_instancias_secciones_rec.seccion_id,
                       codigo_sec = p_instancias_secciones_rec.codigo_sec,
                       metodo_id = p_instancias_secciones_rec.metodo_id,
                       nivel = p_instancias_secciones_rec.nivel,
                       periodo_id = p_instancias_secciones_rec.periodo_id,
                       horario_id = p_instancias_secciones_rec.horario_id,
                       modalidad_id = p_instancias_secciones_rec.modalidad_id,
                       cedula_prof = p_instancias_secciones_rec.cedula_prof,
                       f_inicio = p_instancias_secciones_rec.f_inicio,
                       f_fin = p_instancias_secciones_rec.f_fin,
                       estatus = p_instancias_secciones_rec.estatus
               WHERE CURRENT OF instancias_secciones_rowid_cur;
            END IF;

            CLOSE instancias_secciones_rowid_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd_rowid;

    PROCEDURE del (
                  p_id IN instancias_secciones.id%TYPE
                  )
    IS
    BEGIN

       DELETE FROM   instancias_secciones
             WHERE
                  id = del.p_id
                   ;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del;

    PROCEDURE del_rowid (p_rowid IN varchar2)
    IS
    BEGIN

       DELETE FROM   instancias_secciones
             WHERE   ROWID = del_rowid.p_rowid;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del_rowid;

    PROCEDURE web_del (
                      p_id IN instancias_secciones.id%TYPE,
                      p_hash IN varchar2
                      )
   IS
      l_instancias_secciones_rec instancias_secciones_rt;
   BEGIN


      OPEN instancias_secciones_cur(
                            web_del.p_id
                            );

      FETCH instancias_secciones_cur INTO l_instancias_secciones_rec;

      IF instancias_secciones_cur%NOTFOUND THEN
         CLOSE instancias_secciones_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del.p_hash != l_instancias_secciones_rec.hash THEN
            CLOSE instancias_secciones_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM instancias_secciones
            WHERE CURRENT OF instancias_secciones_cur;

            CLOSE instancias_secciones_cur;
         END IF;
      END IF;



   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del;

   PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2)
   IS
      l_instancias_secciones_rec instancias_secciones_rt;
   BEGIN


      OPEN instancias_secciones_rowid_cur(web_del_rowid.p_rowid);

      FETCH instancias_secciones_rowid_cur INTO l_instancias_secciones_rec;

      IF instancias_secciones_rowid_cur%NOTFOUND THEN
         CLOSE instancias_secciones_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del_rowid.p_hash != l_instancias_secciones_rec.hash THEN
            CLOSE instancias_secciones_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM instancias_secciones
            WHERE CURRENT OF instancias_secciones_rowid_cur;

            CLOSE instancias_secciones_rowid_cur;
         END IF;
      END IF;

   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del_rowid;

END tapi_instancias_secciones;

 

/
--------------------------------------------------------
--  DDL for Package Body TAPI_MATERIALES
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."TAPI_MATERIALES" IS

   /**
   * TAPI_MATERIALES
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: 01-OCT-2019 12:25
   * Created By: FUNDAUC
   */


   --GLOBAL_PRIVATE_CURSORS
   --By PK
   CURSOR materiales_cur (
                       p_id IN materiales.id%TYPE
                       )
   IS
      SELECT
            id_mat,
            tipo,
            descripcion,
            id_curso,
            evento,
            nivel,
            iva_exento,
            activo,
            id,
            seccion_id,
            creado_por,
            creado_el,
            modificado_por,
            modificado_el,
            cohorte_id,
            tapi_materiales.hash(id),
            ROWID
      FROM materiales
      WHERE
           id = materiales_cur.p_id
      FOR UPDATE;

    --By Rowid
    CURSOR materiales_rowid_cur (p_rowid IN VARCHAR2)
    IS
      SELECT
             id_mat,
             tipo,
             descripcion,
             id_curso,
             evento,
             nivel,
             iva_exento,
             activo,
             id,
             seccion_id,
             creado_por,
             creado_el,
             modificado_por,
             modificado_el,
             cohorte_id,
             tapi_materiales.hash(id),
             ROWID
      FROM materiales
      WHERE ROWID = p_rowid
      FOR UPDATE;


    FUNCTION hash (
                  p_id IN materiales.id%TYPE
                  )
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format VARCHAR2(64);
   BEGIN


     --Get actual NLS_DATE_FORMAT
     SELECT   VALUE
       INTO   l_date_format
       FROM   v$nls_parameters
      WHERE   parameter = 'NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            id_mat||
            tipo||
            descripcion||
            id_curso||
            evento||
            nivel||
            iva_exento||
            activo||
            id||
            seccion_id||
            creado_por||
            creado_el||
            modificado_por||
            modificado_el||
            cohorte_id
      INTO l_string
      FROM materiales
      WHERE
           id = hash.p_id
           ;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash;

    FUNCTION hash_rowid (p_rowid IN varchar2)
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format varchar2(64);
   BEGIN

      --Get actual NLS_DATE_FORMAT
      SELECT VALUE INTO l_date_format  FROM v$nls_parameters WHERE parameter ='NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            id_mat||
            tipo||
            descripcion||
            id_curso||
            evento||
            nivel||
            iva_exento||
            activo||
            id||
            seccion_id||
            creado_por||
            creado_el||
            modificado_por||
            modificado_el||
            cohorte_id
      INTO l_string
      FROM materiales
      WHERE  ROWID = hash_rowid.p_rowid;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash_rowid;

   FUNCTION rt (
               p_id IN materiales.id%TYPE
               )
      RETURN materiales_rt RESULT_CACHE
   IS
      l_materiales_rec materiales_rt;
   BEGIN

      SELECT a.*,
             tapi_materiales.hash(id),
             rowid
      INTO l_materiales_rec
      FROM materiales a
      WHERE
           id = rt.p_id
           ;


      RETURN l_materiales_rec;

   END rt;

   FUNCTION rt_for_update (
                          p_id IN materiales.id%TYPE
                          )
      RETURN materiales_rt RESULT_CACHE
   IS
      l_materiales_rec materiales_rt;
   BEGIN


      SELECT a.*,
             tapi_materiales.hash(id),
             rowid
      INTO l_materiales_rec
      FROM materiales a
      WHERE
           id = rt_for_update.p_id
      FOR UPDATE;


      RETURN l_materiales_rec;

   END rt_for_update;

    FUNCTION tt (
                p_id IN materiales.id%TYPE DEFAULT NULL
                )
       RETURN materiales_tt
       PIPELINED
    IS
       l_materiales_rec   materiales_rt;
    BEGIN

       FOR c1 IN (SELECT   a.*, ROWID
                    FROM   materiales a
                   WHERE
                        id = NVL(tt.p_id,id)
                        )
       LOOP
              l_materiales_rec.id_mat := c1.id_mat;
              l_materiales_rec.tipo := c1.tipo;
              l_materiales_rec.descripcion := c1.descripcion;
              l_materiales_rec.id_curso := c1.id_curso;
              l_materiales_rec.evento := c1.evento;
              l_materiales_rec.nivel := c1.nivel;
              l_materiales_rec.iva_exento := c1.iva_exento;
              l_materiales_rec.activo := c1.activo;
              l_materiales_rec.id := c1.id;
              l_materiales_rec.seccion_id := c1.seccion_id;
              l_materiales_rec.creado_por := c1.creado_por;
              l_materiales_rec.creado_el := c1.creado_el;
              l_materiales_rec.modificado_por := c1.modificado_por;
              l_materiales_rec.modificado_el := c1.modificado_el;
              l_materiales_rec.cohorte_id := c1.cohorte_id;
              l_materiales_rec.hash := tapi_materiales.hash( c1.id);
              l_materiales_rec.row_id := c1.ROWID;
              PIPE ROW (l_materiales_rec);
       END LOOP;

       RETURN;

    END tt;


    PROCEDURE ins (p_materiales_rec IN OUT materiales_rt)
    IS
        l_rowtype     materiales%ROWTYPE;

    BEGIN


        l_rowtype.id_mat := ins.p_materiales_rec.id_mat;
        l_rowtype.tipo := ins.p_materiales_rec.tipo;
        l_rowtype.descripcion := ins.p_materiales_rec.descripcion;
        l_rowtype.id_curso := ins.p_materiales_rec.id_curso;
        l_rowtype.evento := ins.p_materiales_rec.evento;
        l_rowtype.nivel := ins.p_materiales_rec.nivel;
        l_rowtype.iva_exento := ins.p_materiales_rec.iva_exento;
        l_rowtype.activo := ins.p_materiales_rec.activo;
        l_rowtype.id := ins.p_materiales_rec.id;
        l_rowtype.seccion_id := ins.p_materiales_rec.seccion_id;
        l_rowtype.creado_por := ins.p_materiales_rec.creado_por;
        l_rowtype.creado_el := ins.p_materiales_rec.creado_el;
        l_rowtype.modificado_por := ins.p_materiales_rec.modificado_por;
        l_rowtype.modificado_el := ins.p_materiales_rec.modificado_el;
        l_rowtype.cohorte_id := ins.p_materiales_rec.cohorte_id;

       INSERT INTO materiales
          VALUES   l_rowtype
       RETURNING
                   id_mat ,
                   tipo ,
                   descripcion ,
                   id_curso ,
                   evento ,
                   nivel ,
                   iva_exento ,
                   activo ,
                   id ,
                   seccion_id ,
                   creado_por ,
                   creado_el ,
                   modificado_por ,
                   modificado_el ,
                   cohorte_id 
            INTO   l_rowtype;

         ins.p_materiales_rec.id_mat := l_rowtype.id_mat;
         ins.p_materiales_rec.tipo := l_rowtype.tipo;
         ins.p_materiales_rec.descripcion := l_rowtype.descripcion;
         ins.p_materiales_rec.id_curso := l_rowtype.id_curso;
         ins.p_materiales_rec.evento := l_rowtype.evento;
         ins.p_materiales_rec.nivel := l_rowtype.nivel;
         ins.p_materiales_rec.iva_exento := l_rowtype.iva_exento;
         ins.p_materiales_rec.activo := l_rowtype.activo;
         ins.p_materiales_rec.id := l_rowtype.id;
         ins.p_materiales_rec.seccion_id := l_rowtype.seccion_id;
         ins.p_materiales_rec.creado_por := l_rowtype.creado_por;
         ins.p_materiales_rec.creado_el := l_rowtype.creado_el;
         ins.p_materiales_rec.modificado_por := l_rowtype.modificado_por;
         ins.p_materiales_rec.modificado_el := l_rowtype.modificado_el;
         ins.p_materiales_rec.cohorte_id := l_rowtype.cohorte_id;



    END ins;

    PROCEDURE upd (
                  p_materiales_rec         IN materiales_rt,
                  p_ignore_nulls         IN boolean := FALSE
                  )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   materiales
             SET id_mat = NVL(p_materiales_rec.id_mat,id_mat),
                tipo = NVL(p_materiales_rec.tipo,tipo),
                descripcion = NVL(p_materiales_rec.descripcion,descripcion),
                id_curso = NVL(p_materiales_rec.id_curso,id_curso),
                evento = NVL(p_materiales_rec.evento,evento),
                nivel = NVL(p_materiales_rec.nivel,nivel),
                iva_exento = NVL(p_materiales_rec.iva_exento,iva_exento),
                activo = NVL(p_materiales_rec.activo,activo),
                id = NVL(p_materiales_rec.id,id),
                seccion_id = NVL(p_materiales_rec.seccion_id,seccion_id),
                creado_por = NVL(p_materiales_rec.creado_por,creado_por),
                creado_el = NVL(p_materiales_rec.creado_el,creado_el),
                modificado_por = NVL(p_materiales_rec.modificado_por,modificado_por),
                modificado_el = NVL(p_materiales_rec.modificado_el,modificado_el),
                cohorte_id = NVL(p_materiales_rec.cohorte_id,cohorte_id)
           WHERE
                id = upd.p_materiales_rec.id
                ;
       ELSE
          UPDATE   materiales
             SET id_mat = p_materiales_rec.id_mat,
                tipo = p_materiales_rec.tipo,
                descripcion = p_materiales_rec.descripcion,
                id_curso = p_materiales_rec.id_curso,
                evento = p_materiales_rec.evento,
                nivel = p_materiales_rec.nivel,
                iva_exento = p_materiales_rec.iva_exento,
                activo = p_materiales_rec.activo,
                id = p_materiales_rec.id,
                seccion_id = p_materiales_rec.seccion_id,
                creado_por = p_materiales_rec.creado_por,
                creado_el = p_materiales_rec.creado_el,
                modificado_por = p_materiales_rec.modificado_por,
                modificado_el = p_materiales_rec.modificado_el,
                cohorte_id = p_materiales_rec.cohorte_id
           WHERE
                id = upd.p_materiales_rec.id
                ;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd;


    PROCEDURE upd_rowid (
                         p_materiales_rec         IN materiales_rt,
                         p_ignore_nulls         IN boolean := FALSE
                        )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   materiales
             SET id_mat = NVL(p_materiales_rec.id_mat,id_mat),
                tipo = NVL(p_materiales_rec.tipo,tipo),
                descripcion = NVL(p_materiales_rec.descripcion,descripcion),
                id_curso = NVL(p_materiales_rec.id_curso,id_curso),
                evento = NVL(p_materiales_rec.evento,evento),
                nivel = NVL(p_materiales_rec.nivel,nivel),
                iva_exento = NVL(p_materiales_rec.iva_exento,iva_exento),
                activo = NVL(p_materiales_rec.activo,activo),
                id = NVL(p_materiales_rec.id,id),
                seccion_id = NVL(p_materiales_rec.seccion_id,seccion_id),
                creado_por = NVL(p_materiales_rec.creado_por,creado_por),
                creado_el = NVL(p_materiales_rec.creado_el,creado_el),
                modificado_por = NVL(p_materiales_rec.modificado_por,modificado_por),
                modificado_el = NVL(p_materiales_rec.modificado_el,modificado_el),
                cohorte_id = NVL(p_materiales_rec.cohorte_id,cohorte_id)
           WHERE  ROWID = p_materiales_rec.row_id;
       ELSE
          UPDATE   materiales
             SET id_mat = p_materiales_rec.id_mat,
                tipo = p_materiales_rec.tipo,
                descripcion = p_materiales_rec.descripcion,
                id_curso = p_materiales_rec.id_curso,
                evento = p_materiales_rec.evento,
                nivel = p_materiales_rec.nivel,
                iva_exento = p_materiales_rec.iva_exento,
                activo = p_materiales_rec.activo,
                id = p_materiales_rec.id,
                seccion_id = p_materiales_rec.seccion_id,
                creado_por = p_materiales_rec.creado_por,
                creado_el = p_materiales_rec.creado_el,
                modificado_por = p_materiales_rec.modificado_por,
                modificado_el = p_materiales_rec.modificado_el,
                cohorte_id = p_materiales_rec.cohorte_id
           WHERE  ROWID = p_materiales_rec.row_id;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd_rowid;

   PROCEDURE web_upd (
                  p_materiales_rec         IN materiales_rt,
                  p_ignore_nulls         IN boolean := FALSE
                )
   IS
      l_materiales_rec materiales_rt;
   BEGIN

      OPEN materiales_cur(
                             web_upd.p_materiales_rec.id
                        );

      FETCH materiales_cur INTO l_materiales_rec;

      IF materiales_cur%NOTFOUND THEN
         CLOSE materiales_cur;
         RAISE e_row_missing;
      ELSE
         IF p_materiales_rec.hash != l_materiales_rec.hash THEN
            CLOSE materiales_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(p_ignore_nulls, FALSE)
            THEN

                UPDATE   materiales
                   SET id_mat = NVL(p_materiales_rec.id_mat,id_mat),
                       tipo = NVL(p_materiales_rec.tipo,tipo),
                       descripcion = NVL(p_materiales_rec.descripcion,descripcion),
                       id_curso = NVL(p_materiales_rec.id_curso,id_curso),
                       evento = NVL(p_materiales_rec.evento,evento),
                       nivel = NVL(p_materiales_rec.nivel,nivel),
                       iva_exento = NVL(p_materiales_rec.iva_exento,iva_exento),
                       activo = NVL(p_materiales_rec.activo,activo),
                       id = NVL(p_materiales_rec.id,id),
                       seccion_id = NVL(p_materiales_rec.seccion_id,seccion_id),
                       creado_por = NVL(p_materiales_rec.creado_por,creado_por),
                       creado_el = NVL(p_materiales_rec.creado_el,creado_el),
                       modificado_por = NVL(p_materiales_rec.modificado_por,modificado_por),
                       modificado_el = NVL(p_materiales_rec.modificado_el,modificado_el),
                       cohorte_id = NVL(p_materiales_rec.cohorte_id,cohorte_id)
               WHERE CURRENT OF materiales_cur;
            ELSE
                UPDATE   materiales
                   SET id_mat = p_materiales_rec.id_mat,
                       tipo = p_materiales_rec.tipo,
                       descripcion = p_materiales_rec.descripcion,
                       id_curso = p_materiales_rec.id_curso,
                       evento = p_materiales_rec.evento,
                       nivel = p_materiales_rec.nivel,
                       iva_exento = p_materiales_rec.iva_exento,
                       activo = p_materiales_rec.activo,
                       id = p_materiales_rec.id,
                       seccion_id = p_materiales_rec.seccion_id,
                       creado_por = p_materiales_rec.creado_por,
                       creado_el = p_materiales_rec.creado_el,
                       modificado_por = p_materiales_rec.modificado_por,
                       modificado_el = p_materiales_rec.modificado_el,
                       cohorte_id = p_materiales_rec.cohorte_id
               WHERE CURRENT OF materiales_cur;
            END IF;

            CLOSE materiales_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd;

   PROCEDURE web_upd_rowid (
                            p_materiales_rec    IN materiales_rt,
                            p_ignore_nulls         IN boolean := FALSE
                           )
   IS
      l_materiales_rec materiales_rt;
   BEGIN

      OPEN materiales_rowid_cur(web_upd_rowid.p_materiales_rec.row_id);

      FETCH materiales_rowid_cur INTO l_materiales_rec;

      IF materiales_rowid_cur%NOTFOUND THEN
         CLOSE materiales_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_upd_rowid.p_materiales_rec.hash != l_materiales_rec.hash THEN
            CLOSE materiales_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(web_upd_rowid.p_ignore_nulls, FALSE)
            THEN
                UPDATE   materiales
                   SET id_mat = NVL(p_materiales_rec.id_mat,id_mat),
                       tipo = NVL(p_materiales_rec.tipo,tipo),
                       descripcion = NVL(p_materiales_rec.descripcion,descripcion),
                       id_curso = NVL(p_materiales_rec.id_curso,id_curso),
                       evento = NVL(p_materiales_rec.evento,evento),
                       nivel = NVL(p_materiales_rec.nivel,nivel),
                       iva_exento = NVL(p_materiales_rec.iva_exento,iva_exento),
                       activo = NVL(p_materiales_rec.activo,activo),
                       id = NVL(p_materiales_rec.id,id),
                       seccion_id = NVL(p_materiales_rec.seccion_id,seccion_id),
                       creado_por = NVL(p_materiales_rec.creado_por,creado_por),
                       creado_el = NVL(p_materiales_rec.creado_el,creado_el),
                       modificado_por = NVL(p_materiales_rec.modificado_por,modificado_por),
                       modificado_el = NVL(p_materiales_rec.modificado_el,modificado_el),
                       cohorte_id = NVL(p_materiales_rec.cohorte_id,cohorte_id)
               WHERE CURRENT OF materiales_rowid_cur;
            ELSE
                UPDATE   materiales
                   SET id_mat = p_materiales_rec.id_mat,
                       tipo = p_materiales_rec.tipo,
                       descripcion = p_materiales_rec.descripcion,
                       id_curso = p_materiales_rec.id_curso,
                       evento = p_materiales_rec.evento,
                       nivel = p_materiales_rec.nivel,
                       iva_exento = p_materiales_rec.iva_exento,
                       activo = p_materiales_rec.activo,
                       id = p_materiales_rec.id,
                       seccion_id = p_materiales_rec.seccion_id,
                       creado_por = p_materiales_rec.creado_por,
                       creado_el = p_materiales_rec.creado_el,
                       modificado_por = p_materiales_rec.modificado_por,
                       modificado_el = p_materiales_rec.modificado_el,
                       cohorte_id = p_materiales_rec.cohorte_id
               WHERE CURRENT OF materiales_rowid_cur;
            END IF;

            CLOSE materiales_rowid_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd_rowid;

    PROCEDURE del (
                  p_id IN materiales.id%TYPE
                  )
    IS
    BEGIN

       DELETE FROM   materiales
             WHERE
                  id = del.p_id
                   ;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del;

    PROCEDURE del_rowid (p_rowid IN varchar2)
    IS
    BEGIN

       DELETE FROM   materiales
             WHERE   ROWID = del_rowid.p_rowid;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del_rowid;

    PROCEDURE web_del (
                      p_id IN materiales.id%TYPE,
                      p_hash IN varchar2
                      )
   IS
      l_materiales_rec materiales_rt;
   BEGIN


      OPEN materiales_cur(
                            web_del.p_id
                            );

      FETCH materiales_cur INTO l_materiales_rec;

      IF materiales_cur%NOTFOUND THEN
         CLOSE materiales_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del.p_hash != l_materiales_rec.hash THEN
            CLOSE materiales_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM materiales
            WHERE CURRENT OF materiales_cur;

            CLOSE materiales_cur;
         END IF;
      END IF;



   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del;

   PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2)
   IS
      l_materiales_rec materiales_rt;
   BEGIN


      OPEN materiales_rowid_cur(web_del_rowid.p_rowid);

      FETCH materiales_rowid_cur INTO l_materiales_rec;

      IF materiales_rowid_cur%NOTFOUND THEN
         CLOSE materiales_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del_rowid.p_hash != l_materiales_rec.hash THEN
            CLOSE materiales_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM materiales
            WHERE CURRENT OF materiales_rowid_cur;

            CLOSE materiales_rowid_cur;
         END IF;
      END IF;

   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del_rowid;

END tapi_materiales;

 

/
--------------------------------------------------------
--  DDL for Package Body TAPI_PRECIOS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."TAPI_PRECIOS" IS

   /**
   * TAPI_PRECIOS
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: 25-FEB-2020 17:08
   * Created By: FUNDAUC
   */


   --GLOBAL_PRIVATE_CURSORS
   --By PK
   CURSOR precios_cur (
                       p_id IN precios.id%TYPE
                       )
   IS
      SELECT
            tipo_item,
            fecha,
            precio1,
            precio2,
            precio3,
            status,
            precio4,
            precio5,
            id,
            tapi_precios.hash(id),
            ROWID
      FROM precios
      WHERE
           id = precios_cur.p_id
      FOR UPDATE;

    --By Rowid
    CURSOR precios_rowid_cur (p_rowid IN VARCHAR2)
    IS
      SELECT
             tipo_item,
             fecha,
             precio1,
             precio2,
             precio3,
             status,
             precio4,
             precio5,
             id,
             tapi_precios.hash(id),
             ROWID
      FROM precios
      WHERE ROWID = p_rowid
      FOR UPDATE;


    FUNCTION hash (
                  p_id IN precios.id%TYPE
                  )
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format VARCHAR2(64);
   BEGIN


     --Get actual NLS_DATE_FORMAT
     SELECT   VALUE
       INTO   l_date_format
       FROM   v$nls_parameters
      WHERE   parameter = 'NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            tipo_item||
            fecha||
            precio1||
            precio2||
            precio3||
            status||
            precio4||
            precio5||
            id
      INTO l_string
      FROM precios
      WHERE
           id = hash.p_id
           ;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash;

    FUNCTION hash_rowid (p_rowid IN varchar2)
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format varchar2(64);
   BEGIN

      --Get actual NLS_DATE_FORMAT
      SELECT VALUE INTO l_date_format  FROM v$nls_parameters WHERE parameter ='NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            tipo_item||
            fecha||
            precio1||
            precio2||
            precio3||
            status||
            precio4||
            precio5||
            id
      INTO l_string
      FROM precios
      WHERE  ROWID = hash_rowid.p_rowid;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash_rowid;

   FUNCTION rt (
               p_id IN precios.id%TYPE
               )
      RETURN precios_rt RESULT_CACHE
   IS
      l_precios_rec precios_rt;
   BEGIN

      SELECT a.*,
             tapi_precios.hash(id),
             rowid
      INTO l_precios_rec
      FROM precios a
      WHERE
           id = rt.p_id
           ;


      RETURN l_precios_rec;

   END rt;

   FUNCTION rt_for_update (
                          p_id IN precios.id%TYPE
                          )
      RETURN precios_rt RESULT_CACHE
   IS
      l_precios_rec precios_rt;
   BEGIN


      SELECT a.*,
             tapi_precios.hash(id),
             rowid
      INTO l_precios_rec
      FROM precios a
      WHERE
           id = rt_for_update.p_id
      FOR UPDATE;


      RETURN l_precios_rec;

   END rt_for_update;

    FUNCTION tt (
                p_id IN precios.id%TYPE DEFAULT NULL
                )
       RETURN precios_tt
       PIPELINED
    IS
       l_precios_rec   precios_rt;
    BEGIN

       FOR c1 IN (SELECT   a.*, ROWID
                    FROM   precios a
                   WHERE
                        id = NVL(tt.p_id,id)
                        )
       LOOP
              l_precios_rec.tipo_item := c1.tipo_item;
              l_precios_rec.fecha := c1.fecha;
              l_precios_rec.precio1 := c1.precio1;
              l_precios_rec.precio2 := c1.precio2;
              l_precios_rec.precio3 := c1.precio3;
              l_precios_rec.status := c1.status;
              l_precios_rec.precio4 := c1.precio4;
              l_precios_rec.precio5 := c1.precio5;
              l_precios_rec.id := c1.id;
              l_precios_rec.hash := tapi_precios.hash( c1.id);
              l_precios_rec.row_id := c1.ROWID;
              PIPE ROW (l_precios_rec);
       END LOOP;

       RETURN;

    END tt;


    PROCEDURE ins (p_precios_rec IN OUT precios_rt)
    IS
        l_rowtype     precios%ROWTYPE;

    BEGIN


        l_rowtype.tipo_item := ins.p_precios_rec.tipo_item;
        l_rowtype.fecha := ins.p_precios_rec.fecha;
        l_rowtype.precio1 := ins.p_precios_rec.precio1;
        l_rowtype.precio2 := ins.p_precios_rec.precio2;
        l_rowtype.precio3 := ins.p_precios_rec.precio3;
        l_rowtype.status := ins.p_precios_rec.status;
        l_rowtype.precio4 := ins.p_precios_rec.precio4;
        l_rowtype.precio5 := ins.p_precios_rec.precio5;
        l_rowtype.id := ins.p_precios_rec.id;

       INSERT INTO precios
          VALUES   l_rowtype
       RETURNING
                   tipo_item ,
                   fecha ,
                   precio1 ,
                   precio2 ,
                   precio3 ,
                   status ,
                   precio4 ,
                   precio5 ,
                   id 
            INTO   l_rowtype;

         ins.p_precios_rec.tipo_item := l_rowtype.tipo_item;
         ins.p_precios_rec.fecha := l_rowtype.fecha;
         ins.p_precios_rec.precio1 := l_rowtype.precio1;
         ins.p_precios_rec.precio2 := l_rowtype.precio2;
         ins.p_precios_rec.precio3 := l_rowtype.precio3;
         ins.p_precios_rec.status := l_rowtype.status;
         ins.p_precios_rec.precio4 := l_rowtype.precio4;
         ins.p_precios_rec.precio5 := l_rowtype.precio5;
         ins.p_precios_rec.id := l_rowtype.id;



    END ins;

    PROCEDURE upd (
                  p_precios_rec         IN precios_rt,
                  p_ignore_nulls         IN boolean := FALSE
                  )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   precios
             SET tipo_item = NVL(p_precios_rec.tipo_item,tipo_item),
                fecha = NVL(p_precios_rec.fecha,fecha),
                precio1 = NVL(p_precios_rec.precio1,precio1),
                precio2 = NVL(p_precios_rec.precio2,precio2),
                precio3 = NVL(p_precios_rec.precio3,precio3),
                status = NVL(p_precios_rec.status,status),
                precio4 = NVL(p_precios_rec.precio4,precio4),
                precio5 = NVL(p_precios_rec.precio5,precio5),
                id = NVL(p_precios_rec.id,id)
           WHERE
                id = upd.p_precios_rec.id
                ;
       ELSE
          UPDATE   precios
             SET tipo_item = p_precios_rec.tipo_item,
                fecha = p_precios_rec.fecha,
                precio1 = p_precios_rec.precio1,
                precio2 = p_precios_rec.precio2,
                precio3 = p_precios_rec.precio3,
                status = p_precios_rec.status,
                precio4 = p_precios_rec.precio4,
                precio5 = p_precios_rec.precio5,
                id = p_precios_rec.id
           WHERE
                id = upd.p_precios_rec.id
                ;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd;


    PROCEDURE upd_rowid (
                         p_precios_rec         IN precios_rt,
                         p_ignore_nulls         IN boolean := FALSE
                        )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   precios
             SET tipo_item = NVL(p_precios_rec.tipo_item,tipo_item),
                fecha = NVL(p_precios_rec.fecha,fecha),
                precio1 = NVL(p_precios_rec.precio1,precio1),
                precio2 = NVL(p_precios_rec.precio2,precio2),
                precio3 = NVL(p_precios_rec.precio3,precio3),
                status = NVL(p_precios_rec.status,status),
                precio4 = NVL(p_precios_rec.precio4,precio4),
                precio5 = NVL(p_precios_rec.precio5,precio5),
                id = NVL(p_precios_rec.id,id)
           WHERE  ROWID = p_precios_rec.row_id;
       ELSE
          UPDATE   precios
             SET tipo_item = p_precios_rec.tipo_item,
                fecha = p_precios_rec.fecha,
                precio1 = p_precios_rec.precio1,
                precio2 = p_precios_rec.precio2,
                precio3 = p_precios_rec.precio3,
                status = p_precios_rec.status,
                precio4 = p_precios_rec.precio4,
                precio5 = p_precios_rec.precio5,
                id = p_precios_rec.id
           WHERE  ROWID = p_precios_rec.row_id;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd_rowid;

   PROCEDURE web_upd (
                  p_precios_rec         IN precios_rt,
                  p_ignore_nulls         IN boolean := FALSE
                )
   IS
      l_precios_rec precios_rt;
   BEGIN

      OPEN precios_cur(
                             web_upd.p_precios_rec.id
                        );

      FETCH precios_cur INTO l_precios_rec;

      IF precios_cur%NOTFOUND THEN
         CLOSE precios_cur;
         RAISE e_row_missing;
      ELSE
         IF p_precios_rec.hash != l_precios_rec.hash THEN
            CLOSE precios_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(p_ignore_nulls, FALSE)
            THEN

                UPDATE   precios
                   SET tipo_item = NVL(p_precios_rec.tipo_item,tipo_item),
                       fecha = NVL(p_precios_rec.fecha,fecha),
                       precio1 = NVL(p_precios_rec.precio1,precio1),
                       precio2 = NVL(p_precios_rec.precio2,precio2),
                       precio3 = NVL(p_precios_rec.precio3,precio3),
                       status = NVL(p_precios_rec.status,status),
                       precio4 = NVL(p_precios_rec.precio4,precio4),
                       precio5 = NVL(p_precios_rec.precio5,precio5),
                       id = NVL(p_precios_rec.id,id)
               WHERE CURRENT OF precios_cur;
            ELSE
                UPDATE   precios
                   SET tipo_item = p_precios_rec.tipo_item,
                       fecha = p_precios_rec.fecha,
                       precio1 = p_precios_rec.precio1,
                       precio2 = p_precios_rec.precio2,
                       precio3 = p_precios_rec.precio3,
                       status = p_precios_rec.status,
                       precio4 = p_precios_rec.precio4,
                       precio5 = p_precios_rec.precio5,
                       id = p_precios_rec.id
               WHERE CURRENT OF precios_cur;
            END IF;

            CLOSE precios_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd;

   PROCEDURE web_upd_rowid (
                            p_precios_rec    IN precios_rt,
                            p_ignore_nulls         IN boolean := FALSE
                           )
   IS
      l_precios_rec precios_rt;
   BEGIN

      OPEN precios_rowid_cur(web_upd_rowid.p_precios_rec.row_id);

      FETCH precios_rowid_cur INTO l_precios_rec;

      IF precios_rowid_cur%NOTFOUND THEN
         CLOSE precios_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_upd_rowid.p_precios_rec.hash != l_precios_rec.hash THEN
            CLOSE precios_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(web_upd_rowid.p_ignore_nulls, FALSE)
            THEN
                UPDATE   precios
                   SET tipo_item = NVL(p_precios_rec.tipo_item,tipo_item),
                       fecha = NVL(p_precios_rec.fecha,fecha),
                       precio1 = NVL(p_precios_rec.precio1,precio1),
                       precio2 = NVL(p_precios_rec.precio2,precio2),
                       precio3 = NVL(p_precios_rec.precio3,precio3),
                       status = NVL(p_precios_rec.status,status),
                       precio4 = NVL(p_precios_rec.precio4,precio4),
                       precio5 = NVL(p_precios_rec.precio5,precio5),
                       id = NVL(p_precios_rec.id,id)
               WHERE CURRENT OF precios_rowid_cur;
            ELSE
                UPDATE   precios
                   SET tipo_item = p_precios_rec.tipo_item,
                       fecha = p_precios_rec.fecha,
                       precio1 = p_precios_rec.precio1,
                       precio2 = p_precios_rec.precio2,
                       precio3 = p_precios_rec.precio3,
                       status = p_precios_rec.status,
                       precio4 = p_precios_rec.precio4,
                       precio5 = p_precios_rec.precio5,
                       id = p_precios_rec.id
               WHERE CURRENT OF precios_rowid_cur;
            END IF;

            CLOSE precios_rowid_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd_rowid;

    PROCEDURE del (
                  p_id IN precios.id%TYPE
                  )
    IS
    BEGIN

       DELETE FROM   precios
             WHERE
                  id = del.p_id
                   ;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del;

    PROCEDURE del_rowid (p_rowid IN varchar2)
    IS
    BEGIN

       DELETE FROM   precios
             WHERE   ROWID = del_rowid.p_rowid;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del_rowid;

    PROCEDURE web_del (
                      p_id IN precios.id%TYPE,
                      p_hash IN varchar2
                      )
   IS
      l_precios_rec precios_rt;
   BEGIN


      OPEN precios_cur(
                            web_del.p_id
                            );

      FETCH precios_cur INTO l_precios_rec;

      IF precios_cur%NOTFOUND THEN
         CLOSE precios_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del.p_hash != l_precios_rec.hash THEN
            CLOSE precios_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM precios
            WHERE CURRENT OF precios_cur;

            CLOSE precios_cur;
         END IF;
      END IF;



   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del;

   PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2)
   IS
      l_precios_rec precios_rt;
   BEGIN


      OPEN precios_rowid_cur(web_del_rowid.p_rowid);

      FETCH precios_rowid_cur INTO l_precios_rec;

      IF precios_rowid_cur%NOTFOUND THEN
         CLOSE precios_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del_rowid.p_hash != l_precios_rec.hash THEN
            CLOSE precios_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM precios
            WHERE CURRENT OF precios_rowid_cur;

            CLOSE precios_rowid_cur;
         END IF;
      END IF;

   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del_rowid;

END tapi_precios;

 

/
--------------------------------------------------------
--  DDL for Package Body TAPI_SECCIONES
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."TAPI_SECCIONES" IS

   /**
   * TAPI_SECCIONES
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: 01-OCT-2019 11:06
   * Created By: FUNDAUC
   */


   --GLOBAL_PRIVATE_CURSORS
   --By PK
   CURSOR secciones_cur (
                       p_id IN secciones.id%TYPE
                       )
   IS
      SELECT
            id_seccion,
            id_metodo,
            nivel,
            id_salon,
            tope,
            status,
            id_edif,
            horario,
            cedula_prof,
            modalidad,
            fec_inicio,
            periodo,
            id_horario,
            id_calendario,
            id,
            creado_por,
            creado_el,
            modificado_por,
            modificado_el,
            tapi_secciones.hash(id),
            ROWID
      FROM secciones
      WHERE
           id = secciones_cur.p_id
      FOR UPDATE;

    --By Rowid
    CURSOR secciones_rowid_cur (p_rowid IN VARCHAR2)
    IS
      SELECT
             id_seccion,
             id_metodo,
             nivel,
             id_salon,
             tope,
             status,
             id_edif,
             horario,
             cedula_prof,
             modalidad,
             fec_inicio,
             periodo,
             id_horario,
             id_calendario,
             id,
             creado_por,
             creado_el,
             modificado_por,
             modificado_el,
             tapi_secciones.hash(id),
             ROWID
      FROM secciones
      WHERE ROWID = p_rowid
      FOR UPDATE;


    FUNCTION hash (
                  p_id IN secciones.id%TYPE
                  )
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format VARCHAR2(64);
   BEGIN


     --Get actual NLS_DATE_FORMAT
     SELECT   VALUE
       INTO   l_date_format
       FROM   v$nls_parameters
      WHERE   parameter = 'NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            id_seccion||
            id_metodo||
            nivel||
            id_salon||
            tope||
            status||
            id_edif||
            horario||
            cedula_prof||
            modalidad||
            fec_inicio||
            periodo||
            id_horario||
            id_calendario||
            id||
            creado_por||
            creado_el||
            modificado_por||
            modificado_el
      INTO l_string
      FROM secciones
      WHERE
           id = hash.p_id
           ;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash;

    FUNCTION hash_rowid (p_rowid IN varchar2)
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format varchar2(64);
   BEGIN

      --Get actual NLS_DATE_FORMAT
      SELECT VALUE INTO l_date_format  FROM v$nls_parameters WHERE parameter ='NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            id_seccion||
            id_metodo||
            nivel||
            id_salon||
            tope||
            status||
            id_edif||
            horario||
            cedula_prof||
            modalidad||
            fec_inicio||
            periodo||
            id_horario||
            id_calendario||
            id||
            creado_por||
            creado_el||
            modificado_por||
            modificado_el
      INTO l_string
      FROM secciones
      WHERE  ROWID = hash_rowid.p_rowid;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash_rowid;

   FUNCTION rt (
               p_id IN secciones.id%TYPE
               )
      RETURN secciones_rt RESULT_CACHE
   IS
      l_secciones_rec secciones_rt;
   BEGIN

      SELECT a.*,
             tapi_secciones.hash(id),
             rowid
      INTO l_secciones_rec
      FROM secciones a
      WHERE
           id = rt.p_id
           ;


      RETURN l_secciones_rec;

   END rt;

   FUNCTION rt_for_update (
                          p_id IN secciones.id%TYPE
                          )
      RETURN secciones_rt RESULT_CACHE
   IS
      l_secciones_rec secciones_rt;
   BEGIN


      SELECT a.*,
             tapi_secciones.hash(id),
             rowid
      INTO l_secciones_rec
      FROM secciones a
      WHERE
           id = rt_for_update.p_id
      FOR UPDATE;


      RETURN l_secciones_rec;

   END rt_for_update;

    FUNCTION tt (
                p_id IN secciones.id%TYPE DEFAULT NULL
                )
       RETURN secciones_tt
       PIPELINED
    IS
       l_secciones_rec   secciones_rt;
    BEGIN

       FOR c1 IN (SELECT   a.*, ROWID
                    FROM   secciones a
                   WHERE
                        id = NVL(tt.p_id,id)
                        )
       LOOP
              l_secciones_rec.id_seccion := c1.id_seccion;
              l_secciones_rec.id_metodo := c1.id_metodo;
              l_secciones_rec.nivel := c1.nivel;
              l_secciones_rec.id_salon := c1.id_salon;
              l_secciones_rec.tope := c1.tope;
              l_secciones_rec.status := c1.status;
              l_secciones_rec.id_edif := c1.id_edif;
              l_secciones_rec.horario := c1.horario;
              l_secciones_rec.cedula_prof := c1.cedula_prof;
              l_secciones_rec.modalidad := c1.modalidad;
              l_secciones_rec.fec_inicio := c1.fec_inicio;
              l_secciones_rec.periodo := c1.periodo;
              l_secciones_rec.id_horario := c1.id_horario;
              l_secciones_rec.id_calendario := c1.id_calendario;
              l_secciones_rec.id := c1.id;
              l_secciones_rec.creado_por := c1.creado_por;
              l_secciones_rec.creado_el := c1.creado_el;
              l_secciones_rec.modificado_por := c1.modificado_por;
              l_secciones_rec.modificado_el := c1.modificado_el;
              l_secciones_rec.hash := tapi_secciones.hash( c1.id);
              l_secciones_rec.row_id := c1.ROWID;
              PIPE ROW (l_secciones_rec);
       END LOOP;

       RETURN;

    END tt;


    PROCEDURE ins (p_secciones_rec IN OUT secciones_rt)
    IS
        l_rowtype     secciones%ROWTYPE;

    BEGIN


        l_rowtype.id_seccion := ins.p_secciones_rec.id_seccion;
        l_rowtype.id_metodo := ins.p_secciones_rec.id_metodo;
        l_rowtype.nivel := ins.p_secciones_rec.nivel;
        l_rowtype.id_salon := ins.p_secciones_rec.id_salon;
        l_rowtype.tope := ins.p_secciones_rec.tope;
        l_rowtype.status := ins.p_secciones_rec.status;
        l_rowtype.id_edif := ins.p_secciones_rec.id_edif;
        l_rowtype.horario := ins.p_secciones_rec.horario;
        l_rowtype.cedula_prof := ins.p_secciones_rec.cedula_prof;
        l_rowtype.modalidad := ins.p_secciones_rec.modalidad;
        l_rowtype.fec_inicio := ins.p_secciones_rec.fec_inicio;
        l_rowtype.periodo := ins.p_secciones_rec.periodo;
        l_rowtype.id_horario := ins.p_secciones_rec.id_horario;
        l_rowtype.id_calendario := ins.p_secciones_rec.id_calendario;
        l_rowtype.id := ins.p_secciones_rec.id;
        l_rowtype.creado_por := ins.p_secciones_rec.creado_por;
        l_rowtype.creado_el := ins.p_secciones_rec.creado_el;
        l_rowtype.modificado_por := ins.p_secciones_rec.modificado_por;
        l_rowtype.modificado_el := ins.p_secciones_rec.modificado_el;

       INSERT INTO secciones
          VALUES   l_rowtype
       RETURNING
                   id_seccion ,
                   id_metodo ,
                   nivel ,
                   id_salon ,
                   tope ,
                   status ,
                   id_edif ,
                   horario ,
                   cedula_prof ,
                   modalidad ,
                   fec_inicio ,
                   periodo ,
                   id_horario ,
                   id_calendario ,
                   id ,
                   creado_por ,
                   creado_el ,
                   modificado_por ,
                   modificado_el 
            INTO   l_rowtype;

         ins.p_secciones_rec.id_seccion := l_rowtype.id_seccion;
         ins.p_secciones_rec.id_metodo := l_rowtype.id_metodo;
         ins.p_secciones_rec.nivel := l_rowtype.nivel;
         ins.p_secciones_rec.id_salon := l_rowtype.id_salon;
         ins.p_secciones_rec.tope := l_rowtype.tope;
         ins.p_secciones_rec.status := l_rowtype.status;
         ins.p_secciones_rec.id_edif := l_rowtype.id_edif;
         ins.p_secciones_rec.horario := l_rowtype.horario;
         ins.p_secciones_rec.cedula_prof := l_rowtype.cedula_prof;
         ins.p_secciones_rec.modalidad := l_rowtype.modalidad;
         ins.p_secciones_rec.fec_inicio := l_rowtype.fec_inicio;
         ins.p_secciones_rec.periodo := l_rowtype.periodo;
         ins.p_secciones_rec.id_horario := l_rowtype.id_horario;
         ins.p_secciones_rec.id_calendario := l_rowtype.id_calendario;
         ins.p_secciones_rec.id := l_rowtype.id;
         ins.p_secciones_rec.creado_por := l_rowtype.creado_por;
         ins.p_secciones_rec.creado_el := l_rowtype.creado_el;
         ins.p_secciones_rec.modificado_por := l_rowtype.modificado_por;
         ins.p_secciones_rec.modificado_el := l_rowtype.modificado_el;



    END ins;

    PROCEDURE upd (
                  p_secciones_rec         IN secciones_rt,
                  p_ignore_nulls         IN boolean := FALSE
                  )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   secciones
             SET id_seccion = NVL(p_secciones_rec.id_seccion,id_seccion),
                id_metodo = NVL(p_secciones_rec.id_metodo,id_metodo),
                nivel = NVL(p_secciones_rec.nivel,nivel),
                id_salon = NVL(p_secciones_rec.id_salon,id_salon),
                tope = NVL(p_secciones_rec.tope,tope),
                status = NVL(p_secciones_rec.status,status),
                id_edif = NVL(p_secciones_rec.id_edif,id_edif),
                horario = NVL(p_secciones_rec.horario,horario),
                cedula_prof = NVL(p_secciones_rec.cedula_prof,cedula_prof),
                modalidad = NVL(p_secciones_rec.modalidad,modalidad),
                fec_inicio = NVL(p_secciones_rec.fec_inicio,fec_inicio),
                periodo = NVL(p_secciones_rec.periodo,periodo),
                id_horario = NVL(p_secciones_rec.id_horario,id_horario),
                id_calendario = NVL(p_secciones_rec.id_calendario,id_calendario),
                id = NVL(p_secciones_rec.id,id),
                creado_por = NVL(p_secciones_rec.creado_por,creado_por),
                creado_el = NVL(p_secciones_rec.creado_el,creado_el),
                modificado_por = NVL(p_secciones_rec.modificado_por,modificado_por),
                modificado_el = NVL(p_secciones_rec.modificado_el,modificado_el)
           WHERE
                id = upd.p_secciones_rec.id
                ;
       ELSE
          UPDATE   secciones
             SET id_seccion = p_secciones_rec.id_seccion,
                id_metodo = p_secciones_rec.id_metodo,
                nivel = p_secciones_rec.nivel,
                id_salon = p_secciones_rec.id_salon,
                tope = p_secciones_rec.tope,
                status = p_secciones_rec.status,
                id_edif = p_secciones_rec.id_edif,
                horario = p_secciones_rec.horario,
                cedula_prof = p_secciones_rec.cedula_prof,
                modalidad = p_secciones_rec.modalidad,
                fec_inicio = p_secciones_rec.fec_inicio,
                periodo = p_secciones_rec.periodo,
                id_horario = p_secciones_rec.id_horario,
                id_calendario = p_secciones_rec.id_calendario,
                id = p_secciones_rec.id,
                creado_por = p_secciones_rec.creado_por,
                creado_el = p_secciones_rec.creado_el,
                modificado_por = p_secciones_rec.modificado_por,
                modificado_el = p_secciones_rec.modificado_el
           WHERE
                id = upd.p_secciones_rec.id
                ;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd;


    PROCEDURE upd_rowid (
                         p_secciones_rec         IN secciones_rt,
                         p_ignore_nulls         IN boolean := FALSE
                        )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   secciones
             SET id_seccion = NVL(p_secciones_rec.id_seccion,id_seccion),
                id_metodo = NVL(p_secciones_rec.id_metodo,id_metodo),
                nivel = NVL(p_secciones_rec.nivel,nivel),
                id_salon = NVL(p_secciones_rec.id_salon,id_salon),
                tope = NVL(p_secciones_rec.tope,tope),
                status = NVL(p_secciones_rec.status,status),
                id_edif = NVL(p_secciones_rec.id_edif,id_edif),
                horario = NVL(p_secciones_rec.horario,horario),
                cedula_prof = NVL(p_secciones_rec.cedula_prof,cedula_prof),
                modalidad = NVL(p_secciones_rec.modalidad,modalidad),
                fec_inicio = NVL(p_secciones_rec.fec_inicio,fec_inicio),
                periodo = NVL(p_secciones_rec.periodo,periodo),
                id_horario = NVL(p_secciones_rec.id_horario,id_horario),
                id_calendario = NVL(p_secciones_rec.id_calendario,id_calendario),
                id = NVL(p_secciones_rec.id,id),
                creado_por = NVL(p_secciones_rec.creado_por,creado_por),
                creado_el = NVL(p_secciones_rec.creado_el,creado_el),
                modificado_por = NVL(p_secciones_rec.modificado_por,modificado_por),
                modificado_el = NVL(p_secciones_rec.modificado_el,modificado_el)
           WHERE  ROWID = p_secciones_rec.row_id;
       ELSE
          UPDATE   secciones
             SET id_seccion = p_secciones_rec.id_seccion,
                id_metodo = p_secciones_rec.id_metodo,
                nivel = p_secciones_rec.nivel,
                id_salon = p_secciones_rec.id_salon,
                tope = p_secciones_rec.tope,
                status = p_secciones_rec.status,
                id_edif = p_secciones_rec.id_edif,
                horario = p_secciones_rec.horario,
                cedula_prof = p_secciones_rec.cedula_prof,
                modalidad = p_secciones_rec.modalidad,
                fec_inicio = p_secciones_rec.fec_inicio,
                periodo = p_secciones_rec.periodo,
                id_horario = p_secciones_rec.id_horario,
                id_calendario = p_secciones_rec.id_calendario,
                id = p_secciones_rec.id,
                creado_por = p_secciones_rec.creado_por,
                creado_el = p_secciones_rec.creado_el,
                modificado_por = p_secciones_rec.modificado_por,
                modificado_el = p_secciones_rec.modificado_el
           WHERE  ROWID = p_secciones_rec.row_id;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd_rowid;

   PROCEDURE web_upd (
                  p_secciones_rec         IN secciones_rt,
                  p_ignore_nulls         IN boolean := FALSE
                )
   IS
      l_secciones_rec secciones_rt;
   BEGIN

      OPEN secciones_cur(
                             web_upd.p_secciones_rec.id
                        );

      FETCH secciones_cur INTO l_secciones_rec;

      IF secciones_cur%NOTFOUND THEN
         CLOSE secciones_cur;
         RAISE e_row_missing;
      ELSE
         IF p_secciones_rec.hash != l_secciones_rec.hash THEN
            CLOSE secciones_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(p_ignore_nulls, FALSE)
            THEN

                UPDATE   secciones
                   SET id_seccion = NVL(p_secciones_rec.id_seccion,id_seccion),
                       id_metodo = NVL(p_secciones_rec.id_metodo,id_metodo),
                       nivel = NVL(p_secciones_rec.nivel,nivel),
                       id_salon = NVL(p_secciones_rec.id_salon,id_salon),
                       tope = NVL(p_secciones_rec.tope,tope),
                       status = NVL(p_secciones_rec.status,status),
                       id_edif = NVL(p_secciones_rec.id_edif,id_edif),
                       horario = NVL(p_secciones_rec.horario,horario),
                       cedula_prof = NVL(p_secciones_rec.cedula_prof,cedula_prof),
                       modalidad = NVL(p_secciones_rec.modalidad,modalidad),
                       fec_inicio = NVL(p_secciones_rec.fec_inicio,fec_inicio),
                       periodo = NVL(p_secciones_rec.periodo,periodo),
                       id_horario = NVL(p_secciones_rec.id_horario,id_horario),
                       id_calendario = NVL(p_secciones_rec.id_calendario,id_calendario),
                       id = NVL(p_secciones_rec.id,id),
                       creado_por = NVL(p_secciones_rec.creado_por,creado_por),
                       creado_el = NVL(p_secciones_rec.creado_el,creado_el),
                       modificado_por = NVL(p_secciones_rec.modificado_por,modificado_por),
                       modificado_el = NVL(p_secciones_rec.modificado_el,modificado_el)
               WHERE CURRENT OF secciones_cur;
            ELSE
                UPDATE   secciones
                   SET id_seccion = p_secciones_rec.id_seccion,
                       id_metodo = p_secciones_rec.id_metodo,
                       nivel = p_secciones_rec.nivel,
                       id_salon = p_secciones_rec.id_salon,
                       tope = p_secciones_rec.tope,
                       status = p_secciones_rec.status,
                       id_edif = p_secciones_rec.id_edif,
                       horario = p_secciones_rec.horario,
                       cedula_prof = p_secciones_rec.cedula_prof,
                       modalidad = p_secciones_rec.modalidad,
                       fec_inicio = p_secciones_rec.fec_inicio,
                       periodo = p_secciones_rec.periodo,
                       id_horario = p_secciones_rec.id_horario,
                       id_calendario = p_secciones_rec.id_calendario,
                       id = p_secciones_rec.id,
                       creado_por = p_secciones_rec.creado_por,
                       creado_el = p_secciones_rec.creado_el,
                       modificado_por = p_secciones_rec.modificado_por,
                       modificado_el = p_secciones_rec.modificado_el
               WHERE CURRENT OF secciones_cur;
            END IF;

            CLOSE secciones_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd;

   PROCEDURE web_upd_rowid (
                            p_secciones_rec    IN secciones_rt,
                            p_ignore_nulls         IN boolean := FALSE
                           )
   IS
      l_secciones_rec secciones_rt;
   BEGIN

      OPEN secciones_rowid_cur(web_upd_rowid.p_secciones_rec.row_id);

      FETCH secciones_rowid_cur INTO l_secciones_rec;

      IF secciones_rowid_cur%NOTFOUND THEN
         CLOSE secciones_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_upd_rowid.p_secciones_rec.hash != l_secciones_rec.hash THEN
            CLOSE secciones_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(web_upd_rowid.p_ignore_nulls, FALSE)
            THEN
                UPDATE   secciones
                   SET id_seccion = NVL(p_secciones_rec.id_seccion,id_seccion),
                       id_metodo = NVL(p_secciones_rec.id_metodo,id_metodo),
                       nivel = NVL(p_secciones_rec.nivel,nivel),
                       id_salon = NVL(p_secciones_rec.id_salon,id_salon),
                       tope = NVL(p_secciones_rec.tope,tope),
                       status = NVL(p_secciones_rec.status,status),
                       id_edif = NVL(p_secciones_rec.id_edif,id_edif),
                       horario = NVL(p_secciones_rec.horario,horario),
                       cedula_prof = NVL(p_secciones_rec.cedula_prof,cedula_prof),
                       modalidad = NVL(p_secciones_rec.modalidad,modalidad),
                       fec_inicio = NVL(p_secciones_rec.fec_inicio,fec_inicio),
                       periodo = NVL(p_secciones_rec.periodo,periodo),
                       id_horario = NVL(p_secciones_rec.id_horario,id_horario),
                       id_calendario = NVL(p_secciones_rec.id_calendario,id_calendario),
                       id = NVL(p_secciones_rec.id,id),
                       creado_por = NVL(p_secciones_rec.creado_por,creado_por),
                       creado_el = NVL(p_secciones_rec.creado_el,creado_el),
                       modificado_por = NVL(p_secciones_rec.modificado_por,modificado_por),
                       modificado_el = NVL(p_secciones_rec.modificado_el,modificado_el)
               WHERE CURRENT OF secciones_rowid_cur;
            ELSE
                UPDATE   secciones
                   SET id_seccion = p_secciones_rec.id_seccion,
                       id_metodo = p_secciones_rec.id_metodo,
                       nivel = p_secciones_rec.nivel,
                       id_salon = p_secciones_rec.id_salon,
                       tope = p_secciones_rec.tope,
                       status = p_secciones_rec.status,
                       id_edif = p_secciones_rec.id_edif,
                       horario = p_secciones_rec.horario,
                       cedula_prof = p_secciones_rec.cedula_prof,
                       modalidad = p_secciones_rec.modalidad,
                       fec_inicio = p_secciones_rec.fec_inicio,
                       periodo = p_secciones_rec.periodo,
                       id_horario = p_secciones_rec.id_horario,
                       id_calendario = p_secciones_rec.id_calendario,
                       id = p_secciones_rec.id,
                       creado_por = p_secciones_rec.creado_por,
                       creado_el = p_secciones_rec.creado_el,
                       modificado_por = p_secciones_rec.modificado_por,
                       modificado_el = p_secciones_rec.modificado_el
               WHERE CURRENT OF secciones_rowid_cur;
            END IF;

            CLOSE secciones_rowid_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd_rowid;

    PROCEDURE del (
                  p_id IN secciones.id%TYPE
                  )
    IS
    BEGIN

       DELETE FROM   secciones
             WHERE
                  id = del.p_id
                   ;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del;

    PROCEDURE del_rowid (p_rowid IN varchar2)
    IS
    BEGIN

       DELETE FROM   secciones
             WHERE   ROWID = del_rowid.p_rowid;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del_rowid;

    PROCEDURE web_del (
                      p_id IN secciones.id%TYPE,
                      p_hash IN varchar2
                      )
   IS
      l_secciones_rec secciones_rt;
   BEGIN


      OPEN secciones_cur(
                            web_del.p_id
                            );

      FETCH secciones_cur INTO l_secciones_rec;

      IF secciones_cur%NOTFOUND THEN
         CLOSE secciones_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del.p_hash != l_secciones_rec.hash THEN
            CLOSE secciones_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM secciones
            WHERE CURRENT OF secciones_cur;

            CLOSE secciones_cur;
         END IF;
      END IF;



   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del;

   PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2)
   IS
      l_secciones_rec secciones_rt;
   BEGIN


      OPEN secciones_rowid_cur(web_del_rowid.p_rowid);

      FETCH secciones_rowid_cur INTO l_secciones_rec;

      IF secciones_rowid_cur%NOTFOUND THEN
         CLOSE secciones_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del_rowid.p_hash != l_secciones_rec.hash THEN
            CLOSE secciones_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM secciones
            WHERE CURRENT OF secciones_rowid_cur;

            CLOSE secciones_rowid_cur;
         END IF;
      END IF;

   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del_rowid;

END tapi_secciones;

 

/
--------------------------------------------------------
--  DDL for Package Body TAPI_USUARIOS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."TAPI_USUARIOS" IS

   /**
   * TAPI_USUARIOS
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: 18-AGO-2019 18:18
   * Created By: FUNDAUC
   */


   --GLOBAL_PRIVATE_CURSORS
   --By PK
   CURSOR usuarios_cur (
                       p_cedula IN usuarios.cedula%TYPE
                       )
   IS
      SELECT
            cedula,
            nombre_usuario,
            contrasena,
            id_rol,
            email,
            nombre,
            cia,
            prog_academico,
            activo,
            bloqueado,
            creado_por,
            creado_el,
            modificado_por,
            modificado_el,
            tapi_usuarios.hash(cedula),
            ROWID
      FROM usuarios
      WHERE
           cedula = usuarios_cur.p_cedula
      FOR UPDATE;

    --By Rowid
    CURSOR usuarios_rowid_cur (p_rowid IN VARCHAR2)
    IS
      SELECT
             cedula,
             nombre_usuario,
             contrasena,
             id_rol,
             email,
             nombre,
             cia,
             prog_academico,
             activo,
             bloqueado,
             creado_por,
             creado_el,
             modificado_por,
             modificado_el,
             tapi_usuarios.hash(cedula),
             ROWID
      FROM usuarios
      WHERE ROWID = p_rowid
      FOR UPDATE;


    FUNCTION hash (
                  p_cedula IN usuarios.cedula%TYPE
                  )
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format VARCHAR2(64);
   BEGIN


     --Get actual NLS_DATE_FORMAT
     SELECT   VALUE
       INTO   l_date_format
       FROM   v$nls_parameters
      WHERE   parameter = 'NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            cedula||
            nombre_usuario||
            contrasena||
            id_rol||
            email||
            nombre||
            cia||
            prog_academico||
            activo||
            bloqueado||
            creado_por||
            creado_el||
            modificado_por||
            modificado_el
      INTO l_string
      FROM usuarios
      WHERE
           cedula = hash.p_cedula
           ;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash;

    FUNCTION hash_rowid (p_rowid IN varchar2)
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format varchar2(64);
   BEGIN

      --Get actual NLS_DATE_FORMAT
      SELECT VALUE INTO l_date_format  FROM v$nls_parameters WHERE parameter ='NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            cedula||
            nombre_usuario||
            contrasena||
            id_rol||
            email||
            nombre||
            cia||
            prog_academico||
            activo||
            bloqueado||
            creado_por||
            creado_el||
            modificado_por||
            modificado_el
      INTO l_string
      FROM usuarios
      WHERE  ROWID = hash_rowid.p_rowid;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash_rowid;

   FUNCTION rt (
               p_cedula IN usuarios.cedula%TYPE
               )
      RETURN usuarios_rt RESULT_CACHE
   IS
      l_usuarios_rec usuarios_rt;
   BEGIN

      SELECT a.*,
             tapi_usuarios.hash(cedula),
             rowid
      INTO l_usuarios_rec
      FROM usuarios a
      WHERE
           cedula = rt.p_cedula
           ;


      RETURN l_usuarios_rec;

   END rt;

   FUNCTION rt_for_update (
                          p_cedula IN usuarios.cedula%TYPE
                          )
      RETURN usuarios_rt RESULT_CACHE
   IS
      l_usuarios_rec usuarios_rt;
   BEGIN


      SELECT a.*,
             tapi_usuarios.hash(cedula),
             rowid
      INTO l_usuarios_rec
      FROM usuarios a
      WHERE
           cedula = rt_for_update.p_cedula
      FOR UPDATE;


      RETURN l_usuarios_rec;

   END rt_for_update;

    FUNCTION tt (
                p_cedula IN usuarios.cedula%TYPE DEFAULT NULL
                )
       RETURN usuarios_tt
       PIPELINED
    IS
       l_usuarios_rec   usuarios_rt;
    BEGIN

       FOR c1 IN (SELECT   a.*, ROWID
                    FROM   usuarios a
                   WHERE
                        cedula = NVL(tt.p_cedula,cedula)
                        )
       LOOP
              l_usuarios_rec.cedula := c1.cedula;
              l_usuarios_rec.nombre_usuario := c1.nombre_usuario;
              l_usuarios_rec.contrasena := c1.contrasena;
              l_usuarios_rec.id_rol := c1.id_rol;
              l_usuarios_rec.email := c1.email;
              l_usuarios_rec.nombre := c1.nombre;
              l_usuarios_rec.cia := c1.cia;
              l_usuarios_rec.prog_academico := c1.prog_academico;
              l_usuarios_rec.activo := c1.activo;
              l_usuarios_rec.bloqueado := c1.bloqueado;
              l_usuarios_rec.creado_por := c1.creado_por;
              l_usuarios_rec.creado_el := c1.creado_el;
              l_usuarios_rec.modificado_por := c1.modificado_por;
              l_usuarios_rec.modificado_el := c1.modificado_el;
              l_usuarios_rec.hash := tapi_usuarios.hash( c1.cedula);
              l_usuarios_rec.row_id := c1.ROWID;
              PIPE ROW (l_usuarios_rec);
       END LOOP;

       RETURN;

    END tt;


    PROCEDURE ins (p_usuarios_rec IN OUT usuarios_rt)
    IS
        l_rowtype     usuarios%ROWTYPE;

    BEGIN


        l_rowtype.cedula := ins.p_usuarios_rec.cedula;
        l_rowtype.nombre_usuario := ins.p_usuarios_rec.nombre_usuario;
        l_rowtype.contrasena := ins.p_usuarios_rec.contrasena;
        l_rowtype.id_rol := ins.p_usuarios_rec.id_rol;
        l_rowtype.email := ins.p_usuarios_rec.email;
        l_rowtype.nombre := ins.p_usuarios_rec.nombre;
        l_rowtype.cia := ins.p_usuarios_rec.cia;
        l_rowtype.prog_academico := ins.p_usuarios_rec.prog_academico;
        l_rowtype.activo := ins.p_usuarios_rec.activo;
        l_rowtype.bloqueado := ins.p_usuarios_rec.bloqueado;
        l_rowtype.creado_por := ins.p_usuarios_rec.creado_por;
        l_rowtype.creado_el := ins.p_usuarios_rec.creado_el;
        l_rowtype.modificado_por := ins.p_usuarios_rec.modificado_por;
        l_rowtype.modificado_el := ins.p_usuarios_rec.modificado_el;

       INSERT INTO usuarios
          VALUES   l_rowtype
       RETURNING
                   cedula ,
                   nombre_usuario ,
                   contrasena ,
                   id_rol ,
                   email ,
                   nombre ,
                   cia ,
                   prog_academico ,
                   activo ,
                   bloqueado ,
                   creado_por ,
                   creado_el ,
                   modificado_por ,
                   modificado_el 
            INTO   l_rowtype;

         ins.p_usuarios_rec.cedula := l_rowtype.cedula;
         ins.p_usuarios_rec.nombre_usuario := l_rowtype.nombre_usuario;
         ins.p_usuarios_rec.contrasena := l_rowtype.contrasena;
         ins.p_usuarios_rec.id_rol := l_rowtype.id_rol;
         ins.p_usuarios_rec.email := l_rowtype.email;
         ins.p_usuarios_rec.nombre := l_rowtype.nombre;
         ins.p_usuarios_rec.cia := l_rowtype.cia;
         ins.p_usuarios_rec.prog_academico := l_rowtype.prog_academico;
         ins.p_usuarios_rec.activo := l_rowtype.activo;
         ins.p_usuarios_rec.bloqueado := l_rowtype.bloqueado;
         ins.p_usuarios_rec.creado_por := l_rowtype.creado_por;
         ins.p_usuarios_rec.creado_el := l_rowtype.creado_el;
         ins.p_usuarios_rec.modificado_por := l_rowtype.modificado_por;
         ins.p_usuarios_rec.modificado_el := l_rowtype.modificado_el;



    END ins;

    PROCEDURE upd (
                  p_usuarios_rec         IN usuarios_rt,
                  p_ignore_nulls         IN boolean := FALSE
                  )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   usuarios
             SET cedula = NVL(p_usuarios_rec.cedula,cedula),
                nombre_usuario = NVL(p_usuarios_rec.nombre_usuario,nombre_usuario),
                contrasena = NVL(p_usuarios_rec.contrasena,contrasena),
                id_rol = NVL(p_usuarios_rec.id_rol,id_rol),
                email = NVL(p_usuarios_rec.email,email),
                nombre = NVL(p_usuarios_rec.nombre,nombre),
                cia = NVL(p_usuarios_rec.cia,cia),
                prog_academico = NVL(p_usuarios_rec.prog_academico,prog_academico),
                activo = NVL(p_usuarios_rec.activo,activo),
                bloqueado = NVL(p_usuarios_rec.bloqueado,bloqueado),
                creado_por = NVL(p_usuarios_rec.creado_por,creado_por),
                creado_el = NVL(p_usuarios_rec.creado_el,creado_el),
                modificado_por = NVL(p_usuarios_rec.modificado_por,modificado_por),
                modificado_el = NVL(p_usuarios_rec.modificado_el,modificado_el)
           WHERE
                cedula = upd.p_usuarios_rec.cedula
                ;
       ELSE
          UPDATE   usuarios
             SET cedula = p_usuarios_rec.cedula,
                nombre_usuario = p_usuarios_rec.nombre_usuario,
                contrasena = p_usuarios_rec.contrasena,
                id_rol = p_usuarios_rec.id_rol,
                email = p_usuarios_rec.email,
                nombre = p_usuarios_rec.nombre,
                cia = p_usuarios_rec.cia,
                prog_academico = p_usuarios_rec.prog_academico,
                activo = p_usuarios_rec.activo,
                bloqueado = p_usuarios_rec.bloqueado,
                creado_por = p_usuarios_rec.creado_por,
                creado_el = p_usuarios_rec.creado_el,
                modificado_por = p_usuarios_rec.modificado_por,
                modificado_el = p_usuarios_rec.modificado_el
           WHERE
                cedula = upd.p_usuarios_rec.cedula
                ;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd;


    PROCEDURE upd_rowid (
                         p_usuarios_rec         IN usuarios_rt,
                         p_ignore_nulls         IN boolean := FALSE
                        )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   usuarios
             SET cedula = NVL(p_usuarios_rec.cedula,cedula),
                nombre_usuario = NVL(p_usuarios_rec.nombre_usuario,nombre_usuario),
                contrasena = NVL(p_usuarios_rec.contrasena,contrasena),
                id_rol = NVL(p_usuarios_rec.id_rol,id_rol),
                email = NVL(p_usuarios_rec.email,email),
                nombre = NVL(p_usuarios_rec.nombre,nombre),
                cia = NVL(p_usuarios_rec.cia,cia),
                prog_academico = NVL(p_usuarios_rec.prog_academico,prog_academico),
                activo = NVL(p_usuarios_rec.activo,activo),
                bloqueado = NVL(p_usuarios_rec.bloqueado,bloqueado),
                creado_por = NVL(p_usuarios_rec.creado_por,creado_por),
                creado_el = NVL(p_usuarios_rec.creado_el,creado_el),
                modificado_por = NVL(p_usuarios_rec.modificado_por,modificado_por),
                modificado_el = NVL(p_usuarios_rec.modificado_el,modificado_el)
           WHERE  ROWID = p_usuarios_rec.row_id;
       ELSE
          UPDATE   usuarios
             SET cedula = p_usuarios_rec.cedula,
                nombre_usuario = p_usuarios_rec.nombre_usuario,
                contrasena = p_usuarios_rec.contrasena,
                id_rol = p_usuarios_rec.id_rol,
                email = p_usuarios_rec.email,
                nombre = p_usuarios_rec.nombre,
                cia = p_usuarios_rec.cia,
                prog_academico = p_usuarios_rec.prog_academico,
                activo = p_usuarios_rec.activo,
                bloqueado = p_usuarios_rec.bloqueado,
                creado_por = p_usuarios_rec.creado_por,
                creado_el = p_usuarios_rec.creado_el,
                modificado_por = p_usuarios_rec.modificado_por,
                modificado_el = p_usuarios_rec.modificado_el
           WHERE  ROWID = p_usuarios_rec.row_id;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd_rowid;

   PROCEDURE web_upd (
                  p_usuarios_rec         IN usuarios_rt,
                  p_ignore_nulls         IN boolean := FALSE
                )
   IS
      l_usuarios_rec usuarios_rt;
   BEGIN

      OPEN usuarios_cur(
                             web_upd.p_usuarios_rec.cedula
                        );

      FETCH usuarios_cur INTO l_usuarios_rec;

      IF usuarios_cur%NOTFOUND THEN
         CLOSE usuarios_cur;
         RAISE e_row_missing;
      ELSE
         IF p_usuarios_rec.hash != l_usuarios_rec.hash THEN
            CLOSE usuarios_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(p_ignore_nulls, FALSE)
            THEN

                UPDATE   usuarios
                   SET cedula = NVL(p_usuarios_rec.cedula,cedula),
                       nombre_usuario = NVL(p_usuarios_rec.nombre_usuario,nombre_usuario),
                       contrasena = NVL(p_usuarios_rec.contrasena,contrasena),
                       id_rol = NVL(p_usuarios_rec.id_rol,id_rol),
                       email = NVL(p_usuarios_rec.email,email),
                       nombre = NVL(p_usuarios_rec.nombre,nombre),
                       cia = NVL(p_usuarios_rec.cia,cia),
                       prog_academico = NVL(p_usuarios_rec.prog_academico,prog_academico),
                       activo = NVL(p_usuarios_rec.activo,activo),
                       bloqueado = NVL(p_usuarios_rec.bloqueado,bloqueado),
                       creado_por = NVL(p_usuarios_rec.creado_por,creado_por),
                       creado_el = NVL(p_usuarios_rec.creado_el,creado_el),
                       modificado_por = NVL(p_usuarios_rec.modificado_por,modificado_por),
                       modificado_el = NVL(p_usuarios_rec.modificado_el,modificado_el)
               WHERE CURRENT OF usuarios_cur;
            ELSE
                UPDATE   usuarios
                   SET cedula = p_usuarios_rec.cedula,
                       nombre_usuario = p_usuarios_rec.nombre_usuario,
                       contrasena = p_usuarios_rec.contrasena,
                       id_rol = p_usuarios_rec.id_rol,
                       email = p_usuarios_rec.email,
                       nombre = p_usuarios_rec.nombre,
                       cia = p_usuarios_rec.cia,
                       prog_academico = p_usuarios_rec.prog_academico,
                       activo = p_usuarios_rec.activo,
                       bloqueado = p_usuarios_rec.bloqueado,
                       creado_por = p_usuarios_rec.creado_por,
                       creado_el = p_usuarios_rec.creado_el,
                       modificado_por = p_usuarios_rec.modificado_por,
                       modificado_el = p_usuarios_rec.modificado_el
               WHERE CURRENT OF usuarios_cur;
            END IF;

            CLOSE usuarios_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd;

   PROCEDURE web_upd_rowid (
                            p_usuarios_rec    IN usuarios_rt,
                            p_ignore_nulls         IN boolean := FALSE
                           )
   IS
      l_usuarios_rec usuarios_rt;
   BEGIN

      OPEN usuarios_rowid_cur(web_upd_rowid.p_usuarios_rec.row_id);

      FETCH usuarios_rowid_cur INTO l_usuarios_rec;

      IF usuarios_rowid_cur%NOTFOUND THEN
         CLOSE usuarios_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_upd_rowid.p_usuarios_rec.hash != l_usuarios_rec.hash THEN
            CLOSE usuarios_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(web_upd_rowid.p_ignore_nulls, FALSE)
            THEN
                UPDATE   usuarios
                   SET cedula = NVL(p_usuarios_rec.cedula,cedula),
                       nombre_usuario = NVL(p_usuarios_rec.nombre_usuario,nombre_usuario),
                       contrasena = NVL(p_usuarios_rec.contrasena,contrasena),
                       id_rol = NVL(p_usuarios_rec.id_rol,id_rol),
                       email = NVL(p_usuarios_rec.email,email),
                       nombre = NVL(p_usuarios_rec.nombre,nombre),
                       cia = NVL(p_usuarios_rec.cia,cia),
                       prog_academico = NVL(p_usuarios_rec.prog_academico,prog_academico),
                       activo = NVL(p_usuarios_rec.activo,activo),
                       bloqueado = NVL(p_usuarios_rec.bloqueado,bloqueado),
                       creado_por = NVL(p_usuarios_rec.creado_por,creado_por),
                       creado_el = NVL(p_usuarios_rec.creado_el,creado_el),
                       modificado_por = NVL(p_usuarios_rec.modificado_por,modificado_por),
                       modificado_el = NVL(p_usuarios_rec.modificado_el,modificado_el)
               WHERE CURRENT OF usuarios_rowid_cur;
            ELSE
                UPDATE   usuarios
                   SET cedula = p_usuarios_rec.cedula,
                       nombre_usuario = p_usuarios_rec.nombre_usuario,
                       contrasena = p_usuarios_rec.contrasena,
                       id_rol = p_usuarios_rec.id_rol,
                       email = p_usuarios_rec.email,
                       nombre = p_usuarios_rec.nombre,
                       cia = p_usuarios_rec.cia,
                       prog_academico = p_usuarios_rec.prog_academico,
                       activo = p_usuarios_rec.activo,
                       bloqueado = p_usuarios_rec.bloqueado,
                       creado_por = p_usuarios_rec.creado_por,
                       creado_el = p_usuarios_rec.creado_el,
                       modificado_por = p_usuarios_rec.modificado_por,
                       modificado_el = p_usuarios_rec.modificado_el
               WHERE CURRENT OF usuarios_rowid_cur;
            END IF;

            CLOSE usuarios_rowid_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd_rowid;

    PROCEDURE del (
                  p_cedula IN usuarios.cedula%TYPE
                  )
    IS
    BEGIN

       DELETE FROM   usuarios
             WHERE
                  cedula = del.p_cedula
                   ;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del;

    PROCEDURE del_rowid (p_rowid IN varchar2)
    IS
    BEGIN

       DELETE FROM   usuarios
             WHERE   ROWID = del_rowid.p_rowid;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del_rowid;

    PROCEDURE web_del (
                      p_cedula IN usuarios.cedula%TYPE,
                      p_hash IN varchar2
                      )
   IS
      l_usuarios_rec usuarios_rt;
   BEGIN


      OPEN usuarios_cur(
                            web_del.p_cedula
                            );

      FETCH usuarios_cur INTO l_usuarios_rec;

      IF usuarios_cur%NOTFOUND THEN
         CLOSE usuarios_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del.p_hash != l_usuarios_rec.hash THEN
            CLOSE usuarios_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM usuarios
            WHERE CURRENT OF usuarios_cur;

            CLOSE usuarios_cur;
         END IF;
      END IF;



   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del;

   PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2)
   IS
      l_usuarios_rec usuarios_rt;
   BEGIN


      OPEN usuarios_rowid_cur(web_del_rowid.p_rowid);

      FETCH usuarios_rowid_cur INTO l_usuarios_rec;

      IF usuarios_rowid_cur%NOTFOUND THEN
         CLOSE usuarios_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del_rowid.p_hash != l_usuarios_rec.hash THEN
            CLOSE usuarios_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM usuarios
            WHERE CURRENT OF usuarios_rowid_cur;

            CLOSE usuarios_rowid_cur;
         END IF;
      END IF;

   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del_rowid;

END tapi_usuarios;



/
--------------------------------------------------------
--  DDL for Package Body TEPLSQL
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."TEPLSQL" 
AS
   g_buffer   CLOB;

   PROCEDURE output_clob (p_clob IN CLOB)
   AS
      l_offset   NUMBER DEFAULT 1 ;
   BEGIN
      LOOP
         EXIT WHEN l_offset > DBMS_LOB.getlength (p_clob);
         DBMS_OUTPUT.put_line (DBMS_LOB.SUBSTR (p_clob, 255, l_offset));
         l_offset    := l_offset + 255;
      END LOOP;
   END output_clob;

   /**
   * Receives the template directive key-value data separated by commas
   * and assign this key-values to the associative array
   *
   * @param  p_directive      the key-value data template directive
   * @param  p_vars           the associative array
   */
   PROCEDURE set_template_directive (p_directive IN CLOB, p_vars IN OUT NOCOPY t_assoc_array)
   AS
      l_key         VARCHAR2 (256);
      l_value       VARCHAR2 (256);
      l_directive   VARCHAR2 (32767);
   BEGIN
      l_directive := REGEXP_REPLACE (p_directive, '\s', '');

      FOR c1 IN (    SELECT   REGEXP_REPLACE (REGEXP_SUBSTR (l_directive
                                                           , '[^,]+'
                                                           , 1
                                                           , LEVEL), '\s', '')
                                 text
                       FROM   DUAL
                 CONNECT BY   REGEXP_SUBSTR (l_directive
                                           , '[^,]+'
                                           , 1
                                           , LEVEL) IS NOT NULL)
      LOOP
         l_key       := SUBSTR (c1.text, 1, INSTR (c1.text, '=') - 1);
         l_value     := SUBSTR (c1.text, INSTR (c1.text, '=') + 1);
         p_vars ('template_' || l_key) := l_value;
      END LOOP;
   END set_template_directive;

   /**
   * Receives the name of the object, usually a package,
   * which contains an embedded template and return the template.
   *
   * @param  p_template_name    the name of the template
   * @param  p_object_name      the name of the object (usually the name of the package)
   * @param  p_object_type      the type of the object (PACKAGE, PROCEDURE, FUNCTION...)
   * @param  p_schema           the schema of the object
   * @return                    the template.
   */
    FUNCTION include (p_template_name   IN VARCHAR2 DEFAULT NULL
                    , p_object_name     IN VARCHAR2 DEFAULT 'TE_TEMPLATES'
                    , p_object_type     IN VARCHAR2 DEFAULT 'PACKAGE'
                    , p_schema          IN VARCHAR2 DEFAULT NULL )
       RETURN CLOB
    AS
       l_result       CLOB;
       l_object_ddl   CLOB;
       l_template     CLOB;
       l_tmp          CLOB;
       i              PLS_INTEGER := 1;
       l_found        PLS_INTEGER := 0;
       l_object_name     VARCHAR2 (64);
       l_template_name   VARCHAR2 (64);
       l_object_type     VARCHAR2 (64);
       l_schema          VARCHAR2 (64);
    BEGIN

        --Force Defaults
        l_template_name := p_template_name;
        l_object_name := NVL(p_object_name,'TE_TEMPLATES');
        l_object_type := NVL(p_object_type,'PACKAGE');
        l_schema := p_schema;

       --Search for the template in the table TE_TEMPLATES
       IF  l_template_name IS NOT NULL
       AND l_object_name = 'TE_TEMPLATES'
       THEN
          BEGIN
              SELECT   template
                INTO   l_template
                FROM   te_templates
               WHERE   name = UPPER (l_template_name);
          EXCEPTION
          WHEN NO_DATA_FOUND
          THEN
            l_template := EMPTY_CLOB();
          END;

           RETURN l_template;

       ELSE
          --Search the template in other Oracle Object

          --Get package source DDL
          l_object_ddl :=
             DBMS_METADATA.get_ddl (NVL (UPPER (l_object_type), 'PACKAGE'), UPPER (l_object_name), UPPER (l_schema));

          --If p_template_name is null get all templates from the object
          --else get only this template.
          IF l_template_name IS NOT NULL
          THEN
             LOOP
                l_tmp       :=
                   REGEXP_SUBSTR (l_object_ddl
                                , '<%@ template([^%>].*?)%>'
                                , 1
                                , i
                                , 'n');

                l_found     := INSTR (l_tmp, 'name=' || l_template_name);

                EXIT WHEN LENGTH (l_tmp) = 0 OR l_found <> 0;
                i           := i + 1;
             END LOOP;
          ELSE
             l_found     := 0;
          END IF;

          -- i has the occurrence of the substr where the template is
          l_tmp       := NULL;

          LOOP
             --Get Template from the object
             $IF DBMS_DB_VERSION.ver_le_10
             $THEN
                l_tmp       :=
                   REGEXP_REPLACE (REGEXP_REPLACE (REGEXP_SUBSTR (l_object_ddl
                                                                , '\$if[[:blank:]]+false[[:blank:]]+\$then' || CHR (10) || '([^\$end].*?)\$end'
                                                                , 1
                                                                , i
                                                                , 'n')
                                                 , '\$if[[:blank:]]+false[[:blank:]]+\$then' || CHR (10)
                                                 , ''
                                                 , 1
                                                 , 1)
                                 , '\$end'
                                 , ''
                                 , 1
                                 , INSTR ('$end', 1, -1));
             $ELSE
                l_tmp       :=
                   REGEXP_SUBSTR (l_object_ddl
                                , '\$if[[:blank:]]+false[[:blank:]]+\$then' || CHR (10) || '([^\$end].*?)\$end'
                                , 1
                                , i
                                , 'n'
                                , 1);
             $END

             l_template  := l_template || l_tmp;
             EXIT WHEN LENGTH (l_tmp) = 0 OR l_found <> 0;
             i           := i + 1;
          END LOOP;

          RETURN l_template;
       END IF;
    END include;

   /**
   * Bind associative array variables in the template
   *
   * @param  p_template      the template
   * @param  p_vars        the associative array
   */
   PROCEDURE bind_vars (p_template IN OUT NOCOPY CLOB, p_vars IN t_assoc_array)
   AS
      l_key   VARCHAR2 (256);
   BEGIN
      IF p_vars.COUNT () <> 0
      THEN
         l_key       := p_vars.FIRST;

         LOOP
            EXIT WHEN l_key IS NULL;
            p_template    := REPLACE (p_template, '${' || l_key || '}', TO_CLOB (p_vars (l_key)));
            l_key       := p_vars.NEXT (l_key);
         END LOOP;
      END IF;
   END bind_vars;

   /**
   * Parse template marks
   *
   * @param  p_template      the template
   * @param  p_vars        the associative array
   */
   PROCEDURE parse (p_template IN CLOB, p_vars IN t_assoc_array DEFAULT null_assoc_array)
   AS
      l_open_count    PLS_INTEGER;
      l_close_count   PLS_INTEGER;
   BEGIN
      $if dbms_db_version.ver_le_10 $then
          /**
          *  ATTENTION, these instructions are very slow and penalize template processing time.
          *  If performance is critical to your system, you should disable the parser only for BD <= 10g
          */
          l_open_count :=
             NVL (LENGTH (REGEXP_REPLACE (p_template
                                        , '(<)%|.'
                                        , '\1'
                                        , 1
                                        , 0
                                        , 'n')), 0);

          l_close_count :=
             NVL (LENGTH (REGEXP_REPLACE (p_template
                                        , '(%)>|.'
                                        , '\1'
                                        , 1
                                        , 0
                                        , 'n')), 0);
      $else
          l_open_count := regexp_count (p_template, '<\%');
          l_close_count := regexp_count (p_template, '\%>');
      $end


      IF l_open_count <> l_close_count
      THEN
         raise_application_error (-20001
                                ,    '##Parser Exception processing the template: '||p_vars('template_name')
                                  || '. One or more tags (<% %>) are not closed: '
                                  || l_open_count
                                  || ' <> '
                                  || l_close_count
                                  || CHR (10));
      END IF;
   END parse;

   /**
   * Interprets the received template and convert it into executable plsql
   *
   * @param  p_template    the template
   * @param  p_vars        the associative array
   */
   PROCEDURE interpret (p_template IN OUT NOCOPY CLOB, p_vars IN t_assoc_array DEFAULT null_assoc_array)
   AS
      l_vars       t_assoc_array := p_vars;
      l_declare    CLOB;
      l_tmp        CLOB;
      i            PLS_INTEGER := 0;
   BEGIN

      --Template directive
      $if dbms_db_version.ver_le_10 $then
          l_tmp       :=
             REPLACE (REPLACE (REGEXP_SUBSTR (p_template
                                            , '<%@ template([^%>].*?)\s*%>'
                                            , 1
                                            , 1
                                            , 'n'), '<%@ template', ''), '%>', '');
      $else
          l_tmp       :=
             REGEXP_SUBSTR (p_template
                          , '<%@ template([^%>].*?)\s*%>'
                          , 1
                          , 1
                          , 'n'
                          , 1);
      $end

      --Set template directive variables into var associative array
      set_template_directive (l_tmp, l_vars);

      --Bind the variables into template
      bind_vars (p_template, l_vars);

      --Null all variables not binded
      p_template    := REGEXP_REPLACE (p_template, '\$\{\S*\}', '');

      --Parse <% %> tags
      parse (p_template, l_vars);

      --Dos to Unix
      p_template  :=
         REGEXP_REPLACE (p_template
                       , CHR(13)||CHR(10)
                       , CHR(10)
                       , 1,0,'nm');

      --Delete all template directives
      p_template  :=
         REGEXP_REPLACE (p_template
                       , '<%@ template([^%>].*?)\s*%>[[:blank:]]*\s$?'
                       , ''
                       , 1
                       , 0
                       , 'n');

      --Escaped chars except \\n
      p_template  :=
         REGEXP_REPLACE (p_template
                       , '\\\\([^n])'
                       , ']'');tePLSQL.p(q''[\1]'');tePLSQL.p(q''['
                       , 1
                       , 0
                       , 'n');


      --New lines.
      p_template  :=
         REGEXP_REPLACE (p_template
                       , '(\\\\n)'
                       , CHR (10) --|| ']'');tePLSQL.p(q''['
                       , 1
                       , 0
                       , 'n');


      --Delete the line breaks for lines ending in %>[blanks]CHR(10)
      p_template  :=
         REGEXP_REPLACE (p_template
                       , '(%>[[:blank:]]*?' || CHR (10) || ')'
                       , '%>'
                       , 1
                       , 0
                       , '');

      --Delete new lines with !\n
      p_template  :=
         REGEXP_REPLACE (p_template
                       , '([[:blank:]]*\!\\n[[:blank:]]*' || CHR (10) || '?[[:blank:]]*)'
                       , ''
                       , 1
                       , 0
                       , 'm');

      -- Delete all blanks before <% in the beginning of each line
      p_template  :=
         REGEXP_REPLACE (p_template
                       , '(^[[:blank:]]*<%)'
                       , '<%'
                       , 1
                       , 0
                       , 'm');

      --Merge all declaration blocks into a single block
      l_tmp       := NULL;

      LOOP
         i           := i + 1;
          $if dbms_db_version.ver_le_10 $then
             l_tmp       :=
                REPLACE (REPLACE (REGEXP_SUBSTR (p_template
                                               , '<%!([^%>].*?)%>'
                                               , 1
                                               , i
                                               , 'n'), '<%!', ''), '%>', '');
         $else
             l_tmp       :=
                REGEXP_SUBSTR (p_template
                             , '<%!([^%>].*?)%>'
                             , 1
                             , i
                             , 'n'
                             , 1);
         $end

         l_declare   := l_declare || l_tmp;
         EXIT WHEN LENGTH (l_tmp) = 0;
      END LOOP;

      --Delete declaration blocks from template
      p_template  :=
         REGEXP_REPLACE (p_template
                       , '<%!([^%>].*?)%>'
                       , ''
                       , 1
                       , 0
                       , 'n');

      --Expresison directive
      p_template  :=
         REGEXP_REPLACE (p_template
                       , '<%=([^%>].*?)%>'
                       , ']'');tePLSQL.p(\1);tePLSQL.p(q''['
                       , 1
                       , 0
                       , 'n');

      --Code blocks directive
      --p_template  :=
      --   REGEXP_REPLACE (p_template
      --                 , '<%([^%>].*?)%>'
      --                 , ']''); \1 tePLSQL.p(q''['
      --                , 1
      --                 , 0
      --                 , 'n');

      p_template  := 'DECLARE ' || l_declare || ' BEGIN tePLSQL.p(q''[' || p_template || ' ]''); END;';

   END interpret;

   /**
   * Search for include directives, includes and evaluates the specified templates.
   * Nested include are allowed
   *
   * @param  p_template    the template
   * @param  p_vars        the associative array
   */
   PROCEDURE get_includes (p_template IN OUT NOCOPY CLOB, p_vars IN t_assoc_array DEFAULT null_assoc_array )
    AS
       l_tmp             CLOB;
       l_result          CLOB;

       l_str_tmp         VARCHAR2 (64);

       TYPE array_t IS TABLE OF VARCHAR2 (64);

       l_strig_tt        array_t;
       l_object_name     VARCHAR2 (64);
       l_template_name   VARCHAR2 (64);
       l_object_type     VARCHAR2 (64);
       l_schema          VARCHAR2 (64);

       l_start           PLS_INTEGER := 0;
       l_end             PLS_INTEGER := 0;
       l_number_includes PLS_INTEGER := 0;
    BEGIN
       /*
       --Pseudocode
       while there includes
       do
           get include
           interpret template
           concatenate result template into p_template
       done
       */
       WHILE REGEXP_INSTR (p_template, '<%@ include\((.*?)\)\s*%>') <> 0
       LOOP
          --Init
          l_str_tmp   := NULL;
          l_object_name := NULL;
          l_template_name := NULL;
          l_object_type := NULL;
          l_schema    := NULL;
          l_tmp       := NULL;
          l_start     := 0;
          l_end       := 0;

          --get include directive
          l_str_tmp   :=
             REGEXP_SUBSTR (p_template
                          , '<%@ include\((.*?)\)\s*%>'
                          , 1
                          , 1
                          , 'n'
                          , 1);

          IF LENGTH (l_str_tmp) > 0
          THEN
                 SELECT   REGEXP_REPLACE (REGEXP_SUBSTR (l_str_tmp
                                                       , '[^,]+'
                                                       , 1
                                                       , LEVEL), '\s', '')
                             text
                   BULK   COLLECT
                   INTO   l_strig_tt
                   FROM   DUAL
             CONNECT BY   REGEXP_SUBSTR (l_str_tmp
                                       , '[^,]+'
                                       , 1
                                       , LEVEL) IS NOT NULL;

             --populate variables
             IF l_strig_tt.EXISTS (1)
             THEN
                l_template_name := l_strig_tt (1);
             END IF;

             IF l_strig_tt.EXISTS (2)
             THEN
                l_object_name := l_strig_tt (2);
             END IF;

             IF l_strig_tt.EXISTS (3)
             THEN
                l_object_type := l_strig_tt (3);
             END IF;

             IF l_strig_tt.EXISTS (4)
             THEN
                l_schema    := l_strig_tt (4);
             END IF;

             --get included template
             l_tmp       :=
                include (l_template_name
                       , l_object_name
                       , l_object_type
                       , l_object_type);

             --Interpret the template
             interpret (l_tmp, p_vars);


             l_tmp := ']''); '|| l_tmp ||' tePLSQL.p(q''[';

             --Start and End of the expression
             l_start     :=
                REGEXP_INSTR (p_template
                            , '<%@ include\((.*?)\)\s*%>'
                            , 1
                            , 1
                            , 0
                            , 'n');

             l_end       :=
                REGEXP_INSTR (p_template
                            , '<%@ include\((.*?)\)\s*%>'
                            , 1
                            , 1
                            , 1
                            , 'n');

             --concatenate result template into first template
             IF (NVL (l_start, 0) > 0)
             THEN
                DBMS_LOB.createtemporary (l_result, FALSE, DBMS_LOB.call);

                IF l_start > 1
                THEN
                   DBMS_LOB.COPY (l_result
                                , p_template
                                , l_start - 1
                                , 1
                                , 1);
                END IF;

                IF LENGTH (l_tmp) > 0
                THEN
                   DBMS_LOB.COPY (l_result
                                , l_tmp
                                , DBMS_LOB.getlength (l_tmp)
                                , DBMS_LOB.getlength (l_result) +1
                                , 1);
                END IF;

                --A�adimos el resto de la fuente a la varbiable resultado
                DBMS_LOB.COPY (l_result
                             , p_template
                             , DBMS_LOB.getlength (p_template)
                             , DBMS_LOB.getlength (l_result) +1
                             , l_end);
             END IF;


             p_template  := l_result;

             DBMS_LOB.freetemporary (l_result);
          END IF;

          l_number_includes := l_number_includes +1;
          if l_number_includes >= 50
          then
            raise_application_error (-20001, 'Too much include directive in the template, Recursive include?');
          end if;

       END LOOP;
    END get_includes;

   PROCEDURE PRINT (p_data IN CLOB)
   AS
   BEGIN
      g_buffer    := g_buffer || p_data;
   END PRINT;

   PROCEDURE PRINT (p_data IN VARCHAR2)
   AS
   BEGIN
      g_buffer    := g_buffer || p_data;
   END PRINT;

   PROCEDURE PRINT (p_data IN NUMBER)
   AS
   BEGIN
      g_buffer    := g_buffer || TO_CHAR (p_data);
   END PRINT;

   PROCEDURE p (p_data IN CLOB)
   AS
   BEGIN
      g_buffer    := g_buffer || p_data;
   END p;

   PROCEDURE p (p_data IN VARCHAR2)
   AS
   BEGIN
      g_buffer    := g_buffer || p_data;
   END p;

   PROCEDURE p (p_data IN NUMBER)
   AS
   BEGIN
      g_buffer    := g_buffer || TO_CHAR (p_data);
   END p;

   FUNCTION render (p_vars IN t_assoc_array DEFAULT null_assoc_array, p_template IN CLOB)
      RETURN CLOB
   AS
    l_template   CLOB := p_template;
    l_length pls_integer;
   BEGIN
      --Clear buffer
      g_buffer    := NULL;

      --Parse <% %> tags
      --parse (l_template);

      --Get Includes
      get_includes(l_template);

      --Interpret the template
      interpret(l_template, p_vars);

      --Code blocks directive
      l_template  :=
         REGEXP_REPLACE (l_template
                       , '<%([^%>].*?)%>'
                       , ']''); \1 tePLSQL.p(q''['
                       , 1
                       , 0
                       , 'n');

      --DBMS_OUTPUT.put_line (l_template);

      --Execute the template
      $if dbms_db_version.ver_le_10 $then
          --10g
          DECLARE
             v_upperbound   NUMBER;
             v_cur          INTEGER;
             v_sql          DBMS_SQL.varchar2a;
             v_ret          NUMBER;
          BEGIN
             v_upperbound := CEIL (DBMS_LOB.getlength (l_template) / 32767);

             FOR i IN 1 .. v_upperbound
             LOOP
                v_sql (i)   := DBMS_LOB.SUBSTR (l_template, -- clob statement
                                                  32767, -- amount
                                                  ( (i - 1) * 32767) + 1);
             END LOOP;

             v_cur       := DBMS_SQL.open_cursor;
             -- parse sql statement
             DBMS_SQL.parse (v_cur
                           , v_sql
                           , 1
                           , v_upperbound
                           , FALSE
                           , DBMS_SQL.native);
             -- execute
             v_ret       := DBMS_SQL.execute (v_cur);
          EXCEPTION
             WHEN OTHERS
             THEN
                --Trim buffer
                l_length := DBMS_LOB.getlength (g_buffer);
                IF l_length > 500
                THEN
                    l_length := 500;
                END IF;
                g_buffer := DBMS_LOB.SUBSTR (g_buffer, l_length, DBMS_LOB.getlength (g_buffer) - (l_length - 1));

                --Print error
                PRINT ('### tePLSQL Render Error ###');
                PRINT (CHR (10));
                PRINT (SQLERRM || ' ' || DBMS_UTILITY.format_error_backtrace ());
                PRINT (CHR (10));
                PRINT ('### Processed template ###');
                PRINT (CHR (10));
                PRINT (l_template);
          END;

      $else
          -- 11g
          BEGIN
             EXECUTE IMMEDIATE l_template;
          EXCEPTION
             WHEN OTHERS
             THEN
                --Trim buffer
                l_length := DBMS_LOB.getlength (g_buffer);
                IF l_length > 500
                THEN
                    l_length := 500;
                END IF;
                g_buffer := DBMS_LOB.SUBSTR (g_buffer, l_length, DBMS_LOB.getlength (g_buffer) - (l_length - 1));

                --Print error
                PRINT ('### tePLSQL Render Error ###');
                PRINT (CHR (10));
                PRINT (SQLERRM || ' ' || DBMS_UTILITY.format_error_backtrace ());
                PRINT (CHR (10));
                PRINT ('### Processed template ###');
                PRINT (CHR (10));
                PRINT (l_template);
          END;
      $end

      l_template  := g_buffer;
      g_buffer    := NULL;

      RETURN l_template;
   EXCEPTION
      WHEN OTHERS
      THEN
         raise_application_error (-20001, SQLERRM || ' ' || DBMS_UTILITY.format_error_backtrace ());
   END render;


   FUNCTION process (p_vars            IN t_assoc_array DEFAULT null_assoc_array
                   , p_template_name   IN VARCHAR2 DEFAULT NULL
                   , p_object_name     IN VARCHAR2 DEFAULT 'TE_TEMPLATES'
                   , p_object_type     IN VARCHAR2 DEFAULT 'PACKAGE'
                   , p_schema          IN VARCHAR2 DEFAULT NULL )
      RETURN CLOB
   AS
      l_result       CLOB;
      l_template     CLOB;
   BEGIN
      --Get template
      l_template := include(p_template_name,p_object_name,p_object_type,p_schema);

      IF LENGTH (l_template) = 0
      THEN
         IF p_template_name IS NOT NULL
         THEN
            raise_application_error (-20002
                                   , 'Template ' || p_template_name || ' not found in object ' || UPPER (p_object_name));
         ELSE
            raise_application_error (-20002
                                   , 'The object ' || p_object_name || ' not has a template inside the "$if false $then"');
         END IF;
      END IF;

      --Render template
      l_result    := render (p_vars,l_template);
      RETURN l_result;
   END process;
END teplsql;

/
--------------------------------------------------------
--  DDL for Package Body TOOLKIT
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."TOOLKIT" AS

  g_key     RAW(32767)  := UTL_RAW.cast_to_raw('fundauc2019');
  g_pad_chr VARCHAR2(1) := '~';

  PROCEDURE padstring (p_text  IN OUT  VARCHAR2);


  -- --------------------------------------------------
  FUNCTION encrypt (p_text  IN  VARCHAR2) RETURN RAW IS
  -- --------------------------------------------------
    l_text       VARCHAR2(32767) := p_text;
    l_encrypted  RAW(32767);
  BEGIN
    padstring(l_text);
    DBMS_OBFUSCATION_TOOLKIT.desencrypt(input          => UTL_RAW.cast_to_raw(l_text),
                                        key            => g_key,
                                        encrypted_data => l_encrypted);
    RETURN l_encrypted;
  END;
  -- --------------------------------------------------



  -- --------------------------------------------------
  FUNCTION decrypt (p_raw  IN  RAW) RETURN VARCHAR2 IS
  -- --------------------------------------------------
    l_decrypted  VARCHAR2(32767);
  BEGIN
    DBMS_OBFUSCATION_TOOLKIT.desdecrypt(input => p_raw,
                                        key   => g_key,
                                        decrypted_data => l_decrypted);

    RETURN RTrim(UTL_RAW.cast_to_varchar2(l_decrypted), g_pad_chr);
  END;
  -- --------------------------------------------------

  -- --------------------------------------------------
  FUNCTION LOGIN (p_username IN VARCHAR2, p_password VARCHAR2) RETURN BOOLEAN IS
    l_return number;
    l_usuario usuarios.nombre_usuario%type;
    l_password usuarios.contrasena%type;
    begin 
      begin
      select nombre_usuario,contrasena into l_usuario, l_password from usuarios where UPPER(nombre_usuario) = UPPER(p_username);

     if toolkit.encrypt(p_password) = l_password and l_usuario = p_username then
--      DBMS_OUTPUT.PUT_LINE('if = ' || upper(p_password)||'='||l_password ||' and '||l_usuario||'='||upper(p_username));
--      if upper(p_password) = upper(l_password) and upper(l_usuario) = upper(p_username) then
        return true;
        else
        return false;
      end if;
      exception when no_data_found then
        return false;  
      end;
  END;
  -- --------------------------------------------------

  -- --------------------------------------------------
  PROCEDURE padstring (p_text  IN OUT  VARCHAR2) IS
  -- --------------------------------------------------
    l_units  NUMBER;
  BEGIN
    IF LENGTH(p_text) MOD 8 > 0 THEN
      l_units := TRUNC(LENGTH(p_text)/8) + 1;
      p_text  := RPAD(p_text, l_units * 8, g_pad_chr);
    END IF;
  END;
  -- --------------------------------------------------

  FUNCTION get_tipo_acceso (p_usr IN VARCHAR2, p_app VARCHAR2) RETURN CHAR IS
    l_return CHAR(1) := null;
    l_usuario usuarios.nombre_usuario%type;
    l_app_id  number;
  BEGIN
    FOR c IN (select role_static_id from apex_appl_acl_user_roles where application_id = p_app and user_name = p_usr) LOOP
        IF c.role_static_id in ('CONTROLEST','SUPCONTROLEST') and l_return is null THEN
            l_return := 'I';
        ELSIF c.role_static_id in ('DIPLOMADOS','SUPDIPLO') and l_return is null THEN
            l_return := 'D';
        ELSIF c.role_static_id in ('ADMINISTRATOR') THEN
            l_return := 'T';
        END IF;
    END LOOP;
    return l_return;
  END;

END toolkit;

/
--------------------------------------------------------
--  DDL for Package Body UTL_CALENDARIOS_DETALLES
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."UTL_CALENDARIOS_DETALLES" AS

    FUNCTION getTotalPeriodosCal (
        vid_calendario NUMBER
    ) RETURN NUMBER AS
        eof  NUMBER;
        dml  VARCHAR2(2000);
    BEGIN
        dml := 'SELECT count(*) FROM Calendarios_detalle WHERE id_calendario = '|| vid_calendario;

        EXECUTE IMMEDIATE dml
        INTO eof;

--DBMS_OUTPUT.PUT_LINE(dml);
        IF eof IS NULL THEN
            eof := 0;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := 0;
            RETURN eof;
        WHEN OTHERS THEN
            eof := 0;
            dbms_output.put_line('COUNT: '
                                 || sqlerrm
                                 || dml);
            RETURN eof;
    END getTotalPeriodosCal;

    FUNCTION getTotalPeriodosCalMod (
        vid_calendario NUMBER,
        vid_modalidad NUMBER
    ) RETURN NUMBER AS
        eof  NUMBER;
        dml  VARCHAR2(2000);
    BEGIN
        dml := 'SELECT count(*) FROM Calendarios_detalle WHERE id_calendario = '|| vid_calendario||' and modalidad = '||vid_modalidad;

        EXECUTE IMMEDIATE dml
        INTO eof;

--DBMS_OUTPUT.PUT_LINE(dml);
        IF eof IS NULL THEN
            eof := 0;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := 0;
            RETURN eof;
        WHEN OTHERS THEN
            eof := 0;
            dbms_output.put_line('COUNT: '
                                 || sqlerrm
                                 || dml);
            RETURN eof;
    END getTotalPeriodosCalMod;


   FUNCTION getSiguentePeriodoMod (
        vid_calendario NUMBER,
        vid_modalidad NUMBER
    ) RETURN NUMBER AS
        eof   NUMBER;
        dml   VARCHAR2(2000);
    BEGIN

        dml := 'SELECT nvl(max(periodo),0)+1 FROM Calendarios_detalle WHERE id_calendario='||vid_calendario||' and modalidad = '|| vid_modalidad;

        EXECUTE IMMEDIATE dml
        INTO eof;

DBMS_OUTPUT.PUT_LINE(dml);
        IF eof IS NULL THEN
            eof := 0;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := 0;
            RETURN eof;
        WHEN OTHERS THEN
            eof := 0;
            dbms_output.put_line('COUNT: '
                                 || sqlerrm
                                 || dml);
            RETURN eof;
    END getSiguentePeriodoMod;
    
    FUNCTION getCalendario (
        vid_calendario NUMBER
    ) RETURN VARCHAR2 AS
        eof  VARCHAR2(100);
        dml  VARCHAR2(2000);
    BEGIN
        dml := 'SELECT DESCRIPCION FROM Calendarios WHERE id_calendario = '|| vid_calendario;

        EXECUTE IMMEDIATE dml
        INTO eof;

--DBMS_OUTPUT.PUT_LINE(dml);
        IF eof IS NULL THEN
            eof := NULL;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := NULL;
            RETURN eof;
        WHEN OTHERS THEN
            eof := NULL;
            dbms_output.put_line('COUNT: '
                                 || sqlerrm
                                 || dml);
            RETURN eof;
    END getCalendario;

END utl_calendarios_detalles;

/
--------------------------------------------------------
--  DDL for Package Body UTL_CONFIGURACION
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."UTL_CONFIGURACION" AS

    FUNCTION getConfIva RETURN NUMBER IS
        eof  NUMBER;
        dml  VARCHAR2(2000);
    BEGIN
        dml := 'SELECT TASA_IVA FROM configuracion';

        EXECUTE IMMEDIATE dml
        INTO eof;

DBMS_OUTPUT.PUT_LINE(dml);
        IF eof IS NULL THEN
            eof := 0;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := 0;
            RETURN eof;
        WHEN OTHERS THEN
            eof := 0;
            dbms_output.put_line('COUNT: '
                                 || sqlerrm
                                 || dml);
            RETURN eof;
    END getConfIva;

    FUNCTION getConfUltFactura RETURN NUMBER IS
        eof  NUMBER;
        dml  VARCHAR2(2000);
    BEGIN
        dml := 'SELECT ULT_FACTURA+1 FROM configuracion';

        EXECUTE IMMEDIATE dml
        INTO eof;

DBMS_OUTPUT.PUT_LINE(dml);
        IF eof IS NULL THEN
            eof := 0;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := 0;
            RETURN eof;
        WHEN OTHERS THEN
            eof := 0;
            dbms_output.put_line('COUNT: '
                                 || sqlerrm
                                 || dml);
            RETURN eof;
    END getConfUltFactura;

    PROCEDURE actConfUltFactura(numero IN number) IS
    BEGIN

        update configuracion set ULT_FACTURA = numero;

    END actConfUltFactura;

    FUNCTION getConfPorTDC RETURN NUMBER IS
        eof  NUMBER;
        dml  VARCHAR2(2000);
    BEGIN
        dml := 'SELECT PORC_TARJ_CRE FROM configuracion';

        EXECUTE IMMEDIATE dml
        INTO eof;

DBMS_OUTPUT.PUT_LINE(dml);
        IF eof IS NULL THEN
            eof := 0;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := 0;
            RETURN eof;
        WHEN OTHERS THEN
            eof := 0;
            dbms_output.put_line('COUNT: '
                                 || sqlerrm
                                 || dml);
            RETURN eof;
    END getConfPorTDC;

    FUNCTION getConfPorTDB RETURN NUMBER IS
        eof  NUMBER;
        dml  VARCHAR2(2000);
    BEGIN
        dml := 'SELECT PORC_TARJ_DEB FROM configuracion';

        EXECUTE IMMEDIATE dml
        INTO eof;

DBMS_OUTPUT.PUT_LINE(dml);
        IF eof IS NULL THEN
            eof := 0;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := 0;
            RETURN eof;
        WHEN OTHERS THEN
            eof := 0;
            dbms_output.put_line('COUNT: '
                                 || sqlerrm
                                 || dml);
            RETURN eof;
    END getConfPorTDB;


END utl_configuracion;

/
--------------------------------------------------------
--  DDL for Package Body UTL_ESTUDIANTES
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."UTL_ESTUDIANTES" AS

    FUNCTION getTipoEstudiante (
        vid_tipoest NUMBER
    ) RETURN VARCHAR2 AS
        eof  VARCHAR2(100);
        dml  VARCHAR2(2000);
    BEGIN
        dml := 'SELECT DESCRIPCION FROM tipo_estudiante WHERE id_tipo_est = '|| vid_tipoest;

        EXECUTE IMMEDIATE dml
        INTO eof;

--DBMS_OUTPUT.PUT_LINE(dml);
        IF eof IS NULL THEN
            eof := NULL;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := NULL;
            RETURN eof;
        WHEN OTHERS THEN
            eof := NULL;
            dbms_output.put_line('COUNT: '
                                 || sqlerrm
                                 || dml);
            RETURN eof;
    END getTipoEstudiante;

END utl_estudiantes;

/
--------------------------------------------------------
--  DDL for Package Body UTL_FACTURA
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."UTL_FACTURA" AS

    FUNCTION getTotal (
        vid NUMBER
    ) RETURN NUMBER AS
        eof  NUMBER := 0;
        dml  VARCHAR2(2000);
    BEGIN
        dml := 'SELECT MONTO FROM FACTURA WHERE id = '|| vid;

        EXECUTE IMMEDIATE dml
        INTO eof;

--DBMS_OUTPUT.PUT_LINE(dml);
        IF eof = 0 THEN
            eof := 0;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := 0;
            RETURN eof;
        WHEN OTHERS THEN
            eof := 0;
            dbms_output.put_line('MONTO: '
                                 || sqlerrm
                                 || dml);
            RETURN eof;
    END getTotal;

    PROCEDURE insIngDiferido (
        vfid IN NUMBER, 
        vmonto IN NUMBER,
        vresp OUT NUMBER
    ) IS
        p_detalle_factura_rec   fundauc.tapi_detalle_factura.detalle_factura_rt;
    BEGIN

        p_detalle_factura_rec.renglon := detalle_factura_seq.nextval;
        p_detalle_factura_rec.tipo_item := 'ID';
        p_detalle_factura_rec.item := case when sign(vmonto) = -1 then 'IDN' else 'IDP' end;
        p_detalle_factura_rec.descripcion := case when sign(vmonto) = -1 then 'INGRESO DIFERIDO NEGATIVO (DIFERENCIA FACTURA)' else 'INGRESO DIFERIDO POSITIVO (DIFERENCIA FACTURA)' end;
        p_detalle_factura_rec.cantidad := 1;
        p_detalle_factura_rec.p_unidad := vmonto;
        p_detalle_factura_rec.bs_descuento := 0;
        p_detalle_factura_rec.subtotal := 1*vmonto;
        p_detalle_factura_rec.materiales_id := case when sign(vmonto) = -1 then 94 else 95 end;
        p_detalle_factura_rec.factura_id := vfid;

        tapi_detalle_factura.ins(p_detalle_factura_rec => p_detalle_factura_rec);

        vresp := 0;
    EXCEPTION
        WHEN OTHERS THEN
            vresp := 1;
            dbms_output.put_line('COUNT: '
                                 || sqlerrm
                                 );

    END insIngDiferido;

END utl_factura;

/
--------------------------------------------------------
--  DDL for Package Body UTL_FACTURA_DEPOSITO
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."UTL_FACTURA_DEPOSITO" AS 

    PROCEDURE ins_multi (
        v_jsonfac IN varchar2,
        vid_deposito IN number
    ) IS

    l_idFact     factura.id%type;
    l_values    apex_json.t_values;
    l_row_count PLS_INTEGER;
    l_monto     NUMBER := 0;
    l_total     NUMBER := 0;
    P_FACTURA_DEPOSITO_REC FUNDAUC.TAPI_FACTURA_DEPOSITO.FACTURA_DEPOSITO_RT;

    BEGIN
        apex_debug.message('inside process Bulk Update Commission');
        -- parse text to JSON
        apex_json.parse(p_values => l_values, p_source => v_jsonfac);
     -- get number of rows selected
        l_row_count := apex_json.get_count(p_path => 'rows', p_values => l_values);
        -- loop through the selected rows
        FOR i IN 1..l_row_count LOOP
         -- get Primary Key value from JSON data
         l_idFact := null;  
            l_idFact := TO_NUMBER(apex_json.get_varchar2(p_path => 'rows[%d].facId', p0 => i, p_values => l_values));
            apex_debug.message('l_idFact' || l_idFact);
            -- update employee commission

            P_FACTURA_DEPOSITO_REC.FACTURA_ID := l_idFact;
            P_FACTURA_DEPOSITO_REC.DEPOSITO_ID := vid_deposito;

            TAPI_FACTURA_DEPOSITO.INS(P_FACTURA_DEPOSITO_REC);

        END LOOP;

    END;
END UTL_FACTURA_DEPOSITO;

/
--------------------------------------------------------
--  DDL for Package Body UTL_HORARIOS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."UTL_HORARIOS" AS

    FUNCTION getTotalHorarios (
        vid_modalidad NUMBER
    ) RETURN NUMBER AS
        eof  NUMBER;
        dml  VARCHAR2(2000);
    BEGIN
        dml := 'SELECT count(*) FROM Horarios WHERE modalidad = '|| vid_modalidad;

        EXECUTE IMMEDIATE dml
        INTO eof;

--DBMS_OUTPUT.PUT_LINE(dml);
        IF eof IS NULL THEN
            eof := 0;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := 0;
            RETURN eof;
        WHEN OTHERS THEN
            eof := 0;
            dbms_output.put_line('COUNT: '
                                 || sqlerrm
                                 || dml);
            RETURN eof;
    END getTotalHorarios;

    FUNCTION getHorario (
        vid_horario NUMBER
    ) RETURN VARCHAR2 AS
        eof  VARCHAR2(100);
        dml  VARCHAR2(2000);
    BEGIN
        dml := 'SELECT to_char(HORA,''HH:MI AM'')||''-''||to_char(HORA_FIN,''HH:MI AM'') FROM Horarios WHERE id_horario = '|| vid_horario;

        EXECUTE IMMEDIATE dml
        INTO eof;

--DBMS_OUTPUT.PUT_LINE(dml);
        IF eof IS NULL THEN
            eof := NULL;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := NULL;
            RETURN eof;
        WHEN OTHERS THEN
            eof := NULL;
            dbms_output.put_line('COUNT: '
                                 || sqlerrm
                                 || dml);
            RETURN eof;
    END getHorario;

    FUNCTION getHorarioMin (
        vid_horario NUMBER
    ) RETURN VARCHAR2 AS
        eof  VARCHAR2(100);
        dml  VARCHAR2(2000);
    BEGIN
        dml := 'SELECT to_char(HORA,''HH'')||''A''||to_char(HORA_FIN,''HH'') FROM Horarios WHERE id_horario = '|| vid_horario;

        EXECUTE IMMEDIATE dml
        INTO eof;

--DBMS_OUTPUT.PUT_LINE(dml);
        IF eof IS NULL THEN
            eof := NULL;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := NULL;
            RETURN eof;
        WHEN OTHERS THEN
            eof := NULL;
            dbms_output.put_line('COUNT: '
                                 || sqlerrm
                                 || dml);
            RETURN eof;
    END getHorarioMin;

    FUNCTION getIdHorario (
        vdes_horario VARCHAR2,
        vid_modalidad NUMBER
    ) RETURN NUMBER AS
        eof  NUMBER;
        dml  VARCHAR2(2000);
    BEGIN
        dml := 'SELECT id_horario FROM Horarios WHERE to_char(HORA,''HH:MI AM'')||''-''||to_char(HORA_FIN,''HH:MI AM'') = '''||vdes_horario||''' AND modalidad= '||vid_modalidad;

        EXECUTE IMMEDIATE dml
        INTO eof;

DBMS_OUTPUT.PUT_LINE(dml);
        IF eof IS NULL THEN
            eof := NULL;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := NULL;
            RETURN eof;
        WHEN OTHERS THEN
            eof := NULL;
            dbms_output.put_line('COUNT: '
                                 || sqlerrm
                                 || dml);
            RETURN eof;
    END getIdHorario;

END utl_horarios;

/
--------------------------------------------------------
--  DDL for Package Body UTL_INSCRIPCIONES
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."UTL_INSCRIPCIONES" AS

    FUNCTION getinscripcionesseccion (
        vid_seccion NUMBER,
        vid_periodo NUMBER
    ) RETURN NUMBER AS
        eof   NUMBER;
        dml   VARCHAR2(2000);
    BEGIN
        dml := 'SELECT count(*) FROM Inscripciones WHERE estatus not in (''IF'',''IFXC'') and seccion_id = '
        || vid_seccion
        || ' and periodo_id='
        || vid_periodo;
        EXECUTE IMMEDIATE dml INTO
            eof;
        dbms_output.put_line(dml);
        IF
            eof IS NULL
        THEN
            eof := 0;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := 0;
            RETURN eof;
        WHEN OTHERS THEN
            eof := 0;
            dbms_output.put_line('COUNT: '
            || sqlerrm
            || dml);
            RETURN eof;
    END getinscripcionesseccion;

    FUNCTION getinscripcionescohorte (
        vid_cohorte NUMBER,
        vid_periodo NUMBER
    ) RETURN NUMBER AS
        eof   NUMBER;
        dml   VARCHAR2(2000);
    BEGIN
        dml := 'SELECT count(*) FROM Inscripciones WHERE estatus not in (''IF'',''IFXC'') and cohorte_id = '
        || vid_cohorte
        || ' and periodo_id='
        || vid_periodo;
        EXECUTE IMMEDIATE dml INTO
            eof;
        dbms_output.put_line(dml);
        IF
            eof IS NULL
        THEN
            eof := 0;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := 0;
            RETURN eof;
        WHEN OTHERS THEN
            eof := 0;
            dbms_output.put_line('COUNT: '
            || sqlerrm
            || dml);
            RETURN eof;
    END getinscripcionescohorte;

    FUNCTION getdesstatus (
        v_status VARCHAR2
    ) RETURN VARCHAR2 AS
        eof   VARCHAR2(50);
        dml   VARCHAR2(2000);
    BEGIN
        dml := 'SELECT CASE '
        || ' WHEN '''
        || v_status
        || ''' = ''ACXC'' THEN ''Activa en Curso, por Cobrar'''
        || ' WHEN '''
        || v_status
        || ''' = ''ACP'' THEN ''Activa en Curso, Pagada'''
        || ' WHEN '''
        || v_status
        || ''' = ''AEXC'' THEN ''Activa por Comenzar, por Cobrar'''
        || ' WHEN '''
        || v_status
        || ''' = ''AEP'' THEN ''Activa por Comenzar, Pagada'''
        || ' WHEN '''
        || v_status
        || ''' = ''IF'' THEN ''Inactiva Finalizada'''
        || ' WHEN '''
        || v_status
        || ''' = ''IFXC'' THEN ''Inactiva Finalizada, por Cobrar'''
        || ' WHEN '''
        || v_status
        || ''' = ''AN'' THEN ''Anulada'''
        || ' WHEN '''
        || v_status
        || ''' = ''AEX'' THEN ''Activa por Comenzar, Exonerado'''
        || ' WHEN '''
        || v_status
        || ''' = ''ACX'' THEN ''Activa en Curso, Exonerado'''
        || ' WHEN '''
        || v_status
        || ''' = ''AES'' THEN ''Activa por Comenzar, Suspendido'''
        || ' WHEN '''
        || v_status
        || ''' = ''ACS'' THEN ''Activa en Curso, Suspendido'''
        || ' ELSE ''No Registrada'' END ESTATUS FROM dual';

        EXECUTE IMMEDIATE dml INTO
            eof;
--DBMS_OUTPUT.PUT_LINE(v_status);
--DBMS_OUTPUT.PUT_LINE(dml);
        IF
            eof IS NULL
        THEN
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;
    EXCEPTION
        WHEN no_data_found THEN
            RETURN eof;
        WHEN OTHERS THEN
            dbms_output.put_line('COUNT: '
            || sqlerrm
            || dml);
            RETURN eof;
    END getdesstatus;

    FUNCTION getstatusfac (
        vid_insc NUMBER
    ) RETURN VARCHAR2 AS

        eof                   VARCHAR2(255);
        l_ins_fac_rec         inscripcion_factura%rowtype;
        l_factura_rec         factura%rowtype;
        l_inscripciones_rec   inscripciones%rowtype;
    BEGIN
        SELECT
            *
        INTO
            l_inscripciones_rec
        FROM
            inscripciones
        WHERE
            id = vid_insc;

        dbms_output.put_line('Entrando...'
        || vid_insc);
        dbms_output.put_line('ID='
        || vid_insc
        || ' EXONERADO '
        || l_inscripciones_rec.es_exonerado
        || ' SUSPENDIDO '
        || l_inscripciones_rec.es_suspendido);

        IF
            ( l_inscripciones_rec.es_exonerado = 'N' AND l_inscripciones_rec.es_suspendido = 'N' )
        THEN
            SELECT
                *
            INTO
                l_ins_fac_rec
            FROM
                inscripcion_factura
            WHERE
                inscripcion_id = vid_insc;

            SELECT
                *
            INTO
                l_factura_rec
            FROM
                factura
            WHERE
                id = l_ins_fac_rec.factura_id;

        END IF;

        dbms_output.put_line('ID='
        || vid_insc
        || ' EXONERADO '
        || l_inscripciones_rec.es_exonerado
        || ' SUSPENDIDO '
        || l_inscripciones_rec.es_suspendido);

        CASE
            WHEN l_inscripciones_rec.es_exonerado = 'S' THEN
                eof := '<span class="rap-badge-exonerado">EXONERADO</span>';
            WHEN l_inscripciones_rec.es_suspendido = 'S' THEN
                eof := '<span class="rap-badge-exonerado">SUSPENDIDO</span>';
            ELSE
                CASE
                    WHEN l_factura_rec.status = 'A' THEN
                        eof := '<span class="rap-badge-anulada">ANULADA</span>';
                    WHEN l_factura_rec.status = 'V' THEN
                        eof := '<span class="rap-badge-emitida">'
                        || l_factura_rec.id_fact
                        || '</span>';
                    WHEN l_factura_rec.status = 'PC' THEN
                        eof := '<span class="rap-badge-pendiente">POR COBRAR</span>';
                END CASE;
        END CASE;

        IF
            eof IS NULL
        THEN
            RETURN 'NO REGISTRADO';
        ELSE
            RETURN eof;
        END IF;
    EXCEPTION
        WHEN no_data_found THEN
            RETURN 'NO REGISTRADO';
        WHEN OTHERS THEN
            dbms_output.put_line('COUNT: '
            || sqlerrm);
            RETURN eof;
    END getstatusfac;

    PROCEDURE elimina_inscripciones IS
        l_rc   NUMBER;
    BEGIN
        l_rc := log_message('[INFO] EJECUTANDO JOB ELIMINA_INSCRIPCIONES ');
        DELETE inscripciones WHERE
            estatus = 'Activa, En Proceso';

        dbms_output.put_line('[INFO] JOB EJECUTADO');
        l_rc := log_message('[INFO] JOB ELIMINA_INSCRIPCIONES EJECUTADO');
    END;

    PROCEDURE actualiza_estatus IS
        l_rc   NUMBER;
    BEGIN
        l_rc := log_message('[INFO] EJECUTANDO JOB ACTUALIZA ESTATUS INSCRIPCIONES ');
        FOR cur IN (
            SELECT
                id,
                CASE
                        WHEN utl_periodos.getstatusperiodosec(seccion_id) = 'Finalizado'
                             AND (
                            CASE
                                WHEN instr(utl_inscripciones.getstatusfac(id),'EXONERADO') > 1  THEN 'E'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'SUSPENDIDO') > 1 THEN 'S'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'POR COBRAR') > 1 THEN 'PC'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'ANULADA') > 1    THEN 'A'
                                ELSE 'X'
                            END
                        ) = 'PC' THEN 'IFXC'
                        WHEN utl_periodos.getstatusperiodosec(seccion_id) = 'Finalizado'   THEN 'IF'
                        WHEN utl_periodos.getstatusperiodosec(seccion_id) = 'En Curso'
                             AND fecha_ins + 9 < TO_DATE(token(substr(utl_periodos.getperiodo(107),4),1,'-'),'DD/MM/YYYY')
                             AND (
                            CASE
                                WHEN instr(utl_inscripciones.getstatusfac(id),'EXONERADO') > 1  THEN 'E'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'SUSPENDIDO') > 1 THEN 'S'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'POR COBRAR') > 1 THEN 'PC'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'ANULADA') > 1    THEN 'A'
                                ELSE 'X'
                            END
                        ) <> 'PC' THEN 'IF'
                        WHEN utl_periodos.getstatusperiodosec(seccion_id) = 'En Curso'
                             AND (
                            CASE
                                WHEN instr(utl_inscripciones.getstatusfac(id),'EXONERADO') > 1  THEN 'E'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'SUSPENDIDO') > 1 THEN 'S'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'POR COBRAR') > 1 THEN 'PC'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'ANULADA') > 1    THEN 'A'
                                ELSE 'X'
                            END
                        ) = 'X' THEN 'ACP'
                        WHEN utl_periodos.getstatusperiodosec(seccion_id) = 'En Curso'
                             AND (
                            CASE
                                WHEN instr(utl_inscripciones.getstatusfac(id),'EXONERADO') > 1  THEN 'E'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'SUSPENDIDO') > 1 THEN 'S'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'POR COBRAR') > 1 THEN 'PC'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'ANULADA') > 1    THEN 'A'
                                ELSE 'X'
                            END
                        ) = 'PC' THEN 'ACXC'
                        WHEN utl_periodos.getstatusperiodosec(seccion_id) = 'En Curso'
                             AND (
                            CASE
                                WHEN instr(utl_inscripciones.getstatusfac(id),'EXONERADO') > 1  THEN 'E'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'SUSPENDIDO') > 1 THEN 'S'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'POR COBRAR') > 1 THEN 'PC'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'ANULADA') > 1    THEN 'A'
                                ELSE 'X'
                            END
                        ) = 'E' THEN 'ACX'
                        WHEN utl_periodos.getstatusperiodosec(seccion_id) = 'En Curso'
                             AND (
                            CASE
                                WHEN instr(utl_inscripciones.getstatusfac(id),'EXONERADO') > 1  THEN 'E'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'SUSPENDIDO') > 1 THEN 'S'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'POR COBRAR') > 1 THEN 'PC'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'ANULADA') > 1    THEN 'A'
                                ELSE 'X'
                            END
                        ) = 'S' THEN 'ACS'
                        WHEN utl_periodos.getstatusperiodosec(seccion_id) = 'Por Comenzar'
                             AND (
                            CASE
                                WHEN instr(utl_inscripciones.getstatusfac(id),'EXONERADO') > 1  THEN 'E'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'SUSPENDIDO') > 1 THEN 'S'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'POR COBRAR') > 1 THEN 'PC'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'ANULADA') > 1    THEN 'A'
                                ELSE 'X'
                            END
                        ) = 'X' THEN 'AEP'
                        WHEN utl_periodos.getstatusperiodosec(seccion_id) = 'Por Comenzar'
                             AND (
                            CASE
                                WHEN instr(utl_inscripciones.getstatusfac(id),'EXONERADO') > 1  THEN 'E'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'SUSPENDIDO') > 1 THEN 'S'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'POR COBRAR') > 1 THEN 'PC'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'ANULADA') > 1    THEN 'A'
                                ELSE 'X'
                            END
                        ) = 'PC' THEN 'AEXC'
                        WHEN utl_periodos.getstatusperiodosec(seccion_id) = 'Por Comenzar'
                             AND (
                            CASE
                                WHEN instr(utl_inscripciones.getstatusfac(id),'EXONERADO') > 1  THEN 'E'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'SUSPENDIDO') > 1 THEN 'S'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'POR COBRAR') > 1 THEN 'PC'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'ANULADA') > 1    THEN 'A'
                                ELSE 'X'
                            END
                        ) = 'E' THEN 'AEX'
                        WHEN utl_periodos.getstatusperiodosec(seccion_id) = 'Por Comenzar'
                             AND (
                            CASE
                                WHEN instr(utl_inscripciones.getstatusfac(id),'EXONERADO') > 1  THEN 'E'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'SUSPENDIDO') > 1 THEN 'S'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'POR COBRAR') > 1 THEN 'PC'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'ANULADA') > 1    THEN 'A'
                                ELSE 'X'
                            END
                        ) = 'S' THEN 'AES'
                        WHEN (
                            CASE
                                WHEN instr(utl_inscripciones.getstatusfac(id),'EXONERADO') > 1  THEN 'E'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'SUSPENDIDO') > 1 THEN 'S'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'POR COBRAR') > 1 THEN 'PC'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'ANULADA') > 1    THEN 'A'
                                ELSE 'X'
                            END
                        ) = 'A' THEN 'AN'
                    END
                estatus
            FROM
                inscripciones
            WHERE
                estatus <> 'IF'
        ) LOOP
            EXECUTE IMMEDIATE 'update inscripciones set estatus='''
            || cur.estatus
            || ''' where id='
            || cur.id;
        END LOOP;

        dbms_output.put_line('[INFO] JOB EJECUTADO');
        l_rc := log_message('[INFO] JOB ACTUALIZA_ESTATUS EJECUTADO');
    END;

    PROCEDURE actualiza_est_ins (
        facturas IN VARCHAR2
    )
        IS
    BEGIN
        UPDATE inscripciones i
            SET
                estatus = (
                    SELECT
                            CASE
                                WHEN utl_periodos.getstatusperiodosec(seccion_id) = 'Finalizado'
                                     AND (
                                    CASE
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'EXONERADO') > 1  THEN 'E'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'SUSPENDIDO') > 1 THEN 'S'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'POR COBRAR') > 1 THEN 'PC'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'ANULADA') > 1    THEN 'A'
                                        ELSE 'X'
                                    END
                                ) = 'PC' THEN 'IFXC'
                                WHEN utl_periodos.getstatusperiodosec(seccion_id) = 'Finalizado'   THEN 'IF'
                                WHEN utl_periodos.getstatusperiodosec(seccion_id) = 'En Curso'
                                     AND fecha_ins + 9 < TO_DATE(token(substr(utl_periodos.getperiodo(107),4),1,'-'),'DD/MM/YYYY')
                                     AND (
                                    CASE
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'EXONERADO') > 1  THEN 'E'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'SUSPENDIDO') > 1 THEN 'S'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'POR COBRAR') > 1 THEN 'PC'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'ANULADA') > 1    THEN 'A'
                                        ELSE 'X'
                                    END
                                ) <> 'PC' THEN 'IF'
                                WHEN utl_periodos.getstatusperiodosec(seccion_id) = 'En Curso'
                                     AND (
                                    CASE
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'EXONERADO') > 1  THEN 'E'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'SUSPENDIDO') > 1 THEN 'S'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'POR COBRAR') > 1 THEN 'PC'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'ANULADA') > 1    THEN 'A'
                                        ELSE 'X'
                                    END
                                ) = 'X' THEN 'ACP'
                                WHEN utl_periodos.getstatusperiodosec(seccion_id) = 'En Curso'
                                     AND (
                                    CASE
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'EXONERADO') > 1  THEN 'E'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'SUSPENDIDO') > 1 THEN 'S'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'POR COBRAR') > 1 THEN 'PC'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'ANULADA') > 1    THEN 'A'
                                        ELSE 'X'
                                    END
                                ) = 'PC' THEN 'ACXC'
                                WHEN utl_periodos.getstatusperiodosec(seccion_id) = 'En Curso'
                                     AND (
                                    CASE
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'EXONERADO') > 1  THEN 'E'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'SUSPENDIDO') > 1 THEN 'S'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'POR COBRAR') > 1 THEN 'PC'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'ANULADA') > 1    THEN 'A'
                                        ELSE 'X'
                                    END
                                ) = 'E' THEN 'ACX'
                                WHEN utl_periodos.getstatusperiodosec(seccion_id) = 'En Curso'
                                     AND (
                                    CASE
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'EXONERADO') > 1  THEN 'E'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'SUSPENDIDO') > 1 THEN 'S'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'POR COBRAR') > 1 THEN 'PC'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'ANULADA') > 1    THEN 'A'
                                        ELSE 'X'
                                    END
                                ) = 'S' THEN 'ACS'
                                WHEN utl_periodos.getstatusperiodosec(seccion_id) = 'Por Comenzar'
                                     AND (
                                    CASE
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'EXONERADO') > 1  THEN 'E'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'SUSPENDIDO') > 1 THEN 'S'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'POR COBRAR') > 1 THEN 'PC'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'ANULADA') > 1    THEN 'A'
                                        ELSE 'X'
                                    END
                                ) = 'X' THEN 'AEP'
                                WHEN utl_periodos.getstatusperiodosec(seccion_id) = 'Por Comenzar'
                                     AND (
                                    CASE
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'EXONERADO') > 1  THEN 'E'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'SUSPENDIDO') > 1 THEN 'S'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'POR COBRAR') > 1 THEN 'PC'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'ANULADA') > 1    THEN 'A'
                                        ELSE 'X'
                                    END
                                ) = 'PC' THEN 'AEXC'
                                WHEN utl_periodos.getstatusperiodosec(seccion_id) = 'Por Comenzar'
                                     AND (
                                    CASE
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'EXONERADO') > 1  THEN 'E'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'SUSPENDIDO') > 1 THEN 'S'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'POR COBRAR') > 1 THEN 'PC'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'ANULADA') > 1    THEN 'A'
                                        ELSE 'X'
                                    END
                                ) = 'E' THEN 'AEX'
                                WHEN utl_periodos.getstatusperiodosec(seccion_id) = 'Por Comenzar'
                                     AND (
                                    CASE
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'EXONERADO') > 1  THEN 'E'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'SUSPENDIDO') > 1 THEN 'S'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'POR COBRAR') > 1 THEN 'PC'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'ANULADA') > 1    THEN 'A'
                                        ELSE 'X'
                                    END
                                ) = 'S' THEN 'AES'
                                WHEN (
                                    CASE
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'EXONERADO') > 1  THEN 'E'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'SUSPENDIDO') > 1 THEN 'S'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'POR COBRAR') > 1 THEN 'PC'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'ANULADA') > 1    THEN 'A'
                                        ELSE 'X'
                                    END
                                ) = 'A' THEN 'AN'
                            END
                        estatus
                    FROM
                        inscripciones
                    WHERE
                        id = i.id
                )
        WHERE
            estatus <> 'IF'
            AND   id IN (
                SELECT
                    regexp_substr(facturas,'[^:]+',1,level)
                FROM
                    dual
                CONNECT BY
                    regexp_substr(facturas,'[^:]+',1,level) IS NOT NULL
            );

    END;

    FUNCTION log_message (
        message IN VARCHAR2
    ) RETURN NUMBER AS
        l_id   NUMBER;
    BEGIN
        BEGIN
            SELECT
                ( nvl(MAX(log_id),0) + 1 )
            INTO
                l_id
            FROM
                job_log;

            INSERT INTO job_log (
                log_id,
                log_message,
                log_time
            ) VALUES (
                l_id,
                message,
                SYSDATE
            );

            RETURN 0;
        EXCEPTION
            WHEN OTHERS THEN
                dbms_output.put_line('[INFO] ERROR WHILE LOG_MESSAGE '
                || sqlcode
                || ' '
                || substr(sqlerrm,1,64) );

                RETURN 1;
        END;
    END log_message;

    FUNCTION getseccionrec (
        p_renglon   IN detalle_factura.renglon%TYPE
    ) RETURN seccion_rt
        RESULT_CACHE
    IS
        l_seccion_rec   seccion_rt;
        l_fecha_ini     DATE;
    BEGIN
        SELECT
            item,
            token(descripcion,1,'|') id_metodo,
            to_number(replace(token(descripcion,2,'|'),'NIVEL ','') ) nivel,
            utl_horarios.getidhorario(token(descripcion,3,'|'),utl_modalidades.getidmodalidad(token(descripcion,5,'|') ) ) id_horario,
            utl_modalidades.getidmodalidad(token(descripcion,5,'|') ) id_modalidad,
            TO_DATE(token(descripcion,4,'|'),'DD/MM/YYYY') fecha_ini
        INTO
            l_seccion_rec.seccion_id,l_seccion_rec.id_metodo,l_seccion_rec.nivel,l_seccion_rec.id_horario,l_seccion_rec.id_modalidad,l_fecha_ini
        FROM
            detalle_factura
        WHERE
            renglon = p_renglon;

    /*  DBMS_OUTPUT.PUT_LINE('Renglon='||p_renglon);
      DBMS_OUTPUT.PUT_LINE('SeccionID='||l_seccion_rec.seccion_id);
      DBMS_OUTPUT.PUT_LINE('IdMetodo='||l_seccion_rec.id_metodo);
      DBMS_OUTPUT.PUT_LINE('Nivel='||l_seccion_rec.nivel);
      DBMS_OUTPUT.PUT_LINE('Horario='||l_seccion_rec.id_horario);
      DBMS_OUTPUT.PUT_LINE('id_modalidad='||l_seccion_rec.id_modalidad);
      DBMS_OUTPUT.PUT_LINE('fecha_ini='||to_char(l_fecha_ini,'DDMMYYYY'));*/

        SELECT
            id
        INTO
            l_seccion_rec.id_periodo
        FROM
            calendarios_detalle cd,
            metodos m
        WHERE
            modalidad = l_seccion_rec.id_modalidad
            AND   fecha_ini = l_fecha_ini
            AND   m.id_metodo = l_seccion_rec.id_metodo
            AND   m.id_calendario = cd.id_calendario;

    --  DBMS_OUTPUT.PUT_LINE('id_periodo='||l_seccion_rec.id_periodo);

        RETURN l_seccion_rec;
    EXCEPTION
        WHEN no_data_found THEN
            l_seccion_rec := NULL;
            RETURN l_seccion_rec;
    END getseccionrec;

    FUNCTION getsecciondes (
        p_id_seccion   IN secciones.id%TYPE
    ) RETURN VARCHAR2 IS
        l_seccion_des   VARCHAR2(255);
    BEGIN
        SELECT
            s.id_seccion
            || '|'
            || s.id_metodo
            || '|NIVEL '
            || lpad(s.nivel,2,'0')
            || '|'
            || utl_horarios.gethorario(s.id_horario)
            || '|'
            || TO_CHAR(cd.fecha_ini,'DD/MM/YYYY')
            || '|'
            || m.descripcion
            || '|'
            || id_salon seccion
        INTO
            l_seccion_des
        FROM
            secciones s,
            modalidades m,
            calendarios_detalle cd
        WHERE
            s.id = p_id_seccion
            AND   s.modalidad = m.id_modalidad
            AND   s.periodo = cd.id;

    --  DBMS_OUTPUT.PUT_LINE('id_periodo='||l_seccion_rec.id_periodo);

        RETURN l_seccion_des;
    EXCEPTION
        WHEN no_data_found THEN
            l_seccion_des := NULL;
            RETURN l_seccion_des;
    END getsecciondes;

    FUNCTION getseccioncod (
        p_id_secc   IN secciones.id%TYPE
    ) RETURN VARCHAR2 IS
        l_seccion_des   VARCHAR2(255);
    BEGIN
        SELECT
            s.id_seccion
        INTO
            l_seccion_des
        FROM
            secciones s
        WHERE
            s.id = p_id_secc;

    --  DBMS_OUTPUT.PUT_LINE('id_periodo='||l_seccion_rec.id_periodo);

        RETURN l_seccion_des;
    EXCEPTION
        WHEN no_data_found THEN
            l_seccion_des := NULL;
            RETURN l_seccion_des;
    END getseccioncod;

    FUNCTION getcohortedes (
        p_id_cohorte   IN cohortes.id%TYPE
    ) RETURN VARCHAR2 IS
        l_cohorte_des   VARCHAR2(255);
    BEGIN
        SELECT
            upper(descripcion
            || ' - '
            || cd.nombre) des
        INTO
            l_cohorte_des
        FROM
            diplomados d,
            cohortes c,
            ciudades cd
        WHERE
            c.id = p_id_cohorte
            AND   c.diplomado_id = d.id
            AND   c.id_ciudad = cd.id_ciudad;

    --  DBMS_OUTPUT.PUT_LINE('id_periodo='||l_seccion_rec.id_periodo);

        RETURN l_cohorte_des;
    EXCEPTION
        WHEN no_data_found THEN
            l_cohorte_des := NULL;
            RETURN l_cohorte_des;
    END getcohortedes;

    FUNCTION getcodigoseccion (
        metodo_id      IN VARCHAR2,
        nivel          IN NUMBER,
        periodo_id     IN NUMBER,
        modalidad_id   IN NUMBER,
        horario_id     IN NUMBER
    ) RETURN VARCHAR2 AS

        l_codigo       VARCHAR2(50);
        l_codigo_new   VARCHAR2(50);
        l_letra        VARCHAR2(1);
        l_num          NUMBER;
        incompleto EXCEPTION;

        FUNCTION codif (
            num NUMBER
        ) RETURN VARCHAR2 AS
            let   VARCHAR2(1);
        BEGIN
            SELECT
                translate(TO_CHAR(num),'123456789','ABCDEFGHI')
            INTO
                let
            FROM
                dual;

            RETURN let;
        END codif;

        FUNCTION decod (
            let VARCHAR2
        ) RETURN NUMBER AS
            num   NUMBER;
        BEGIN
            SELECT
                translate(TO_CHAR(let),'ABCDEFGHI','123456789')
            INTO
                num
            FROM
                dual;

            RETURN num;
        END decod;

        PROCEDURE display (
            p_obj IN VARCHAR2
        )
            IS
        BEGIN
            dbms_output.put_line(p_obj);
        END;

    BEGIN
    
        if metodo_id is null or nivel is null or periodo_id is null or modalidad_id is null or horario_id is null then
            raise incompleto;
        end if;
        SELECT
            '('
            || metodo_id
            || '|'
            || lpad(nivel,2,'0')
            || '|'
            || periodo_id
            || '|'
            || utl_modalidades.getsiglas(modalidad_id)
            || '|'
            || utl_horarios.gethorariomin(horario_id)
            || ')' codigo
        INTO
            l_codigo_new
        FROM
            dual;

 
            l_letra := codif(1);
  --  display('l_codigo_new1='||i.codigo);
            SELECT
                MAX(id_seccion)
            INTO
                l_codigo
            FROM
                secciones
            WHERE
                substr(id_seccion,1,length(id_seccion) - 1) = l_codigo_new;
        
    --    display('l_codigo1='||l_codigo);

            IF
                l_codigo IS NULL
            THEN
   --         display('l codigo is null');
                l_letra := codif(1);
                RETURN l_codigo_new
                || l_letra; 
   --         display(i.codigo||l_letra);
            ELSE
                l_letra := substr(l_codigo,length(l_codigo),1);
   --         display('l_letra1='||l_letra);
                l_num := decod(l_letra) + 1;
   --         display('l_num='||l_num);
                l_letra := codif(l_num);
   --         display('l_letra2='||l_letra);
                RETURN l_codigo_new
                || l_letra; 
   --         display(i.codigo||l_letra);
            END IF;

        EXCEPTION
            WHEN incompleto THEN
                dbms_output.put_line('Parametros Incompletos');
                RETURN 'INCOMPLETO';
            WHEN no_data_found THEN
                l_letra := codif(1);
                RETURN l_codigo_new
                || l_letra;
            WHEN OTHERS THEN
                display(l_codigo_new
                || l_letra);
                RETURN 'INCOMPLETO';

    END getcodigoseccion;

END utl_inscripciones;

/
--------------------------------------------------------
--  DDL for Package Body UTL_MATERIALES
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."UTL_MATERIALES" IS

    FUNCTION getrecdetallefac (
        vid_material NUMBER,
        vtipo_mat VARCHAR2
    ) RETURN detalle_factura_rt
        RESULT_CACHE
    IS
        l_detalle_factura_rec detalle_factura_rt;
    BEGIN
        IF vtipo_mat = 'C' THEN
            SELECT
                0 renglon,
                tipo,
                id_mat,
                descripcion
                || ' '
                || DECODE(m.iva_exento, 'S', '(E)', NULL) descripcion,
                1 cantidad,
                p.precio1,
                0 bs_descuento,
                1 * p.precio1 subtotal,
                m.id,
                0 factura_id
            INTO l_detalle_factura_rec
            FROM
                materiales   m,
                precios      p
            WHERE
                m.id = p.id
                AND seccion_id = vid_material;

        ELSE
            SELECT
                0 renglon,
                tipo,
                id_mat,
                descripcion
                || ' '
                || DECODE(m.iva_exento, 'S', '(E)', NULL) descripcion,
                1 cantidad,
                p.precio1,
                0 bs_descuento,
                1 * p.precio1 subtotal,
                m.id,
                0 factura_id
            INTO l_detalle_factura_rec
            FROM
                materiales   m,
                precios      p
            WHERE
                m.id = p.id
                AND m.id = vid_material;

        END IF;

        RETURN l_detalle_factura_rec;
    EXCEPTION
        WHEN no_data_found THEN
            l_detalle_factura_rec := NULL;
            RETURN l_detalle_factura_rec;
        WHEN OTHERS THEN
            l_detalle_factura_rec := NULL;
            dbms_output.put_line('COUNT: ' || sqlerrm);
            RETURN l_detalle_factura_rec;
    END getrecdetallefac;

    FUNCTION getrecdetallefac (
        vcod_mat VARCHAR2
    ) RETURN detalle_factura_rt
        RESULT_CACHE
    IS
        l_detalle_factura_rec detalle_factura_rt;
    BEGIN
            SELECT
                0 renglon,
                tipo,
                id_mat,
                descripcion
                || ' '
                || DECODE(m.iva_exento, 'S', '(E)', NULL) descripcion,
                1 cantidad,
                p.precio1,
                0 bs_descuento,
                1 * p.precio1 subtotal,
                m.id,
                0 factura_id
            INTO l_detalle_factura_rec
            FROM
                materiales   m,
                precios      p
            WHERE
                m.id = p.id
                AND m.id_mat = vcod_mat;

        RETURN l_detalle_factura_rec;
    EXCEPTION
        WHEN no_data_found THEN
            l_detalle_factura_rec := NULL;
            RETURN l_detalle_factura_rec;
        WHEN OTHERS THEN
            l_detalle_factura_rec := NULL;
            dbms_output.put_line('COUNT: ' || sqlerrm);
            RETURN l_detalle_factura_rec;
    END getrecdetallefac;

    FUNCTION getexentoiva (
        vid_material NUMBER
    ) RETURN CHAR IS
        resp char(1);
    BEGIN
        SELECT
            iva_exento
        INTO resp
        FROM
            materiales m
        WHERE
            id = vid_material;

            RETURN resp;

    EXCEPTION
        WHEN no_data_found THEN
            resp := 'N';
            RETURN resp;
        WHEN OTHERS THEN
            resp := 'N';
            dbms_output.put_line('COUNT: ' || sqlerrm);
            RETURN resp;
    END getexentoiva;

END utl_materiales;

/
--------------------------------------------------------
--  DDL for Package Body UTL_MODALIDADES
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."UTL_MODALIDADES" AS

    FUNCTION getModalidad (
        vid_modalidad NUMBER
    ) RETURN VARCHAR2 AS
        eof  VARCHAR2(100);
        dml  VARCHAR2(2000);
    BEGIN
        dml := 'SELECT DESCRIPCION FROM Modalidades WHERE id_modalidad = '|| vid_modalidad;

        EXECUTE IMMEDIATE dml
        INTO eof;

--DBMS_OUTPUT.PUT_LINE(dml);
        IF eof IS NULL THEN
            eof := NULL;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := NULL;
            RETURN eof;
        WHEN OTHERS THEN
            eof := NULL;
            dbms_output.put_line('COUNT: '
                                 || sqlerrm
                                 || dml);
            RETURN eof;
    END getModalidad;
    
    FUNCTION getSiglas (
        vid_modalidad NUMBER
    ) RETURN VARCHAR2 AS
        eof  VARCHAR2(100);
        dml  VARCHAR2(2000);
    BEGIN
        dml := 'SELECT SIGLAS FROM Modalidades WHERE id_modalidad = '|| vid_modalidad;

        EXECUTE IMMEDIATE dml
        INTO eof;

--DBMS_OUTPUT.PUT_LINE(dml);
        IF eof IS NULL THEN
            eof := NULL;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := NULL;
            RETURN eof;
        WHEN OTHERS THEN
            eof := NULL;
            dbms_output.put_line('COUNT: '
                                 || sqlerrm
                                 || dml);
            RETURN eof;
    END getSiglas;

    FUNCTION getIdModalidad (
        vdes_modalidad VARCHAR2
    ) RETURN NUMBER AS
        eof  NUMBER;
        dml  VARCHAR2(2000);
    BEGIN
        dml := 'SELECT id_modalidad FROM Modalidades WHERE DESCRIPCION = '''||vdes_modalidad||'''';

        EXECUTE IMMEDIATE dml
        INTO eof;

--DBMS_OUTPUT.PUT_LINE(dml);
        IF eof IS NULL THEN
            eof := NULL;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := NULL;
            RETURN eof;
        WHEN OTHERS THEN
            eof := NULL;
            dbms_output.put_line('COUNT: '
                                 || sqlerrm
                                 || dml);
            RETURN eof;
    END getIdModalidad;

END utl_modalidades;

/
--------------------------------------------------------
--  DDL for Package Body UTL_PERIODOS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."UTL_PERIODOS" AS

    FUNCTION getTotalPeriodos (
        vid_calendario NUMBER
    ) RETURN NUMBER AS
        eof  NUMBER;
        dml  VARCHAR2(2000);
    BEGIN
        dml := 'SELECT count(*) FROM calendarios_detalle WHERE id_calendario = '|| vid_calendario;

        EXECUTE IMMEDIATE dml
        INTO eof;

--DBMS_OUTPUT.PUT_LINE(dml);
        IF eof IS NULL THEN
            eof := 0;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := 0;
            RETURN eof;
        WHEN OTHERS THEN
            eof := 0;
            dbms_output.put_line('COUNT: '
                                 || sqlerrm
                                 || dml);
            RETURN eof;
    END getTotalPeriodos;

    FUNCTION getPeriodo (
        vid_periodo NUMBER
    ) RETURN VARCHAR2 AS
        eof  VARCHAR2(100);
        dml  VARCHAR2(2000);
    BEGIN
        dml := 'SELECT ''(''||ID||'') ''||TO_CHAR(FECHA_INI,''DD/MM/YYYY'')||''-''||TO_CHAR(FECHA_FIN,''DD/MM/YYYY'') FROM calendarios_detalle WHERE id = '|| vid_periodo;

        EXECUTE IMMEDIATE dml
        INTO eof;

--DBMS_OUTPUT.PUT_LINE(dml);
        IF eof IS NULL THEN
            eof := NULL;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := NULL;
            RETURN eof;
        WHEN OTHERS THEN
            eof := NULL;
            dbms_output.put_line('COUNT: '
                                 || sqlerrm
                                 || dml);
            RETURN eof;
    END getPeriodo;

    FUNCTION getPeriodoFInicio (
        vid_periodo NUMBER
    ) RETURN DATE AS
        eof  DATE;
        dml  VARCHAR2(2000);
    BEGIN
        dml := 'SELECT FECHA_INI FROM calendarios_detalle WHERE id = '|| vid_periodo;

        EXECUTE IMMEDIATE dml
        INTO eof;

--DBMS_OUTPUT.PUT_LINE(dml);
        IF eof IS NULL THEN
            eof := NULL;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := NULL;
            RETURN eof;
        WHEN OTHERS THEN
            eof := NULL;
            dbms_output.put_line('COUNT: '
                                 || sqlerrm
                                 || dml);
            RETURN eof;
    END getPeriodoFInicio;

    FUNCTION getPeriodoFFin (
        vid_periodo NUMBER
    ) RETURN DATE AS
        eof  DATE;
        dml  VARCHAR2(2000);
    BEGIN
        dml := 'SELECT FECHA_FIN FROM calendarios_detalle WHERE id = '|| vid_periodo;

        EXECUTE IMMEDIATE dml
        INTO eof;

--DBMS_OUTPUT.PUT_LINE(dml);
        IF eof IS NULL THEN
            eof := NULL;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := NULL;
            RETURN eof;
        WHEN OTHERS THEN
            eof := NULL;
            dbms_output.put_line('COUNT: '
                                 || sqlerrm
                                 || dml);
            RETURN eof;
    END getPeriodoFFin;


    FUNCTION getPeriodoSec (
        vid_seccion NUMBER
    ) RETURN VARCHAR2 AS
        eof  VARCHAR2(100);
        dml  VARCHAR2(2000);
        l_periodo number;
    BEGIN

        select periodo into l_periodo from secciones where id = vid_seccion;

        dml := 'SELECT ''(''||ID||'') ''||TO_CHAR(FECHA_INI,''DD/MM/YYYY'')||''-''||TO_CHAR(FECHA_FIN,''DD/MM/YYYY'') FROM calendarios_detalle WHERE id = '|| l_periodo;

        EXECUTE IMMEDIATE dml
        INTO eof;

--DBMS_OUTPUT.PUT_LINE(dml);
        IF eof IS NULL THEN
            eof := NULL;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := NULL;
            RETURN eof;
        WHEN OTHERS THEN
            eof := NULL;
            dbms_output.put_line('COUNT: '
                                 || sqlerrm
                                 || dml);
            RETURN eof;
    END getPeriodoSec;

    FUNCTION getPeriodoCor (
        vid_cohorte NUMBER
    ) RETURN VARCHAR2 AS
        eof  VARCHAR2(100);
        dml  VARCHAR2(2000);
        l_periodo number;
    BEGIN

        select periodo into l_periodo from cohortes where id = vid_cohorte;

        dml := 'SELECT ''(''||ID||'') ''||TO_CHAR(FECHA_INI,''DD/MM/YYYY'')||''-''||TO_CHAR(FECHA_FIN,''DD/MM/YYYY'') FROM calendarios_detalle WHERE id = '|| l_periodo;

        EXECUTE IMMEDIATE dml
        INTO eof;

--DBMS_OUTPUT.PUT_LINE(dml);
        IF eof IS NULL THEN
            eof := NULL;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := NULL;
            RETURN eof;
        WHEN OTHERS THEN
            eof := NULL;
            dbms_output.put_line('COUNT: '
                                 || sqlerrm
                                 || dml);
            RETURN eof;
    END getPeriodoCor;

    FUNCTION getStatusPeriodo (
        vid_periodo NUMBER
    ) RETURN VARCHAR2 AS
        l_fini date;
        l_ffin date;
        l_hoy date := sysdate;
        eof varchar(20);
    BEGIN
        SELECT FECHA_INI,FECHA_FIN into l_fini, l_ffin FROM calendarios_detalle WHERE id = vid_periodo;

        CASE
          WHEN l_hoy BETWEEN l_fini and l_ffin THEN eof := 'En Curso';
          WHEN l_hoy < l_fini THEN eof := 'Por Comenzar';
          WHEN l_hoy > l_ffin THEN eof := 'Finalizado';
        END CASE;

--DBMS_OUTPUT.PUT_LINE(dml);
        IF eof IS NULL THEN
            eof := 'Finalizado';
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := 'Finalizado';
            RETURN eof;
        WHEN OTHERS THEN
            eof := 'Finalizado';
            dbms_output.put_line('STATUS: '
                                 || sqlerrm);
            RETURN eof;
    END getStatusPeriodo;

    FUNCTION getStatusPeriodoSec (
        vid_seccion NUMBER
    ) RETURN VARCHAR2 AS
        l_fini date;
        l_ffin date;
        l_periodo number;
        l_hoy date := sysdate;
        eof varchar(20);
    BEGIN

        SELECT periodo into l_periodo from secciones where id = vid_seccion;

        SELECT FECHA_INI,FECHA_FIN into l_fini, l_ffin FROM calendarios_detalle WHERE id = l_periodo;

        CASE
          WHEN l_hoy BETWEEN l_fini and l_ffin THEN eof := 'En Curso';
          WHEN l_hoy < l_fini THEN eof := 'Por Comenzar';
          WHEN l_hoy > l_ffin THEN eof := 'Finalizado';
        END CASE;

--DBMS_OUTPUT.PUT_LINE(dml);
        IF eof IS NULL THEN
            eof := NULL;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := 'Finalizado';
            RETURN eof;
        WHEN OTHERS THEN
            eof := NULL;
            dbms_output.put_line('STATUS: '
                                 || sqlerrm);
            RETURN eof;
    END getStatusPeriodoSec;
    
    FUNCTION getPeriodoFecIniSec (
        vid_seccion NUMBER
    ) RETURN DATE AS
        eof  DATE;
        dml  VARCHAR2(2000);
        l_periodo number;
    BEGIN

        select periodo into l_periodo from secciones where id = vid_seccion;

        dml := 'SELECT FECHA_INI FROM calendarios_detalle WHERE id = '|| l_periodo;

        EXECUTE IMMEDIATE dml
        INTO eof;

--DBMS_OUTPUT.PUT_LINE(dml);
        IF eof IS NULL THEN
            eof := NULL;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := NULL;
            RETURN eof;
        WHEN OTHERS THEN
            eof := NULL;
            dbms_output.put_line('COUNT: '
                                 || sqlerrm
                                 || dml);
            RETURN eof;
    END getPeriodoFecIniSec;

    FUNCTION getPeriodoFecFinSec (
        vid_seccion NUMBER
    ) RETURN DATE AS
        eof  DATE;
        dml  VARCHAR2(2000);
        l_periodo number;
    BEGIN

        select periodo into l_periodo from secciones where id = vid_seccion;

        dml := 'SELECT FECHA_FIN FROM calendarios_detalle WHERE id = '|| l_periodo;

        EXECUTE IMMEDIATE dml
        INTO eof;

--DBMS_OUTPUT.PUT_LINE(dml);
        IF eof IS NULL THEN
            eof := NULL;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := NULL;
            RETURN eof;
        WHEN OTHERS THEN
            eof := NULL;
            dbms_output.put_line('COUNT: '
                                 || sqlerrm
                                 || dml);
            RETURN eof;
    END getPeriodoFecFinSec;


    FUNCTION getPeriodoFecIniCor (
        vid_cohorte NUMBER
    ) RETURN DATE AS
        eof  DATE;
        dml  VARCHAR2(2000);
        l_periodo number;
    BEGIN

        select periodo into l_periodo from cohortes where id = vid_cohorte;

        dml := 'SELECT FECHA_INI FROM calendarios_detalle WHERE id = '|| l_periodo;

        EXECUTE IMMEDIATE dml
        INTO eof;

--DBMS_OUTPUT.PUT_LINE(dml);
        IF eof IS NULL THEN
            eof := NULL;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := NULL;
            RETURN eof;
        WHEN OTHERS THEN
            eof := NULL;
            dbms_output.put_line('COUNT: '
                                 || sqlerrm
                                 || dml);
            RETURN eof;
    END getPeriodoFecIniCor;


    FUNCTION getStatusPeriodoCor (
        vid_cohorte NUMBER
    ) RETURN VARCHAR2 AS
        l_fini date;
        l_ffin date;
        l_periodo number;
        l_hoy date := sysdate;
        eof varchar(20);
    BEGIN

        SELECT periodo into l_periodo from cohortes where id = vid_cohorte;

        SELECT FECHA_INI,FECHA_FIN into l_fini, l_ffin FROM calendarios_detalle WHERE id = l_periodo;

        CASE
          WHEN l_hoy BETWEEN l_fini and l_ffin THEN eof := 'En Curso';
          WHEN l_hoy < l_fini THEN eof := 'Por Comenzar';
          WHEN l_hoy > l_ffin THEN eof := 'Finalizado';
        END CASE;

--DBMS_OUTPUT.PUT_LINE(dml);
        IF eof IS NULL THEN
            eof := NULL;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := 'Finalizado';
            RETURN eof;
        WHEN OTHERS THEN
            eof := NULL;
            dbms_output.put_line('STATUS: '
                                 || sqlerrm);
            RETURN eof;
    END getStatusPeriodoCor;

END utl_periodos;

/
--------------------------------------------------------
--  DDL for Function ACT_FECHAS_JSONHV
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "FUNDAUC"."ACT_FECHAS_JSONHV" (metadata IN CLOB) RETURN CLOB IS

  meta          CLOB;
  md_obj        JSON_OBJECT_T;
  li_arr        JSON_ARRAY_T;
  fi_item       JSON_ELEMENT_T;
  ff_item       JSON_ELEMENT_T;
  sec_obj       JSON_OBJECT_T;
  fac_obj        JSON_OBJECT_T;
  per_obj        JSON_OBJECT_T;
  f_fact        DATE;
  f_ini         DATE;
  f_fin         DATE;
  nro_fact      NUMBER;
  id_per        NUMBER;
  id_fac        NUMBER;

  PROCEDURE display (p_obj IN JSON_OBJECT_T) IS
  BEGIN
    DBMS_OUTPUT.put_line(p_obj.stringify);
  END;
  PROCEDURE display (p_ele IN JSON_ELEMENT_T) IS
  BEGIN
    DBMS_OUTPUT.put_line(p_ele.stringify);
  END;
  PROCEDURE display (p_arr IN JSON_ARRAY_T) IS
  BEGIN
    DBMS_OUTPUT.put_line(p_arr.stringify);
  END;

BEGIN
  select metadata into meta from hoja_vida_est where rownum = 1;

  md_obj := JSON_OBJECT_T.parse(meta);

    per_obj := JSON_OBJECT_T(md_obj.get_Object('seccion').get_Object('periodo'));

    fi_item := JSON_OBJECT_T(md_obj.get_Object('seccion')).get('id_horario');
    ff_item := JSON_OBJECT_T(md_obj.get_Object('seccion')).get('horario');

    f_ini := to_date(per_obj.get_string('fecha_ini'),'DD/MM/YYYY');
    f_fin := to_date(per_obj.get_string('fecha_fin'),'DD/MM/YYYY');

    per_obj.put('fecha_ini',to_char(f_ini,'YYYY-MM-DD')||'T'||to_char(f_ini,'HH24:MI:SS'));
    per_obj.put('fecha_fin',to_char(f_fin,'YYYY-MM-DD')||'T'||to_char(f_fin,'HH24:MI:SS'));

 --   DBMS_OUTPUT.PUT_LINE(to_char(f_ini,'YYYY-MM-DD')||'T'||to_char(f_ini,'HH24:MI:SS')||'Z');

    fac_obj := JSON_OBJECT_T(md_obj.get_Object('factura'));

    id_fac := fac_obj.get_number('id');

    select id_fact, fecha_emi into nro_fact, f_fact from factura where id=id_fac;

    fac_obj.put('fecha_emi',f_fact);
    fac_obj.put('nro_fac',nro_fact);

    meta := md_obj.to_string;
  --  display(md_obj);
    return meta;

END;

/
--------------------------------------------------------
--  DDL for Function ARREGLA_JSONHV
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "FUNDAUC"."ARREGLA_JSONHV" (metadata IN CLOB) RETURN CLOB IS

  meta          CLOB;
  md_obj        JSON_OBJECT_T;
  li_arr        JSON_ARRAY_T;
  id_item       JSON_ELEMENT_T;
  hr_item       JSON_ELEMENT_T;
  sec_obj       JSON_OBJECT_T;
  fac_obj        JSON_OBJECT_T;
  hor_obj        JSON_OBJECT_T;

  PROCEDURE display (p_obj IN JSON_OBJECT_T) IS
  BEGIN
    DBMS_OUTPUT.put_line(p_obj.stringify);
  END;
  PROCEDURE display (p_ele IN JSON_ELEMENT_T) IS
  BEGIN
    DBMS_OUTPUT.put_line(p_ele.stringify);
  END;
  PROCEDURE display (p_arr IN JSON_ARRAY_T) IS
  BEGIN
    DBMS_OUTPUT.put_line(p_arr.stringify);
  END;

BEGIN

  md_obj := JSON_OBJECT_T.parse(metadata);

    hor_obj := new JSON_OBJECT_T('{"horario":{}}');

    id_item := JSON_OBJECT_T(md_obj.get_Object('seccion')).get('id_horario');
    hr_item := JSON_OBJECT_T(md_obj.get_Object('seccion')).get('horario');

  --  DBMS_OUTPUT.PUT_LINE(JSON_OBJECT_T(md_obj.get_Object('seccion')).get('id_horario').to_string);

    hor_obj.put('id_horario',id_item);
    hor_obj.put('horario',hr_item);

 --   display(hor_obj);

    fac_obj := JSON_OBJECT_T(md_obj.get_Object('seccion').get_Object('factura'));
    sec_obj := JSON_OBJECT_T(md_obj.get_Object('seccion'));
    sec_obj.remove('factura');
    sec_obj.remove('id_horario');
    sec_obj.remove('horario');

    sec_obj.put('horario',hor_obj);

    md_obj.put('factura',fac_obj);

    meta := md_obj.to_string;

    return meta;

END;

/
--------------------------------------------------------
--  DDL for Function BUSCACAMPO
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "FUNDAUC"."BUSCACAMPO" (
   table_name IN VARCHAR2,
   colum_des  IN VARCHAR2,
   condition IN VARCHAR2 DEFAULT NULL) RETURN VARCHAR2 IS

   sql_stmt  VARCHAR2(4000); -- almacena el valor de la sentencia SQL
   where_clause VARCHAR2(4000) := ' WHERE ' || condition; -- almacena la condicion
   descrip   VARCHAR2(1000); -- almacena el valor del campo.

BEGIN
   IF condition IS NULL THEN where_clause := NULL; END IF; -- si la condicion el nula se elimina el where
   sql_stmt := 'SELECT ' || colum_des || ' from ' || table_name || where_clause; -- armado de la sentencia
   begin
   DBMS_OUTPUT.put_line(sql_stmt);
   EXECUTE IMMEDIATE sql_stmt INTO descrip; -- ejecucion de la sentencia
   exception
   when no_data_found then -- si no consigue datos
     descrip := '0'; -- asigna un 0 al valor indicando que no se cumple la condicion
   when others then -- en cualquier otro caso
     dbms_output.put_line(SQLERRM); -- despliega el error
	 descrip := SQLERRM;
   end;
   return(descrip); -- retorna el valor del campo
END;

/
--------------------------------------------------------
--  DDL for Function ESNUMERO
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "FUNDAUC"."ESNUMERO" (v_num IN VARCHAR2)
   RETURN NUMBER
AS
   s_num    NUMBER := 1;
   v_prov   NUMBER;
BEGIN
   v_prov := TO_NUMBER (v_num);
   RETURN s_num;
EXCEPTION
   WHEN OTHERS
   THEN
      s_num := 0;
      RETURN s_num;
END;

/
--------------------------------------------------------
--  DDL for Function EXISTE
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "FUNDAUC"."EXISTE" (vtabla    VARCHAR2,
                                            vwhere    VARCHAR2)
   RETURN BOOLEAN AUTHID CURRENT_USER
IS
   eof     NUMBER;
   dml     VARCHAR2(2000);

  -- vcampo VARCHAR2(30) := buscafkr(vprop,vtabla,vtablar);

/******************************************************************************
   NAME:       EXISTE
   PURPOSE:    Verifica si existe una tabla en la base de datos

   REVISIONS:
   Ver        Date        Author           Description
   ---------  ----------  ---------------  ------------------------------------
   1.0        30/11/2011   padron       1. Created this function.

   NOTES:

   Automatically available Auto Replace Keywords:
      Object Name:     EXISTE_TABLA
      Sysdate:         30/11/2011
      Date and Time:   30/11/2011, 08:17:30 a.m., and 30/11/2011 08:17:30 a.m.
      Username:        padron (set in TOAD Options, Procedure Editor)
      Table Name:       (set in the "New PL/SQL Object" dialog)

******************************************************************************/
BEGIN
   dml := '
   SELECT count(*)
     FROM '||vtabla||'
    WHERE '||vwhere;

    EXECUTE IMMEDIATE dml into eof;

--DBMS_OUTPUT.PUT_LINE(dml);

   if eof = 0 then
     RETURN false;
   else
     RETURN true;
   end if;

EXCEPTION
   WHEN NO_DATA_FOUND
   THEN
      eof := 0;
      return false;
   WHEN OTHERS
   THEN
      eof := 0;

      DBMS_OUTPUT.PUT_LINE('EXISTE: '||SQLERRM||dml);
            return false;
END EXISTE;

/
--------------------------------------------------------
--  DDL for Function GET_BASEIMP
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "FUNDAUC"."GET_BASEIMP" (valor    VARCHAR2,
                                            monto    NUMBER)
   RETURN NUMBER AUTHID CURRENT_USER
IS
   rmonto     NUMBER;

BEGIN

 CASE (VALOR)  
    WHEN 'N' THEN
        rmonto :=  monto;
    ELSE
        rmonto := 0;
 END CASE;

     RETURN rmonto;
END GET_BASEIMP;

/
--------------------------------------------------------
--  DDL for Function GET_EXENTO
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "FUNDAUC"."GET_EXENTO" (valor    VARCHAR2,
                                            monto    NUMBER)
   RETURN NUMBER AUTHID CURRENT_USER
IS
   rmonto     NUMBER;

BEGIN

 CASE (VALOR)  
    WHEN 'S' THEN
        rmonto :=  monto;
    ELSE
        rmonto := 0;
 END CASE;

     RETURN rmonto;
END GET_EXENTO;

/
--------------------------------------------------------
--  DDL for Function GETHACECUANTO
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "FUNDAUC"."GETHACECUANTO" (
    p_date IN DATE
) RETURN VARCHAR2 AS
    x   VARCHAR2(255);
BEGIN
    x := 'hace '|| 
        CASE
            WHEN SYSDATE - p_date < 1 / 1440 THEN round(24 * 60 * 60 * (SYSDATE - p_date) )
            || ' segundos'
            WHEN SYSDATE - p_date < 1 / 24 THEN round(24 * 60 * (SYSDATE - p_date) )
            || ' minutos'
            WHEN SYSDATE - p_date < 1 THEN round(24 * (SYSDATE - p_date) )
            || ' horas'
            WHEN SYSDATE - p_date < 14 THEN trunc(SYSDATE - p_date)
            || ' dias'
                $IF $$BRITISH $THEN
            WHEN MOD(trunc(SYSDATE - p_date),14) = 0 THEN trunc(SYSDATE - p_date) / 14
            || ' quincenas'
                $END
            WHEN SYSDATE - p_date < 60 THEN trunc( (SYSDATE - p_date) / 7)
            || ' semanas'
            WHEN SYSDATE - p_date < 365 THEN round(months_between(SYSDATE,p_date) )
            || ' meses'
            ELSE round(months_between(SYSDATE,p_date) / 12,1)
            || ' años'
        END;

    x := regexp_replace(x,'(^1 &#91;&#91;:alnum:&#93;&#93;{4,10})s','\1');
    x := x;
    RETURN x;
END getHaceCuanto;

/
--------------------------------------------------------
--  DDL for Function GET_INSCRIPCION_JSON
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "FUNDAUC"."GET_INSCRIPCION_JSON" (
   p_ins_id in inscripciones.id%type,
   p_tipo char,
   p_codigo number
)
   return clob
is
  l_inscripcion_row inscripciones%ROWTYPE;
  l_seccion_row secciones%ROWTYPE;
  l_cohorte_row cohortes%ROWTYPE;
 
  TYPE horario_typer
   IS
      RECORD (
            id_horario horarios.id_horario%TYPE,
            horario VARCHAR2(255)
      );
  l_horario_row horario_typer;
  
  l_periodo_row calendarios_detalle%ROWTYPE;
  l_factura_row factura%ROWTYPE;
  l_cod_json_clob clob;
  l_periodo number := 0;
  l_horario number := 0;

BEGIN

  APEX_JSON.initialize_clob_output;


  APEX_JSON.open_object; -- {

  if p_tipo = 'S' then
      SELECT s.*
      INTO   l_seccion_row
      FROM   secciones s
      WHERE  s.id = p_codigo;

     l_periodo := l_seccion_row.periodo;
     l_horario := l_seccion_row.id_horario;

      APEX_JSON.open_object('seccion'); -- seccion {

      APEX_JSON.write('id_seccion', l_seccion_row.id_seccion);
      APEX_JSON.write('codigo',l_seccion_row.id);
      APEX_JSON.write('id_metodo', l_seccion_row.id_metodo);
      APEX_JSON.write('nivel', l_seccion_row.nivel);
      APEX_JSON.write('id_salon',l_seccion_row.id_salon);
      APEX_JSON.write('tope',l_seccion_row.tope);
      APEX_JSON.write('status',l_seccion_row.status);
      APEX_JSON.write('id_edif',l_seccion_row.id_edif);
      APEX_JSON.write('cedula_prof',l_seccion_row.cedula_prof);
      APEX_JSON.write('modalidad',utl_modalidades.getModalidad(l_seccion_row.modalidad));
  end if;
    if p_tipo = 'C' then
      SELECT s.*
      INTO   l_cohorte_row
      FROM   cohortes s
      WHERE  s.id = p_codigo;

      l_periodo := l_cohorte_row.periodo;

      APEX_JSON.open_object('cohorte'); -- cohorte {

      APEX_JSON.write('codigo', l_cohorte_row.codigo);
      APEX_JSON.write('id',l_cohorte_row.id);
      APEX_JSON.write('diplomado_id', l_cohorte_row.diplomado_id);
      APEX_JSON.write('cohorte', l_cohorte_row.cohorte);
      APEX_JSON.write('costo',l_cohorte_row.costo);
      APEX_JSON.write('cupo',l_cohorte_row.cupo);
      APEX_JSON.write('status',l_cohorte_row.status);
      APEX_JSON.write('cuotas',l_cohorte_row.cuotas);
      APEX_JSON.write('facilitador',l_cohorte_row.facilitador);
      APEX_JSON.write('id_modalidad',utl_modalidades.getModalidad(l_cohorte_row.id_modalidad));
      APEX_JSON.write('id_ciudad',l_cohorte_row.id_ciudad);
      APEX_JSON.write('empresa',l_cohorte_row.empresa);
  end if;


  begin
  select * into l_periodo_row
  from calendarios_detalle
  where id = l_periodo;

  APEX_JSON.open_object('periodo'); -- periodo {
  APEX_JSON.write('id',l_periodo_row.id);
  APEX_JSON.write('id_calendario',l_periodo_row.id_calendario);
  APEX_JSON.write('cod_periodo',l_periodo_row.periodo);
  APEX_JSON.write('fecha_ini',to_char(l_periodo_row.fecha_ini,'YYYY-MM-DD')||'T'||to_char(l_periodo_row.fecha_ini,'HH24:MI:SS')||'Z');
  APEX_JSON.write('fecha_fin',to_char(l_periodo_row.fecha_fin,'YYYY-MM-DD')||'T'||to_char(l_periodo_row.fecha_ini,'HH24:MI:SS')||'Z');
  APEX_JSON.write('modalidad',l_periodo_row.modalidad);
  APEX_JSON.write('periodo_activo',l_periodo_row.periodo_activo);

  exception
  when no_data_found then
     APEX_JSON.open_object('periodo'); -- periodo {
     APEX_JSON.write('id',l_periodo);
  end;
  APEX_JSON.close_object; -- } --periodo
  
  begin
  select id_horario, UTL_HORARIOS.GETHORARIO(id_horario) horario 
  into l_horario_row
  from horarios
  where id_horario = l_horario;

  APEX_JSON.open_object('horario'); -- horario {
  APEX_JSON.write('id_horario',l_horario_row.id_horario);
  APEX_JSON.write('horario',l_horario_row.horario);

  exception
  when no_data_found then
     APEX_JSON.open_object('horario'); -- horario {
     APEX_JSON.write('id_horario',l_periodo);
  end;
  APEX_JSON.close_object; -- } --horario

  
  APEX_JSON.close_object; -- } --seccion
  begin
      select f.* 
      into l_factura_row
      from factura f, inscripcion_factura if
      where f.id = if.factura_id
      and if.inscripcion_id = p_ins_id; 

      APEX_JSON.open_object('factura'); -- factura {
      APEX_JSON.write('id',l_factura_row.id);
      APEX_JSON.write('tipo_fac',l_factura_row.tipo);
      APEX_JSON.write('cedula_est',l_factura_row.cedula_est);
      APEX_JSON.write('rif',l_factura_row.rif);
      APEX_JSON.write('nombre_cliente',l_factura_row.nombre_cliente);
      APEX_JSON.write('dir_fiscal',l_factura_row.dir_fiscal);
      APEX_JSON.write('fecha_emi',l_factura_row.fecha_emi);
      APEX_JSON.write('status',l_factura_row.status);
      APEX_JSON.write('programa',l_factura_row.programa);
      APEX_JSON.write('monto',l_factura_row.monto);
      APEX_JSON.write('fecha_emi',l_factura_row.fecha_emi);
      APEX_JSON.write('nro_fac',l_factura_row.id_fact);
      APEX_JSON.close_object; -- } --factura}

      exception
      when no_data_found then
         APEX_JSON.open_object('factura'); -- factura {
         APEX_JSON.close_object; -- } --factura}
  end;
   
/*    begin
       select * into l_inscripcion_row
       from inscripciones
       where id = p_ins_id;

      APEX_JSON.open_object('inscripcion'); -- inscripcion {
      APEX_JSON.write('id',l_inscripcion_row.id);
      APEX_JSON.write('fecha_ins',l_inscripcion_row.fecha_ins);
      APEX_JSON.write('est_matricula',l_inscripcion_row.est_matricula);
      APEX_JSON.write('seccion_id',l_inscripcion_row.seccion_id);
      APEX_JSON.write('periodo_id',l_inscripcion_row.periodo_id);
      APEX_JSON.write('cohorte_id',l_inscripcion_row.cohorte_id);
      APEX_JSON.write('horario_id',l_inscripcion_row.horario_id);
      APEX_JSON.write('es_exonerado',l_inscripcion_row.es_exonerado);
      APEX_JSON.write('es_suspendido',l_inscripcion_row.es_suspendido);
      APEX_JSON.write('estatus',l_inscripcion_row.estatus);
      APEX_JSON.close_object; -- } --inscripcion}

      exception
      when no_data_found then
         APEX_JSON.open_object('inscripcion'); -- inscripcion {
         APEX_JSON.close_object; -- } --inscripcion}
  end;*/


  
  

  APEX_JSON.close_object; -- } objeto

  DBMS_OUTPUT.put_line(APEX_JSON.get_clob_output);

  l_cod_json_clob := apex_json.get_clob_output;

  APEX_JSON.free_output;

  return l_cod_json_clob;
END get_inscripcion_json;

/
--------------------------------------------------------
--  DDL for Function INS_INSCRIPCION_JSONHV
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "FUNDAUC"."INS_INSCRIPCION_JSONHV" (metadata IN CLOB) RETURN CLOB IS

  meta          CLOB;
  md_obj        JSON_OBJECT_T;
  li_arr        JSON_ARRAY_T;
  id_item       JSON_ELEMENT_T;
  hr_item       JSON_ELEMENT_T;
  hor_obj       JSON_OBJECT_T;
  fac_obj        JSON_OBJECT_T;
  ins_obj        JSON_OBJECT_T;
  l_inscripcion_row inscripciones%ROWTYPE;
  fac_id       NUMBER;
  hor_id       NUMBER;

  PROCEDURE display (p_obj IN JSON_OBJECT_T) IS
  BEGIN
    DBMS_OUTPUT.put_line(p_obj.stringify);
  END;
  PROCEDURE display (p_obj IN CLOB) IS
  BEGIN
    DBMS_OUTPUT.put_line(p_obj);
  END;
  PROCEDURE display (p_ele IN JSON_ELEMENT_T) IS
  BEGIN
    DBMS_OUTPUT.put_line(p_ele.stringify);
  END;
  PROCEDURE display (p_arr IN JSON_ARRAY_T) IS
  BEGIN
    DBMS_OUTPUT.put_line(p_arr.stringify);
  END;

BEGIN

--  select metadata into meta from hoja_vida_est where rownum = 1;
  md_obj := JSON_OBJECT_T.parse(metadata);

--  display(md_obj);

    ins_obj := new JSON_OBJECT_T();

--    display(ins_obj);
    hor_obj := JSON_OBJECT_T(md_obj.get_Object('seccion').get_Object('horario'));

--    display(hor_obj);

    hor_id := hor_obj.get_number('id_horario');

    fac_obj := JSON_OBJECT_T(md_obj.get_Object('factura'));

    fac_id := fac_obj.get_number('id');

    select * into l_inscripcion_row
       from inscripciones
       where id in (select inscripcion_id from INSCRIPCION_FACTURA where factura_id=fac_id);

    ins_obj.put('id',l_inscripcion_row.id);
    ins_obj.put('fecha_ins',l_inscripcion_row.fecha_ins);
    ins_obj.put('est_matricula',l_inscripcion_row.est_matricula);
    ins_obj.put('seccion_id',l_inscripcion_row.seccion_id);
    ins_obj.put('periodo_id',l_inscripcion_row.periodo_id);
    ins_obj.put('cohorte_id',l_inscripcion_row.cohorte_id);
    ins_obj.put('horario_id',hor_id);
    ins_obj.put('es_exonerado',l_inscripcion_row.es_exonerado);
    ins_obj.put('es_suspendido',l_inscripcion_row.es_suspendido);
    ins_obj.put('estatus',l_inscripcion_row.estatus);

--    display(ins_obj);

    md_obj.put('inscripcion',ins_obj);

    meta := md_obj.to_string;

    return meta;
  --  display(meta);

END;

/
--------------------------------------------------------
--  DDL for Function LISTA
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "FUNDAUC"."LISTA" (input varchar2 )
    RETURN varchar2
    PARALLEL_ENABLE AGGREGATE USING string_agg_type;

/
--------------------------------------------------------
--  DDL for Function MAXIMO
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "FUNDAUC"."MAXIMO" (vtabla    VARCHAR2,
                                            vcampo    VARCHAR2,
                                            vwhere    VARCHAR2)
   RETURN NUMBER AUTHID CURRENT_USER
IS
   eof     NUMBER;
   dml     VARCHAR2(2000);

  -- vcampo VARCHAR2(30) := buscafkr(vprop,vtabla,vtablar);

/******************************************************************************
   NAME:       MINIMO
   PURPOSE:    Verifica si existe una tabla en la base de datos

   REVISIONS:
   Ver        Date        Author           Description
   ---------  ----------  ---------------  ------------------------------------
   1.0        30/11/2011   padron       1. Created this function.

   NOTES:

   Automatically available Auto Replace Keywords:
      Object Name:     EXISTE_TABLA
      Sysdate:         30/11/2011
      Date and Time:   30/11/2011, 08:17:30 a.m., and 30/11/2011 08:17:30 a.m.
      Username:        padron (set in TOAD Options, Procedure Editor)
      Table Name:       (set in the "New PL/SQL Object" dialog)

******************************************************************************/
BEGIN
   dml := '
   SELECT max('||vcampo||')
     FROM '||vtabla||'
    WHERE '||vwhere;

    EXECUTE IMMEDIATE dml into eof;

--DBMS_OUTPUT.PUT_LINE(dml);

   if eof is null then
     eof := 0;
     RETURN eof;
   else
     RETURN eof;
   end if;

EXCEPTION
   WHEN NO_DATA_FOUND
   THEN
      eof := 0;
      return eof;
   WHEN OTHERS
   THEN
      eof := 0;

      DBMS_OUTPUT.PUT_LINE('MAXIMO: '||SQLERRM||dml);
            return eof;
END MAXIMO;

/
--------------------------------------------------------
--  DDL for Function MINIMO
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "FUNDAUC"."MINIMO" (vtabla    VARCHAR2,
                                            vcampo    VARCHAR2,
                                            vwhere    VARCHAR2)
   RETURN NUMBER AUTHID CURRENT_USER
IS
   eof     NUMBER;
   dml     VARCHAR2(2000);

  -- vcampo VARCHAR2(30) := buscafkr(vprop,vtabla,vtablar);

/******************************************************************************
   NAME:       MINIMO
   PURPOSE:    Verifica si existe una tabla en la base de datos

   REVISIONS:
   Ver        Date        Author           Description
   ---------  ----------  ---------------  ------------------------------------
   1.0        30/11/2011   padron       1. Created this function.

   NOTES:

   Automatically available Auto Replace Keywords:
      Object Name:     EXISTE_TABLA
      Sysdate:         30/11/2011
      Date and Time:   30/11/2011, 08:17:30 a.m., and 30/11/2011 08:17:30 a.m.
      Username:        padron (set in TOAD Options, Procedure Editor)
      Table Name:       (set in the "New PL/SQL Object" dialog)

******************************************************************************/
BEGIN
   dml := '
   SELECT min('||vcampo||')
     FROM '||vtabla||'
    WHERE '||vwhere;

    EXECUTE IMMEDIATE dml into eof;

--DBMS_OUTPUT.PUT_LINE(dml);

   if eof is null then
     eof := 0;
     RETURN eof;
   else
     RETURN eof;
   end if;

EXCEPTION
   WHEN NO_DATA_FOUND
   THEN
      eof := 0;
      return eof;
   WHEN OTHERS
   THEN
      eof := 0;

      DBMS_OUTPUT.PUT_LINE('MINIMO: '||SQLERRM||dml);
            return eof;
END MINIMO;

/
--------------------------------------------------------
--  DDL for Function TOKEN
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "FUNDAUC"."TOKEN" (LINEBUF   IN VARCHAR2,
                                           col       IN NUMBER,
                                           separa    IN VARCHAR2)
   RETURN VARCHAR2
IS
   FIRST_TOKEN   VARCHAR2 (2000);
   COMA_POS      NUMBER;
   CONTENIDO     VARCHAR2 (2000) := LINEBUF;
   i             NUMBER := 0;
BEGIN
   IF CONTENIDO IS NULL
   THEN
      FIRST_TOKEN := '';
   ELSE
      LOOP
         EXIT WHEN i = col;
         COMA_POS := INSTR (CONTENIDO, separa);

         IF COMA_POS = 0
         THEN
            FIRST_TOKEN := CONTENIDO;
            CONTENIDO := NULL;
         ELSE
            IF COMA_POS = 1
            THEN
               CONTENIDO := SUBSTR (CONTENIDO, COMA_POS + LENGTH (separa));
               COMA_POS := INSTR (CONTENIDO, separa);
               DBMS_OUTPUT.PUT_LINE(i||'-'||CONTENIDO||'-'||COMA_POS||'-'||length(separa));
               FIRST_TOKEN := SUBSTR (CONTENIDO, 1, COMA_POS - 1);
               CONTENIDO := SUBSTR (CONTENIDO, COMA_POS + LENGTH (separa));
            ELSE
               FIRST_TOKEN := SUBSTR (CONTENIDO, 1, COMA_POS - 1);
               CONTENIDO := SUBSTR (CONTENIDO, COMA_POS + LENGTH (separa));
            END IF;
         END IF;

         i := i + 1;
      END LOOP;
   END IF;

   RETURN FIRST_TOKEN;
   EXCEPTION WHEN OTHERS THEN
   DBMS_OUTPUT.put_line(SQLERRM);
END;

/
--------------------------------------------------------
--  DDL for Function TOKENCOUNT
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "FUNDAUC"."TOKENCOUNT" (LINEBUF   IN VARCHAR2,
                                                separa    IN VARCHAR2)
   RETURN VARCHAR2
IS
   FIRST_TOKEN   VARCHAR2 (2000);
   COMA_POS      NUMBER;
   CONTENIDO     VARCHAR2 (2000) := LINEBUF;
   i             NUMBER := 0;
BEGIN
   IF CONTENIDO IS NULL
   THEN
      i := 0;
   ELSE
      LOOP
         EXIT WHEN COMA_POS = 0;
         COMA_POS := INSTR (CONTENIDO, separa);
         DBMS_OUTPUT.PUT_LINE (COMA_POS);

         IF COMA_POS = 0
         THEN
            FIRST_TOKEN := CONTENIDO;
            CONTENIDO := NULL;
         ELSE
            IF COMA_POS = 1
            THEN
               CONTENIDO := SUBSTR (CONTENIDO, COMA_POS + LENGTH (separa));
               COMA_POS := INSTR (CONTENIDO, separa);
               --DBMS_OUTPUT.PUT_LINE(i||'-'||CONTENIDO||'-'||COMA_POS);
               FIRST_TOKEN := SUBSTR (CONTENIDO, 1, COMA_POS - 1);
               CONTENIDO := SUBSTR (CONTENIDO, COMA_POS + LENGTH (separa));
            ELSE
               FIRST_TOKEN := SUBSTR (CONTENIDO, 1, COMA_POS - 1);
               CONTENIDO := SUBSTR (CONTENIDO, COMA_POS + LENGTH (separa));
            END IF;
         END IF;

         i := i + 1;
      -- DBMS_OUTPUT.PUT_LINE(i||'-'||FIRST_TOKEN);
      END LOOP;
   END IF;

   RETURN i;
END;

/
--------------------------------------------------------
--  Constraints for Table FACTURA_DEPOSITO
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."FACTURA_DEPOSITO" MODIFY ("DEPOSITO_ID" NOT NULL DISABLE);
  ALTER TABLE "FUNDAUC"."FACTURA_DEPOSITO" MODIFY ("FACTURA_ID" NOT NULL DISABLE);
  ALTER TABLE "FUNDAUC"."FACTURA_DEPOSITO" ADD CONSTRAINT "FACTURA_DEPOSITO_PK" PRIMARY KEY ("FACTURA_ID", "DEPOSITO_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 262144 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC"  ENABLE;
--------------------------------------------------------
--  Constraints for Table INSCRIPCIONES_BAK
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."INSCRIPCIONES_BAK" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "FUNDAUC"."INSCRIPCIONES_BAK" MODIFY ("FECHA_INS" NOT NULL ENABLE);
  ALTER TABLE "FUNDAUC"."INSCRIPCIONES_BAK" MODIFY ("EST_MATRICULA" NOT NULL ENABLE);
  ALTER TABLE "FUNDAUC"."INSCRIPCIONES_BAK" MODIFY ("SECCION_ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table DETALLE_FACTURA
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."DETALLE_FACTURA" MODIFY ("RENGLON" NOT NULL ENABLE);
  ALTER TABLE "FUNDAUC"."DETALLE_FACTURA" MODIFY ("MATERIALES_ID" NOT NULL ENABLE);
  ALTER TABLE "FUNDAUC"."DETALLE_FACTURA" MODIFY ("FACTURA_ID" NOT NULL ENABLE);
  ALTER TABLE "FUNDAUC"."DETALLE_FACTURA" ADD CONSTRAINT "DETALLE_FACTURA_PK" PRIMARY KEY ("RENGLON")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 196608 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC"  ENABLE;
--------------------------------------------------------
--  Constraints for Table TIPO_MATERIAL
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."TIPO_MATERIAL" MODIFY ("USA_SECCION" NOT NULL ENABLE);
  ALTER TABLE "FUNDAUC"."TIPO_MATERIAL" ADD CONSTRAINT "PK_TIPO_MATERIAL" PRIMARY KEY ("ABREV")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC"  ENABLE;
--------------------------------------------------------
--  Constraints for Table COMPANIAS
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."COMPANIAS" MODIFY ("DESCRIPCION" NOT NULL DISABLE);
  ALTER TABLE "FUNDAUC"."COMPANIAS" ADD CONSTRAINT "COMPANIAS_PK" PRIMARY KEY ("CODIGO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC"  ENABLE;
--------------------------------------------------------
--  Constraints for Table PRECIOS
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."PRECIOS" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "FUNDAUC"."PRECIOS" MODIFY ("TIPO_ITEM" NOT NULL DISABLE);
  ALTER TABLE "FUNDAUC"."PRECIOS" MODIFY ("PRECIO1" NOT NULL DISABLE);
  ALTER TABLE "FUNDAUC"."PRECIOS" ADD CONSTRAINT "PRECIOS_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC"  ENABLE;
--------------------------------------------------------
--  Constraints for Table TIPO_PROFESOR
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."TIPO_PROFESOR" MODIFY ("DESCRIPCION" NOT NULL ENABLE);
  ALTER TABLE "FUNDAUC"."TIPO_PROFESOR" ADD PRIMARY KEY ("ID_TIPO_PROF")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC"  ENABLE;
--------------------------------------------------------
--  Constraints for Table EDIFICIOS
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."EDIFICIOS" MODIFY ("ID_EDIF" NOT NULL DISABLE);
  ALTER TABLE "FUNDAUC"."EDIFICIOS" ADD CONSTRAINT "EDIFICIOS_PK" PRIMARY KEY ("ID_EDIF")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC"  ENABLE;
--------------------------------------------------------
--  Constraints for Table DIPLOMADOS
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."DIPLOMADOS" MODIFY ("ID_DIPLOMADO" NOT NULL DISABLE);
  ALTER TABLE "FUNDAUC"."DIPLOMADOS" MODIFY ("DESCRIPCION" NOT NULL DISABLE);
  ALTER TABLE "FUNDAUC"."DIPLOMADOS" MODIFY ("HORAS" NOT NULL DISABLE);
  ALTER TABLE "FUNDAUC"."DIPLOMADOS" MODIFY ("COORDINADOR" NOT NULL DISABLE);
  ALTER TABLE "FUNDAUC"."DIPLOMADOS" MODIFY ("ID" NOT NULL DISABLE);
  ALTER TABLE "FUNDAUC"."DIPLOMADOS" ADD CONSTRAINT "DIPLOMADOS_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC"  ENABLE;
  ALTER TABLE "FUNDAUC"."DIPLOMADOS" ADD CONSTRAINT "DIPLOMADOS_UK1" UNIQUE ("ID_DIPLOMADO") DISABLE;
--------------------------------------------------------
--  Constraints for Table CONDICIONES_ESPECIALES
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."CONDICIONES_ESPECIALES" MODIFY ("ID_CONDICION" NOT NULL DISABLE);
  ALTER TABLE "FUNDAUC"."CONDICIONES_ESPECIALES" ADD CONSTRAINT "CONDICIONES_ESPECIALES_PK" PRIMARY KEY ("ID_CONDICION")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC"  ENABLE;
--------------------------------------------------------
--  Constraints for Table MODALIDADES
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."MODALIDADES" MODIFY ("ID_MODALIDAD" NOT NULL DISABLE);
  ALTER TABLE "FUNDAUC"."MODALIDADES" MODIFY ("DESCRIPCION" NOT NULL DISABLE);
  ALTER TABLE "FUNDAUC"."MODALIDADES" ADD CONSTRAINT "MODALIDADES_PK" PRIMARY KEY ("ID_MODALIDAD")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC"  ENABLE;
  ALTER TABLE "FUNDAUC"."MODALIDADES" ADD CONSTRAINT "MODALIDAD_UK" UNIQUE ("DESCRIPCION") DISABLE;
--------------------------------------------------------
--  Constraints for Table CLIENTES
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."CLIENTES" MODIFY ("RIF" NOT NULL ENABLE);
  ALTER TABLE "FUNDAUC"."CLIENTES" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "FUNDAUC"."CLIENTES" ADD CONSTRAINT "CLIENTES_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC"  ENABLE;
  ALTER TABLE "FUNDAUC"."CLIENTES" ADD CONSTRAINT "CLIENTES_UK1" UNIQUE ("RIF")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC"  ENABLE;
--------------------------------------------------------
--  Constraints for Table OCUPACIONES
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."OCUPACIONES" ADD CONSTRAINT "OCUPACIONES_PK" PRIMARY KEY ("ID_OCUPACION")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC"  ENABLE;
--------------------------------------------------------
--  Constraints for Table FORMA_PAGO
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."FORMA_PAGO" MODIFY ("DESCRIPCION" NOT NULL DISABLE);
  ALTER TABLE "FUNDAUC"."FORMA_PAGO" ADD CONSTRAINT "FORMA_PAGO_PK" PRIMARY KEY ("ID_PAGO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC"  ENABLE;
--------------------------------------------------------
--  Constraints for Table INSCRIPCIONES
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."INSCRIPCIONES" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "FUNDAUC"."INSCRIPCIONES" MODIFY ("FECHA_INS" NOT NULL ENABLE);
  ALTER TABLE "FUNDAUC"."INSCRIPCIONES" MODIFY ("EST_MATRICULA" NOT NULL ENABLE);
  ALTER TABLE "FUNDAUC"."INSCRIPCIONES" MODIFY ("SECCION_ID" NOT NULL ENABLE);
  ALTER TABLE "FUNDAUC"."INSCRIPCIONES" MODIFY ("ES_EXONERADO" NOT NULL ENABLE);
  ALTER TABLE "FUNDAUC"."INSCRIPCIONES" MODIFY ("PROG_ACADEMICO" NOT NULL ENABLE);
  ALTER TABLE "FUNDAUC"."INSCRIPCIONES" MODIFY ("ES_SUSPENDIDO" NOT NULL ENABLE);
  ALTER TABLE "FUNDAUC"."INSCRIPCIONES" ADD CONSTRAINT "INSCRIPCIONES_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 131072 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC"  ENABLE;
--------------------------------------------------------
--  Constraints for Table HORARIOS
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."HORARIOS" MODIFY ("ID_HORARIO" NOT NULL DISABLE);
  ALTER TABLE "FUNDAUC"."HORARIOS" MODIFY ("MODALIDAD" NOT NULL DISABLE);
  ALTER TABLE "FUNDAUC"."HORARIOS" ADD CONSTRAINT "HORARIOS_PK" PRIMARY KEY ("ID_HORARIO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC"  ENABLE;
--------------------------------------------------------
--  Constraints for Table FACTURA
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."FACTURA" MODIFY ("MONTO" NOT NULL DISABLE);
  ALTER TABLE "FUNDAUC"."FACTURA" MODIFY ("ID" NOT NULL DISABLE);
  ALTER TABLE "FUNDAUC"."FACTURA" MODIFY ("CREADO_EL" NOT NULL DISABLE);
  ALTER TABLE "FUNDAUC"."FACTURA" MODIFY ("ESCREDITO" NOT NULL ENABLE);
  ALTER TABLE "FUNDAUC"."FACTURA" ADD CONSTRAINT "PK_FACT" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 131072 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC"  ENABLE;
--------------------------------------------------------
--  Constraints for Table ZONAS
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."ZONAS" MODIFY ("DESCRIPCION" NOT NULL DISABLE);
  ALTER TABLE "FUNDAUC"."ZONAS" ADD CONSTRAINT "ZONAS_PK" PRIMARY KEY ("ID_ZONA")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC"  ENABLE;
--------------------------------------------------------
--  Constraints for Table MATERIALES
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."MATERIALES" MODIFY ("TIPO" NOT NULL ENABLE);
  ALTER TABLE "FUNDAUC"."MATERIALES" MODIFY ("DESCRIPCION" NOT NULL ENABLE);
  ALTER TABLE "FUNDAUC"."MATERIALES" MODIFY ("IVA_EXENTO" NOT NULL ENABLE);
  ALTER TABLE "FUNDAUC"."MATERIALES" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "FUNDAUC"."MATERIALES" ADD CONSTRAINT "MATERIALES_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC"  ENABLE;
--------------------------------------------------------
--  Constraints for Table CALENDARIOS
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."CALENDARIOS" MODIFY ("DESCRIPCION" NOT NULL DISABLE);
  ALTER TABLE "FUNDAUC"."CALENDARIOS" MODIFY ("ACTIVO" NOT NULL DISABLE);
  ALTER TABLE "FUNDAUC"."CALENDARIOS" MODIFY ("TIPO_CAL" NOT NULL ENABLE);
  ALTER TABLE "FUNDAUC"."CALENDARIOS" ADD CONSTRAINT "CALENDARIOS_PK" PRIMARY KEY ("ID_CALENDARIO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC"  ENABLE;
--------------------------------------------------------
--  Constraints for Table PROFESOR
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."PROFESOR" MODIFY ("NACIONALIDAD" NOT NULL DISABLE);
  ALTER TABLE "FUNDAUC"."PROFESOR" MODIFY ("NOMBRE" NOT NULL DISABLE);
  ALTER TABLE "FUNDAUC"."PROFESOR" ADD CONSTRAINT "PROFESOR_PK" PRIMARY KEY ("CEDULA_PROF")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC"  ENABLE;
--------------------------------------------------------
--  Constraints for Table PROGRAMA_ACADEMICO
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."PROGRAMA_ACADEMICO" ADD CONSTRAINT "PROGRAMA_ACADEMICO_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC"  ENABLE;
  ALTER TABLE "FUNDAUC"."PROGRAMA_ACADEMICO" ADD CONSTRAINT "PROGRAMA_ACADEMICO_CHK1" CHECK (activo in ('S','N')) DISABLE;
--------------------------------------------------------
--  Constraints for Table CONFIGURACION
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."CONFIGURACION" MODIFY ("ULT_FACTURA" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table METODOS
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."METODOS" ADD CONSTRAINT "PK_METODO" PRIMARY KEY ("ID_METODO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC"  ENABLE;
--------------------------------------------------------
--  Constraints for Table DEPT
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."DEPT" ADD PRIMARY KEY ("DEPTNO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC"  ENABLE;
--------------------------------------------------------
--  Constraints for Table DEPOSITO
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."DEPOSITO" MODIFY ("REFERENCIA" NOT NULL ENABLE);
  ALTER TABLE "FUNDAUC"."DEPOSITO" MODIFY ("MONTO" NOT NULL ENABLE);
  ALTER TABLE "FUNDAUC"."DEPOSITO" MODIFY ("ID" NOT NULL DISABLE);
  ALTER TABLE "FUNDAUC"."DEPOSITO" ADD CONSTRAINT "PK_DEPOSITO" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 131072 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC"  ENABLE;
  ALTER TABLE "FUNDAUC"."DEPOSITO" ADD CONSTRAINT "DEPOSITO_UK" UNIQUE ("REFERENCIA", "ID_BANCO", "FORMA_PAGO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 196608 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC"  ENABLE;
--------------------------------------------------------
--  Constraints for Table USUARIOS
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."USUARIOS" MODIFY ("ACTIVO" NOT NULL ENABLE);
  ALTER TABLE "FUNDAUC"."USUARIOS" MODIFY ("BLOQUEADO" NOT NULL ENABLE);
  ALTER TABLE "FUNDAUC"."USUARIOS" MODIFY ("CREADO_EL" NOT NULL ENABLE);
  ALTER TABLE "FUNDAUC"."USUARIOS" ADD CONSTRAINT "USUARIOS_PK" PRIMARY KEY ("CEDULA")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC"  ENABLE;
  ALTER TABLE "FUNDAUC"."USUARIOS" ADD CONSTRAINT "USUARIOS_UK1" UNIQUE ("NOMBRE_USUARIO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC"  ENABLE;
--------------------------------------------------------
--  Constraints for Table TE_TEMPLATES
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."TE_TEMPLATES" MODIFY ("CREATED_BY" NOT NULL ENABLE);
  ALTER TABLE "FUNDAUC"."TE_TEMPLATES" MODIFY ("CREATED_DATE" NOT NULL ENABLE);
  ALTER TABLE "FUNDAUC"."TE_TEMPLATES" MODIFY ("MODIFIED_BY" NOT NULL ENABLE);
  ALTER TABLE "FUNDAUC"."TE_TEMPLATES" MODIFY ("MODIFIED_DATE" NOT NULL ENABLE);
  ALTER TABLE "FUNDAUC"."TE_TEMPLATES" ADD CONSTRAINT "TE_TEMPLATES_PK" PRIMARY KEY ("NAME")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  TABLESPACE "FUNDAUC"  ENABLE;
--------------------------------------------------------
--  Constraints for Table BANCOS
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."BANCOS" MODIFY ("NOMBRE" NOT NULL DISABLE);
  ALTER TABLE "FUNDAUC"."BANCOS" ADD CONSTRAINT "BANCOS_PK" PRIMARY KEY ("ID_BANCO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC"  ENABLE;
--------------------------------------------------------
--  Constraints for Table EMP
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."EMP" MODIFY ("EMPNO" NOT NULL ENABLE);
  ALTER TABLE "FUNDAUC"."EMP" ADD PRIMARY KEY ("EMPNO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC"  ENABLE;
--------------------------------------------------------
--  Constraints for Table INSCRIPCION_FACTURA
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."INSCRIPCION_FACTURA" MODIFY ("INSCRIPCION_ID" NOT NULL ENABLE);
  ALTER TABLE "FUNDAUC"."INSCRIPCION_FACTURA" MODIFY ("FACTURA_ID" NOT NULL ENABLE);
  ALTER TABLE "FUNDAUC"."INSCRIPCION_FACTURA" ADD CONSTRAINT "INSCRIP_FAC_PK" PRIMARY KEY ("INSCRIPCION_ID", "FACTURA_ID")
  USING INDEX (CREATE UNIQUE INDEX "FUNDAUC"."INSCRIPCION_FACTURA_PK" ON "FUNDAUC"."INSCRIPCION_FACTURA" ("INSCRIPCION_ID", "FACTURA_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 131072 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC" )  ENABLE;
--------------------------------------------------------
--  Constraints for Table ROLES
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."ROLES" ADD CONSTRAINT "ROLES_PK" PRIMARY KEY ("ID_ROL")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC"  ENABLE;
--------------------------------------------------------
--  Constraints for Table FACTURA_BAK
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."FACTURA_BAK" MODIFY ("ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table ESTUDIANTE
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."ESTUDIANTE" MODIFY ("NACIONALIDAD" NOT NULL ENABLE);
  ALTER TABLE "FUNDAUC"."ESTUDIANTE" MODIFY ("NOMBRE" NOT NULL ENABLE);
  ALTER TABLE "FUNDAUC"."ESTUDIANTE" MODIFY ("ID_TIPO_EST" NOT NULL ENABLE);
  ALTER TABLE "FUNDAUC"."ESTUDIANTE" ADD CONSTRAINT "PK_ESTUDIANTE" PRIMARY KEY ("MATRICULA")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 720896 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC"  ENABLE;
--------------------------------------------------------
--  Constraints for Table SALONES
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."SALONES" MODIFY ("CAPACIDAD" NOT NULL DISABLE);
  ALTER TABLE "FUNDAUC"."SALONES" ADD CONSTRAINT "PK_SALON" PRIMARY KEY ("ID_SALON", "EDIFICIO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC"  ENABLE;
--------------------------------------------------------
--  Constraints for Table HOJA_VIDA_EST_BK
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."HOJA_VIDA_EST_BK" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "FUNDAUC"."HOJA_VIDA_EST_BK" ADD CONSTRAINT "HOJA_VIDA_BK_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC"  ENABLE;
--------------------------------------------------------
--  Constraints for Table SECCIONES
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."SECCIONES" MODIFY ("ID_METODO" NOT NULL DISABLE);
  ALTER TABLE "FUNDAUC"."SECCIONES" MODIFY ("MODALIDAD" NOT NULL DISABLE);
  ALTER TABLE "FUNDAUC"."SECCIONES" MODIFY ("ID_HORARIO" NOT NULL DISABLE);
  ALTER TABLE "FUNDAUC"."SECCIONES" MODIFY ("ID_CALENDARIO" NOT NULL DISABLE);
  ALTER TABLE "FUNDAUC"."SECCIONES" MODIFY ("ID" NOT NULL DISABLE);
  ALTER TABLE "FUNDAUC"."SECCIONES" ADD CONSTRAINT "SECCIONES_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC"  ENABLE;
  ALTER TABLE "FUNDAUC"."SECCIONES" ADD CONSTRAINT "SECCIONES_UK1" UNIQUE ("ID_SECCION")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC"  ENABLE;
--------------------------------------------------------
--  Constraints for Table INSTANCIAS_SECCIONES
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."INSTANCIAS_SECCIONES" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "FUNDAUC"."INSTANCIAS_SECCIONES" ADD CONSTRAINT "INSTANCIAS_SECCIONES_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC"  ENABLE;
  ALTER TABLE "FUNDAUC"."INSTANCIAS_SECCIONES" MODIFY ("F_INICIO" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table JOB_LOG
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."JOB_LOG" ADD PRIMARY KEY ("LOG_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC"  ENABLE;
--------------------------------------------------------
--  Constraints for Table HOJA_VIDA_EST
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."HOJA_VIDA_EST" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "FUNDAUC"."HOJA_VIDA_EST" ADD CONSTRAINT "CC_JSON_METADATA" CHECK (METADATA is JSON) ENABLE;
  ALTER TABLE "FUNDAUC"."HOJA_VIDA_EST" ADD CONSTRAINT "HOJA_VIDA_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC"  ENABLE;
--------------------------------------------------------
--  Constraints for Table INSCRIPCIONES_HIS
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."INSCRIPCIONES_HIS" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "FUNDAUC"."INSCRIPCIONES_HIS" MODIFY ("FECHA_INS" NOT NULL ENABLE);
  ALTER TABLE "FUNDAUC"."INSCRIPCIONES_HIS" MODIFY ("EST_MATRICULA" NOT NULL ENABLE);
  ALTER TABLE "FUNDAUC"."INSCRIPCIONES_HIS" MODIFY ("SECCION_ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table INSCRIPCIONES_RESP
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."INSCRIPCIONES_RESP" MODIFY ("ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table CIUDADES
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."CIUDADES" ADD CONSTRAINT "CIUDADES_PK" PRIMARY KEY ("ID_CIUDAD")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC"  ENABLE;
--------------------------------------------------------
--  Constraints for Table TIPO_ESTUDIANTE
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."TIPO_ESTUDIANTE" MODIFY ("DESCRIPCION" NOT NULL DISABLE);
  ALTER TABLE "FUNDAUC"."TIPO_ESTUDIANTE" ADD CONSTRAINT "TIPO_ESTUDIANTE_PK" PRIMARY KEY ("ID_TIPO_EST")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC"  ENABLE;
--------------------------------------------------------
--  Constraints for Table SECCIONES_BAK
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."SECCIONES_BAK" MODIFY ("ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table ESTADOS
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."ESTADOS" ADD CONSTRAINT "ESTADOS_PK" PRIMARY KEY ("ID_ESTADO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC"  ENABLE;
--------------------------------------------------------
--  Constraints for Table CTAXCOB
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."CTAXCOB" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "FUNDAUC"."CTAXCOB" MODIFY ("CLIENTE_ID" NOT NULL ENABLE);
  ALTER TABLE "FUNDAUC"."CTAXCOB" MODIFY ("FECHA" NOT NULL ENABLE);
  ALTER TABLE "FUNDAUC"."CTAXCOB" MODIFY ("CREDITO" NOT NULL ENABLE);
  ALTER TABLE "FUNDAUC"."CTAXCOB" MODIFY ("MONTO" NOT NULL ENABLE);
  ALTER TABLE "FUNDAUC"."CTAXCOB" ADD CONSTRAINT "CTAXCOB_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC"  ENABLE;
--------------------------------------------------------
--  Constraints for Table CALENDARIOS_DETALLE
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."CALENDARIOS_DETALLE" MODIFY ("ID_CALENDARIO" NOT NULL DISABLE);
  ALTER TABLE "FUNDAUC"."CALENDARIOS_DETALLE" MODIFY ("PERIODO" NOT NULL DISABLE);
  ALTER TABLE "FUNDAUC"."CALENDARIOS_DETALLE" MODIFY ("MODALIDAD" NOT NULL DISABLE);
  ALTER TABLE "FUNDAUC"."CALENDARIOS_DETALLE" MODIFY ("ID" NOT NULL DISABLE);
  ALTER TABLE "FUNDAUC"."CALENDARIOS_DETALLE" ADD CONSTRAINT "CALENDARIOS_DETALLE_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC"  ENABLE;
  ALTER TABLE "FUNDAUC"."CALENDARIOS_DETALLE" ADD CONSTRAINT "CK_PER_ACTIVO" CHECK ( periodo_activo IN (
        'N',
        'S'
    ) ) DISABLE;
--------------------------------------------------------
--  Constraints for Table EVENTOS
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."EVENTOS" MODIFY ("DESCRIPCION" NOT NULL DISABLE);
  ALTER TABLE "FUNDAUC"."EVENTOS" ADD CONSTRAINT "EVENTOS_PK" PRIMARY KEY ("ID_EVENTO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC"  ENABLE;
--------------------------------------------------------
--  Constraints for Table COHORTES
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."COHORTES" MODIFY ("ID" NOT NULL DISABLE);
  ALTER TABLE "FUNDAUC"."COHORTES" MODIFY ("TIPO_DIPLO" NOT NULL DISABLE);
  ALTER TABLE "FUNDAUC"."COHORTES" MODIFY ("DIPLOMADO_ID" NOT NULL DISABLE);
  ALTER TABLE "FUNDAUC"."COHORTES" ADD CONSTRAINT "COHORTES_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "FUNDAUC"  ENABLE;
  ALTER TABLE "FUNDAUC"."COHORTES" ADD CONSTRAINT "COHORTES_UK1" UNIQUE ("CODIGO") DISABLE;
--------------------------------------------------------
--  Ref Constraints for Table CALENDARIOS_DETALLE
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."CALENDARIOS_DETALLE" ADD CONSTRAINT "CALENDARIOS_DET_MOD_FK" FOREIGN KEY ("MODALIDAD")
	  REFERENCES "FUNDAUC"."MODALIDADES" ("ID_MODALIDAD") ENABLE;
  ALTER TABLE "FUNDAUC"."CALENDARIOS_DETALLE" ADD CONSTRAINT "CALENDARIOS_DET_CAL_FK" FOREIGN KEY ("ID_CALENDARIO")
	  REFERENCES "FUNDAUC"."CALENDARIOS" ("ID_CALENDARIO") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table CIUDADES
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."CIUDADES" ADD CONSTRAINT "CIUD_EST_FK" FOREIGN KEY ("ID_ESTADO")
	  REFERENCES "FUNDAUC"."ESTADOS" ("ID_ESTADO") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table COHORTES
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."COHORTES" ADD CONSTRAINT "COHORTES_DIPLOMADOS_FK" FOREIGN KEY ("DIPLOMADO_ID")
	  REFERENCES "FUNDAUC"."DIPLOMADOS" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table DETALLE_FACTURA
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."DETALLE_FACTURA" ADD CONSTRAINT "DET_FAC_MATERIALES_FK" FOREIGN KEY ("MATERIALES_ID")
	  REFERENCES "FUNDAUC"."MATERIALES" ("ID") DISABLE;
  ALTER TABLE "FUNDAUC"."DETALLE_FACTURA" ADD CONSTRAINT "FK_FACT" FOREIGN KEY ("FACTURA_ID")
	  REFERENCES "FUNDAUC"."FACTURA" ("ID") ON DELETE CASCADE ENABLE;
  ALTER TABLE "FUNDAUC"."DETALLE_FACTURA" ADD CONSTRAINT "DET_FAC_TIPO_MAT_FK1" FOREIGN KEY ("TIPO_ITEM")
	  REFERENCES "FUNDAUC"."TIPO_MATERIAL" ("ABREV") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table EMP
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."EMP" ADD FOREIGN KEY ("DEPTNO")
	  REFERENCES "FUNDAUC"."DEPT" ("DEPTNO") ENABLE;
  ALTER TABLE "FUNDAUC"."EMP" ADD FOREIGN KEY ("MGR")
	  REFERENCES "FUNDAUC"."EMP" ("EMPNO") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table ESTUDIANTE
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."ESTUDIANTE" ADD CONSTRAINT "ESTUDIANTE_OCUPACIONES_FK" FOREIGN KEY ("PROFESION")
	  REFERENCES "FUNDAUC"."OCUPACIONES" ("ID_OCUPACION") ENABLE;
  ALTER TABLE "FUNDAUC"."ESTUDIANTE" ADD CONSTRAINT "ESTUDIANTE_CIUDADES_FK" FOREIGN KEY ("CIUDAD")
	  REFERENCES "FUNDAUC"."CIUDADES" ("ID_CIUDAD") ENABLE;
  ALTER TABLE "FUNDAUC"."ESTUDIANTE" ADD CONSTRAINT "ESTUDIANTE_COMPANIAS_FK" FOREIGN KEY ("SEDE")
	  REFERENCES "FUNDAUC"."COMPANIAS" ("CODIGO") ENABLE;
  ALTER TABLE "FUNDAUC"."ESTUDIANTE" ADD CONSTRAINT "ESTUDIANTE_ESTADOS_FK" FOREIGN KEY ("ESTADO")
	  REFERENCES "FUNDAUC"."ESTADOS" ("ID_ESTADO") ENABLE;
  ALTER TABLE "FUNDAUC"."ESTUDIANTE" ADD CONSTRAINT "EST_TP_EST_FK" FOREIGN KEY ("ID_TIPO_EST")
	  REFERENCES "FUNDAUC"."TIPO_ESTUDIANTE" ("ID_TIPO_EST") ENABLE;
  ALTER TABLE "FUNDAUC"."ESTUDIANTE" ADD CONSTRAINT "ESTUDIANTE_ZONAS_FK" FOREIGN KEY ("ZONA")
	  REFERENCES "FUNDAUC"."ZONAS" ("ID_ZONA") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table FACTURA
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."FACTURA" ADD CONSTRAINT "FACTURA_COMPANIAS_FK" FOREIGN KEY ("PROGRAMA")
	  REFERENCES "FUNDAUC"."COMPANIAS" ("CODIGO") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table FACTURA_DEPOSITO
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."FACTURA_DEPOSITO" ADD CONSTRAINT "FACTURA_DEPOSITO_DEPOSITO_FK" FOREIGN KEY ("DEPOSITO_ID")
	  REFERENCES "FUNDAUC"."DEPOSITO" ("ID") ENABLE;
  ALTER TABLE "FUNDAUC"."FACTURA_DEPOSITO" ADD CONSTRAINT "FACTURA_DEPOSITO_FACTURA_FK" FOREIGN KEY ("FACTURA_ID")
	  REFERENCES "FUNDAUC"."FACTURA" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table INSCRIPCIONES
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."INSCRIPCIONES" ADD CONSTRAINT "INSCRIPCIONES_SECCIONES_FK" FOREIGN KEY ("SECCION_ID")
	  REFERENCES "FUNDAUC"."SECCIONES" ("ID") ENABLE;
  ALTER TABLE "FUNDAUC"."INSCRIPCIONES" ADD CONSTRAINT "INSCRIPCIONES_FK1" FOREIGN KEY ("COHORTE_ID")
	  REFERENCES "FUNDAUC"."COHORTES" ("ID") ENABLE;
  ALTER TABLE "FUNDAUC"."INSCRIPCIONES" ADD CONSTRAINT "INSCRIPCIONES_ESTUDIANTE_FK" FOREIGN KEY ("EST_MATRICULA")
	  REFERENCES "FUNDAUC"."ESTUDIANTE" ("MATRICULA") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table MATERIALES
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."MATERIALES" ADD CONSTRAINT "MATERIALES_SECCIONES_FK" FOREIGN KEY ("SECCION_ID")
	  REFERENCES "FUNDAUC"."SECCIONES" ("ID") ENABLE;
  ALTER TABLE "FUNDAUC"."MATERIALES" ADD CONSTRAINT "MATERIALES_COHORTES_FK" FOREIGN KEY ("COHORTE_ID")
	  REFERENCES "FUNDAUC"."COHORTES" ("ID") ENABLE;
  ALTER TABLE "FUNDAUC"."MATERIALES" ADD CONSTRAINT "MATERIALES_TIPO_MATERIAL_FK" FOREIGN KEY ("TIPO")
	  REFERENCES "FUNDAUC"."TIPO_MATERIAL" ("ABREV") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table PRECIOS
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."PRECIOS" ADD CONSTRAINT "PRECIOS_FK1" FOREIGN KEY ("ID")
	  REFERENCES "FUNDAUC"."MATERIALES" ("ID") ON DELETE CASCADE ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table SALONES
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."SALONES" ADD CONSTRAINT "SALONES_EDIFICIOS_FK" FOREIGN KEY ("EDIFICIO")
	  REFERENCES "FUNDAUC"."EDIFICIOS" ("ID_EDIF") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table SECCIONES
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."SECCIONES" ADD CONSTRAINT "SECCIONES_METODOS_FK" FOREIGN KEY ("ID_METODO")
	  REFERENCES "FUNDAUC"."METODOS" ("ID_METODO") ENABLE;
  ALTER TABLE "FUNDAUC"."SECCIONES" ADD CONSTRAINT "SECCIONES_MODALIDADES_FK" FOREIGN KEY ("MODALIDAD")
	  REFERENCES "FUNDAUC"."MODALIDADES" ("ID_MODALIDAD") ENABLE;
  ALTER TABLE "FUNDAUC"."SECCIONES" ADD CONSTRAINT "SECCIONES_PROFESOR_FK" FOREIGN KEY ("CEDULA_PROF")
	  REFERENCES "FUNDAUC"."PROFESOR" ("CEDULA_PROF") ENABLE;
  ALTER TABLE "FUNDAUC"."SECCIONES" ADD CONSTRAINT "SECCIONES_SALONES_FK" FOREIGN KEY ("ID_SALON", "ID_EDIF")
	  REFERENCES "FUNDAUC"."SALONES" ("ID_SALON", "EDIFICIO") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table USUARIOS
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."USUARIOS" ADD CONSTRAINT "USR_ROL_FK" FOREIGN KEY ("ID_ROL")
	  REFERENCES "FUNDAUC"."ROLES" ("ID_ROL") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table ZONAS
--------------------------------------------------------

  ALTER TABLE "FUNDAUC"."ZONAS" ADD CONSTRAINT "FK_ZONAS" FOREIGN KEY ("ID_CIUDAD")
	  REFERENCES "FUNDAUC"."CIUDADES" ("ID_CIUDAD") ENABLE;
