--------------------------------------------------------
--  DDL for Package Body APEX_ENHANCED_LOV_ITEM
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."APEX_ENHANCED_LOV_ITEM" as

  g_app_id  number default v('APP_ID');
  g_page_id number default v('APP_PAGE_ID');
  g_debug   boolean default case when v('DEBUG') = 'YES' then true else false end;
  g_ajax_mode varchar2(4000);

  g_ajax_search_string varchar2(4000);
  g_ajax_search_column_idx number;

  g_item   apex_plugin.t_page_item;
  g_plugin apex_plugin.t_plugin;

  --
  -- function prepareSqlQuery
  --
  function prepareSqlQuery return varchar2
  is
    v_query varchar2(32767) := g_item.lov_definition;
  begin
    /*
      queries generated by APEX for static inline lov and static shared lov
    */
    --select /*+ cardinality(t 5) no_result_cache */ disp, val from table(wwv_flow_utilities.get_temp_lov_data(1)) t order by disp
    --select /*+ cardinality(t 10) no_result_cache */ disp, val from table(wwv_flow_utilities.get_temp_lov_data(1)) t order by insert_order, disp

    if  instr(v_query, '*/ disp, val from') > 0  then
      v_query := '
        /*1*/
        select disp d, val r from (
          '||v_query||'
        ) /*2*/
      ';
    end if;

    return 'select * from ('||v_query||') where r is not null';
  end prepareSqlQuery;

  --
  -- getBindedRefCursor
  --

  function getBindedRefCursor(
    pi_sql in varchar2
  ) return sys_refcursor as
    v_apex_items_names    DBMS_SQL.VARCHAR2_TABLE;
    v_cursor              pls_integer;
    v_status              number;
  begin
    v_apex_items_names := WWV_FLOW_UTILITIES.GET_BINDS( pi_sql );

    -- open v_cursor;
    v_cursor := dbms_sql.open_cursor;

    dbms_sql.parse (v_cursor, pi_sql, dbms_sql.native);

    -- bind items
    for i in 1..v_apex_items_names.count loop

      if v_apex_items_names(i) = ':SEARCH_STRING' then
        dbms_sql.bind_variable (v_cursor, v_apex_items_names(i), g_ajax_search_string );
      else
        dbms_sql.bind_variable (v_cursor, v_apex_items_names(i), v( trim(both ':' from v_apex_items_names(i)) ) );
      end if;

    end loop;

    v_status := dbms_sql.execute(v_cursor);

    return dbms_sql.to_refcursor(v_cursor);  
  end getBindedRefCursor;

  --
  -- t_item_render_param_to_json
  --

  function t_item_render_param_to_json(
    p_param in apex_plugin.t_item_render_param
  ) return clob is 

    v_clob clob;
  begin
    apex_json.initialize_clob_output;
    apex_json.open_object;

    apex_json.write('value_set_by_controller', p_param.value_set_by_controller);
    apex_json.write('value', p_param.value);
    apex_json.write('is_readonly', p_param.is_readonly);
    apex_json.write('is_printer_friendly', p_param.is_printer_friendly );

    apex_json.close_object;

    v_clob := apex_json.get_clob_output;

    apex_json.free_output;

    return v_clob;
  end t_item_render_param_to_json;

  --
  -- t_plugin_to_json
  --

  function t_plugin_to_json(
    p_plugin in apex_plugin.t_plugin
  ) return clob is 
    v_clob clob;
  begin
    apex_json.initialize_clob_output;
    apex_json.open_object;

    apex_json.write('name', p_plugin.name);
    apex_json.write('file_prefix', p_plugin.file_prefix);
    apex_json.write('ajaxIdentifier', apex_plugin.get_ajax_identifier);
    apex_json.write('attribute_01', p_plugin.attribute_01);
    apex_json.write('attribute_02', p_plugin.attribute_02);
    apex_json.write('attribute_03', p_plugin.attribute_03);
    apex_json.write('attribute_04', p_plugin.attribute_04);
    apex_json.write('attribute_05', p_plugin.attribute_05);
    apex_json.write('attribute_06', p_plugin.attribute_06);
    apex_json.write('attribute_07', p_plugin.attribute_07);
    apex_json.write('attribute_08', p_plugin.attribute_08);
    apex_json.write('attribute_09', p_plugin.attribute_09);
    apex_json.write('attribute_10', p_plugin.attribute_10);
    apex_json.write('attribute_11', p_plugin.attribute_11);
    apex_json.write('attribute_12', p_plugin.attribute_12);
    apex_json.write('attribute_13', p_plugin.attribute_13);
    apex_json.write('attribute_14', p_plugin.attribute_14);
    apex_json.write('attribute_15', p_plugin.attribute_15);

    apex_json.close_object;

    v_clob := apex_json.get_clob_output;

    apex_json.free_output;

    return v_clob;
  end t_plugin_to_json;
  --
  -- t_page_item_to_json
  --
  function t_page_item_to_json(
    p_item in apex_plugin.t_item
  ) return clob
  is
    v_clob clob;
  begin

    apex_json.initialize_clob_output;
    apex_json.open_object;

    apex_json.write('id', p_item.id);
    apex_json.write('name', p_item.name);
    apex_json.write('label', p_item.label);
    apex_json.write('plain_label', p_item.plain_label);
    apex_json.write('label_id', p_item.label_id);
    apex_json.write('placeholder', p_item.placeholder);
    apex_json.write('format_mask', p_item.format_mask);
    apex_json.write('is_required', p_item.is_required);
    apex_json.write('lov_definition', p_item.lov_definition);
    apex_json.write('lov_display_extra', p_item.lov_display_extra);
    apex_json.write('lov_display_null', p_item.lov_display_null);
    apex_json.write('lov_null_text', p_item.lov_null_text);
    apex_json.write('lov_null_value', p_item.lov_null_value);
    apex_json.write('lov_cascade_parent_items', p_item.lov_cascade_parent_items);
    apex_json.write('ajax_items_to_submit', p_item.ajax_items_to_submit);
    apex_json.write('ajax_optimize_refresh', p_item.ajax_optimize_refresh);
    apex_json.write('element_width', p_item.element_width);
    apex_json.write('element_max_length', p_item.element_max_length);
    apex_json.write('element_height', p_item.element_height);
    apex_json.write('element_css_classes', p_item.element_css_classes);
    apex_json.write('element_attributes', p_item.element_attributes);
    apex_json.write('element_option_attributes', p_item.element_option_attributes);
    apex_json.write('escape_output', p_item.escape_output);
    apex_json.write('attribute_01', p_item.attribute_01);
    apex_json.write('attribute_02', p_item.attribute_02);
    apex_json.write('attribute_03', p_item.attribute_03);
    apex_json.write('attribute_04', p_item.attribute_04);
    apex_json.write('attribute_05', p_item.attribute_05);
    apex_json.write('attribute_06', p_item.attribute_06);
    apex_json.write('attribute_07', p_item.attribute_07);
    apex_json.write('attribute_08', p_item.attribute_08);
    apex_json.write('attribute_09', p_item.attribute_09);
    apex_json.write('attribute_10', p_item.attribute_10);
    apex_json.write('attribute_11', p_item.attribute_11);
    apex_json.write('attribute_12', p_item.attribute_12);
    apex_json.write('attribute_13', p_item.attribute_13);
    apex_json.write('attribute_14', p_item.attribute_14);
    apex_json.write('attribute_15', p_item.attribute_15);

    apex_json.close_object;

    v_clob := apex_json.get_clob_output;

    apex_json.free_output;

    return v_clob;
  end t_page_item_to_json;

  --
  -- function f_queryGetColumnType
  --
  function f_queryGetColumnType(
    p_col_type in number
  ) return varchar2 is 
    l_col_type varchar2(50);
  begin
    if p_col_type = 1 then
      l_col_type := 'VARCHAR2';

    elsif p_col_type = 2 then
      l_col_type := 'NUMBER';

    elsif p_col_type = 12 then
      l_col_type := 'DATE';

    elsif p_col_type in (180,181,231) then
      l_col_type := 'TIMESTAMP';

      if p_col_type = 231 then
          l_col_type := 'TIMESTAMP_LTZ';
      end if;

    elsif p_col_type = 112 then
      l_col_type := 'CLOB';

    elsif p_col_type = 113 then

      l_col_type := 'BLOB';

    elsif p_col_type = 96 then
      l_col_type := 'CHAR';

    else
        l_col_type := 'OTHER';
    end if;

    return l_col_type;

  end f_queryGetColumnType;

  --
  -- procedure p_queryDescribeColumns
  --
  procedure p_queryDescribeColumns(
    pi_sql              in  varchar2,
    po_columns_no       out number,
    po_columns_info_arr out sys.dbms_sql.desc_tab2
  ) 
  is
    v_apex_items_names  DBMS_SQL.VARCHAR2_TABLE := WWV_FLOW_UTILITIES.GET_BINDS( pi_sql );
    v_cursor            pls_integer;
    v_desc_col_no       number          := 0;
    v_desc_col_info     sys.dbms_sql.desc_tab2;  
    v_status            number;

  begin
    v_cursor := dbms_sql.open_cursor;

    dbms_sql.parse ( v_cursor, pi_sql, dbms_sql.native);

    --bind items
    for i in 1..v_apex_items_names.count loop
      dbms_sql.bind_variable (v_cursor, v_apex_items_names(i), v( trim(both ':' from v_apex_items_names(i)) ) );
    end loop;

    sys.dbms_sql.describe_columns2( v_cursor, v_desc_col_no, v_desc_col_info);

    v_status := dbms_sql.execute(v_cursor);

    po_columns_no       := v_desc_col_no;
    po_columns_info_arr := v_desc_col_info;

  end p_queryDescribeColumns;

  --
  -- function f_queryPrepareConditions
  --
  function f_queryPrepareConditions(
    pi_sql in varchar2
  ) return varchar2
  is
    v_desc_col_no   number          := 0;
    v_desc_col_info sys.dbms_sql.desc_tab2;  
    v_return        varchar2(32767);
  begin
    p_queryDescribeColumns(
      pi_sql              => pi_sql,
      po_columns_no       => v_desc_col_no,
      po_columns_info_arr => v_desc_col_info
    );

    if g_ajax_search_column_idx is not null then
      --search by specific column
      v_return := 'where upper('||v_desc_col_info(g_ajax_search_column_idx).col_name||') like upper(''%''||:SEARCH_STRING||''%'')';
    else
      --search by every column from query
      v_return := 'where ';

      for i in 1..v_desc_col_no loop
        v_return := v_return||' upper('||v_desc_col_info(i).col_name||') like upper(''%''||:SEARCH_STRING||''%'') or';
      end loop;

      v_return := rtrim(v_return, ' or');

    end if;

    return v_return;
  end f_queryPrepareConditions;

  --
  -- f_queryGetColumnsJson
  --

  function f_queryGetColumnsJson return clob is
    v_return        CLOB;
    v_desc_col_no   number          := 0;
    v_desc_col_info sys.dbms_sql.desc_tab2;  
  begin
    p_queryDescribeColumns(
      pi_sql              => prepareSqlQuery,
      po_columns_no       => v_desc_col_no,
      po_columns_info_arr => v_desc_col_info
    );

    apex_json.initialize_clob_output;
    apex_json.open_array;

    for i in 1..v_desc_col_no loop
      apex_json.open_object;
      apex_json.write('COLUMN_NAME', v_desc_col_info(i).col_name);
      apex_json.write('COLUMN_TYPE', f_queryGetColumnType( v_desc_col_info(i).col_type ) );
      apex_json.write('SHEMA_NAME', v_desc_col_info(i).col_schema_name, true );
      apex_json.write('IDX', i );

      apex_json.close_object;
    end loop;

    apex_json.close_array;

    v_return := apex_json.get_clob_output;

    apex_json.free_output;

    return v_return;
  end f_queryGetColumnsJson;

  --
  -- f_getDisplayValues
  --
  function f_getDisplayValues(
    pi_value in varchar2
  ) return varchar2
  is
    v_cursor sys_refcursor;
    v_result varchar2(32767);
    v_query  varchar2(32767);
  begin
    v_query := '
      select 
        listagg(d, '', '') within group( order by d asc )
      from (
        '||prepareSqlQuery||'
      ) 
      where
        r in ('||''''||replace(pi_value, ':', ''',''')||''''||')
    ';

    v_cursor := getBindedRefCursor( v_query );

    FETCH v_cursor INTO v_result;

    CLOSE v_cursor;

    return v_result;
  end f_getDisplayValues;

  --
  -- f_autocompleteGetDefaulsSearch
  --

  function f_autocompleteGetDefaulsSearch return varchar2
  is 
    v_attr_autocomplete_d_search  APEX_APPLICATION_PAGE_ITEMS.attribute_04%type := g_item.attribute_04;
    v_conditions                  varchar2(32767);
  begin

    if v_attr_autocomplete_d_search = 'D%' then
      v_conditions := v_conditions||' 
        and upper(d) like upper(:SEARCH_STRING||''%'') 
      ';
    end if;

    if v_attr_autocomplete_d_search = '%D' then
      v_conditions := v_conditions||' 
        and upper(d) like upper(''%''||:SEARCH_STRING) 
      ';
    end if;

    if v_attr_autocomplete_d_search = '%D%' then
      v_conditions := v_conditions||' 
        and upper(d) like upper(''%''||:SEARCH_STRING||''%'') 
      ';
    end if;

    if v_attr_autocomplete_d_search = 'D' then
      v_conditions := v_conditions||' 
        and upper(d) = upper(:SEARCH_STRING) 
      ';
    end if;

    if v_attr_autocomplete_d_search = 'R%' then
      v_conditions := v_conditions||' 
        and upper(r) like upper(:SEARCH_STRING||''%'') 
      ';
    end if;

    if v_attr_autocomplete_d_search = '%R' then
      v_conditions := v_conditions||' 
        and upper(r) like upper(''%''||:SEARCH_STRING) 
      ';
    end if;

    if v_attr_autocomplete_d_search = '%R%' then
      v_conditions := v_conditions||' 
        and upper(r) like upper(''%''||:SEARCH_STRING||''%'') 
      ';
    end if;

    if v_attr_autocomplete_d_search = 'R' then
      v_conditions := v_conditions||' 
        and upper(R) = upper(:SEARCH_STRING) 
      ';
    end if;

    if v_attr_autocomplete_d_search = 'DR%' then
      v_conditions := v_conditions||' 
        and (
          upper(r) like upper(:SEARCH_STRING||''%'')
          or upper(d) like upper(:SEARCH_STRING||''%'')
        )
      ';
    end if;

    if v_attr_autocomplete_d_search = '%DR' then
      v_conditions := v_conditions||' 
        and (
          upper(r) like upper(''%''||:SEARCH_STRING)
          or upper(d) like upper(''%''||:SEARCH_STRING)
        )
      ';
    end if;

    if v_attr_autocomplete_d_search = '%DR%' then
      v_conditions := v_conditions||' 
        and (
          upper(r) like upper(''%''||:SEARCH_STRING||''%'')
          or upper(d) like upper(''%''||:SEARCH_STRING||''%'')
        )
      ';
    end if;

    if v_attr_autocomplete_d_search = 'DR' then
      v_conditions := v_conditions||' 
        and (
          upper(r) = upper(:SEARCH_STRING)
          or upper(d) = upper(:SEARCH_STRING)
        )
      ';
    end if;  

    return v_conditions;
  end f_autocompleteGetDefaulsSearch;

  --
  -- function f_getRownumLimiterStart
  --
  function f_getRownumLimiterStart(
    p_page          in number,
    p_rows_per_page in number
  ) return number
  is
    v_start_rownum_with number;
    v_start_rownum      number;
  begin
    v_start_rownum_with := (p_page-1)*p_rows_per_page+1;

    if v_start_rownum_with = 0 then
      v_start_rownum := 1;
    else
      v_start_rownum := v_start_rownum_with;
    end if;

    return v_start_rownum;

  end f_getRownumLimiterStart;

  --
  -- f_popupGetCurrentPageDataCount
  --

  function f_popupGetCurrentPageDataCount(
    pi_where in varchar2
  ) return number 
  is
    v_cursor  sys_refcursor;
    v_result  number;
    v_query   varchar2(4000);
  begin
    v_cursor :=  getBindedRefCursor( 'select count(1) from ( '||prepareSqlQuery||' )'||pi_where );

    FETCH v_cursor INTO v_result;

    CLOSE v_cursor;

    return v_result;
  end f_popupGetCurrentPageDataCount;

  --
  -- f_queryRemoveOrderBy
  --
  function f_queryRemoveOrderBy(
    pi_sql_query in varchar2
  ) return varchar2 is
  begin
    return REGEXP_REPLACE(pi_sql_query, '(\s{0,})order(\s{1,})by(\s{1,})([^\sdecode])(.*)|(\s{1,})(order(\s{1,})by(\s{1,})decode\([^\)]*\))', '');
  end f_queryRemoveOrderBy;

  --
  -- p_ajax_getReturnValues
  --

  procedure p_ajax_getReturnValues is
    v_query      varchar2(32767) := g_item.lov_definition;
    v_where      varchar2(32767);
    v_ref_cursor sys_refcursor;
  begin

    if g_ajax_search_string is not null then
      v_where := f_queryPrepareConditions( v_query );
    end if;


    v_query := '
      select
        r
      from (
        '||v_query||'
      )
      '||v_where||'
    ';

    v_ref_cursor := getBindedRefCursor(v_query);

    apex_json.open_object;

    if g_debug then
      apex_json.write( 'query', v_query, true );
    end if;

    apex_json.write( 'searchString', g_ajax_search_string, true );
    apex_json.write( 'searchColumnIdx', g_ajax_search_column_idx, true );
    apex_json.write( 'data', v_ref_cursor );    

    apex_json.close_object;  

  end p_ajax_getReturnValues;

  --
  -- f_queryAutocomplete
  --
  function f_queryAutocomplete(
    pi_rownum_start in varchar2 default 0,
    pi_rownum_end   in varchar2 default 0
  ) return varchar2 is
    v_lov_query varchar2(32767);  
    v_query     varchar2(32767);

    v_attr_autocomplete_settings APEX_APPLICATION_PAGE_ITEMS.attribute_01%type := g_item.attribute_01;
    v_attr_autocomplete_search   APEX_APPLICATION_PAGE_ITEMS.attribute_02%type := g_item.attribute_02;

  begin
    v_lov_query := f_queryRemoveOrderBy( prepareSqlQuery );

    v_query := '
      select 
        * 
      from ( 
        '||v_lov_query||' 
      ) 
      where
        1=1
    ';

    if instr(v_attr_autocomplete_settings, 'UCSL') > 0 then
      --custom search
      v_query := v_query ||' '||v_attr_autocomplete_search||'';
    else
      --default search
      v_query := v_query ||f_autocompleteGetDefaulsSearch();
    end if;

    if pi_rownum_start = 0 and pi_rownum_end = 0 then
      return v_query;
    end if;

    return '
      select 
        *
      from (
        select 
          a.*, 
          rownum pretius_rnum
        from (
          /**/
          '||v_query||'
          /**/
        ) a
        where rownum < '||pi_rownum_end||'
      )
      where pretius_rnum >= '||pi_rownum_start||'
    ';
  end f_queryAutocomplete;



  --
  -- f_query_popupSelected
  --
  function f_query_popupSelected(
    pi_collection_name in varchar2,
    pi_query           in varchar2
  ) return varchar2 is
  begin
   return '
      select
        query.* 
      from 
        apex_collections
      join (
        '||pi_query||'
      ) query
      on
        c001 = r
      where
        collection_name = '''||pi_collection_name||'''
    ';
  end f_query_popupSelected;


  --
  -- p_ajax_getSessionState
  --    
  procedure p_ajax_getSessionState is
    v_selected_arr    APEX_APPLICATION_GLOBAL.VC_ARR2;
    v_collection_name APEX_COLLECTIONS.COLLECTION_NAME%TYPE := g_item.name||'_SHOWSELECTED';

    v_session_value   varchar2(4000) := v(g_item.name);
    v_query           varchar2(32767);

    v_ref_cursor      sys_refcursor;
  begin

    v_selected_arr := APEX_UTIL.STRING_TO_TABLE (
      p_string    => v_session_value,
      p_separator => ':'
    );

    APEX_COLLECTION.CREATE_OR_TRUNCATE_COLLECTION( v_collection_name );

    APEX_COLLECTION.ADD_MEMBERS(
      p_collection_name => v_collection_name,
      p_c001            => v_selected_arr
    );

    v_query := f_queryRemoveOrderBy( prepareSqlQuery );

    v_query := f_query_popupSelected(
      pi_collection_name => v_collection_name,
      pi_query           => v_query
    );

    open v_ref_cursor for v_query;

    apex_json.open_object;

    if g_debug then
      apex_json.write( 'query', v_query, true );
    end if;

    apex_json.write( 'request', g_ajax_mode, true );
    apex_json.write( 'data', v_ref_cursor );
    apex_json.write( 'session', v_session_value);

    apex_json.close_object;
  end p_ajax_getSessionState;

  --
  --  p_ajax_autocomplete
  --
  procedure p_ajax_autocomplete 
  is
    v_ref_cursor     sys_refcursor;
    v_ref_cursor_cnt sys_refcursor;

    v_rows_per_page number default to_number(v('APP_AJAX_X02'));
    v_page          number default to_number(v('APP_AJAX_X04'));
    v_start_rownum  number;
    v_end_rownum    number;

    v_query         varchar2(32767);
  begin

    v_start_rownum := f_getRownumLimiterStart(
      p_page => v_page,
      p_rows_per_page => v_rows_per_page
    );

    v_end_rownum := v_start_rownum + v_rows_per_page;

    v_query := f_queryAutocomplete(
      pi_rownum_start => v_start_rownum,
      pi_rownum_end   => v_end_rownum
    );

    v_ref_cursor := getBindedRefCursor(v_query);

    v_ref_cursor_cnt := getBindedRefCursor('select count(1) cnt from ('||f_queryAutocomplete||')');


    apex_json.open_object;

    if g_debug then
      apex_json.write( 'query', v_query, true );
    end if;

    apex_json.write( 'request',       g_ajax_mode, true );
    apex_json.write( 'searchString',  g_ajax_search_string, true );
    apex_json.write( 'rownumStart',   v_start_rownum, true );
    apex_json.write( 'rownumEnd',     v_end_rownum , true );
    apex_json.write( 'requestedPage', v_page , true );
    apex_json.write( 'rowsPerPage',   v_rows_per_page , true );
    apex_json.write( 'data',          v_ref_cursor );
    apex_json.write( 'dataVolume',    v_ref_cursor_cnt );


    apex_json.close_object;

  end p_ajax_autocomplete;  

  --
  -- p_ajax_popup_report
  --
  procedure p_ajax_popup_report is
    v_rows_per_page       number default to_number(v('APP_AJAX_X02'));
    v_page                number default to_number(v('APP_AJAX_X04'));
    v_sortColumnIdx       number default to_number(v('APP_AJAX_X05'));
    v_start_rownum        number;
    v_end_rownum          number;

    v_sortColumnDirection varchar2(4) default v('APP_AJAX_X06');
    v_query               varchar2(32767);
    v_order_by            varchar2(4000);
    v_where               varchar2(32767);
    e_msg                 varchar2(4000);

    v_ref_cursor          sys_refcursor;
    e_open_ref_cursor     exception;
  begin
    v_start_rownum := f_getRownumLimiterStart(
      p_page => v_page,
      p_rows_per_page => v_rows_per_page
    );

    v_end_rownum := v_start_rownum + v_rows_per_page -1;

    v_query := prepareSqlQuery;

    v_query := replace(v_query, chr(9), ' ');
    v_query := replace(v_query, chr(10)||chr(13), ' ');
    v_query := replace(v_query, chr(10), ' ');
    v_query := replace(v_query, chr(13), ' ');

    if  instr(v_query, '*/ disp, val from') = 0  then
      v_query := f_queryRemoveOrderBy( v_query );
    end if;

    if v_sortColumnIdx is not null then
      v_order_by := 'order by '||v_sortColumnIdx||' '||v_sortColumnDirection||'';
    end if;

    if g_ajax_search_string is not null then
      v_where := f_queryPrepareConditions( v_query );
    end if;

    v_query := '
      select 
        *
      from (
        select 
          a.*, 
          rownum pretius_rnum
        from (
          select
            *
          from (
            '||v_query||'
          )
          '||v_where||'
          '||v_order_by||'
        ) a
        where rownum <= '||v_end_rownum||'
      )
      where 
        pretius_rnum >= '||v_start_rownum||'
    ';

    v_ref_cursor := getBindedRefCursor(v_query);

    apex_json.open_object;

    if g_debug then
      apex_json.write( 'query', v_query, true );
    end if;

    apex_json.write( 'request', g_ajax_mode, true );
    apex_json.write( 'searchString', g_ajax_search_string, true );
    apex_json.write( 'rownumStart', v_start_rownum, true );
    apex_json.write( 'rownumEnd', v_end_rownum, true );
    apex_json.write( 'requestedPage', v_page, true );
    apex_json.write( 'rowsPerPage', v_rows_per_page, true );
    apex_json.write( 'sortByColumnIdx', v_sortColumnIdx, true );
    apex_json.write( 'sortByColumnDirection', v_sortColumnDirection, true );
    apex_json.write( 'searchColumnIdx', g_ajax_search_column_idx, true );
    apex_json.write( 'totalCount', f_popupGetCurrentPageDataCount( v_where ) );
    apex_json.write( 'data', v_ref_cursor );  

    apex_json.close_object;

  end p_ajax_popup_report;  

  --
  -- p_ajax_popup_selected
  --    
  procedure p_ajax_popup_selected is
    v_selected_arr    APEX_APPLICATION_GLOBAL.VC_ARR2 default APEX_APPLICATION.G_F01;
    v_collection_name APEX_COLLECTIONS.COLLECTION_NAME%TYPE := g_item.name||'_SHOWSELECTED';

    v_ref_cursor sys_refcursor;
    v_query      varchar2(32000);
  begin
    APEX_COLLECTION.CREATE_OR_TRUNCATE_COLLECTION( v_collection_name );

    APEX_COLLECTION.ADD_MEMBERS(
      p_collection_name => v_collection_name,
      p_c001 => v_selected_arr
    );

    v_query := f_queryRemoveOrderBy( prepareSqlQuery );

    v_query := f_query_popupSelected(
      pi_collection_name => v_collection_name,
      pi_query           => v_query
    );

    open v_ref_cursor for v_query;

    apex_json.open_object;

    if g_debug then
      apex_json.write( 'query', v_query, true );
    end if;

    apex_json.write( 'request', g_ajax_mode, true );
    apex_json.write( 'data', v_ref_cursor );  

    apex_json.close_object;

  end p_ajax_popup_selected;


  --
  -- procedure render
  --

  procedure render (
    p_item   in            apex_plugin.t_item,
    p_plugin in            apex_plugin.t_plugin,
    p_param  in            apex_plugin.t_item_render_param,
    p_result in out nocopy apex_plugin.t_item_render_result 
  ) is
    v_debug_prefix        varchar2(100)   := '# '||p_plugin.name;
    v_item_name           varchar2(4000)  := p_item.name;
    v_is_required         varchar2(8)     := case when p_item.is_required then 'required' else null end;
    v_item_value          varchar2(32767) := p_param.value;
    v_popup_default_icon  varchar2(50)    := 'fa-list-ul';
    v_item_name_attr      varchar2(32767);    
    v_item_attributes     clob;
    v_translations_ref    sys_refcursor;

    v_attr_autocomplete_settings   APEX_APPLICATION_PAGE_ITEMS.attribute_01%type := p_item.attribute_01;
    v_attr_autocomplete_search     APEX_APPLICATION_PAGE_ITEMS.attribute_02%type := p_item.attribute_02;
    v_attr_autocomplete_template   APEX_APPLICATION_PAGE_ITEMS.attribute_03%type := p_item.attribute_03;
    v_attr_autocomplete_d_search   APEX_APPLICATION_PAGE_ITEMS.attribute_04%type := p_item.attribute_04;
    v_attr_settings                APEX_APPLICATION_PAGE_ITEMS.attribute_05%type := p_item.attribute_05;
    v_attr_popup_settings          APEX_APPLICATION_PAGE_ITEMS.attribute_06%type := p_item.attribute_06;
    v_attr_popup_columns_settings  APEX_APPLICATION_PAGE_ITEMS.attribute_07%type := p_item.attribute_07;
    v_attr_autocomplete_tags_no    APEX_APPLICATION_PAGE_ITEMS.attribute_08%type := p_item.attribute_08;
    v_attr_autocomplete_min_length APEX_APPLICATION_PAGE_ITEMS.attribute_09%type := p_item.attribute_09;
    v_attr_popup_report_basic_conf APEX_APPLICATION_PAGE_ITEMS.attribute_10%type := p_item.attribute_10;
    v_attr_popup_title_text        APEX_APPLICATION_PAGE_ITEMS.attribute_11%type := p_item.attribute_11;
    v_attr_popup_width             APEX_APPLICATION_PAGE_ITEMS.attribute_12%type := p_item.attribute_12;
    v_attr_popup_height            APEX_APPLICATION_PAGE_ITEMS.attribute_13%type := p_item.attribute_13;
    v_attr_autocomplete_maxHeight  APEX_APPLICATION_PAGE_ITEMS.attribute_14%type := p_item.attribute_14;
    v_attr_autocomplete_rows2show  APEX_APPLICATION_PAGE_ITEMS.attribute_15%type := p_item.attribute_15;
    v_item_icon_class              APEX_APPLICATION_PAGE_ITEMS.ITEM_ICON_CSS_CLASSES%TYPE ;
    v_apex_version                 APEX_RELEASE.VERSION_NO%TYPE;    
  begin

    g_item := p_item;
    g_plugin := p_plugin;
    g_debug := case when v('DEBUG') = 'YES' then true else false end;

    SELECT 
      VERSION_NO 
    into
      v_apex_version
    FROM 
      APEX_RELEASE;

    v_item_name_attr := apex_plugin.get_input_name_for_page_item(
      p_is_multi_value => true
    );

    if g_debug then
      apex_javascript.add_onload_code (
        p_code => 'apex.debug.log("'||v_debug_prefix||'", "p_item", '||t_page_item_to_json(p_item)||');'
      );

      apex_javascript.add_onload_code (
        p_code => 'apex.debug.log("'||v_debug_prefix||'", "p_plugin", '||t_plugin_to_json(p_plugin)||');'
      );

      apex_javascript.add_onload_code (
        p_code => 'apex.debug.log("'||v_debug_prefix||'", "p_params", '||t_item_render_param_to_json(p_param)||');'
      );    
    end if;

    apex_plugin_util.print_hidden_if_readonly (
      p_item_name           => p_item.name,
      p_value               => v_item_value,
      p_is_readonly         => p_param.is_readonly,
      p_is_printer_friendly => p_param.is_printer_friendly
    );

    if p_param.is_printer_friendly or p_param.is_readonly then
      apex_plugin_util.print_display_only (
        p_item_name        => p_item.name,
        p_display_value    => f_getDisplayValues(v_item_value),
        p_show_line_breaks => false,
        p_escape           => p_item.escape_output,
        p_attributes       => p_item.element_attributes
      );
    else 
      htp.p(''                                        ||
        '<input'                                      ||
        ' type="text"'                                ||
        ' id="'||p_item.name||'"'                     ||
        ' name="'||v_item_name_attr||'"'              ||
        ' class="text_field apex-item-text '|| p_item.element_css_classes ||'"' ||
        ' maxlength="'||p_item.element_max_length||'"'||
        ' size="'||p_item.element_width||'"'          ||
        ' autocomplete="off"'                         ||
        ' placeholder="'||p_item.placeholder||'"'     ||
        ' value="'                                    ||
      '');


      APEX_PLUGIN_UTIL.PRINT_ESCAPED_VALUE(
        APEX_ESCAPE.HTML( v_item_value )
      );

      htp.p(''                                        ||
        '"'                                           || --closing of value attr
        ' data-return-value=""'                       ||
        ' '||v_is_required                            ||
        '>'                                           ||
      '');

      --fetch icon
      begin
        select 
          NVL(ITEM_ICON_CSS_CLASSES, v_popup_default_icon)
        into
          v_item_icon_class
        from 
          apex_application_page_items 
        where 
          application_id = g_app_id
          and page_id = g_page_id
          and item_name = p_item.name;
      exception
        when others then
          v_item_icon_class := v_popup_default_icon;
      end;

      apex_json.initialize_clob_output;
      apex_json.open_object;

      apex_json.write('autoCompleteSettings',             v_attr_autocomplete_settings,   true);
      apex_json.write('autoCompleteSettingsSearchLogic',  v_attr_autocomplete_search,     true);
      apex_json.write('autoCompleteSettingsTemplate',     v_attr_autocomplete_template,   true);
      apex_json.write('autoCompleteTagsNo',               v_attr_autocomplete_tags_no,    true);
      apex_json.write('autoCompleteMinInputLength',       v_attr_autocomplete_min_length, true);
      apex_json.write('autoCompleteMaxHeight',            v_attr_autocomplete_maxHeight,  true);
      apex_json.write('autoCompleteRows2Show',            v_attr_autocomplete_rows2show,  true);

      apex_json.write('settings',                         NVL(v_attr_settings, ''), true);
      apex_json.write('popupSettings',                    v_attr_popup_settings, true);
      apex_json.write('popupColumnSettings',              v_attr_popup_columns_settings, true);
      apex_json.write('popupReportBasicConf',             v_attr_popup_report_basic_conf, true);
      apex_json.write('popupTitleText',                   v_attr_popup_title_text, true);
      apex_json.write('popupWidth',                       v_attr_popup_width, true);
      apex_json.write('popupHeight',                      v_attr_popup_height, true);

      open v_translations_ref for
        select 
          TRANSLATABLE_MESSAGE,
          MESSAGE_TEXT
        from
          APEX_APPLICATION_TRANSLATIONS aat
        where
          APPLICATION_ID = g_app_id
          and LANGUAGE_CODE = (
            select APPLICATION_PRIMARY_LANGUAGE from APEX_APPLICATIONS where application_id = aat.application_id
          )
          and TRANSLATABLE_MESSAGE like 'PAELI%'
      ;

      apex_json.write('translations', v_translations_ref);

      apex_json.close_object;

      v_item_attributes := apex_json.get_clob_output;

      apex_json.free_output;

      apex_javascript.add_onload_code(''                                                                ||
        '$("#' ||v_item_name || '").enhancedLovItem({'                                                  ||
        '  "item":  $.extend('||t_page_item_to_json(p_item)||', {"icon": "'||v_item_icon_class||'"}),'  ||
        '  "param": '||  t_item_render_param_to_json(p_param)||','                                      ||
        '  "plugin": '|| t_plugin_to_json(p_plugin)          ||','                                      ||
        '  "columns": '||f_queryGetColumnsJson||','                                                   ||
        '  "attributes": '||v_item_attributes||','                                                      ||
        '  "apexVersion": "'||v_apex_version||'",'                                                      ||
        '  "debug": "'||v('DEBUG')||'" == "YES" ? true : false '                                        ||
        '});'                                                                                           ||
      '');

    end if;  

  end render;

  --
  -- procedure ajax
  --
  procedure ajax(
    p_item   in            apex_plugin.t_item,
    p_plugin in            apex_plugin.t_plugin,
    p_param  in            apex_plugin.t_item_ajax_param,
    p_result in out nocopy apex_plugin.t_item_ajax_result 
  ) is

    v_ajax_mode     varchar2(100)   default v('APP_AJAX_X01');
    v_search_string varchar2(4000)  default APEX_ESCAPE.HTML(v('APP_AJAX_X03'));
    v_search_column number          default v('APP_AJAX_X07');

  begin

    g_item      := p_item;
    g_plugin    := p_plugin;
    g_debug     := case when v('DEBUG') = 'YES' then true else false end;
    g_ajax_mode := v_ajax_mode;

    g_ajax_search_string := replace(v_search_string, '''', '''''');
    g_ajax_search_column_idx := v('APP_AJAX_X07');

    if g_ajax_mode = 'AUTOCOMPLETE' then
      p_ajax_autocomplete;
    elsif g_ajax_mode = 'POPUP' then
      p_ajax_popup_report;
    elsif g_ajax_mode = 'GETONLYSELECTED' then
      p_ajax_popup_selected;
    elsif g_ajax_mode = 'GETSESSIONSTATE' then
      p_ajax_getSessionState;
    elsif g_ajax_mode = 'DEBUG' then
      null;
    elsif g_ajax_mode = 'CASCADINGLOV' then
      apex_json.open_object;
      apex_json.write( 'request', g_ajax_mode, true );
      apex_json.close_object;  
    else
      p_ajax_getReturnValues;
    end if;

  end ajax;  
end;

/
--------------------------------------------------------
--  DDL for Package Body AS_PDF3_MOD
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."AS_PDF3_MOD" 
is
--
  type tHex is table of pls_integer index by VARCHAR2(2);

  lHex tHex;

  type tp_pls_tab is table of pls_integer index by pls_integer;
  type tp_objects_tab is table of number(10) index by pls_integer;
  type tp_pages_tab is table of blob index by pls_integer;
  type tp_settings is record
    ( page_width number
    , page_height number
    , margin_left number
    , margin_right number
    , margin_top number
    , margin_bottom number
    );
  type tp_settings_tab is table of tp_settings index by pls_integer;

  type tp_font is record
    ( standard boolean
    , family varchar2(100)
    , style varchar2(2)  -- N Normal
                         -- I Italic
                         -- B Bold
                         -- BI Bold Italic
    , subtype varchar2(15)
    , name varchar2(100)
    , fontname varchar2(100)
    , char_width_tab tp_pls_tab
    , encoding varchar2(100)    , charset varchar2(1000)
    , compress_font boolean := true
    , fontsize number
    , unit_norm number
    , bb_xmin pls_integer
    , bb_ymin pls_integer
    , bb_xmax pls_integer
    , bb_ymax pls_integer
    , flags pls_integer
    , first_char pls_integer
    , last_char pls_integer
    , italic_angle number
    , ascent pls_integer
    , descent pls_integer
    , capheight pls_integer
    , stemv pls_integer
    , diff varchar2(32767)
    , cid boolean := false
    , fontfile2 blob
    , ttf_offset pls_integer
    , used_chars tp_pls_tab
    , numGlyphs pls_integer
    , indexToLocFormat pls_integer
    , loca tp_pls_tab
    , code2glyph tp_pls_tab
    , hmetrics tp_pls_tab
    );
  type tp_font_tab is table of tp_font index by pls_integer;
  type tp_img is record
    ( adler32 varchar2(8)
    , width pls_integer
    , height pls_integer
    , color_res pls_integer
    , color_tab raw(768)
    , greyscale boolean
    , pixels blob
    , type varchar2(5)
    , nr_colors pls_integer
    , transparancy_index pls_integer
    );
  type tp_img_tab is table of tp_img index by pls_integer;
  type tp_info is record
    ( title varchar2(1024)
    , author varchar2(1024)
    , subject varchar2(1024)
    , keywords varchar2(32767)
    );
  type tp_page_prcs is table of clob index by pls_integer;
--
-- globals
  g_pdf_doc blob; -- the PDF-document being constructed
  g_objects tp_objects_tab;
  g_pages tp_pages_tab;
  g_settings_per_page tp_settings_tab;
  g_settings tp_settings;
  g_fonts tp_font_tab;
  g_used_fonts tp_pls_tab;
  g_current_font pls_integer;
  g_current_font_record tp_font;
  g_images tp_img_tab;
  g_x number;  -- current x-location of the "cursor"
  g_y number;  -- current y-location of the "cursor"
  g_info tp_info;
  g_page_nr pls_integer;
  g_page_prcs tp_page_prcs;
--
-- constants
  c_nl constant varchar2(2) := chr(13) || chr(10);
--
  function num2raw( p_value number )
  return raw
  is
  begin
    return hextoraw( to_char( p_value, 'FM0XXXXXXX' ) );
  end;
--
  function raw2num( p_value raw )
  return number
  is
  begin
    return to_number( rawtohex( p_value ), 'XXXXXXXX' );
  end;
--
  function raw2num( p_value raw, p_pos pls_integer, p_len pls_integer )
  return pls_integer
  is
  begin
    return to_number( rawtohex( utl_raw.substr( p_value, p_pos, p_len ) ), 'XXXXXXXX' );
  end;
--
  function to_short( p_val raw, p_factor number := 1 )
  return number
  is
    t_rv number;
  begin
    t_rv := to_number( rawtohex( p_val ), 'XXXXXXXXXX' );
    if t_rv > 32767
    then
      t_rv := t_rv - 65536;
    end if;
    return t_rv * p_factor;
  end;
--
  function blob2num( p_blob blob, p_len integer, p_pos integer )
  return number
  is
  begin
    return to_number( rawtohex( dbms_lob.substr( p_blob, p_len, p_pos ) ), 'xxxxxxxx' );
  end;
--
  function file2blob( p_dir varchar2, p_file_name varchar2 )
  return blob
  is
    t_raw raw(32767);
    t_blob blob;
    fh utl_file.file_type;
  begin
    fh := utl_file.fopen( p_dir, p_file_name, 'rb' );
    dbms_lob.createtemporary( t_blob, true );
    loop
      begin
        utl_file.get_raw( fh, t_raw );
        dbms_lob.append( t_blob, t_raw );
      exception
        when no_data_found
        then
          exit;
      end;
    end loop;
    utl_file.fclose( fh );
    return t_blob;
  exception
    when others
    then
      if utl_file.is_open( fh )
      then
        utl_file.fclose( fh );
      end if;
      raise;
  end;
--
  procedure init_core_fonts
  is
    function uncompress_withs( p_compressed_tab varchar2 )
    return tp_pls_tab
    is
      t_rv tp_pls_tab;
      t_tmp raw(32767);
    begin
      if p_compressed_tab is not null
      then
        t_tmp := utl_compress.lz_uncompress
          ( utl_encode.base64_decode( utl_raw.cast_to_raw( p_compressed_tab ) ) );
        for i in 0 .. 255
        loop
          t_rv( i ) := to_number( utl_raw.substr( t_tmp, i * 4 + 1, 4 ), '0xxxxxxx' );
        end loop;
      end if;
      return t_rv;
    end;
--
    procedure init_core_font
      ( p_ind pls_integer
      , p_family varchar2
      , p_style varchar2
      , p_name varchar2
      , p_compressed_tab varchar2
      )
    is
    begin
      g_fonts( p_ind ).family := p_family;
      g_fonts( p_ind ).style := p_style;
      g_fonts( p_ind ).name := p_name;
      g_fonts( p_ind ).fontname := p_name;
      g_fonts( p_ind ).standard := true;
      g_fonts( p_ind ).encoding := 'WE8MSWIN1252';
      g_fonts( p_ind ).charset := sys_context( 'userenv', 'LANGUAGE' );
      g_fonts( p_ind ).charset := substr( g_fonts( p_ind ).charset
                                        , 1
                                        , instr( g_fonts( p_ind ).charset, '.' )
                                        ) || g_fonts( p_ind ).encoding;
      g_fonts( p_ind ).char_width_tab := uncompress_withs( p_compressed_tab );
    end;
  begin
    init_core_font( 1, 'helvetica', 'N', 'Helvetica'
      ,  'H4sIAAAAAAAAC81Tuw3CMBC94FQMgMQOLAGVGzNCGtc0dAxAT+8lsgE7RKJFomOA'
      || 'SLT4frHjBEFJ8XSX87372C8A1Qr+Ax5gsWGYU7QBAK4x7gTnGLOS6xJPOd8w5NsM'
      || '2OvFvQidAP04j1nyN3F7iSNny3E6DylPeeqbNqvti31vMpfLZuzH86oPdwaeo6X+'
      || '5X6Oz5VHtTqJKfYRNVu6y0ZyG66rdcxzXJe+Q/KJ59kql+bTt5K6lKucXvxWeHKf'
      || '+p6Tfersfh7RHuXMZjHsdUkxBeWtM60gDjLTLoHeKsyDdu6m8VK3qhnUQAmca9BG'
      || 'Dq3nP+sV/4FcD6WOf9K/ne+hdav+DTuNLeYABAAA' );
--
    init_core_font( 2, 'helvetica', 'I', 'Helvetica-Oblique'
      ,  'H4sIAAAAAAAAC81Tuw3CMBC94FQMgMQOLAGVGzNCGtc0dAxAT+8lsgE7RKJFomOA'
      || 'SLT4frHjBEFJ8XSX87372C8A1Qr+Ax5gsWGYU7QBAK4x7gTnGLOS6xJPOd8w5NsM'
      || '2OvFvQidAP04j1nyN3F7iSNny3E6DylPeeqbNqvti31vMpfLZuzH86oPdwaeo6X+'
      || '5X6Oz5VHtTqJKfYRNVu6y0ZyG66rdcxzXJe+Q/KJ59kql+bTt5K6lKucXvxWeHKf'
      || '+p6Tfersfh7RHuXMZjHsdUkxBeWtM60gDjLTLoHeKsyDdu6m8VK3qhnUQAmca9BG'
      || 'Dq3nP+sV/4FcD6WOf9K/ne+hdav+DTuNLeYABAAA' );
--
    init_core_font( 3, 'helvetica', 'B', 'Helvetica-Bold'
      ,  'H4sIAAAAAAAAC8VSsRHCMAx0SJcBcgyRJaBKkxXSqKahYwB6+iyRTbhLSUdHRZUB'
      || 'sOWXLF8SKCn+ZL/0kizZuaJ2/0fn8XBu10SUF28n59wbvoCr51oTD61ofkHyhBwK'
      || '8rXusVaGAb4q3rXOBP4Qz+wfUpzo5FyO4MBr39IH+uLclFvmCTrz1mB5PpSD52N1'
      || 'DfqS988xptibWfbw9Sa/jytf+dz4PqQz6wi63uxxBpCXY7uUj88jNDNy1mYGdl97'
      || '856nt2f4WsOFed4SpzumNCvlT+jpmKC7WgH3PJn9DaZfA42vlgh96d+wkHy0/V95'
      || 'xyv8oj59QbvBN2I/iAuqEAAEAAA=' );
--
    init_core_font( 4, 'helvetica', 'BI', 'Helvetica-BoldOblique'
      ,  'H4sIAAAAAAAAC8VSsRHCMAx0SJcBcgyRJaBKkxXSqKahYwB6+iyRTbhLSUdHRZUB'
      || 'sOWXLF8SKCn+ZL/0kizZuaJ2/0fn8XBu10SUF28n59wbvoCr51oTD61ofkHyhBwK'
      || '8rXusVaGAb4q3rXOBP4Qz+wfUpzo5FyO4MBr39IH+uLclFvmCTrz1mB5PpSD52N1'
      || 'DfqS988xptibWfbw9Sa/jytf+dz4PqQz6wi63uxxBpCXY7uUj88jNDNy1mYGdl97'
      || '856nt2f4WsOFed4SpzumNCvlT+jpmKC7WgH3PJn9DaZfA42vlgh96d+wkHy0/V95'
      || 'xyv8oj59QbvBN2I/iAuqEAAEAAA=' );
--
    init_core_font( 5, 'times', 'N', 'Times-Roman'
      ,  'H4sIAAAAAAAAC8WSKxLCQAyG+3Bopo4bVHbwHGCvUNNT9AB4JEwvgUBimUF3wCNR'
      || 'qAoGRZL9twlQikR8kzTvZBtF0SP6O7Ej1kTnSRfEhHw7+Jy3J4XGi8w05yeZh2sE'
      || '4j312ZDeEg1gvSJy6C36L9WX1urr4xrolfrSrYmrUCeDPGMu5+cQ3Ur3OXvQ+TYf'
      || '+2FGexOZvTM1L3S3o5fJjGQJX2n68U2ur3X5m3cTvfbxsk9pcsMee60rdTjnhNkc'
      || 'Zip9HOv9+7/tI3Oif3InOdV/oLdx3gq2HIRaB1Ob7XPk35QwwxDyxg3e09Dv6nSf'
      || 'rxQjvty8ywDce9CXvdF9R+4y4o+7J1P/I9sABAAA' );
--
    init_core_font( 6, 'times', 'I', 'Times-Italic'
      ,  'H4sIAAAAAAAAC8WSPQ6CQBCFF+i01NB5g63tPcBegYZTeAB6SxNLjLUH4BTEeAYr'
      || 'Kwpj5ezsW2YgoKXFl2Hnb9+wY4x5m7+TOOJMdIFsRywodkfMBX9aSz7bXGp+gj6+'
      || 'R4TvOtJ3CU5Eq85tgGsbxG3QN8iFZY1WzpxXwkckFTR7e1G6osZGWT1bDuBnTeP5'
      || 'KtW/E71c0yB2IFbBphuyBXIL9Y/9fPvhf8se6vsa8nmeQtU6NSf6ch9fc8P9DpqK'
      || 'cPa5/I7VxDwruTN9kV3LDvQ+h1m8z4I4x9LIbnn/Fv6nwOdyGq+d33jk7/cxztyq'
      || 'XRhTz/it7Mscg7fT5CO+9ahnYk20Hww5IrwABAAA' );
--
    init_core_font( 7, 'times', 'B', 'Times-Bold'
      , 'H4sIAAAAAAAAC8VSuw3CQAy9XBqUAVKxAZkgHQUNEiukySxpqOjTMQEDZIrUDICE'
      || 'RHUVVfy9c0IQJcWTfbafv+ece7u/Izs553cgAyN/APagl+wjgN3XKZ5kmTg/IXkw'
      || 'h4JqXUEfAb1I1VvwFYysk9iCffmN4+gtccSr5nlwDpuTepCZ/MH0FZibDUnO7MoR'
      || 'HXdDuvgjpzNxgevG+dF/hr3dWfoNyEZ8Taqn+7d7ozmqpGM8zdMYruFrXopVjvY2'
      || 'in9gXe+5vBf1KfX9E6TOVBsb8i5iqwQyv9+a3Gg/Cv+VoDtaQ7xdPwfNYRDji09g'
      || 'X/FvLNGmO62B9jSsoFwgfM+jf1z/SPwrkTMBOkCTBQAEAAA=' );
--
    init_core_font( 8, 'times', 'BI', 'Times-BoldItalic'
      ,  'H4sIAAAAAAAAC8WSuw2DMBCGHegYwEuECajIAGwQ0TBFBnCfPktkAKagzgCRIqWi'
      || 'oso9fr+Qo5RB+nT2ve+wMWYzf+fgjKmOJFelPhENnS0xANJXHfwHSBtjfoI8nMMj'
      || 'tXo63xKW/Cx9ONRn3US6C/wWvYeYNr+LH2IY6cHGPkJfvsc5kX7mFjF+Vqs9iT6d'
      || 'zwEL26y1Qz62nWlvD5VSf4R9zPuon/ne+C45+XxXf5lnTGLTOZCXPx8v9Qfdjdid'
      || '5vD/f/+/pE/Ur14kG+xjTHRc84pZWsC2Hjk2+Hgbx78j4Z8W4DlL+rBnEN5Bie6L'
      || 'fsL+1u/InuYCdsdaeAs+RxftKfGdfQDlDF/kAAQAAA==' );
--
    init_core_font( 9, 'courier', 'N', 'Courier', null );
    for i in 0 .. 255
    loop
      g_fonts( 9 ).char_width_tab( i ) := 600;
    end loop;
--
    init_core_font( 10, 'courier', 'I', 'Courier-Oblique', null );
    g_fonts( 10 ).char_width_tab := g_fonts( 9 ).char_width_tab;
--
    init_core_font( 11, 'courier', 'B', 'Courier-Bold', null );
    g_fonts( 11 ).char_width_tab := g_fonts( 9 ).char_width_tab;
--
    init_core_font( 12, 'courier', 'BI', 'Courier-BoldOblique', null );
    g_fonts( 12 ).char_width_tab := g_fonts( 9 ).char_width_tab;
--
    init_core_font( 13, 'symbol', 'N', 'Symbol'
      ,  'H4sIAAAAAAAAC82SIU8DQRCFZ28xIE+cqcbha4tENKk/gQCJJ6AweIK9H1CHqKnp'
      || 'D2gTFBaDIcFwCQkJSTG83fem7SU0qYNLvry5nZ25t7NnZkv7c8LQrFhAP6GHZvEY'
      || 'HOB9ylxGubTfNVRc34mKpFonzBQ/gUZ6Ds7AN6i5lv1dKv8Ab1eKQYSV4hUcgZFq'
      || 'J/Sec7fQHtdTn3iqfvdrb7m3e2pZW+xDG3oIJ/Li3gfMr949rlU74DyT1/AuTX1f'
      || 'YGhOzTP8B0/RggsEX/I03vgXPrrslZjfM8/pGu40t2ZjHgud97F7337mXP/GO4h9'
      || '3WmPPaOJ/jrOs9yC52MlrtUzfWupfTX51X/L+13Vl/J/s4W2S3pSfSh5DmeXerMf'
      || '+LXhWQAEAAA=' );
--
    init_core_font( 14, 'zapfdingbats', 'N', 'ZapfDingbats'
      ,  'H4sIAAAAAAAAC83ROy9EQRjG8TkzjdJl163SSHR0EpdsVkSi2UahFhUljUKUIgoq'
      || 'CrvJCtFQyG6EbSSERGxhC0ofQAQFxbIi8T/7PoUPIOEkvzxzzsycdy7O/fUTtToX'
      || 'bnCuvHPOV8gk4r423ovkGQ5od5OTWMeesmBz/RuZIWv4wCAY4z/xjipeqflC9qAD'
      || 'aRwxrxkJievSFzrRh36tZ1zttL6nkGX+A27xrLnttE/IBji9x7UvcIl9nPJ9AL36'
      || 'd1L9hyihoDW10L62cwhNyhntryZVExYl3kMj+zym+CrJv6M8VozPmfr5L8uwJORL'
      || 'tox7NFHG/Obj79FlwhqZ1X292xn6CbAXP/fjjv6rJYyBtUdl1vxEO6fcRB7bMmJ3'
      || 'GYZsTN0GdrDL/Ao5j1GZNr5kwqydX5z1syoiYEq5gCtlSrXi+mVbi3PfVAuhoQAE'
      || 'AAA=' );
--
  end;
--
  function to_char_round
    ( p_value number
    , p_precision pls_integer := 2
    )
  return varchar2
  is
  begin
    return to_char( round( p_value, p_precision ), 'TM9', 'NLS_NUMERIC_CHARACTERS=.,' );
  end;
--
  procedure raw2pdfdoc( p_raw blob )
  is
  begin
    dbms_lob.append( g_pdf_doc, p_raw );
  end;
--
  procedure txt2pdfdoc( p_txt varchar2 )
  is
  begin
    raw2pdfdoc( utl_raw.cast_to_raw( p_txt || c_nl ) );
  end;
--
  function add_object( p_txt varchar2 := null )
  return number
  is
    t_self number(10);
  begin
    t_self := g_objects.count( );
    g_objects( t_self ) := dbms_lob.getlength( g_pdf_doc );
--
    if p_txt is null
    then
      txt2pdfdoc( t_self || ' 0 obj' );
    else
      txt2pdfdoc( t_self || ' 0 obj' || c_nl || '<<' || p_txt || '>>' || c_nl || 'endobj' );
    end if;
--
    return t_self;
  end;
--
  procedure add_object( p_txt varchar2 := null )
  is
    t_dummy number(10) := add_object( p_txt );
  begin
    null;
  end;
--
  function adler32( p_src in blob )
  return varchar2
  is
    s1 pls_integer := 1;
    s2 pls_integer := 0;
    n  pls_integer;
    step_size number;
    tmp varchar2(32766);
    c65521 constant pls_integer := 65521;
  begin
    step_size := trunc( 16383 / dbms_lob.getchunksize( p_src ) ) * dbms_lob.getchunksize( p_src );
    -- AW Bugfix for Chunksizes > 16383
    if step_size=0 then
      step_size:=16383;
    end if;
    for j in 0 .. trunc( ( dbms_lob.getlength( p_src ) - 1 ) / step_size )
    loop
      tmp := rawtohex( dbms_lob.substr( p_src, step_size, j * step_size + 1 ) );
      for i in 1 .. length( tmp ) / 2
      loop
        n:=lHex(substr( tmp, i * 2 - 1, 2 ));--n := to_number( substr( tmp, i * 2 - 1, 2 ), 'xx' );
        s1 := s1 + n;
        if s1 >= c65521
        then
          s1 := s1 - c65521;
        end if;
        s2 := s2 + s1;
        if s2 >= c65521
        then
          s2 := s2 - c65521;
        end if;
      end loop;
    end loop;
    return to_char( s2, 'fm0XXX' ) || to_char( s1, 'fm0XXX' );
  end;
--
  function flate_encode( p_val blob )
  return blob
  is
    t_blob blob;
  begin
    t_blob := hextoraw( '789C' );
    dbms_lob.copy( t_blob
                 , utl_compress.lz_compress( p_val )
                 , dbms_lob.lobmaxsize
                 , 3
                 , 11
                 );
    dbms_lob.trim( t_blob, dbms_lob.getlength( t_blob ) - 8 );
    dbms_lob.append( t_blob, hextoraw( adler32( p_val ) ) );
    return t_blob;
  end;
--
  procedure put_stream
    ( p_stream blob
    , p_compress boolean := true
    , p_extra varchar2 := ''
    , p_tag boolean := true
    )
  is
    t_blob blob;
    t_compress boolean := false;
  begin
    if p_compress and nvl( dbms_lob.getlength( p_stream ), 0 ) > 0
    then
      t_compress := true;
      t_blob := flate_encode( p_stream );
    else
      t_blob := p_stream;
    end if;
    txt2pdfdoc( case when p_tag then '<<' end
                || case when t_compress then '/Filter /FlateDecode ' end
                || '/Length ' || nvl( length( t_blob ), 0 )
                || p_extra
                || '>>' );
    txt2pdfdoc( 'stream' );
    raw2pdfdoc( t_blob );
    txt2pdfdoc( 'endstream' );
    if dbms_lob.istemporary( t_blob ) = 1
    then
      dbms_lob.freetemporary( t_blob );
    end if;
  end;
--
  function add_stream
    ( p_stream blob
    , p_extra varchar2 := ''
    , p_compress boolean := true
    )
  return number
  is
    t_self number(10);
  begin
    t_self := add_object;
    put_stream( p_stream
              , p_compress
              , p_extra
              );
    txt2pdfdoc( 'endobj' );
    return t_self;
  end;
--
  function subset_font( p_index pls_integer )
  return blob
  is
    t_tmp blob;
    t_header blob;
    t_tables blob;
    t_len pls_integer;
    t_code pls_integer;
    t_glyph pls_integer;
    t_offset pls_integer;
    t_factor pls_integer;
    t_unicode pls_integer;
    t_used_glyphs tp_pls_tab;
    t_fmt varchar2(10);
    t_utf16_charset varchar2(1000);
    t_raw raw(32767);
    t_v varchar2(32767);
    t_table_records raw(32767);
  begin
    if g_fonts( p_index ).cid
    then
      t_used_glyphs := g_fonts( p_index ).used_chars;
      t_used_glyphs( 0 ) := 0;
    else
      t_utf16_charset := substr( g_fonts( p_index ).charset, 1, instr( g_fonts( p_index ).charset, '.' ) ) || 'AL16UTF16';
      t_used_glyphs( 0 ) := 0;
      t_code := g_fonts( p_index ).used_chars.first;
      while t_code is not null
      loop
        t_unicode := to_number( rawtohex( utl_raw.convert( hextoraw( to_char( t_code, 'fm0x' ) )
                                                                    , t_utf16_charset
                                                                    , g_fonts( p_index ).charset  -- ???? database characterset ?????
                                                                    )
                                        ), 'XXXXXXXX' );
        if g_fonts( p_index ).flags = 4 -- a symbolic font
        then
-- assume code 32, space maps to the first code from the font
          t_used_glyphs( g_fonts( p_index ).code2glyph( g_fonts( p_index ).code2glyph.first + t_unicode - 32 ) ) := 0;
        else
          t_used_glyphs( g_fonts( p_index ).code2glyph( t_unicode ) ) := 0;
        end if;
        t_code := g_fonts( p_index ).used_chars.next( t_code );
      end loop;
    end if;
--
    dbms_lob.createtemporary( t_tables, true );
    t_header := utl_raw.concat( hextoraw( '00010000' )
                              , dbms_lob.substr( g_fonts( p_index ).fontfile2, 8, g_fonts( p_index ).ttf_offset + 4 )
                              );
    t_offset := 12 + blob2num( g_fonts( p_index ).fontfile2, 2, g_fonts( p_index ).ttf_offset + 4 ) * 16;
    t_table_records := dbms_lob.substr( g_fonts( p_index ).fontfile2
                                      , blob2num( g_fonts( p_index ).fontfile2, 2, g_fonts( p_index ).ttf_offset + 4 ) * 16
                                      , g_fonts( p_index ).ttf_offset + 12
                                      );
    for i in 1 .. blob2num( g_fonts( p_index ).fontfile2, 2, g_fonts( p_index ).ttf_offset + 4 )
    loop
      case utl_raw.cast_to_varchar2( utl_raw.substr( t_table_records, i * 16 - 15, 4 ) )
        when 'post'
        then
          dbms_lob.append( t_header
                         , utl_raw.concat( utl_raw.substr( t_table_records, i * 16 - 15, 4 ) -- tag
                                         , hextoraw( '00000000' ) -- checksum
                                         , num2raw( t_offset + dbms_lob.getlength( t_tables ) ) -- offset
                                         , num2raw( 32 ) -- length
                                         )
                         );
          dbms_lob.append( t_tables
                         , utl_raw.concat( hextoraw( '00030000' )
                                         , dbms_lob.substr( g_fonts( p_index ).fontfile2
                                                          , 28
                                                          , raw2num( t_table_records, i * 16 - 7, 4 ) + 5
                                                          )
                                         )
                         );
        when 'loca'
        then
          if g_fonts( p_index ).indexToLocFormat = 0
          then
            t_fmt := 'fm0XXX';
          else
            t_fmt := 'fm0XXXXXXX';
          end if;
          t_raw := null;
          dbms_lob.createtemporary( t_tmp, true );
          t_len := 0;
          for g in 0 .. g_fonts( p_index ).numGlyphs - 1
          loop
            t_raw := utl_raw.concat( t_raw, hextoraw( to_char( t_len, t_fmt ) ) );
            if utl_raw.length( t_raw ) > 32770
            then
              dbms_lob.append( t_tmp, t_raw );
              t_raw := null;
            end if;
            if t_used_glyphs.exists( g )
            then
              t_len := t_len + g_fonts( p_index ).loca( g + 1 ) - g_fonts( p_index ).loca( g );
            end if;
          end loop;
          t_raw := utl_raw.concat( t_raw, hextoraw( to_char( t_len, t_fmt ) ) );
          dbms_lob.append( t_tmp, t_raw );
          dbms_lob.append( t_header
                         , utl_raw.concat( utl_raw.substr( t_table_records, i * 16 - 15, 4 ) -- tag
                                         , hextoraw( '00000000' ) -- checksum
                                         , num2raw( t_offset + dbms_lob.getlength( t_tables ) ) -- offset
                                         , num2raw( dbms_lob.getlength( t_tmp ) ) -- length
                                         )
                         );
          dbms_lob.append( t_tables, t_tmp );
          dbms_lob.freetemporary( t_tmp );
        when 'glyf'
        then
          if g_fonts( p_index ).indexToLocFormat = 0
          then
            t_factor := 2;
          else
            t_factor := 1;
          end if;
          t_raw := null;
          dbms_lob.createtemporary( t_tmp, true );
          for g in 0 .. g_fonts( p_index ).numGlyphs - 1
          loop
            if (   t_used_glyphs.exists( g )
               and g_fonts( p_index ).loca( g + 1 ) > g_fonts( p_index ).loca( g )
               )
            then
              t_raw := utl_raw.concat( t_raw
                                     , dbms_lob.substr( g_fonts( p_index ).fontfile2
                                                      , ( g_fonts( p_index ).loca( g + 1 ) - g_fonts( p_index ).loca( g ) ) * t_factor
                                                      , g_fonts( p_index ).loca( g ) * t_factor + raw2num( t_table_records, i * 16 - 7, 4 ) + 1
                                                      )
                                     );
              if utl_raw.length( t_raw ) > 32000
              then
                dbms_lob.append( t_tmp, t_raw );
                t_raw := null;
              end if;
            end if;
          end loop;
          if utl_raw.length( t_raw ) > 0
          then
            dbms_lob.append( t_tmp, t_raw );
          end if;
          dbms_lob.append( t_header
                         , utl_raw.concat( utl_raw.substr( t_table_records, i * 16 - 15, 4 ) -- tag
                                         , hextoraw( '00000000' ) -- checksum
                                         , num2raw( t_offset + dbms_lob.getlength( t_tables ) ) -- offset
                                         , num2raw( dbms_lob.getlength( t_tmp ) ) -- length
                                         )
                         );
          dbms_lob.append( t_tables, t_tmp );
          dbms_lob.freetemporary( t_tmp );
        else
          dbms_lob.append( t_header
                         , utl_raw.concat( utl_raw.substr( t_table_records, i * 16 - 15, 4 )    -- tag
                                         , utl_raw.substr( t_table_records, i * 16 - 11, 4 )    -- checksum
                                         , num2raw( t_offset + dbms_lob.getlength( t_tables ) ) -- offset
                                         , utl_raw.substr( t_table_records, i * 16 - 3, 4 )     -- length
                                         )
                         );
          dbms_lob.copy( t_tables
                       , g_fonts( p_index ).fontfile2
                       , raw2num( t_table_records, i * 16 - 3, 4 )
                       , dbms_lob.getlength( t_tables ) + 1
                       , raw2num( t_table_records, i * 16 - 7, 4 ) + 1
                       );
      end case;
    end loop;
    dbms_lob.append( t_header, t_tables );
    dbms_lob.freetemporary( t_tables );
    return t_header;
  end;
--
  function add_font( p_index pls_integer )
  return number
  is
    t_self number(10);
    t_fontfile number(10);
    t_font_subset blob;
    t_used pls_integer;
    t_used_glyphs tp_pls_tab;
    t_w varchar2(32767);
    t_unicode pls_integer;
    t_utf16_charset varchar2(1000);
    t_width number;
  begin
    if g_fonts( p_index ).standard
    then
      return add_object( '/Type/Font'
                       || '/Subtype/Type1'
                       || '/BaseFont/' || g_fonts( p_index ).name
                       || '/Encoding/WinAnsiEncoding' -- code page 1252
                       );
    end if;
--
    if g_fonts( p_index ).cid
    then
      t_self := add_object;
      txt2pdfdoc( '<</Type/Font/Subtype/Type0/Encoding/Identity-H'
                || '/BaseFont/' || g_fonts( p_index ).name
                || '/DescendantFonts ' || to_char( t_self + 1 ) || ' 0 R'
                || '/ToUnicode ' || to_char( t_self + 8 ) || ' 0 R'
                || '>>' );
      txt2pdfdoc( 'endobj' );
      add_object;
      txt2pdfdoc( '[' || to_char( t_self + 2 ) || ' 0 R]' );
      txt2pdfdoc( 'endobj' );
      add_object( '/Type/Font/Subtype/CIDFontType2/CIDToGIDMap/Identity/DW 1000'
                || '/BaseFont/' || g_fonts( p_index ).name
                || '/CIDSystemInfo ' || to_char( t_self + 3 ) || ' 0 R'
                || '/W ' || to_char( t_self + 4 ) || ' 0 R'
                || '/FontDescriptor ' || to_char( t_self + 5 ) || ' 0 R' );
      add_object( '/Ordering(Identity) /Registry(Adobe) /Supplement 0' );
--
      t_utf16_charset := substr( g_fonts( p_index ).charset, 1, instr( g_fonts( p_index ).charset, '.' ) ) || 'AL16UTF16';
      t_used_glyphs := g_fonts( p_index ).used_chars;
      t_used_glyphs( 0 ) := 0;
      t_used := t_used_glyphs.first();
      while t_used is not null
      loop
        if g_fonts( p_index ).hmetrics.exists( t_used )
        then
          t_width := g_fonts( p_index ).hmetrics( t_used );
        else
          t_width := g_fonts( p_index ).hmetrics( g_fonts( p_index ).hmetrics.last() );
        end if;
        t_width := trunc( t_width * g_fonts( p_index ).unit_norm );
        if t_used_glyphs.prior( t_used ) = t_used - 1
        then
          t_w := t_w || ' ' || t_width;
        else
          t_w := t_w || '] ' || t_used || ' [' || t_width;
        end if;
        t_used := t_used_glyphs.next( t_used );
      end loop;
      t_w := '[' || ltrim( t_w, '] ' ) || ']]';
      add_object;
      txt2pdfdoc( t_w );
      txt2pdfdoc( 'endobj' );
      add_object
        (    '/Type/FontDescriptor'
          || '/FontName/' || g_fonts( p_index ).name
          || '/Flags ' || g_fonts( p_index ).flags
          || '/FontBBox [' || g_fonts( p_index ).bb_xmin
          || ' ' || g_fonts( p_index ).bb_ymin
          || ' ' || g_fonts( p_index ).bb_xmax
          || ' ' || g_fonts( p_index ).bb_ymax
          || ']'
          || '/ItalicAngle ' || to_char_round( g_fonts( p_index ).italic_angle )
          || '/Ascent ' || g_fonts( p_index ).ascent
          || '/Descent ' || g_fonts( p_index ).descent
          || '/CapHeight ' || g_fonts( p_index ).capheight
          || '/StemV ' || g_fonts( p_index ).stemv
          || '/FontFile2 ' || to_char( t_self + 6 ) || ' 0 R' );
      t_fontfile := add_stream( g_fonts( p_index ).fontfile2
                              , '/Length1 ' || dbms_lob.getlength( g_fonts( p_index ).fontfile2 )
                              , g_fonts( p_index ).compress_font
                              );
      t_font_subset := subset_font( p_index );
      t_fontfile := add_stream( t_font_subset
                              , '/Length1 ' || dbms_lob.getlength( t_font_subset )
                              , g_fonts( p_index ).compress_font
                              );
      declare
        t_g2c tp_pls_tab;
        t_code     pls_integer;
        t_c_start  pls_integer;
        t_map varchar2(32767);
        t_cmap varchar2(32767);
        t_cor pls_integer;
        t_cnt pls_integer;
      begin
        t_code := g_fonts( p_index ).code2glyph.first;
        if g_fonts( p_index ).flags = 4 -- a symbolic font
        then
-- assume code 32, space maps to the first code from the font
          t_cor := t_code - 32;
        else
          t_cor := 0;
        end if;
        while t_code is not null
        loop
          t_g2c( g_fonts( p_index ).code2glyph( t_code ) ) := t_code - t_cor;
          t_code := g_fonts( p_index ).code2glyph.next( t_code );
        end loop;
        t_cnt := 0;
        t_used_glyphs := g_fonts( p_index ).used_chars;
        t_used := t_used_glyphs.first();
        while t_used is not null
        loop
          t_map := t_map || '<' || to_char( t_used, 'FM0XXX' )
                 || '> <' || to_char( t_g2c( t_used ), 'FM0XXX' )
                 || '>' || chr( 10 );
          if t_cnt = 99
          then
            t_cnt := 0;
            t_cmap := t_cmap || chr( 10 ) || '100 beginbfchar' || chr( 10 ) || t_map || 'endbfchar';
            t_map := '';
          else
            t_cnt := t_cnt + 1;
          end if;
          t_used := t_used_glyphs.next( t_used );
        end loop;
        if t_cnt > 0
        then
          t_cmap := t_cnt || ' beginbfchar' || chr( 10 ) || t_map || 'endbfchar';
        end if;
        t_fontfile := add_stream( utl_raw.cast_to_raw(
'/CIDInit /ProcSet findresource begin 12 dict begin
begincmap
/CIDSystemInfo
<< /Registry (Adobe) /Ordering (UCS) /Supplement 0 >> def
/CMapName /Adobe-Identity-UCS def /CMapType 2 def
1 begincodespacerange
<0000> <FFFF>
endcodespacerange
' || t_cmap || '
endcmap
CMapName currentdict /CMap defineresource pop
end
end' ) );
      end;
      return t_self;
    end if;
--
    g_fonts( p_index ).first_char := g_fonts( p_index ).used_chars.first();
    g_fonts( p_index ).last_char := g_fonts( p_index ).used_chars.last();
    t_self := add_object;
    txt2pdfdoc( '<</Type /Font '
              || '/Subtype /' || g_fonts( p_index ).subtype
              || ' /BaseFont /' || g_fonts( p_index ).name
              || ' /FirstChar ' || g_fonts( p_index ).first_char
              || ' /LastChar ' || g_fonts( p_index ).last_char
              || ' /Widths ' || to_char( t_self + 1 ) || ' 0 R'
              || ' /FontDescriptor ' || to_char( t_self + 2 ) || ' 0 R'
              || ' /Encoding ' || to_char( t_self + 3 ) || ' 0 R'
              || ' >>' );
    txt2pdfdoc( 'endobj' );
    add_object;
    txt2pdfdoc( '[' );
      begin
        for i in g_fonts( p_index ).first_char .. g_fonts( p_index ).last_char
        loop
          txt2pdfdoc( g_fonts( p_index ).char_width_tab( i ) );
        end loop;
      exception
        when others
        then
          dbms_output.put_line( '**** ' || g_fonts( p_index ).name );
      end;
      txt2pdfdoc( ']' );
      txt2pdfdoc( 'endobj' );
      add_object
        (    '/Type /FontDescriptor'
          || ' /FontName /' || g_fonts( p_index ).name
          || ' /Flags ' || g_fonts( p_index ).flags
          || ' /FontBBox [' || g_fonts( p_index ).bb_xmin
          || ' ' || g_fonts( p_index ).bb_ymin
          || ' ' || g_fonts( p_index ).bb_xmax
          || ' ' || g_fonts( p_index ).bb_ymax
          || ']'
          || ' /ItalicAngle ' || to_char_round( g_fonts( p_index ).italic_angle )
          || ' /Ascent ' || g_fonts( p_index ).ascent
          || ' /Descent ' || g_fonts( p_index ).descent
          || ' /CapHeight ' || g_fonts( p_index ).capheight
          || ' /StemV ' || g_fonts( p_index ).stemv
          || case
               when g_fonts( p_index ).fontfile2 is not null
                 then ' /FontFile2 ' || to_char( t_self + 4 ) || ' 0 R'
             end );
      add_object(    '/Type /Encoding /BaseEncoding /WinAnsiEncoding '
                         || g_fonts( p_index ).diff
                         || ' ' );
      if g_fonts( p_index ).fontfile2 is not null
      then
        t_font_subset := subset_font( p_index );
        t_fontfile :=
          add_stream( t_font_subset
                    , '/Length1 ' || dbms_lob.getlength( t_font_subset )
                    , g_fonts( p_index ).compress_font
                    );
    end if;
    return t_self;
  end;
--
  procedure add_image( p_img tp_img )
  is
    t_pallet number(10);
  begin
    if p_img.color_tab is not null
    then
      t_pallet := add_stream( p_img.color_tab );
    else
      t_pallet := add_object;  -- add an empty object
      txt2pdfdoc( 'endobj' );
    end if;
    add_object;
    txt2pdfdoc( '<</Type /XObject /Subtype /Image'
              ||  ' /Width ' || to_char( p_img.width )
              || ' /Height ' || to_char( p_img.height )
              || ' /BitsPerComponent ' || to_char( p_img.color_res )
              );
--
    if p_img.transparancy_index is not null
    then
      txt2pdfdoc( '/Mask [' || p_img.transparancy_index || ' ' || p_img.transparancy_index || ']' );
    end if;
    if p_img.color_tab is null
    then
      if p_img.greyscale
      then
        txt2pdfdoc( '/ColorSpace /DeviceGray' );
      else
        txt2pdfdoc( '/ColorSpace /DeviceRGB' );
      end if;
    else
      txt2pdfdoc(    '/ColorSpace [/Indexed /DeviceRGB '
                || to_char( utl_raw.length( p_img.color_tab ) / 3 - 1 )
                || ' ' || to_char( t_pallet ) || ' 0 R]'
                );
    end if;
--
    if p_img.type = 'jpg'
    then
      put_stream( p_img.pixels, false, '/Filter /DCTDecode', false );
    elsif p_img.type = 'png'
    then
      put_stream( p_img.pixels, false
                ,  ' /Filter /FlateDecode /DecodeParms <</Predictor 15 '
                || '/Colors ' || p_img.nr_colors
                || '/BitsPerComponent ' || p_img.color_res
                || ' /Columns ' || p_img.width
                || ' >> '
                , false );
    else
      put_stream( p_img.pixels, p_tag => false );
    end if;
    txt2pdfdoc( 'endobj' );
  end;
--
  function add_resources
  return number
  is
    t_ind pls_integer;
    t_self number(10);
    t_fonts tp_objects_tab;
  begin
--
    t_ind := g_used_fonts.first;
    while t_ind is not null
    loop
      t_fonts( t_ind ) := add_font( t_ind );
      t_ind := g_used_fonts.next( t_ind );
    end loop;
--
    t_self := add_object;
    txt2pdfdoc( '<</ProcSet [/PDF /Text]' );
--
    if g_used_fonts.count() > 0
    then
      txt2pdfdoc( '/Font <<' );
      t_ind := g_used_fonts.first;
      while t_ind is not null
      loop
        txt2pdfdoc( '/F'|| to_char( t_ind ) || ' '
                  || to_char( t_fonts( t_ind ) ) || ' 0 R'
                  );
        t_ind := g_used_fonts.next( t_ind );
      end loop;
      txt2pdfdoc( '>>' );
    end if;
--
    if g_images.count( ) > 0
    then
      txt2pdfdoc( '/XObject <<' );
      for i in g_images.first .. g_images.last
      loop
        txt2pdfdoc( '/I' || to_char( i ) || ' ' || to_char( t_self + 2 * i ) || ' 0 R' );
      end loop;
      txt2pdfdoc( '>>' );
    end if;
--
    txt2pdfdoc( '>>' );
    txt2pdfdoc( 'endobj' );
--
    if g_images.count( ) > 0
    then
      for i in g_images.first .. g_images.last
      loop
        add_image( g_images( i ) );
      end loop;
    end if;
    return t_self;
  end;
--
  procedure add_page
    ( p_page_ind pls_integer
    , p_parent number
    , p_resources number
    )
  is
    t_content number(10);
  begin
    t_content := add_stream( g_pages( p_page_ind ) );
    add_object;
    txt2pdfdoc( '<< /Type /Page' );
    txt2pdfdoc( '/Parent ' || to_char( p_parent ) || ' 0 R' );
    -- AW: Add a mediabox to each page
    txt2pdfdoc(    '/MediaBox [0 0 '
                || to_char_round( g_settings_per_page( p_page_ind ).page_width
                                , 0
                                )
                || ' '
                || to_char_round( g_settings_per_page( p_page_ind ).page_height
                                , 0
                                )
                || ']' );

    txt2pdfdoc( '/Contents ' || to_char( t_content ) || ' 0 R' );
    txt2pdfdoc( '/Resources ' || to_char( p_resources ) || ' 0 R' );
    txt2pdfdoc( '>>' );
    txt2pdfdoc( 'endobj' );
  end;
--
  function add_pages
  return number
  is
    t_self number(10);
    t_resources number(10);
  begin
    t_resources := add_resources;
    t_self := add_object;
    txt2pdfdoc( '<</Type/Pages/Kids [' );
--
    for i in g_pages.first .. g_pages.last
    loop
      txt2pdfdoc( to_char( t_self + i * 2 + 2 ) || ' 0 R' );
    end loop;
--
    -- AW: take the settings from page 1 as global settings
    if g_settings_per_page.EXISTS(0) THEN
      g_settings:=g_settings_per_page(0);
    end if;
    txt2pdfdoc( ']' );
    txt2pdfdoc( '/Count ' || g_pages.count() );
    txt2pdfdoc(    '/MediaBox [0 0 '
                || to_char_round( g_settings.page_width
                                , 0
                                )
                || ' '
                || to_char_round( g_settings.page_height
                                , 0
                                )
                || ']' );
    txt2pdfdoc( '>>' );
    txt2pdfdoc( 'endobj' );
--
    if g_pages.count() > 0
    then
      for i in g_pages.first .. g_pages.last
      loop
        add_page( i, t_self, t_resources );
      end loop;
    end if;
--
    return t_self;
  end;
--
  function add_catalogue
  return number
  is
  begin
    return add_object( '/Type/Catalog'
                     || '/Pages ' || to_char( add_pages ) || ' 0 R'
                     || '/OpenAction [0 /XYZ null null 0.77]'
                     );
  end;
--
  function add_info
  return number
  is
    t_banner varchar2( 1000 );
  begin
    begin
      select    'running on '
             || replace( replace( replace( substr( banner
                                                 , 1
                                                 , 950
                                                 )
                                         , '\'
                                         , '\\'
                                         )
                                , '('
                                , '\('
                                )
                       , ')'
                       , '\)'
                       )
      into t_banner
      from v$version
      where instr( upper( banner )
                 , 'DATABASE'
                 ) > 0;
      t_banner := '/Producer (' || t_banner || ')';
    exception
      when others
      then
        null;
    end;
--
    return add_object( to_char( sysdate, '"/CreationDate (D:"YYYYMMDDhh24miss")"' )
                     || '/Creator (AS-PDF 0.3.0 by Anton Scheffer)'
                     || t_banner
                     || '/Title <FEFF' || utl_i18n.string_to_raw( g_info.title, 'AL16UTF16' ) || '>'
                     || '/Author <FEFF' || utl_i18n.string_to_raw( g_info.author, 'AL16UTF16' ) || '>'
                     || '/Subject <FEFF' || utl_i18n.string_to_raw( g_info.subject, 'AL16UTF16' ) || '>'
                     || '/Keywords <FEFF' || utl_i18n.string_to_raw( g_info.keywords, 'AL16UTF16' ) || '>'
                     );
  end;
--
  procedure finish_pdf
  is
    t_xref number;
    t_info number(10);
    t_catalogue number(10);
  begin
    if g_pages.count = 0
    then
      new_page;
    end if;
    if g_page_prcs.count > 0
    then
      for i in g_pages.first .. g_pages.last
      loop
        g_page_nr := i;
        for p in g_page_prcs.first .. g_page_prcs.last
        loop
          begin
            execute immediate replace( replace( g_page_prcs( p ), '#PAGE_NR#', i + 1 ), '"PAGE_COUNT#', g_pages.count );
          exception
            when others then null;
          end;
        end loop;
      end loop;
    end if;
    dbms_lob.createtemporary( g_pdf_doc, true );
    txt2pdfdoc( '%PDF-1.3' );
    raw2pdfdoc( hextoraw( '25E2E3CFD30D0A' ) );          -- add a hex comment
    t_info := add_info;
    t_catalogue := add_catalogue;
    t_xref := dbms_lob.getlength( g_pdf_doc );
    txt2pdfdoc( 'xref' );
    txt2pdfdoc( '0 ' || to_char( g_objects.count() ) );
    txt2pdfdoc( '0000000000 65535 f ' );
    for i in 1 .. g_objects.count( ) - 1
    loop
      txt2pdfdoc( to_char( g_objects( i ), 'fm0000000000' ) || ' 00000 n' );
                        -- this line should be exactly 20 bytes, including EOL
    end loop;
    txt2pdfdoc( 'trailer' );
    txt2pdfdoc( '<< /Root ' || to_char( t_catalogue ) || ' 0 R' );
    txt2pdfdoc( '/Info ' || to_char( t_info ) || ' 0 R' );
    txt2pdfdoc( '/Size ' || to_char( g_objects.count() ) );
    txt2pdfdoc( '>>' );
    txt2pdfdoc( 'startxref' );
    txt2pdfdoc( to_char( t_xref ) );
    txt2pdfdoc( '%%EOF' );
--
    g_objects.delete;
    for i in g_pages.first .. g_pages.last
    loop
      dbms_lob.freetemporary( g_pages( i ) );
    end loop;
    g_objects.delete;
    g_pages.delete;
    -- AW: Page-settings
    g_settings_per_page.delete;
    g_fonts.delete;
    g_used_fonts.delete;
    g_page_prcs.delete;
    if g_images.count() > 0
    then
      for i in g_images.first .. g_images.last
      loop
        if dbms_lob.istemporary( g_images( i ).pixels ) = 1
        then
          dbms_lob.freetemporary( g_images( i ).pixels );
        end if;
      end loop;
      g_images.delete;
    end if;
  end;
--
  function conv2uu( p_value number, p_unit varchar2 )
  return number
  is
   c_inch constant number := 25.40025;
  begin
    return round( case lower( p_unit )
                    when 'mm' then p_value * 72 / c_inch
                    when 'cm' then p_value * 720 / c_inch
                    when 'pt' then p_value          -- also point
                    when 'point' then p_value
                    when 'inch'  then p_value * 72
                    when 'in'    then p_value * 72  -- also inch
                    when 'pica'  then p_value * 12
                    when 'p'     then p_value * 12  -- also pica
                    when 'pc'    then p_value * 12  -- also pica
                    when 'em'    then p_value * 12  -- also pica
                    when 'px'    then p_value       -- pixel voorlopig op point zetten
                    when 'px'    then p_value * 0.8 -- pixel
                    else null
                  end
                , 3
                );
  end;
--
  procedure set_page_size
    ( p_width number
    , p_height number
    , p_unit varchar2 := 'cm'
    )
  is
  begin
    g_settings.page_width := conv2uu( p_width, p_unit );
    g_settings.page_height := conv2uu( p_height, p_unit );
  end;
--
  procedure set_page_format( p_format varchar2 := 'A4' )
  is
  begin
    case upper( p_format )
      when 'A3'
      then
        set_page_size( 420, 297, 'mm' );
      when 'A4'
      then
        set_page_size( 297, 210, 'mm' );
      when 'A5'
      then
        set_page_size( 210, 148, 'mm' );
      when 'A6'
      then
        set_page_size( 148, 105, 'mm' );
      when 'LEGAL'
      then
        set_page_size( 14, 8.5, 'in' );
      when 'LETTER'
      then
        set_page_size( 11, 8.5, 'in' );
      when 'QUARTO'
      then
        set_page_size( 11, 9, 'in' );
      when 'EXECUTIVE'
      then
        set_page_size( 10.5, 7.25, 'in' );
      else
        null;
    end case;
  end;
--
  procedure set_page_orientation( p_orientation varchar2 := 'PORTRAIT' )
  is
    t_tmp number;
  begin
    if (  (   upper( p_orientation ) in ( 'L', 'LANDSCAPE' )
          and g_settings.page_height > g_settings.page_width
          )
       or ( upper( p_orientation ) in( 'P', 'PORTRAIT' )
          and g_settings.page_height < g_settings.page_width
          )
       )
    then
      t_tmp := g_settings.page_width;
      g_settings.page_width := g_settings.page_height;
      g_settings.page_height := t_tmp;
    end if;
  end;
--
  procedure set_margins
    ( p_top number := null
    , p_left number := null
    , p_bottom number := null
    , p_right number := null
    , p_unit varchar2 := 'cm'
    )
  is
    t_tmp number;
  begin
    t_tmp := nvl( conv2uu( p_top, p_unit ), -1 );
    if t_tmp < 0 or t_tmp > g_settings.page_height
    then
      t_tmp := conv2uu( 3, 'cm' );
    end if;
    g_settings.margin_top := t_tmp;
    t_tmp := nvl( conv2uu( p_bottom, p_unit ), -1 );
    if t_tmp < 0 or t_tmp > g_settings.page_height
    then
      t_tmp := conv2uu( 4, 'cm' );
    end if;
    g_settings.margin_bottom := t_tmp;
    t_tmp := nvl( conv2uu( p_left, p_unit ), -1 );
    if t_tmp < 0 or t_tmp > g_settings.page_width
    then
      t_tmp := conv2uu( 1, 'cm' );
    end if;
    g_settings.margin_left := t_tmp;
    t_tmp := nvl( conv2uu( p_right, p_unit ), -1 );
    if t_tmp < 0 or t_tmp > g_settings.page_width
    then
      t_tmp := conv2uu( 1, 'cm' );
    end if;
    g_settings.margin_right := t_tmp;
--
    if g_settings.margin_top + g_settings.margin_bottom + conv2uu( 1, 'cm' )> g_settings.page_height
    then
      g_settings.margin_top := 0;
      g_settings.margin_bottom := 0;
    end if;
    if g_settings.margin_left + g_settings.margin_right + conv2uu( 1, 'cm' )> g_settings.page_width
    then
      g_settings.margin_left := 0;
      g_settings.margin_right := 0;
    end if;
  end;
--
  procedure set_info
    ( p_title varchar2 := null
    , p_author varchar2 := null
    , p_subject varchar2 := null
    , p_keywords varchar2 := null
    )
  is
  begin
    g_info.title := substr( p_title, 1, 1024 );
    g_info.author := substr( p_author, 1, 1024 );
    g_info.subject := substr( p_subject, 1, 1024 );
    g_info.keywords := substr( p_keywords, 1, 16383 );
  end;
--
  procedure init
  is
  begin
    g_objects.delete;
    g_pages.delete;
    -- AW: Page-settings
    g_settings_per_page.delete;
    g_fonts.delete;
    g_used_fonts.delete;
    g_page_prcs.delete;
    g_images.delete;
    g_settings := null;
    g_current_font := null;
    g_x := null;
    g_y := null;
    g_info := null;
    g_page_nr := null;
    g_objects( 0 ) := 0;
    init_core_fonts;
    set_page_format;
    set_page_orientation;
    set_margins;
  end;
--
  function get_pdf
  return blob
  is
  begin
    finish_pdf;
    return g_pdf_doc;
  end;
--
  procedure save_pdf
    ( p_dir varchar2 := 'MY_DIR'
    , p_filename varchar2 := 'my.pdf'
    , p_freeblob boolean := true
    )
  is
    t_fh utl_file.file_type;
    t_len pls_integer := 32767;
  begin
    finish_pdf;
    t_fh := utl_file.fopen( p_dir, p_filename, 'wb' );
    for i in 0 .. trunc( ( dbms_lob.getlength( g_pdf_doc ) - 1 ) / t_len )
    loop
      utl_file.put_raw( t_fh
                      , dbms_lob.substr( g_pdf_doc
                                       , t_len
                                       , i * t_len + 1
                                       )
                      );
    end loop;
    utl_file.fclose( t_fh );
    if p_freeblob
    then
      dbms_lob.freetemporary( g_pdf_doc );
    end if;
  end;
--
  procedure raw2page( p_txt raw )
  is
  begin
    if g_pages.count() = 0
    then
      new_page;
    end if;
    dbms_lob.append( g_pages( coalesce( g_page_nr, g_pages.count( ) - 1 ) )
                   , utl_raw.concat( p_txt, hextoraw( '0D0A' ) )
                   );
  end;
--
  procedure txt2page( p_txt varchar2 )
  is
  begin
    raw2page( utl_raw.cast_to_raw( p_txt ) );
  end;
--
  procedure output_font_to_doc( p_output_to_doc boolean )
  is
  begin
    if p_output_to_doc
    then
      txt2page( 'BT /F' || g_current_font || ' '
              || to_char_round( g_fonts( g_current_font ).fontsize ) || ' Tf ET'
              );
    end if;
  end;
--
  procedure set_font
    ( p_index pls_integer
    , p_fontsize_pt number
    , p_output_to_doc boolean := true
    )
  is
  begin
    if p_index is not null
    then
      g_used_fonts( p_index ) := 0;
      g_fonts( p_index ).fontsize := p_fontsize_pt;
      g_current_font_record.fontsize := p_fontsize_pt;
      if NVL(g_current_font,-1) != p_index then -- aw set only if different
        g_current_font := p_index;
        g_current_font_record:=g_fonts( p_index );
      end if;
      output_font_to_doc( p_output_to_doc );
    end if;
  end;
--
  function set_font
    ( p_fontname varchar2
    , p_fontsize_pt number
    , p_output_to_doc boolean := true
    )
  return pls_integer
  is
    t_fontname varchar2(100);
  begin
    if p_fontname is null
    then
      if (  g_current_font is not null
         and p_fontsize_pt != g_fonts( g_current_font ).fontsize
         )
      then
        g_fonts( g_current_font ).fontsize := p_fontsize_pt;
        g_current_font_record:=g_fonts( g_current_font );
        output_font_to_doc( p_output_to_doc );
      end if;
      return g_current_font;
    end if;
--
    t_fontname := lower( p_fontname );
    for i in g_fonts.first .. g_fonts.last
    loop
      if lower( g_fonts( i ).fontname ) = t_fontname
      then
        exit when g_current_font = i and g_fonts( i ).fontsize = p_fontsize_pt and g_page_nr is null;
        g_fonts( i ).fontsize := coalesce( p_fontsize_pt
                                         , g_fonts( nvl( g_current_font, i ) ).fontsize
                                         , 12
                                         );
        g_current_font := i;
        g_current_font_record:=g_fonts(i);
        g_used_fonts( i ) := 0;
        output_font_to_doc( p_output_to_doc );
        return g_current_font;
      end if;
    end loop;
    return null;
  end;
--
  procedure set_font
    ( p_fontname varchar2
    , p_fontsize_pt number
    , p_output_to_doc boolean := true
    )
  is
    t_dummy pls_integer;
  begin
    t_dummy := set_font( p_fontname, p_fontsize_pt, p_output_to_doc );
  end;
--
  function set_font
    ( p_family varchar2
    , p_style varchar2 := 'N'
    , p_fontsize_pt number := null
    , p_output_to_doc boolean := true
    )
  return pls_integer
  is
    t_family varchar2(100);
    t_style varchar2(100);
  begin
    if p_family is null and g_current_font is null
    then
      return null;
    end if;
    if p_family is null and  p_style is null and p_fontsize_pt is null
    then
      return null;
    end if;
    t_family := coalesce( lower( p_family )
                        , g_fonts( g_current_font ).family
                        );
    t_style := upper( p_style );

    t_style := case t_style
                 when 'NORMAL' then 'N'
                 when 'REGULAR' then 'N'
                 when 'BOLD' then 'B'
                 when 'ITALIC' then 'I'
                 when 'OBLIQUE' then 'I'
                 else t_style
               end;
    t_style := coalesce( t_style
                       , case when g_current_font is null then 'N' else g_fonts( g_current_font ).style end
                       );
--
    for i in g_fonts.first .. g_fonts.last
    loop
      if (   g_fonts( i ).family = t_family
         and g_fonts( i ).style = t_style
         )
      then
        return set_font( g_fonts( i ).fontname, p_fontsize_pt, p_output_to_doc );
      end if;
    end loop;
    return null;
  end;
--
  procedure set_font
    ( p_family varchar2
    , p_style varchar2 := 'N'
    , p_fontsize_pt number := null
    , p_output_to_doc boolean := true
    )
  is
    t_dummy pls_integer;
  begin
    t_dummy := set_font( p_family, p_style, p_fontsize_pt, p_output_to_doc );
  end;
--
  procedure new_page
  is
  begin
    g_pages( g_pages.count() ) := null;
    g_settings_per_page(g_settings_per_page.count()):=g_settings;
    dbms_lob.createtemporary( g_pages( g_pages.count() - 1 ), true );
    if g_current_font is not null and g_pages.count() > 0
    then
      txt2page( 'BT /F' || g_current_font || ' '
              || to_char_round( g_fonts( g_current_font ).fontsize )
              || ' Tf ET'
              );
    end if;
    g_x := null;
    g_y := null;
  end;
--
  function pdf_string( p_txt in blob )
  return blob
  is
    t_rv blob;
    t_ind integer;
    type tp_tab_raw is table of raw(1);
    tab_raw tp_tab_raw
      := tp_tab_raw( utl_raw.cast_to_raw( '\' )
                   , utl_raw.cast_to_raw( '(' )
                   , utl_raw.cast_to_raw( ')' )
                   );
  begin
    t_rv := p_txt;
    for i in tab_raw.first .. tab_raw.last
    loop
      t_ind := -1;
      loop
        t_ind := dbms_lob.instr( t_rv
                               , tab_raw( i )
                               , t_ind + 2
                               );
        exit when t_ind <= 0;
        dbms_lob.copy( t_rv
                     , t_rv
                     , dbms_lob.lobmaxsize
                     , t_ind + 1
                     , t_ind
                     );
        dbms_lob.copy( t_rv
                     , utl_raw.cast_to_raw( '\' )
                     , 1
                     , t_ind
                     , 1
                     );
      end loop;
    end loop;
    return t_rv;
  end;
--
  function txt2raw( p_txt varchar2 )
  return raw
  is
    t_rv raw(32767);
    t_unicode pls_integer;
  begin
    if g_current_font is null
    then
      set_font( 'helvetica' );
    end if;
    if g_fonts( g_current_font ).cid
    then
      for i in 1 .. length( p_txt )
      loop
        t_unicode := utl_raw.cast_to_binary_integer( utl_raw.convert( utl_raw.cast_to_raw( substr( p_txt, i, 1 ) )
                                                                    , 'AMERICAN_AMERICA.AL16UTF16'
                                                                    , sys_context( 'userenv', 'LANGUAGE' )  -- ???? font characterset ?????
                                                                    )
                                                 );
        if g_fonts( g_current_font ).flags = 4 -- a symbolic font
        then
-- assume code 32, space maps to the first code from the font
          t_unicode := g_fonts( g_current_font ).code2glyph.first + t_unicode - 32;
        end if;
        if g_current_font_record.code2glyph.exists( t_unicode )
        then
          g_fonts( g_current_font ).used_chars( g_current_font_record.code2glyph( t_unicode ) ) := 0;
          t_rv := utl_raw.concat( t_rv
                                , utl_raw.cast_to_raw( to_char( g_current_font_record.code2glyph( t_unicode ), 'FM0XXX' ) )
                                );
        else
          t_rv := utl_raw.concat( t_rv, utl_raw.cast_to_raw( '0000' ) );

        end if;
      end loop;
      t_rv := utl_raw.concat( utl_raw.cast_to_raw( '<' )
                            , t_rv
                            , utl_raw.cast_to_raw( '>' )
                            );
    else
      t_rv := utl_raw.convert( utl_raw.cast_to_raw( p_txt )
                             , g_fonts( g_current_font ).charset
                             , sys_context( 'userenv', 'LANGUAGE' )
                             );
      for i in 1 .. utl_raw.length( t_rv )
      loop
        g_fonts( g_current_font ).used_chars( raw2num( t_rv, i, 1 ) ) := 0;
      end loop;
      t_rv := utl_raw.concat( utl_raw.cast_to_raw( '(' )
                            , pdf_string( t_rv )
                            , utl_raw.cast_to_raw( ')' )
                            );
    end if;
    return t_rv;
  end;
--
  procedure put_raw( p_x number, p_y number, p_txt raw, p_degrees_rotation number := null )
  is
    c_pi constant number := 3.14159265358979323846264338327950288419716939937510;
    t_tmp varchar2(32767);
    t_sin number;
    t_cos number;
  begin
    t_tmp := to_char_round( p_x ) || ' ' || to_char_round( p_y );
    if p_degrees_rotation is null
    then
      t_tmp := t_tmp || ' Td ';
    else
      t_sin := sin( p_degrees_rotation / 180 * c_pi );
      t_cos := cos( p_degrees_rotation / 180 * c_pi );
      t_tmp := to_char_round( t_cos, 5 ) || ' ' || t_tmp;
      t_tmp := to_char_round( - t_sin, 5 ) || ' ' || t_tmp;
      t_tmp := to_char_round( t_sin, 5 ) || ' ' || t_tmp;
      t_tmp := to_char_round( t_cos, 5 ) || ' ' || t_tmp;
      t_tmp := t_tmp || ' Tm ';
    end if;
    raw2page( utl_raw.concat( utl_raw.cast_to_raw( 'BT ' || t_tmp )
                            , p_txt
                            , utl_raw.cast_to_raw( ' Tj ET' )
                            )
              );
  end;
--
  procedure put_txt( p_x number, p_y number, p_txt varchar2, p_degrees_rotation number := null )
  is
  begin
    if p_txt is not null
    then
      put_raw( p_x, p_y, txt2raw( p_txt ), p_degrees_rotation );
    end if;
  end;
--
  function str_len( p_txt in varchar2 )
  return number
  is
    t_width number;
    t_char pls_integer;
    t_rtxt raw(32767);
    t_tmp number;
    --t_font tp_font;
  begin
    if p_txt is null
    then
      return 0;
    end if;
--
    t_width := 0;
    if g_current_font_record.cid
    then
      t_rtxt := utl_raw.convert( utl_raw.cast_to_raw( p_txt )
                               , 'AMERICAN_AMERICA.AL16UTF16' -- 16 bit font => 2 bytes per char
                               , sys_context( 'userenv', 'LANGUAGE' )  -- ???? font characterset ?????
                               );
      for i in 1 .. utl_raw.length( t_rtxt ) / 2
      loop
        t_char := to_number( utl_raw.substr( t_rtxt, i * 2 - 1, 2 ), 'xxxx' );
        if g_current_font_record.flags = 4
        then
-- assume code 32, space maps to the first code from the font
          t_char := g_current_font_record.code2glyph.first + t_char - 32;
        end if;
        if (   g_current_font_record.code2glyph.exists( t_char )
           and g_current_font_record.hmetrics.exists( g_current_font_record.code2glyph( t_char ) )
           )
        then
          t_tmp := g_current_font_record.hmetrics( g_current_font_record.code2glyph( t_char ) );
        else
          t_tmp := g_current_font_record.hmetrics( g_current_font_record.hmetrics.last() );
        end if;
        t_width := t_width + t_tmp;
      end loop;
      t_width := t_width * g_current_font_record.unit_norm;
      t_width := t_width * g_current_font_record.fontsize / 1000;
    else
      t_rtxt := utl_raw.convert( utl_raw.cast_to_raw( p_txt )
                               , g_current_font_record.charset  -- should be an 8 bit font
                               , sys_context( 'userenv', 'LANGUAGE' )
                               );
      for i in 1 .. utl_raw.length( t_rtxt )
      loop
        t_char := to_number( utl_raw.substr( t_rtxt, i, 1 ), 'xx' );
        t_width := t_width + g_current_font_record.char_width_tab( t_char );
      end loop;
      t_width := t_width * g_current_font_record.fontsize / 1000;
    end if;
    return t_width;
  end;
--
  procedure write
    ( p_txt in varchar2
    , p_x in number := null
    , p_y in number := null
    , p_line_height in number := null
    , p_start in number := null  -- left side of the available text box
    , p_width in number := null  -- width of the available text box
    , p_alignment in varchar2 := null
    )
  is
    t_line_height number;
    t_x number;
    t_y number;
    t_start number;
    t_width number;
    t_len number;
    t_cnt pls_integer;
    t_ind pls_integer;
    t_alignment varchar2(100);
  begin
    if p_txt is null
    then
      return;
    end if;
--
    if g_current_font is null
    then
      set_font( 'helvetica' );
    end if;
--
    t_line_height := nvl( p_line_height, g_fonts( g_current_font ).fontsize );
    if (  t_line_height < g_fonts( g_current_font ).fontsize
       or t_line_height > ( g_settings.page_height - g_settings.margin_top - t_line_height ) / 4
       )
    then
      t_line_height := g_fonts( g_current_font ).fontsize;
    end if;
    t_start := nvl( p_start, g_settings.margin_left );
    if (  t_start < g_settings.margin_left
       or t_start > g_settings.page_width - g_settings.margin_right - g_settings.margin_left
       )
    then
      t_start := g_settings.margin_left;
    end if;
    t_width := nvl( p_width
                  , g_settings.page_width - g_settings.margin_right - g_settings.margin_left
                  );
    if (  t_width < str_len( '   ' )
       or t_width > g_settings.page_width - g_settings.margin_right - g_settings.margin_left
       )
    then
      t_width := g_settings.page_width - g_settings.margin_right - g_settings.margin_left;
    end if;
    t_x := coalesce( p_x, g_x, g_settings.margin_left );
    t_y := coalesce( p_y
                   , g_y
                   , g_settings.page_height - g_settings.margin_top - t_line_height
                   );
    if t_y < 0
    then
      t_y := coalesce( g_y
                     , g_settings.page_height - g_settings.margin_top - t_line_height
                     ) - t_line_height;
    end if;
    if t_x > t_start + t_width
    then
      t_x := t_start;
      t_y := t_y - t_line_height;
    elsif t_x < t_start
    then
      t_x := t_start;
    end if;
    if t_y < g_settings.margin_bottom
    then
      new_page;
      t_x := t_start;
      t_y := g_settings.page_height - g_settings.margin_top - t_line_height;
    end if;
--
    t_ind := instr( p_txt, chr(10) );
    if t_ind > 0
    then
      g_x := t_x;
      g_y := t_y;
      write( rtrim( substr( p_txt, 1, t_ind - 1 ), chr(13) ), t_x, t_y, t_line_height, t_start, t_width, p_alignment );
      t_y := g_y - t_line_height;
      if t_y < g_settings.margin_bottom
      then
        new_page;
        t_y := g_settings.page_height - g_settings.margin_top - t_line_height;
      end if;
      g_x := t_start;
      g_y := t_y;
      write( substr( p_txt, t_ind + 1 ), t_start, t_y, t_line_height, t_start, t_width, p_alignment );
      return;
    end if;
--
    t_len := str_len( p_txt );
    if t_len <= t_width - t_x + t_start
    then
      t_alignment := lower( substr( p_alignment, 1, 100 ) );
      if instr( t_alignment, 'right' ) > 0 or instr( t_alignment, 'end' ) > 0
      then
        t_x := t_start + t_width - t_len;
      elsif instr( t_alignment, 'center' ) > 0
      then
        t_x := ( t_width + t_x + t_start - t_len ) / 2;
      end if;
      put_txt( t_x, t_y, p_txt );
      g_x := t_x + t_len + str_len( ' ' );
      g_y := t_y;
      return;
    end if;
--
    t_cnt := 0;
    while (   instr( p_txt, ' ', 1, t_cnt + 1 ) > 0
          and str_len( substr( p_txt, 1, instr( p_txt, ' ', 1, t_cnt + 1 ) - 1 ) ) <= t_width - t_x + t_start
          )
    loop
      t_cnt := t_cnt + 1;
    end loop;
    if t_cnt > 0
    then
      t_ind := instr( p_txt, ' ', 1, t_cnt );
      write( substr( p_txt, 1, t_ind - 1 ), t_x, t_y, t_line_height, t_start, t_width, p_alignment );
      t_y := t_y - t_line_height;
      if t_y < g_settings.margin_bottom
      then
        new_page;
        t_y := g_settings.page_height - g_settings.margin_top - t_line_height;
      end if;
      write( substr( p_txt, t_ind + 1 ), t_start, t_y, t_line_height, t_start, t_width, p_alignment );
      return;
    end if;
--
    if t_x > t_start and t_len < t_width
    then
      t_y := t_y - t_line_height;
      if t_y < g_settings.margin_bottom
      then
        new_page;
        t_y := g_settings.page_height - g_settings.margin_top - t_line_height;
      end if;
      write( p_txt, t_start, t_y, t_line_height, t_start, t_width, p_alignment );
    else
      if length( p_txt ) = 1
      then
        if t_x > t_start
        then
          t_y := t_y - t_line_height;
          if t_y < g_settings.margin_bottom
          then
            new_page;
            t_y := g_settings.page_height - g_settings.margin_top - t_line_height;
          end if;
        end if;
        write( p_txt, t_x, t_y, t_line_height, t_start, t_len );
      else
        t_ind := 2; -- start with 2 to make sure we get amaller string!
        while str_len( substr( p_txt, 1, t_ind ) ) <= t_width - t_x + t_start
        loop
          t_ind := t_ind + 1;
        end loop;
        write( substr( p_txt, 1, t_ind - 1 ), t_x, t_y, t_line_height, t_start, t_width, p_alignment );
        t_y := t_y - t_line_height;
        if t_y < g_settings.margin_bottom
        then
          new_page;
          t_y := g_settings.page_height - g_settings.margin_top - t_line_height;
        end if;
        write( substr( p_txt, t_ind ), t_start, t_y, t_line_height, t_start, t_width, p_alignment );
      end if;
    end if;
  end;
--
  function load_ttf_font
    ( p_font blob
    , p_encoding varchar2 := 'WINDOWS-1252'
    , p_embed boolean := false
    , p_compress boolean := true
    , p_offset number := 1
    )
  return pls_integer
  is
    this_font tp_font;
    type tp_font_table is record
      ( offset pls_integer
      , length pls_integer
      );
    type tp_tables is table of tp_font_table index by varchar2(4);
    t_tables tp_tables;
    t_tag varchar2(4);
    t_blob blob;
    t_offset pls_integer;
    nr_hmetrics pls_integer;
    subtype tp_glyphname is varchar2(250);
    type tp_glyphnames is table of tp_glyphname index by pls_integer;
    t_glyphnames tp_glyphnames;
    t_glyph2name tp_pls_tab;
    t_font_ind pls_integer;
  begin
    if dbms_lob.substr( p_font, 4, p_offset ) != hextoraw( '00010000' ) --  OpenType Font
    then
      return null;
    end if;
    for i in 1 .. blob2num( p_font, 2, p_offset + 4 )
    loop
      t_tag :=
        utl_raw.cast_to_varchar2( dbms_lob.substr( p_font, 4, p_offset - 4 + i * 16 ) );
      t_tables( t_tag ).offset := blob2num( p_font, 4, p_offset + 4 + i * 16 ) + 1;
      t_tables( t_tag ).length := blob2num( p_font, 4, p_offset + 8 + i * 16 );
    end loop;
--
    if (  not t_tables.exists( 'cmap' )
       or not t_tables.exists( 'glyf' )
       or not t_tables.exists( 'head' )
       or not t_tables.exists( 'hhea' )
       or not t_tables.exists( 'hmtx' )
       or not t_tables.exists( 'loca' )
       or not t_tables.exists( 'maxp' )
       or not t_tables.exists( 'name' )
       or not t_tables.exists( 'post' )
       )
    then
      return null;
    end if;
--
    dbms_lob.createtemporary( t_blob, true );
    dbms_lob.copy( t_blob, p_font, t_tables( 'maxp' ).length, 1, t_tables( 'maxp' ).offset );
    this_font.numGlyphs := blob2num( t_blob, 2, 5 );
--
    dbms_lob.copy( t_blob, p_font, t_tables( 'cmap' ).length, 1, t_tables( 'cmap' ).offset );
    for i in 0 .. blob2num( t_blob, 2, 3 ) - 1
    loop
      if (   dbms_lob.substr( t_blob, 2, 5 + i * 8 ) = hextoraw( '0003' ) -- Windows
         and dbms_lob.substr( t_blob, 2, 5 + i * 8 + 2 )
               in ( hextoraw( '0000' ) -- Symbol
                  , hextoraw( '0001' ) -- Unicode BMP (UCS-2)
                  )
         )
      then
        if dbms_lob.substr( t_blob, 2, 5 + i * 8 + 2 ) = hextoraw( '0000' ) -- Symbol
        then
          this_font.flags := 4; -- symbolic
        else
          this_font.flags := 32; -- non-symbolic
        end if;
        t_offset := blob2num( t_blob, 4, 5 + i * 8 + 4 ) + 1;
        if dbms_lob.substr( t_blob, 2, t_offset ) != hextoraw( '0004' )
        then
          return null;
        end if;
        declare
          t_seg_cnt pls_integer;
          t_end_offs pls_integer;
          t_start_offs pls_integer;
          t_idDelta_offs pls_integer;
          t_idRangeOffset_offs pls_integer;
          t_tmp pls_integer;
          t_start pls_integer;
        begin
          t_seg_cnt := blob2num( t_blob, 2, t_offset + 6 ) / 2;
          t_end_offs := t_offset + 14;
          t_start_offs := t_end_offs + t_seg_cnt * 2 + 2;
          t_idDelta_offs := t_start_offs + t_seg_cnt * 2;
          t_idRangeOffset_offs := t_idDelta_offs + t_seg_cnt * 2;
          for seg in 0 .. t_seg_cnt - 1
          loop
            t_tmp := blob2num( t_blob, 2, t_idRangeOffset_offs + seg * 2 );
            if t_tmp = 0
            then
              t_tmp := blob2num( t_blob, 2, t_idDelta_offs + seg * 2 );
              for c in blob2num( t_blob, 2, t_start_offs + seg * 2 )
                    .. blob2num( t_blob, 2, t_end_offs + seg * 2 )
              loop
                this_font.code2glyph( c ) := mod( c + t_tmp, 65536 );
              end loop;
            else
              t_start := blob2num( t_blob, 2, t_start_offs + seg * 2 );
              for c in t_start .. blob2num( t_blob, 2, t_end_offs + seg * 2 )
              loop
                this_font.code2glyph( c ) := blob2num( t_blob, 2, t_idRangeOffset_offs + t_tmp + ( seg + c - t_start ) * 2 );
              end loop;
            end if;
          end loop;
        end;
        exit;
      end if;
    end loop;
--
    t_glyphnames( 0 ) := '.notdef';
    t_glyphnames( 1 ) := '.null';
    t_glyphnames( 2 ) := 'nonmarkingreturn';
    t_glyphnames( 3 ) := 'space';
    t_glyphnames( 4 ) := 'exclam';
    t_glyphnames( 5 ) := 'quotedbl';
    t_glyphnames( 6 ) := 'numbersign';
    t_glyphnames( 7 ) := 'dollar';
    t_glyphnames( 8 ) := 'percent';
    t_glyphnames( 9 ) := 'ampersand';
    t_glyphnames( 10 ) := 'quotesingle';
    t_glyphnames( 11 ) := 'parenleft';
    t_glyphnames( 12 ) := 'parenright';
    t_glyphnames( 13 ) := 'asterisk';
    t_glyphnames( 14 ) := 'plus';
    t_glyphnames( 15 ) := 'comma';
    t_glyphnames( 16 ) := 'hyphen';
    t_glyphnames( 17 ) := 'period';
    t_glyphnames( 18 ) := 'slash';
    t_glyphnames( 19 ) := 'zero';
    t_glyphnames( 20 ) := 'one';
    t_glyphnames( 21 ) := 'two';
    t_glyphnames( 22 ) := 'three';
    t_glyphnames( 23 ) := 'four';
    t_glyphnames( 24 ) := 'five';
    t_glyphnames( 25 ) := 'six';
    t_glyphnames( 26 ) := 'seven';
    t_glyphnames( 27 ) := 'eight';
    t_glyphnames( 28 ) := 'nine';
    t_glyphnames( 29 ) := 'colon';
    t_glyphnames( 30 ) := 'semicolon';
    t_glyphnames( 31 ) := 'less';
    t_glyphnames( 32 ) := 'equal';
    t_glyphnames( 33 ) := 'greater';
    t_glyphnames( 34 ) := 'question';
    t_glyphnames( 35 ) := 'at';
    t_glyphnames( 36 ) := 'A';
    t_glyphnames( 37 ) := 'B';
    t_glyphnames( 38 ) := 'C';
    t_glyphnames( 39 ) := 'D';
    t_glyphnames( 40 ) := 'E';
    t_glyphnames( 41 ) := 'F';
    t_glyphnames( 42 ) := 'G';
    t_glyphnames( 43 ) := 'H';
    t_glyphnames( 44 ) := 'I';
    t_glyphnames( 45 ) := 'J';
    t_glyphnames( 46 ) := 'K';
    t_glyphnames( 47 ) := 'L';
    t_glyphnames( 48 ) := 'M';
    t_glyphnames( 49 ) := 'N';
    t_glyphnames( 50 ) := 'O';
    t_glyphnames( 51 ) := 'P';
    t_glyphnames( 52 ) := 'Q';
    t_glyphnames( 53 ) := 'R';
    t_glyphnames( 54 ) := 'S';
    t_glyphnames( 55 ) := 'T';
    t_glyphnames( 56 ) := 'U';
    t_glyphnames( 57 ) := 'V';
    t_glyphnames( 58 ) := 'W';
    t_glyphnames( 59 ) := 'X';
    t_glyphnames( 60 ) := 'Y';
    t_glyphnames( 61 ) := 'Z';
    t_glyphnames( 62 ) := 'bracketleft';
    t_glyphnames( 63 ) := 'backslash';
    t_glyphnames( 64 ) := 'bracketright';
    t_glyphnames( 65 ) := 'asciicircum';
    t_glyphnames( 66 ) := 'underscore';
    t_glyphnames( 67 ) := 'grave';
    t_glyphnames( 68 ) := 'a';
    t_glyphnames( 69 ) := 'b';
    t_glyphnames( 70 ) := 'c';
    t_glyphnames( 71 ) := 'd';
    t_glyphnames( 72 ) := 'e';
    t_glyphnames( 73 ) := 'f';
    t_glyphnames( 74 ) := 'g';
    t_glyphnames( 75 ) := 'h';
    t_glyphnames( 76 ) := 'i';
    t_glyphnames( 77 ) := 'j';
    t_glyphnames( 78 ) := 'k';
    t_glyphnames( 79 ) := 'l';
    t_glyphnames( 80 ) := 'm';
    t_glyphnames( 81 ) := 'n';
    t_glyphnames( 82 ) := 'o';
    t_glyphnames( 83 ) := 'p';
    t_glyphnames( 84 ) := 'q';
    t_glyphnames( 85 ) := 'r';
    t_glyphnames( 86 ) := 's';
    t_glyphnames( 87 ) := 't';
    t_glyphnames( 88 ) := 'u';
    t_glyphnames( 89 ) := 'v';
    t_glyphnames( 90 ) := 'w';
    t_glyphnames( 91 ) := 'x';
    t_glyphnames( 92 ) := 'y';
    t_glyphnames( 93 ) := 'z';
    t_glyphnames( 94 ) := 'braceleft';
    t_glyphnames( 95 ) := 'bar';
    t_glyphnames( 96 ) := 'braceright';
    t_glyphnames( 97 ) := 'asciitilde';
    t_glyphnames( 98 ) := 'Adieresis';
    t_glyphnames( 99 ) := 'Aring';
    t_glyphnames( 100 ) := 'Ccedilla';
    t_glyphnames( 101 ) := 'Eacute';
    t_glyphnames( 102 ) := 'Ntilde';
    t_glyphnames( 103 ) := 'Odieresis';
    t_glyphnames( 104 ) := 'Udieresis';
    t_glyphnames( 105 ) := 'aacute';
    t_glyphnames( 106 ) := 'agrave';
    t_glyphnames( 107 ) := 'acircumflex';
    t_glyphnames( 108 ) := 'adieresis';
    t_glyphnames( 109 ) := 'atilde';
    t_glyphnames( 110 ) := 'aring';
    t_glyphnames( 111 ) := 'ccedilla';
    t_glyphnames( 112 ) := 'eacute';
    t_glyphnames( 113 ) := 'egrave';
    t_glyphnames( 114 ) := 'ecircumflex';
    t_glyphnames( 115 ) := 'edieresis';
    t_glyphnames( 116 ) := 'iacute';
    t_glyphnames( 117 ) := 'igrave';
    t_glyphnames( 118 ) := 'icircumflex';
    t_glyphnames( 119 ) := 'idieresis';
    t_glyphnames( 120 ) := 'ntilde';
    t_glyphnames( 121 ) := 'oacute';
    t_glyphnames( 122 ) := 'ograve';
    t_glyphnames( 123 ) := 'ocircumflex';
    t_glyphnames( 124 ) := 'odieresis';
    t_glyphnames( 125 ) := 'otilde';
    t_glyphnames( 126 ) := 'uacute';
    t_glyphnames( 127 ) := 'ugrave';
    t_glyphnames( 128 ) := 'ucircumflex';
    t_glyphnames( 129 ) := 'udieresis';
    t_glyphnames( 130 ) := 'dagger';
    t_glyphnames( 131 ) := 'degree';
    t_glyphnames( 132 ) := 'cent';
    t_glyphnames( 133 ) := 'sterling';
    t_glyphnames( 134 ) := 'section';
    t_glyphnames( 135 ) := 'bullet';
    t_glyphnames( 136 ) := 'paragraph';
    t_glyphnames( 137 ) := 'germandbls';
    t_glyphnames( 138 ) := 'registered';
    t_glyphnames( 139 ) := 'copyright';
    t_glyphnames( 140 ) := 'trademark';
    t_glyphnames( 141 ) := 'acute';
    t_glyphnames( 142 ) := 'dieresis';
    t_glyphnames( 143 ) := 'notequal';
    t_glyphnames( 144 ) := 'AE';
    t_glyphnames( 145 ) := 'Oslash';
    t_glyphnames( 146 ) := 'infinity';
    t_glyphnames( 147 ) := 'plusminus';
    t_glyphnames( 148 ) := 'lessequal';
    t_glyphnames( 149 ) := 'greaterequal';
    t_glyphnames( 150 ) := 'yen';
    t_glyphnames( 151 ) := 'mu';
    t_glyphnames( 152 ) := 'partialdiff';
    t_glyphnames( 153 ) := 'summation';
    t_glyphnames( 154 ) := 'product';
    t_glyphnames( 155 ) := 'pi';
    t_glyphnames( 156 ) := 'integral';
    t_glyphnames( 157 ) := 'ordfeminine';
    t_glyphnames( 158 ) := 'ordmasculine';
    t_glyphnames( 159 ) := 'Omega';
    t_glyphnames( 160 ) := 'ae';
    t_glyphnames( 161 ) := 'oslash';
    t_glyphnames( 162 ) := 'questiondown';
    t_glyphnames( 163 ) := 'exclamdown';
    t_glyphnames( 164 ) := 'logicalnot';
    t_glyphnames( 165 ) := 'radical';
    t_glyphnames( 166 ) := 'florin';
    t_glyphnames( 167 ) := 'approxequal';
    t_glyphnames( 168 ) := 'Delta';
    t_glyphnames( 169 ) := 'guillemotleft';
    t_glyphnames( 170 ) := 'guillemotright';
    t_glyphnames( 171 ) := 'ellipsis';
    t_glyphnames( 172 ) := 'nonbreakingspace';
    t_glyphnames( 173 ) := 'Agrave';
    t_glyphnames( 174 ) := 'Atilde';
    t_glyphnames( 175 ) := 'Otilde';
    t_glyphnames( 176 ) := 'OE';
    t_glyphnames( 177 ) := 'oe';
    t_glyphnames( 178 ) := 'endash';
    t_glyphnames( 179 ) := 'emdash';
    t_glyphnames( 180 ) := 'quotedblleft';
    t_glyphnames( 181 ) := 'quotedblright';
    t_glyphnames( 182 ) := 'quoteleft';
    t_glyphnames( 183 ) := 'quoteright';
    t_glyphnames( 184 ) := 'divide';
    t_glyphnames( 185 ) := 'lozenge';
    t_glyphnames( 186 ) := 'ydieresis';
    t_glyphnames( 187 ) := 'Ydieresis';
    t_glyphnames( 188 ) := 'fraction';
    t_glyphnames( 189 ) := 'currency';
    t_glyphnames( 190 ) := 'guilsinglleft';
    t_glyphnames( 191 ) := 'guilsinglright';
    t_glyphnames( 192 ) := 'fi';
    t_glyphnames( 193 ) := 'fl';
    t_glyphnames( 194 ) := 'daggerdbl';
    t_glyphnames( 195 ) := 'periodcentered';
    t_glyphnames( 196 ) := 'quotesinglbase';
    t_glyphnames( 197 ) := 'quotedblbase';
    t_glyphnames( 198 ) := 'perthousand';
    t_glyphnames( 199 ) := 'Acircumflex';
    t_glyphnames( 200 ) := 'Ecircumflex';
    t_glyphnames( 201 ) := 'Aacute';
    t_glyphnames( 202 ) := 'Edieresis';
    t_glyphnames( 203 ) := 'Egrave';
    t_glyphnames( 204 ) := 'Iacute';
    t_glyphnames( 205 ) := 'Icircumflex';
    t_glyphnames( 206 ) := 'Idieresis';
    t_glyphnames( 207 ) := 'Igrave';
    t_glyphnames( 208 ) := 'Oacute';
    t_glyphnames( 209 ) := 'Ocircumflex';
    t_glyphnames( 210 ) := 'apple';
    t_glyphnames( 211 ) := 'Ograve';
    t_glyphnames( 212 ) := 'Uacute';
    t_glyphnames( 213 ) := 'Ucircumflex';
    t_glyphnames( 214 ) := 'Ugrave';
    t_glyphnames( 215 ) := 'dotlessi';
    t_glyphnames( 216 ) := 'circumflex';
    t_glyphnames( 217 ) := 'tilde';
    t_glyphnames( 218 ) := 'macron';
    t_glyphnames( 219 ) := 'breve';
    t_glyphnames( 220 ) := 'dotaccent';
    t_glyphnames( 221 ) := 'ring';
    t_glyphnames( 222 ) := 'cedilla';
    t_glyphnames( 223 ) := 'hungarumlaut';
    t_glyphnames( 224 ) := 'ogonek';
    t_glyphnames( 225 ) := 'caron';
    t_glyphnames( 226 ) := 'Lslash';
    t_glyphnames( 227 ) := 'lslash';
    t_glyphnames( 228 ) := 'Scaron';
    t_glyphnames( 229 ) := 'scaron';
    t_glyphnames( 230 ) := 'Zcaron';
    t_glyphnames( 231 ) := 'zcaron';
    t_glyphnames( 232 ) := 'brokenbar';
    t_glyphnames( 233 ) := 'Eth';
    t_glyphnames( 234 ) := 'eth';
    t_glyphnames( 235 ) := 'Yacute';
    t_glyphnames( 236 ) := 'yacute';
    t_glyphnames( 237 ) := 'Thorn';
    t_glyphnames( 238 ) := 'thorn';
    t_glyphnames( 239 ) := 'minus';
    t_glyphnames( 240 ) := 'multiply';
    t_glyphnames( 241 ) := 'onesuperior';
    t_glyphnames( 242 ) := 'twosuperior';
    t_glyphnames( 243 ) := 'threesuperior';
    t_glyphnames( 244 ) := 'onehalf';
    t_glyphnames( 245 ) := 'onequarter';
    t_glyphnames( 246 ) := 'threequarters';
    t_glyphnames( 247 ) := 'franc';
    t_glyphnames( 248 ) := 'Gbreve';
    t_glyphnames( 249 ) := 'gbreve';
    t_glyphnames( 250 ) := 'Idotaccent';
    t_glyphnames( 251 ) := 'Scedilla';
    t_glyphnames( 252 ) := 'scedilla';
    t_glyphnames( 253 ) := 'Cacute';
    t_glyphnames( 254 ) := 'cacute';
    t_glyphnames( 255 ) := 'Ccaron';
    t_glyphnames( 256 ) := 'ccaron';
    t_glyphnames( 257 ) := 'dcroat';
--
    dbms_lob.copy( t_blob, p_font, t_tables( 'post' ).length, 1, t_tables( 'post' ).offset );
    this_font.italic_angle := to_short( dbms_lob.substr( t_blob, 2, 5 ) )
                            + to_short( dbms_lob.substr( t_blob, 2, 7 ) ) / 65536;
    case rawtohex( dbms_lob.substr( t_blob, 4, 1 ) )
      when '00010000'
      then
        for g in 0 .. 257
        loop
          t_glyph2name( g ) := g;
        end loop;
      when '00020000'
      then
        t_offset := blob2num( t_blob, 2, 33 ) * 2 + 35;
        while nvl( blob2num( t_blob, 1, t_offset ), 0 ) > 0
        loop
          t_glyphnames( t_glyphnames.count ) := utl_raw.cast_to_varchar2( dbms_lob.substr( t_blob, blob2num( t_blob, 1, t_offset ), t_offset + 1 ) );
          t_offset := t_offset + blob2num( t_blob, 1, t_offset ) + 1;
        end loop;
        for g in 0 .. blob2num( t_blob, 2, 33 ) - 1
        loop
          t_glyph2name( g ) := blob2num( t_blob, 2, 35 + 2 * g );
        end loop;
      when '00025000'
      then
        for g in 0 .. blob2num( t_blob, 2, 33 ) - 1
        loop
          t_offset := blob2num( t_blob, 1, 35 + g );
          if t_offset > 127
          then
            t_glyph2name( g ) := g - t_offset;
          else
            t_glyph2name( g ) := g + t_offset;
          end if;
        end loop;
      when '00030000'
      then
        t_glyphnames.delete;
      else
        dbms_output.put_line( 'no post ' || dbms_lob.substr( t_blob, 4, 1 ) );
    end case;
--
    dbms_lob.copy( t_blob, p_font, t_tables( 'head' ).length, 1, t_tables( 'head' ).offset );
    if dbms_lob.substr( t_blob, 4, 13 ) = hextoraw( '5F0F3CF5' )  -- magic
    then
      declare
        t_tmp pls_integer := blob2num( t_blob, 2, 45 );
      begin
        if bitand( t_tmp, 1 ) = 1
        then
          this_font.style := 'B';
        end if;
        if bitand( t_tmp, 2 ) = 2
        then
          this_font.style := this_font.style || 'I';
          this_font.flags := this_font.flags + 64;
        end if;
        this_font.style := nvl( this_font.style, 'N' );
        this_font.unit_norm := 1000 / blob2num( t_blob, 2, 19 );
        this_font.bb_xmin := to_short( dbms_lob.substr( t_blob, 2, 37 ), this_font.unit_norm );
        this_font.bb_ymin := to_short( dbms_lob.substr( t_blob, 2, 39 ), this_font.unit_norm );
        this_font.bb_xmax := to_short( dbms_lob.substr( t_blob, 2, 41 ), this_font.unit_norm );
        this_font.bb_ymax := to_short( dbms_lob.substr( t_blob, 2, 43 ), this_font.unit_norm );
        this_font.indexToLocFormat := blob2num( t_blob, 2, 51 ); -- 0 for short offsets, 1 for long
      end;
    end if;
--
    dbms_lob.copy( t_blob, p_font, t_tables( 'hhea' ).length, 1, t_tables( 'hhea' ).offset );
    if dbms_lob.substr( t_blob, 4, 1 ) = hextoraw( '00010000' ) -- version 1.0
    then
      this_font.ascent := to_short( dbms_lob.substr( t_blob, 2, 5 ), this_font.unit_norm );
      this_font.descent := to_short( dbms_lob.substr( t_blob, 2, 7 ), this_font.unit_norm );
      this_font.capheight := this_font.ascent;
      nr_hmetrics := blob2num( t_blob, 2, 35 );
    end if;
--
    dbms_lob.copy( t_blob, p_font, t_tables( 'hmtx' ).length, 1, t_tables( 'hmtx' ).offset );
    for j in 0 .. nr_hmetrics - 1
    loop
      this_font.hmetrics( j ) := blob2num( t_blob, 2, 1 + 4 * j );
    end loop;
--
    dbms_lob.copy( t_blob, p_font, t_tables( 'name' ).length, 1, t_tables( 'name' ).offset );
    if dbms_lob.substr( t_blob, 2, 1 ) = hextoraw( '0000' ) -- format 0
    then
      t_offset := blob2num( t_blob, 2, 5 ) + 1;
      for j in 0 .. blob2num( t_blob, 2, 3 ) - 1
      loop
        if (   dbms_lob.substr( t_blob, 2, 7  + j * 12 ) = hextoraw( '0003' ) -- Windows
           and dbms_lob.substr( t_blob, 2, 11 + j * 12 ) = hextoraw( '0409' ) -- English United States
           )
        then
          case rawtohex( dbms_lob.substr( t_blob, 2, 13 + j * 12 ) )
            when '0001'
            then
              this_font.family := utl_i18n.raw_to_char( dbms_lob.substr( t_blob, blob2num( t_blob, 2, 15 + j * 12 ), t_offset + blob2num( t_blob, 2, 17 + j * 12 ) ), 'AL16UTF16' );
            when '0006'
            then
              this_font.name := utl_i18n.raw_to_char( dbms_lob.substr( t_blob, blob2num( t_blob, 2, 15 + j * 12 ), t_offset + blob2num( t_blob, 2, 17 + j * 12 ) ), 'AL16UTF16' );
            else
              null;
          end case;
        end if;
      end loop;
    end if;
--
    if this_font.italic_angle != 0
    then
      this_font.flags := this_font.flags + 64;
    end if;
    this_font.subtype := 'TrueType';
    this_font.stemv := 50;
    this_font.family := lower( this_font.family );
    this_font.encoding := utl_i18n.map_charset( p_encoding
                                              , utl_i18n.generic_context
                                              , utl_i18n.iana_to_oracle
                                              );
    this_font.encoding := nvl( this_font.encoding, upper( p_encoding ) );
    this_font.charset := sys_context( 'userenv', 'LANGUAGE' );
    this_font.charset := substr( this_font.charset
                               , 1
                               , instr( this_font.charset, '.' )
                               ) || this_font.encoding;
    this_font.cid := upper( p_encoding ) in ( 'CID', 'AL16UTF16', 'UTF', 'UNICODE' );
    this_font.fontname := this_font.name;
    this_font.compress_font := p_compress;
--
    if ( p_embed or this_font.cid ) and t_tables.exists( 'OS/2' )
    then
      dbms_lob.copy( t_blob, p_font, t_tables( 'OS/2' ).length, 1, t_tables( 'OS/2' ).offset );
      if blob2num( t_blob, 2, 9 ) != 2
      then
        this_font.fontfile2 := p_font;
        this_font.ttf_offset := p_offset;
        this_font.name := dbms_random.string( 'u', 6 ) || '+' || this_font.name;
--
        t_blob := dbms_lob.substr( p_font, t_tables( 'loca' ).length, t_tables( 'loca' ).offset );
        declare
          t_size pls_integer := 2 + this_font.indexToLocFormat * 2; -- 0 for short offsets, 1 for long
        begin
          for i in 0 .. this_font.numGlyphs
          loop
            this_font.loca( i ) := blob2num( t_blob, t_size, 1 + i * t_size );
          end loop;
        end;
      end if;
    end if;
--
    if not this_font.cid
    then
      if this_font.flags = 4 -- a symbolic font
      then
        declare
          t_real pls_integer;
        begin
          for t_code in 32 .. 255
          loop
            t_real := this_font.code2glyph.first + t_code - 32; -- assume code 32, space maps to the first code from the font
            if this_font.code2glyph.exists( t_real )
            then
              this_font.first_char := least( nvl( this_font.first_char, 255 ), t_code );
              this_font.last_char := t_code;
              if this_font.hmetrics.exists( this_font.code2glyph( t_real ) )
              then
                this_font.char_width_tab( t_code ) := trunc( this_font.hmetrics( this_font.code2glyph( t_real ) ) * this_font.unit_norm );
              else
                this_font.char_width_tab( t_code ) := trunc( this_font.hmetrics( this_font.hmetrics.last() ) * this_font.unit_norm );
              end if;
            else
              this_font.char_width_tab( t_code ) := trunc( this_font.hmetrics( 0 ) * this_font.unit_norm );
            end if;
          end loop;
        end;
      else
        declare
          t_unicode pls_integer;
          t_prv_diff pls_integer;
          t_utf16_charset varchar2(1000);
          t_winansi_charset varchar2(1000);
          t_glyphname tp_glyphname;
        begin
          t_prv_diff := -1;
          t_utf16_charset := substr( this_font.charset, 1, instr( this_font.charset, '.' ) ) || 'AL16UTF16';
          t_winansi_charset := substr( this_font.charset, 1, instr( this_font.charset, '.' ) ) || 'WE8MSWIN1252';
          for t_code in 32 .. 255
          loop
            t_unicode := utl_raw.cast_to_binary_integer( utl_raw.convert( hextoraw( to_char( t_code, 'fm0x' ) )
                                                                        , t_utf16_charset
                                                                        , this_font.charset
                                                                        )
                                                       );
            t_glyphname := '';
            this_font.char_width_tab( t_code ) := trunc( this_font.hmetrics( this_font.hmetrics.last() ) * this_font.unit_norm );
            if this_font.code2glyph.exists( t_unicode )
            then
              this_font.first_char := least( nvl( this_font.first_char, 255 ), t_code );
              this_font.last_char := t_code;
              if this_font.hmetrics.exists( this_font.code2glyph( t_unicode ) )
              then
                this_font.char_width_tab( t_code ) := trunc( this_font.hmetrics( this_font.code2glyph( t_unicode ) ) * this_font.unit_norm );
              end if;
              if t_glyph2name.exists( this_font.code2glyph( t_unicode ) )
              then
                if t_glyphnames.exists( t_glyph2name( this_font.code2glyph( t_unicode ) ) )
                then
                  t_glyphname := t_glyphnames( t_glyph2name( this_font.code2glyph( t_unicode ) ) );
                end if;
              end if;
            end if;
--
            if (   t_glyphname is not null
               and t_unicode != utl_raw.cast_to_binary_integer( utl_raw.convert( hextoraw( to_char( t_code, 'fm0x' ) )
                                                                               , t_winansi_charset
                                                                               , this_font.charset
                                                                               )
                                                              )
               )
            then
              this_font.diff := this_font.diff || case when t_prv_diff != t_code - 1 then ' ' || t_code end || ' /' || t_glyphname;
              t_prv_diff := t_code;
            end if;
          end loop;
        end;
        if this_font.diff is not null
        then
          this_font.diff := '/Differences [' || this_font.diff || ']';
        end if;
      end if;
    end if;
--
    t_font_ind := g_fonts.count( ) + 1;
    g_fonts( t_font_ind ) := this_font;
/*
--
dbms_output.put_line( this_font.fontname || ' ' || this_font.family || ' ' || this_font.style
|| ' ' || this_font.flags
|| ' ' || this_font.code2glyph.first
|| ' ' || this_font.code2glyph.prior( this_font.code2glyph.last )
|| ' ' || this_font.code2glyph.last
|| ' nr glyphs: ' || this_font.numGlyphs
 ); */
--
    return t_font_ind;
  end;
--
  procedure load_ttf_font
    ( p_font blob
    , p_encoding varchar2 := 'WINDOWS-1252'
    , p_embed boolean := false
    , p_compress boolean := true
    , p_offset number := 1
    )
  is
    t_tmp pls_integer;
  begin
    t_tmp := load_ttf_font( p_font, p_encoding, p_embed, p_compress );
  end;
--
  function load_ttf_font
    ( p_dir varchar2 := 'MY_FONTS'
    , p_filename varchar2 := 'BAUHS93.TTF'
    , p_encoding varchar2 := 'WINDOWS-1252'
    , p_embed boolean := false
    , p_compress boolean := true
    )
  return pls_integer
  is
  begin
    return load_ttf_font( file2blob( p_dir, p_filename ), p_encoding, p_embed, p_compress );
  end;
--
  procedure load_ttf_font
    ( p_dir varchar2 := 'MY_FONTS'
    , p_filename varchar2 := 'BAUHS93.TTF'
    , p_encoding varchar2 := 'WINDOWS-1252'
    , p_embed boolean := false
    , p_compress boolean := true
    )
  is
  begin
    load_ttf_font( file2blob( p_dir, p_filename ), p_encoding, p_embed, p_compress );
  end;
--
  procedure load_ttc_fonts
    ( p_ttc blob
    , p_encoding varchar2 := 'WINDOWS-1252'
    , p_embed boolean := false
    , p_compress boolean := true
    )
  is
    type tp_font_table is record
      ( offset pls_integer
      , length pls_integer
      );
    type tp_tables is table of tp_font_table index by varchar2(4);
    t_tables tp_tables;
    t_tag varchar2(4);
    t_blob blob;
    t_offset pls_integer;
    t_font_ind pls_integer;
  begin
    if utl_raw.cast_to_varchar2( dbms_lob.substr( p_ttc, 4, 1 ) ) != 'ttcf'
    then
      return;
    end if;
    for f in 0 .. blob2num( p_ttc, 4, 9 ) - 1
    loop
      t_font_ind := load_ttf_font( p_ttc, p_encoding, p_embed, p_compress, blob2num( p_ttc, 4, 13 + f * 4 ) + 1 );
    end loop;
  end;
--
  procedure load_ttc_fonts
    ( p_dir varchar2 := 'MY_FONTS'
    , p_filename varchar2 := 'CAMBRIA.TTC'
    , p_encoding varchar2 := 'WINDOWS-1252'
    , p_embed boolean := false
    , p_compress boolean := true
    )
  is
  begin
    load_ttc_fonts( file2blob( p_dir, p_filename ), p_encoding, p_embed, p_compress );
  end;
--
  function rgb( p_hex_rgb varchar2 )
  return varchar2
  is
  begin
    return to_char_round( nvl( to_number( substr( ltrim( p_hex_rgb, '#' )
                                                , 1, 2 )
                                        , 'xx' ) / 255
                              , 0 )
                         , 5 ) || ' '
        || to_char_round( nvl(   to_number( substr( ltrim( p_hex_rgb, '#' )
                                                , 3, 2 )
                                        , 'xx' ) / 255
                              , 0 )
                         , 5 ) || ' '
        || to_char_round( nvl(   to_number( substr( ltrim( p_hex_rgb, '#' )
                                                , 5, 2 )
                                        , 'xx' ) / 255
                              , 0 )
                         , 5 ) || ' ';
  end;
--
  procedure set_color( p_rgb varchar2 := '000000', p_backgr boolean )
  is
  begin
    txt2page( rgb( p_rgb ) || case when p_backgr then 'RG' else 'rg' end );
  end;
--
  procedure set_color( p_rgb varchar2 := '000000' )
  is
  begin
    set_color( p_rgb, false );
  end;
--
  procedure set_color
    ( p_red number := 0
    , p_green number := 0
    , p_blue number := 0
    )
  is
  begin
    if (     p_red between 0 and 255
       and p_blue  between 0 and 255
       and p_green between 0 and 255
       )
    then
      set_color(  to_char( p_red, 'fm0x' )
               || to_char( p_green, 'fm0x' )
               || to_char( p_blue, 'fm0x' )
               , false
               );
    end if;
  end;
--
  procedure set_bk_color( p_rgb varchar2 := 'ffffff' )
  is
  begin
    set_color( p_rgb, true );
  end;
--
  procedure set_bk_color
    ( p_red number := 0
    , p_green number := 0
    , p_blue number := 0
    )
  is
  begin
    if (     p_red between 0 and 255
       and p_blue  between 0 and 255
       and p_green between 0 and 255
       )
    then
      set_color(  to_char( p_red, 'fm0x' )
               || to_char( p_green, 'fm0x' )
               || to_char( p_blue, 'fm0x' )
               , true
               );
    end if;
  end;
--
  procedure horizontal_line
    ( p_x number
    , p_y number
    , p_width number
    , p_line_width number := 0.5
    , p_line_color varchar2 := '000000'
    )
  is
    t_use_color boolean;
  begin
    txt2page( 'q ' || to_char_round( p_line_width, 5 ) || ' w' );
    t_use_color := substr( p_line_color
                         , -6
                         ) != '000000';
    if t_use_color
    then
      set_color( p_line_color );
      set_bk_color( p_line_color );
    else
      txt2page( '0 g' );
    end if;
    txt2page(  to_char_round( p_x, 5 ) || ' '
            || to_char_round( p_y, 5 ) || ' m '
            || to_char_round( p_x + p_width, 5 ) || ' '
            || to_char_round( p_y, 5 ) || ' l b'
            );
    txt2page( 'Q' );
  end;
--
  procedure vertical_line
    ( p_x number
    , p_y number
    , p_height number
    , p_line_width number := 0.5
    , p_line_color varchar2 := '000000'
    )
  is
    t_use_color boolean;
  begin
    txt2page( 'q ' || to_char_round( p_line_width, 5 ) || ' w' );
    t_use_color := substr( p_line_color
                         , -6
                         ) != '000000';
    if t_use_color
    then
      set_color( p_line_color );
      set_bk_color( p_line_color );
    else
      txt2page( '0 g' );
    end if;
    txt2page(  to_char_round( p_x, 5 ) || ' '
            || to_char_round( p_y, 5 ) || ' m '
            || to_char_round( p_x, 5 ) || ' '
            || to_char_round( p_y + p_height, 5 ) || ' l b'
            );
    txt2page( 'Q' );
  end;
--
  procedure rect
    ( p_x number
    , p_y number
    , p_width number
    , p_height number
    , p_line_color varchar2 := null
    , p_fill_color varchar2 := null
    , p_line_width number := 0.5
    )
  is
  begin
    txt2page( 'q' );
    if substr( p_line_color, -6 ) != substr( p_fill_color, -6 )
    then
      txt2page( to_char_round( p_line_width, 5 ) || ' w' );
    end if;
    if substr( p_line_color, -6 ) != '000000'
    then
      set_bk_color( p_line_color );
    else
      txt2page( '0 g' );
    end if;
    if p_fill_color is not null
    then
      set_color( p_fill_color );
    end if;
    txt2page(  to_char_round( p_x, 5 ) || ' ' || to_char_round( p_y, 5 ) || ' '
            || to_char_round( p_width, 5 ) || ' ' || to_char_round( p_height, 5 ) || ' re '
            || case
                 when p_fill_color is null
                 then 'S'
                 else case when p_line_color is null then 'f' else 'b' end
               end
            );
    txt2page( 'Q' );
  end;
--
  function get( p_what pls_integer )
  return number
  is
  begin
    return case p_what
             when c_get_page_width    then g_settings.page_width
             when c_get_page_height   then g_settings.page_height
             when c_get_margin_top    then g_settings.margin_top
             when c_get_margin_right  then g_settings.margin_right
             when c_get_margin_bottom then g_settings.margin_bottom
             when c_get_margin_left   then g_settings.margin_left
             when c_get_x             then g_x
             when c_get_y             then g_y
             when c_get_fontsize      then g_fonts( g_current_font ).fontsize
             when c_get_current_font  then g_current_font
           end;
  end;
--
  function parse_jpg( p_img_blob blob )
  return tp_img
  is
    buf raw(4);
    t_img tp_img;
    t_ind integer;
  begin
    if (  dbms_lob.substr( p_img_blob, 2, 1 ) != hextoraw( 'FFD8' )                                      -- SOI Start of Image
       or dbms_lob.substr( p_img_blob, 2, dbms_lob.getlength( p_img_blob ) - 1 ) != hextoraw( 'FFD9' )   -- EOI End of Image
       )
    then  -- this is not a jpg I can handle
      return null;
    end if;
--
    t_img.pixels := p_img_blob;
    t_img.type := 'jpg';
    if dbms_lob.substr( t_img.pixels, 2, 3 ) in ( hextoraw( 'FFE0' )  -- a APP0 jpg
                                                , hextoraw( 'FFE1' )  -- a APP1 jpg
                                                )
    then
      t_img.color_res := 8;
      t_img.height := 1;
      t_img.width := 1;
--
      t_ind := 3;
      t_ind := t_ind + 2 + blob2num( t_img.pixels, 2, t_ind + 2 );
      loop
        buf := dbms_lob.substr( t_img.pixels, 2, t_ind );
        exit when buf = hextoraw( 'FFDA' );  -- SOS Start of Scan
        exit when buf = hextoraw( 'FFD9' );  -- EOI End Of Image
        exit when substr( rawtohex( buf ), 1, 2 ) != 'FF';
        if rawtohex( buf ) in ( 'FFD0'                                                          -- RSTn
                              , 'FFD1', 'FFD2', 'FFD3', 'FFD4', 'FFD5', 'FFD6', 'FFD7', 'FF01'  -- TEM
                              )
        then
          t_ind := t_ind + 2;
        else
          if buf = hextoraw( 'FFC0' )       -- SOF0 (Start Of Frame 0) marker
          then
            t_img.color_res := blob2num( t_img.pixels, 1, t_ind + 4 );
            t_img.height    := blob2num( t_img.pixels, 2, t_ind + 5 );
            t_img.width     := blob2num( t_img.pixels, 2, t_ind + 7 );
          end if;
          t_ind := t_ind + 2 + blob2num( t_img.pixels, 2, t_ind + 2 );
        end if;
      end loop;
    end if;
--
    return t_img;
  end;
--
  function parse_png( p_img_blob blob )
  return tp_img
  is
    t_img tp_img;
    buf raw(32767);
    len integer;
    ind integer;
    color_type pls_integer;
  begin
    if rawtohex( dbms_lob.substr( p_img_blob, 8, 1 ) ) != '89504E470D0A1A0A'  -- not the right signature
    then
      return null;
    end if;
    dbms_lob.createtemporary( t_img.pixels, true );
    ind := 9;
    loop
      len := blob2num( p_img_blob, 4, ind );  -- length
      exit when len is null or ind > dbms_lob.getlength( p_img_blob );
      case utl_raw.cast_to_varchar2( dbms_lob.substr( p_img_blob, 4, ind + 4 ) )  -- Chunk type
        when 'IHDR'
        then
          t_img.width     := blob2num( p_img_blob, 4, ind + 8 );
          t_img.height    := blob2num( p_img_blob, 4, ind + 12 );
          t_img.color_res := blob2num( p_img_blob, 1, ind + 16 );
          color_type      := blob2num( p_img_blob, 1, ind + 17 );
          t_img.greyscale := color_type in ( 0, 4 );
        when 'PLTE'
        then
          t_img.color_tab := dbms_lob.substr( p_img_blob, len, ind + 8 );
        when 'IDAT'
        then
          dbms_lob.copy( t_img.pixels, p_img_blob, len, dbms_lob.getlength( t_img.pixels ) + 1, ind + 8 );
        when 'IEND'
        then
          exit;
        else
          null;
      end case;
      ind := ind + 4 + 4 + len + 4;  -- Length + Chunk type + Chunk data + CRC
    end loop;
--
    t_img.type := 'png';
    t_img.nr_colors := case color_type
                         when 0 then 1
                         when 2 then 3
                         when 3 then 1
                         when 4 then 2
                         else 4
                       end;
--
    return t_img;
  end;
--
  function lzw_decompress
    ( p_blob blob
    , p_bits pls_integer
    )
  return blob
  is
    powers tp_pls_tab;
--
    g_lzw_ind pls_integer;
    g_lzw_bits pls_integer;
    g_lzw_buffer pls_integer;
    g_lzw_bits_used pls_integer;
--
    type tp_lzw_dict is table of raw(1000) index by pls_integer;
    t_lzw_dict tp_lzw_dict;
    t_clr_code pls_integer;
    t_nxt_code pls_integer;
    t_new_code pls_integer;
    t_old_code pls_integer;
    t_blob blob;
--
    function get_lzw_code
    return pls_integer
    is
      t_rv pls_integer;
    begin
      while g_lzw_bits_used < g_lzw_bits
      loop
        g_lzw_ind := g_lzw_ind + 1;
        g_lzw_buffer := blob2num( p_blob, 1, g_lzw_ind ) * powers( g_lzw_bits_used ) + g_lzw_buffer;
        g_lzw_bits_used := g_lzw_bits_used + 8;
      end loop;
      t_rv := bitand( g_lzw_buffer, powers( g_lzw_bits ) - 1 );
      g_lzw_bits_used := g_lzw_bits_used - g_lzw_bits;
      g_lzw_buffer := trunc( g_lzw_buffer / powers( g_lzw_bits ) );
      return t_rv;
    end;
--
  begin
    for i in 0 .. 30
    loop
      powers( i ) := power( 2, i );
    end loop;
--
    t_clr_code := powers( p_bits - 1 );
    t_nxt_code := t_clr_code + 2;
    for i in 0 .. least( t_clr_code - 1, 255 )
    loop
      t_lzw_dict( i ) := hextoraw( to_char( i, 'fm0X' ) );
    end loop;
    dbms_lob.createtemporary( t_blob, true );
    g_lzw_ind := 0;
    g_lzw_bits := p_bits;
    g_lzw_buffer := 0;
    g_lzw_bits_used := 0;
--
    t_old_code := null;
    t_new_code := get_lzw_code( );
    loop
      case nvl( t_new_code, t_clr_code + 1 )
        when t_clr_code + 1
        then
          exit;
        when t_clr_code
        then
          t_new_code := null;
          g_lzw_bits := p_bits;
          t_nxt_code := t_clr_code + 2;
        else
          if t_new_code = t_nxt_code
          then
            t_lzw_dict( t_nxt_code ) :=
              utl_raw.concat( t_lzw_dict( t_old_code )
                            , utl_raw.substr( t_lzw_dict( t_old_code ), 1, 1 )
                            );
            dbms_lob.append( t_blob, t_lzw_dict( t_nxt_code ) );
            t_nxt_code := t_nxt_code + 1;
          elsif t_new_code > t_nxt_code
          then
            exit;
          else
            dbms_lob.append( t_blob, t_lzw_dict( t_new_code ) );
            if t_old_code is not null
            then
              t_lzw_dict( t_nxt_code ) := utl_raw.concat( t_lzw_dict( t_old_code )
                                                        , utl_raw.substr( t_lzw_dict( t_new_code ), 1, 1 )
                                                        );
              t_nxt_code := t_nxt_code + 1;
            end if;
          end if;
          if     bitand( t_nxt_code, powers( g_lzw_bits ) - 1 ) = 0
             and g_lzw_bits < 12
          then
            g_lzw_bits := g_lzw_bits + 1;
          end if;
      end case;
      t_old_code := t_new_code;
      t_new_code := get_lzw_code( );
    end loop;
    t_lzw_dict.delete;
--
    return t_blob;
  end;
--
  function parse_gif( p_img_blob blob )
  return tp_img
  is
    img tp_img;
    buf raw(4000);
    ind integer;
    t_len pls_integer;
  begin
    if dbms_lob.substr( p_img_blob, 3, 1 ) != utl_raw.cast_to_raw( 'GIF' )
    then
      return null;
    end if;
    ind := 7;
    buf := dbms_lob.substr( p_img_blob, 7, 7 );  --  Logical Screen Descriptor
    ind := ind + 7;
    img.color_res := raw2num( utl_raw.bit_and( utl_raw.substr( buf, 5, 1 ), hextoraw( '70' ) ) ) / 16 + 1;
    img.color_res := 8;
    if raw2num( buf, 5, 1 ) > 127
    then
      t_len := 3 * power( 2, raw2num( utl_raw.bit_and( utl_raw.substr( buf, 5, 1 ), hextoraw( '07' ) ) ) + 1 );
      img.color_tab := dbms_lob.substr( p_img_blob, t_len, ind  ); -- Global Color Table
      ind := ind + t_len;
    end if;
--
    loop
      case dbms_lob.substr( p_img_blob, 1, ind )
        when hextoraw( '3B' ) -- trailer
        then
          exit;
        when hextoraw( '21' ) -- extension
        then
          if dbms_lob.substr( p_img_blob, 1, ind + 1 ) = hextoraw( 'F9' )
          then -- Graphic Control Extension
            if utl_raw.bit_and( dbms_lob.substr( p_img_blob, 1, ind + 3 ), hextoraw( '01' ) ) = hextoraw( '01' )
            then -- Transparent Color Flag set
              img.transparancy_index := blob2num( p_img_blob, 1, ind + 6 );
            end if;
          end if;
          ind := ind + 2; -- skip sentinel + label
          loop
            t_len := blob2num( p_img_blob, 1, ind ); -- Block Size
            exit when t_len = 0;
            ind := ind + 1 + t_len; -- skip Block Size + Data Sub-block
          end loop;
          ind := ind + 1;           -- skip last Block Size
        when hextoraw( '2C' )       -- image
        then
          declare
            img_blob blob;
            min_code_size pls_integer;
            code_size pls_integer;
            flags raw(1);
          begin
            img.width := utl_raw.cast_to_binary_integer( dbms_lob.substr( p_img_blob, 2, ind + 5 )
                                                       , utl_raw.little_endian
                                                       );
            img.height := utl_raw.cast_to_binary_integer( dbms_lob.substr( p_img_blob, 2, ind + 7 )
                                                        , utl_raw.little_endian
                                                        );
            img.greyscale := false;
            ind := ind + 1 + 8;                   -- skip sentinel + img sizes
            flags := dbms_lob.substr( p_img_blob, 1, ind );
            if utl_raw.bit_and( flags, hextoraw( '80' ) ) = hextoraw( '80' )
            then
              t_len := 3 * power( 2, raw2num( utl_raw.bit_and( flags, hextoraw( '07' ) ) ) + 1 );
              img.color_tab := dbms_lob.substr( p_img_blob, t_len, ind + 1 );          -- Local Color Table
            end if;
            ind := ind + 1;                                -- skip image Flags
            min_code_size := blob2num( p_img_blob, 1, ind );
            ind := ind + 1;                      -- skip LZW Minimum Code Size
            dbms_lob.createtemporary( img_blob, true );
            loop
              t_len := blob2num( p_img_blob, 1, ind ); -- Block Size
              exit when t_len = 0;
              dbms_lob.append( img_blob, dbms_lob.substr( p_img_blob, t_len, ind + 1 ) ); -- Data Sub-block
              ind := ind + 1 + t_len;      -- skip Block Size + Data Sub-block
            end loop;
            ind := ind + 1;                            -- skip last Block Size
            img.pixels := lzw_decompress( img_blob, min_code_size + 1 );
--
            if utl_raw.bit_and( flags, hextoraw( '40' ) ) = hextoraw( '40' )
            then                                        --  interlaced
              declare
                pass pls_integer;
                pass_ind tp_pls_tab;
              begin
                dbms_lob.createtemporary( img_blob, true );
                pass_ind( 1 ) := 1;
                pass_ind( 2 ) := trunc( ( img.height - 1 ) / 8 ) + 1;
                pass_ind( 3 ) := pass_ind( 2 ) + trunc( ( img.height + 3 ) / 8 );
                pass_ind( 4 ) := pass_ind( 3 ) + trunc( ( img.height + 1 ) / 4 );
                pass_ind( 2 ) := pass_ind( 2 ) * img.width + 1;
                pass_ind( 3 ) := pass_ind( 3 ) * img.width + 1;
                pass_ind( 4 ) := pass_ind( 4 ) * img.width + 1;
                for i in 0 .. img.height - 1
                loop
                  pass := case mod( i, 8 )
                            when 0 then 1
                            when 4 then 2
                            when 2 then 3
                            when 6 then 3
                            else 4
                          end;
                  dbms_lob.append( img_blob, dbms_lob.substr( img.pixels, img.width, pass_ind( pass ) ) );
                  pass_ind( pass ) := pass_ind( pass ) + img.width;
                end loop;
                img.pixels := img_blob;
              end;
            end if;
--
            dbms_lob.freetemporary( img_blob );
          end;
        else
          exit;
      end case;
    end loop;
--
    img.type := 'gif';
    return img;
  end;
--
  function parse_img
    ( p_blob in blob
    , p_adler32 in varchar2 := null
    , p_type in varchar2 := null
    )
  return tp_img
  is
    t_img tp_img;
  begin
    t_img.type := p_type;
    if t_img.type is null
    then
      if rawtohex( dbms_lob.substr( p_blob, 8, 1 ) ) = '89504E470D0A1A0A'
      then
        t_img.type := 'png';
      elsif dbms_lob.substr( p_blob , 3, 1 ) = utl_raw.cast_to_raw( 'GIF' )
      then
        t_img.type := 'gif';
      else
        t_img.type := 'jpg';
      end if;
    end if;
--
    t_img := case lower( t_img.type )
               when 'gif' then parse_gif( p_blob )
               when 'png' then parse_png( p_blob )
               when 'jpg' then parse_jpg( p_blob )
               else null
             end;
--
    if t_img.type is not null
    then
      t_img.adler32 := coalesce( p_adler32, adler32( p_blob ) );
    end if;
    return t_img;
  end;
--
  procedure put_image
    ( p_img blob
    , p_x number
    , p_y number
    , p_width number := null
    , p_height number := null
    , p_align varchar2 := 'center'
    , p_valign varchar2 := 'top'
    , p_adler32 varchar2 := null
  )
  is
    t_x number;
    t_y number;
    t_img tp_img;
    t_ind pls_integer;
    t_adler32 varchar2(8):=p_adler32;
  begin
    if p_img is null
    then
      return;
    end if;
    if t_adler32 is null then
      t_adler32 := adler32( p_img );
    end if;
    t_ind := g_images.first;
    while t_ind is not null
    loop
      exit when g_images( t_ind ).adler32 = t_adler32;
      t_ind := g_images.next( t_ind );
    end loop;
--
    if t_ind is null
    then
      t_img := parse_img( p_img, t_adler32 );
      if t_img.adler32 is null
      then
        return;
      end if;
      t_ind := g_images.count( ) + 1;
      g_images( t_ind ) := t_img;
    end if;
--
    t_x := case substr( upper( p_align ), 1, 1 )
             when 'L' then p_x -- left
             when 'S' then p_x -- start
             when 'R' then p_x + nvl( p_width, 0 ) - g_images( t_ind ).width -- right
             when 'E' then p_x + nvl( p_width, 0 ) - g_images( t_ind ).width -- end
             else ( p_x + nvl( p_width, 0 ) - g_images( t_ind ).width ) / 2       -- center
           end;
    t_y := case substr( upper( p_valign ), 1, 1 )
             when 'C' then ( p_y - nvl( p_height, 0 ) + g_images( t_ind ).height ) / 2  -- center
             when 'B' then p_y - nvl( p_height, 0 ) + g_images( t_ind ).height -- bottom
             else p_y                                          -- top
           end;
--
    txt2page( 'q ' || to_char_round( least( nvl( p_width, g_images( t_ind ).width ), g_images( t_ind ).width ) )
            || ' 0 0 ' || to_char_round( least( nvl( p_height, g_images( t_ind ).height ), g_images( t_ind ).height ) )
            || ' ' || to_char_round( t_x ) || ' ' || to_char_round( t_y )
            || ' cm /I' || to_char( t_ind ) || ' Do Q'
            );
  end;
--
  procedure put_image
    ( p_dir varchar2
    , p_file_name varchar2
    , p_x number
    , p_y number
    , p_width number := null
    , p_height number := null
    , p_align varchar2 := 'center'
    , p_valign varchar2 := 'top'
    , p_adler32 varchar2 := null
  )
  is
    t_blob blob;
  begin
    t_blob := file2blob( p_dir
                       , p_file_name
                       );
    put_image( t_blob
             , p_x
             , p_y
             , p_width
             , p_height
             , p_align
             , p_valign
             , p_adler32
             );
    dbms_lob.freetemporary( t_blob );
  end;
--
  procedure put_image
    ( p_url varchar2
    , p_x number
    , p_y number
    , p_width number := null
    , p_height number := null
    , p_align varchar2 := 'center'
    , p_valign varchar2 := 'top'
    , p_adler32 varchar2 := null
    )
  is
    t_blob blob;
  begin
    t_blob := httpuritype( p_url ).getblob( );
    put_image( t_blob
             , p_x
             , p_y
             , p_width
             , p_height
             , p_align
             , p_valign
             , p_adler32
             );
    dbms_lob.freetemporary( t_blob );
  end;
--
  procedure set_page_proc( p_src clob )
  is
  begin
    g_page_prcs( g_page_prcs.count ) := p_src;
  end;
--
  procedure cursor2table
    ( p_c integer
    , p_widths tp_col_widths := null
    , p_headers tp_headers := null
    )
  is
    t_col_cnt integer;
$IF DBMS_DB_VERSION.VER_LE_10 $THEN
    t_desc_tab dbms_sql.desc_tab2;
$ELSE
    t_desc_tab dbms_sql.desc_tab3;
$END
    d_tab dbms_sql.date_table;
    n_tab dbms_sql.number_table;
    v_tab dbms_sql.varchar2_table;
    t_bulk_size pls_integer := 200;
    t_r integer;
    t_cur_row pls_integer;
    type tp_integer_tab is table of integer;
    t_chars tp_integer_tab := tp_integer_tab( 1, 8, 9, 96, 112 );
    t_dates tp_integer_tab := tp_integer_tab( 12, 178, 179, 180, 181 , 231 );
    t_numerics tp_integer_tab := tp_integer_tab( 2, 100, 101 );
    t_widths tp_col_widths;
    t_tmp number;
    t_x number;
    t_y number;
    t_start_x number;
    t_lineheight number;
    t_padding number := 2;
    t_num_format varchar2(100) := 'tm9';
    t_date_format varchar2(100) := 'dd.mm.yyyy';
    t_txt varchar2(32767);
    c_rf number := 0.2; -- raise factor of text above cell bottom
--
    procedure show_header
    is
    begin
      if p_headers is not null and p_headers.count > 0
      then
        t_x := t_start_x;
        for c in 1 .. t_col_cnt
        loop
          rect( t_x, t_y, t_widths( c ), t_lineheight );
          if c <= p_headers.count
          then
            put_txt( t_x + t_padding, t_y + c_rf * t_lineheight, p_headers( c ) );
          end if;
          t_x := t_x + t_widths( c );
        end loop;
        t_y := t_y - t_lineheight;
      end if;
    end;
--
  begin
$IF DBMS_DB_VERSION.VER_LE_10 $THEN
    dbms_sql.describe_columns2( p_c, t_col_cnt, t_desc_tab );
$ELSE
    dbms_sql.describe_columns3( p_c, t_col_cnt, t_desc_tab );
$END
    if p_widths is null or p_widths.count < t_col_cnt
    then
      t_tmp := get( c_get_page_width ) - get( c_get_margin_left ) - get( c_get_margin_right );
      t_widths := tp_col_widths();
      t_widths.extend( t_col_cnt );
      for c in 1 .. t_col_cnt
      loop
        t_widths( c ) := round( t_tmp / t_col_cnt, 1 );
      end loop;
    else
      t_widths := p_widths;
    end if;
--
    if get( c_get_current_font ) is null
    then
      set_font( 'helvetica', 12 );
    end if;
--
    for c in 1 .. t_col_cnt
    loop
      case
        when t_desc_tab( c ).col_type member of t_numerics
        then
          dbms_sql.define_array( p_c, c, n_tab, t_bulk_size, 1 );
        when t_desc_tab( c ).col_type member of t_dates
        then
          dbms_sql.define_array( p_c, c, d_tab, t_bulk_size, 1 );
        when t_desc_tab( c ).col_type member of t_chars
        then
          dbms_sql.define_array( p_c, c, v_tab, t_bulk_size, 1 );
        else
          null;
      end case;
    end loop;
--
    t_start_x := get( c_get_margin_left );
    t_lineheight := get( c_get_fontsize ) * 1.2;
    t_y := coalesce( get( c_get_y ) - t_lineheight, get( c_get_page_height ) - get( c_get_margin_top ) ) - t_lineheight;
--
    show_header;
--
    loop
      t_r := dbms_sql.fetch_rows( p_c );
      for i in 0 .. t_r - 1
      loop
        if t_y < get( c_get_margin_bottom )
        then
          new_page;
          t_y := get( c_get_page_height ) - get( c_get_margin_top ) - t_lineheight;
          show_header;
        end if;
        t_x := t_start_x;
        for c in 1 .. t_col_cnt
        loop
          case
            when t_desc_tab( c ).col_type member of t_numerics
            then
              n_tab.delete;
              dbms_sql.column_value( p_c, c, n_tab );
              rect( t_x, t_y, t_widths( c ), t_lineheight );
              t_txt := to_char( n_tab( i + n_tab.first() ), t_num_format );
              if t_txt is not null
              then
                put_txt( t_x + t_widths( c ) - t_padding - str_len( t_txt ), t_y + c_rf * t_lineheight, t_txt );
              end if;
              t_x := t_x + t_widths( c );
            when t_desc_tab( c ).col_type member of t_dates
            then
              d_tab.delete;
              dbms_sql.column_value( p_c, c, d_tab );
              rect( t_x, t_y, t_widths( c ), t_lineheight );
              t_txt := to_char( d_tab( i + d_tab.first() ), t_date_format );
              if t_txt is not null
              then
                put_txt( t_x + t_padding, t_y + c_rf * t_lineheight, t_txt );
              end if;
              t_x := t_x + t_widths( c );
            when t_desc_tab( c ).col_type member of t_chars
            then
              v_tab.delete;
              dbms_sql.column_value( p_c, c, v_tab );
              rect( t_x, t_y, t_widths( c ), t_lineheight );
              t_txt := v_tab( i + v_tab.first() );
              if t_txt is not null
              then
                put_txt( t_x + t_padding, t_y + c_rf * t_lineheight, t_txt );
              end if;
              t_x := t_x + t_widths( c );
            else
              null;
          end case;
        end loop;
        t_y := t_y - t_lineheight;
      end loop;
      exit when t_r != t_bulk_size;
    end loop;
    g_y := t_y;
  end;
--
  procedure query2table
    ( p_query varchar2
    , p_widths tp_col_widths := null
    , p_headers tp_headers := null
    )
  is
    t_cx integer;
    t_dummy integer;
  begin
    t_cx := dbms_sql.open_cursor;
    dbms_sql.parse( t_cx, p_query, dbms_sql.native );
    t_dummy := dbms_sql.execute( t_cx );
    cursor2table( t_cx, p_widths, p_headers );
    dbms_sql.close_cursor( t_cx );
  end;

  PROCEDURE PR_GOTO_PAGE(i_nPage IN NUMBER) IS
  BEGIN
    IF i_nPage<=g_pages.count THEN
      g_page_nr:=i_nPage-1;
    END IF;
  END;

  PROCEDURE PR_GOTO_CURRENT_PAGE IS
  BEGIN
    g_page_nr:=NULL;
  END;

  FUNCTION FK_GET_PAGE
  RETURN NUMBER IS
  BEGIN
    RETURN g_page_nr;
  END;

  PROCEDURE PR_LINE(i_nX1         IN NUMBER,
                    i_nY1         IN NUMBER,
                    i_nX2         IN NUMBER,
                    i_nY2         IN NUMBER,
                    i_vcLineColor IN VARCHAR2 DEFAULT NULL,
                    i_nLineWidth  IN NUMBER DEFAULT 0.5,
                    i_vcStroke    IN VARCHAR2 DEFAULT NULL
                   ) IS
  BEGIN
    txt2page('q ' );
    txt2page(to_char_round(i_nLineWidth, 5 ) || ' w' );
    IF SUBSTR(i_vcLineColor, -6 ) != '000000' THEN
      set_bk_color(i_vcLineColor);
    ELSE
      txt2page( '0 g' );
    END IF;

    txt2page('n ');
    IF i_vcStroke IS NOT NULL THEN
      txt2page(i_vcStroke || ' d ');
    END IF;
    txt2page(to_char_round(i_nX1, 5) || ' ' || to_char_round(i_nY1, 5) || ' m ');
    txt2page(to_char_round(i_nX2, 5) || ' ' || to_char_round(i_nY2, 5) || ' l S Q');
  END;

  PROCEDURE PR_POLYGON(i_lXs         IN tVertices,
                       i_lYs         IN tVertices,
                       i_vcLineColor IN VARCHAR2 DEFAULT NULL,
                       i_vcFillColor IN VARCHAR2 DEFAULT NULL,
                       i_nLineWidth  IN NUMBER DEFAULT 0.5
                      ) IS
    vcBuffer VARCHAR2(32767);
  BEGIN
    IF i_lXs.COUNT>0 AND i_lXs.COUNT=i_lYs.COUNT THEN
      txt2page('q ' );
      IF SUBSTR(i_vcLineColor, -6 ) != SUBSTR(i_vcFillColor, -6 ) THEN
        txt2page( to_char_round(i_nLineWidth, 5 ) || ' w' );
      END IF;
      IF SUBSTR(i_vcLineColor, -6 ) != '000000' THEN
        set_bk_color(i_vcLineColor);
      ELSE
        txt2page( '0 g' );
      END IF;
      IF i_vcFillColor IS NOT NULL THEN
        set_color(i_vcFillColor);
      END IF;
      txt2page(' 2.00000 M ');
      txt2page('n ');

      vcBuffer:=to_char_round(i_lXs(1), 5) || ' ' || to_char_round(i_lYs(1), 5) || ' m ';
      FOR i IN 2..i_lXs.COUNT LOOP
        vcBuffer:=vcBuffer || to_char_round(i_lXs(i), 5) || ' ' || to_char_round(i_lYs(i), 5) || ' l ';
      END LOOP;
      vcBuffer:=vcBuffer || to_char_round(i_lXs(1), 5) || ' ' || to_char_round(i_lYs(1), 5) || ' l ';
      vcBuffer:=vcBuffer || CASE WHEN i_vcFillColor IS NULL THEN
                               'S'
                            ELSE CASE WHEN i_vcLineColor IS NULL THEN
                                   'f'
                                 ELSE
                                   'b'
                                 END
                            END;

      txt2page( vcBuffer || ' Q' );
    END IF;
  END;

  PROCEDURE PR_PATH(i_lPath       IN tPath,
                    i_vcLineColor IN VARCHAR2 DEFAULT NULL,
                    i_vcFillColor IN VARCHAR2 DEFAULT NULL,
                    i_nLineWidth  IN NUMBER DEFAULT 0.5
                   ) IS
    vcBuffer VARCHAR2(32767);
  BEGIN
    txt2page('q ' );

    IF SUBSTR(i_vcLineColor, -6) != SUBSTR(i_vcFillColor, -6) THEN
      txt2page(to_char_round(i_nLineWidth, 5) || ' w' );
    END IF;
    IF SUBSTR(i_vcLineColor, -6) != '000000' THEN
      set_bk_color(i_vcLineColor);
    ELSE
      txt2page('0 g');
    END IF;
    IF i_vcFillColor IS NOT NULL THEN
      set_color(i_vcFillColor);
    END IF;

    txt2page('n ');
    FOR i IN 1..i_lPath.COUNT LOOP
      IF i_lPath(i).nType=PATH_MOVE_TO THEN
        vcBuffer:=vcBuffer|| to_char_round( i_lPath(i).nVal1, 5 ) || ' ' ||
                             to_char_round( i_lPath(i).nVal2, 5 ) || ' m ';
      ELSIF i_lPath(i).nType=PATH_LINE_TO THEN
        vcBuffer:=vcBuffer || to_char_round( i_lPath(i).nVal1, 5 ) || ' ' ||
                              to_char_round( i_lPath(i).nVal2, 5 ) || ' l ';
      ELSIF i_lPath(i).nType=PATH_CURVE_TO THEN
        vcBuffer:=vcBuffer || to_char_round( i_lPath(i).nVal1,5)  || ' ' ||
                              to_char_round( i_lPath(i).nVal2,5)  || ' ' ||
                              to_char_round( i_lPath(i).nVal3,5)  || ' ' ||
                              to_char_round( i_lPath(i).nVal4,5)  || ' ' ||
                              to_char_round( i_lPath(i).nVal5,5)  || ' ' ||
                              to_char_round( i_lPath(i).nVal6,5)  || ' c ';
      ELSIF i_lPath(i).nType=PATH_CLOSE THEN
        vcBuffer:=vcBuffer || CASE WHEN i_vcFillColor IS NULL THEN
                                'S'
                               ELSE CASE WHEN i_vcLineColor IS NULL THEN
                                      'f'
                                    ELSE
                                      'b'
                                    END
                               END;
      END IF;
    END LOOP;

    txt2page( vcBuffer || ' Q' );
  END;

$IF not DBMS_DB_VERSION.VER_LE_10 $THEN
--
  procedure refcursor2table
    ( p_rc sys_refcursor
    , p_widths tp_col_widths := null
    , p_headers tp_headers := null
    )
  is
    t_cx integer;
    t_rc sys_refcursor;
  begin
    t_rc := p_rc;
    t_cx := dbms_sql.to_cursor_number( t_rc );
    cursor2table( t_cx, p_widths, p_headers );
    dbms_sql.close_cursor( t_cx );
  end;
$END

begin
  for i IN 0..255 LOOP
    lHex(TO_CHAR(i, 'FM0X')):=i;
  end loop;
end;

/
--------------------------------------------------------
--  DDL for Package Body DIALOG_DEMO
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."DIALOG_DEMO" as
-- use $0$, $1$ ... for client side value substitutions
function prepare_dialog_url (
    p_url in varchar2 )
    return varchar2
is
begin
    return regexp_substr(
           apex_util.prepare_url( p_url ), 'f\?p=[^'']*');
end prepare_dialog_url;
end dialog_demo;

/
--------------------------------------------------------
--  DDL for Package Body FUNDAUC_PKG
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."FUNDAUC_PKG" 
as
    procedure setSede(sede varchar2) is
    begin
        dbms_session.set_context('fundauc_ctx','sede',sede);
    end;

    procedure setProgAcad(prog number) is
    begin
        dbms_session.set_context('fundauc_ctx','prog',prog);
    end;
end fundauc_pkg;

/
--------------------------------------------------------
--  DDL for Package Body GLOBAL
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."GLOBAL" AS

    FUNCTION getval (
        pvar VARCHAR2
    ) RETURN VARCHAR2 AS
        l_val VARCHAR2(255);
    BEGIN
        SELECT
            value
        INTO l_val
        FROM
            global_value
        where upper(var) = upper(pvar);

        RETURN l_val;
    EXCEPTION
        WHEN no_data_found THEN
            raise_application_error(-20000, 'No Existe la variable ' || pvar);
    END;

    PROCEDURE setval (
        pvar   IN     VARCHAR2,
        pval   IN     VARCHAR2
    ) AS
        PRAGMA autonomous_transaction;
        l_val VARCHAR2(255); 
    BEGIN
        SELECT
            value
        INTO l_val
        FROM
            global_value
        WHERE
            upper(var) = upper(pvar);

        UPDATE global_value
        SET
            value = pval
        WHERE
            upper(var) = upper(pvar);

        COMMIT;
    EXCEPTION
        WHEN no_data_found THEN
            INSERT INTO global_value VALUES (
                coalesce(sys_context('APEX$SESSION', 'app_user'), regexp_substr(sys_context('userenv', 'client_identifier'), '^[^:]*'
                ), sys_context('userenv', 'session_user')),
                pvar,
                pval
            );
            commit;

    END;

END;

/
--------------------------------------------------------
--  DDL for Package Body PRETIUS_APEX_NESTED_REPORTS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."PRETIUS_APEX_NESTED_REPORTS" is

  ------------------------
  function printAttributes(
    p_dynamic_action_render_result in apex_plugin.t_dynamic_action_render_result
  ) return clob is
    
  begin

    apex_json.initialize_clob_output;

    apex_json.open_object;
    apex_json.write( 'type', 'apex_plugin.t_dynamic_action_render_result' );

    apex_json.write( 'javascript_function'  , p_dynamic_action_render_result.javascript_function  );
    apex_json.write( 'ajax_identifier'      , p_dynamic_action_render_result.ajax_identifier  );
    apex_json.write( 'attribute_01'         , p_dynamic_action_render_result.attribute_01 );
    apex_json.write( 'attribute_02'         , p_dynamic_action_render_result.attribute_02 );
    apex_json.write( 'attribute_03'         , p_dynamic_action_render_result.attribute_03 );
    apex_json.write( 'attribute_04'         , p_dynamic_action_render_result.attribute_04 );
    apex_json.write( 'attribute_05'         , p_dynamic_action_render_result.attribute_05 );
    apex_json.write( 'attribute_06'         , p_dynamic_action_render_result.attribute_06 );
    apex_json.write( 'attribute_07'         , p_dynamic_action_render_result.attribute_07 );
    apex_json.write( 'attribute_08'         , p_dynamic_action_render_result.attribute_08 );
    apex_json.write( 'attribute_09'         , p_dynamic_action_render_result.attribute_09 );
    apex_json.write( 'attribute_10'         , p_dynamic_action_render_result.attribute_10 );
    apex_json.write( 'attribute_11'         , p_dynamic_action_render_result.attribute_11 );
    apex_json.write( 'attribute_12'         , p_dynamic_action_render_result.attribute_12 );
    apex_json.write( 'attribute_13'         , p_dynamic_action_render_result.attribute_13 );
    apex_json.write( 'attribute_14'         , p_dynamic_action_render_result.attribute_14 );
    apex_json.write( 'attribute_15'         , p_dynamic_action_render_result.attribute_15 );

    apex_json.close_object;

    return apex_json.get_clob_output;

  end printAttributes;


  ------------------------
  function printAttributes(
    p_plugin in apex_plugin.t_plugin
  ) return clob is

  begin

    apex_json.initialize_clob_output;

    apex_json.open_object;
    apex_json.write( 'type', 'apex_plugin.t_plugin' );

    apex_json.write( 'name'        , p_plugin.name         );
    apex_json.write( 'file_prefix' , p_plugin.file_prefix  );
    apex_json.write( 'attribute_01', p_plugin.attribute_01 );
    apex_json.write( 'attribute_02', p_plugin.attribute_02 );
    apex_json.write( 'attribute_03', p_plugin.attribute_03 );
    apex_json.write( 'attribute_04', p_plugin.attribute_04 );
    apex_json.write( 'attribute_05', p_plugin.attribute_05 );
    apex_json.write( 'attribute_06', p_plugin.attribute_06 );
    apex_json.write( 'attribute_07', p_plugin.attribute_07 );
    apex_json.write( 'attribute_08', p_plugin.attribute_08 );
    apex_json.write( 'attribute_09', p_plugin.attribute_09 );
    apex_json.write( 'attribute_10', p_plugin.attribute_10 );
    apex_json.write( 'attribute_11', p_plugin.attribute_11 );
    apex_json.write( 'attribute_12', p_plugin.attribute_12 );
    apex_json.write( 'attribute_13', p_plugin.attribute_13 );
    apex_json.write( 'attribute_14', p_plugin.attribute_14 );
    apex_json.write( 'attribute_15', p_plugin.attribute_15 );

    apex_json.close_object;

    return apex_json.get_clob_output;

  end printAttributes;

  ------------------------
  function printAttributes(
    p_dynamic_action in apex_plugin.t_dynamic_action
  ) return clob is

  begin

    apex_json.initialize_clob_output;

    apex_json.open_object;
    apex_json.write( 'type', 'apex_plugin.t_dynamic_action' );

    apex_json.write( 'id'          , p_dynamic_action.id          , false );
    apex_json.write( 'action'      , p_dynamic_action.action      , false );
    apex_json.write( 'attribute_01', p_dynamic_action.attribute_01, true );
    apex_json.write( 'attribute_02', p_dynamic_action.attribute_02, true );
    apex_json.write( 'attribute_03', p_dynamic_action.attribute_03, true );
    apex_json.write( 'attribute_04', p_dynamic_action.attribute_04, true );
    apex_json.write( 'attribute_05', p_dynamic_action.attribute_05, true );
    apex_json.write( 'attribute_06', p_dynamic_action.attribute_06, true );
    apex_json.write( 'attribute_07', p_dynamic_action.attribute_07, true );
    apex_json.write( 'attribute_08', p_dynamic_action.attribute_08, true );
    apex_json.write( 'attribute_09', p_dynamic_action.attribute_09, true );
    apex_json.write( 'attribute_10', p_dynamic_action.attribute_10, true );
    apex_json.write( 'attribute_11', p_dynamic_action.attribute_11, true );
    apex_json.write( 'attribute_12', p_dynamic_action.attribute_12, true );
    apex_json.write( 'attribute_13', p_dynamic_action.attribute_13, true );
    apex_json.write( 'attribute_14', p_dynamic_action.attribute_14, true );
    apex_json.write( 'attribute_15', p_dynamic_action.attribute_15, true );

    apex_json.close_object;

    return apex_json.get_clob_output;

  end printAttributes;

  --------------------------------
  function getColumnNamesFromQuery(
    p_string in varchar2
  ) return clob is
    v_count   number;
    v_pattern varchar2(50) := '#.+?#';

  begin
    apex_json.initialize_clob_output;

    v_count := regexp_count(p_string, v_pattern, 1, 'm');

    apex_json.open_object;
    apex_json.open_array('queryColumns');

    for i in 1..v_count loop
      apex_json.write( trim(both '#' from regexp_substr(p_string, v_pattern, 1, i, 'm') ) );
    end loop;  

    apex_json.close_array;
    apex_json.close_object;

    return apex_json.get_clob_output;
  end;

  -------------------------
  function getBindVariables(
    p_string in varchar2
  ) return clob is
    l_names DBMS_SQL.VARCHAR2_TABLE;
  begin
    l_names := WWV_FLOW_UTILITIES.GET_BINDS( p_string );

    apex_json.initialize_clob_output;

    apex_json.open_object;
    apex_json.open_array('queryItems');

    for i in 1..l_names.count loop
      apex_json.write( trim(both ':' from  l_names(i) ) );
    end loop;  

    apex_json.close_array;
    apex_json.close_object;

    return apex_json.get_clob_output;

  end getBindVariables;

  -------------------------------
  function getPluginAppAttributes(
    p_plugin in apex_plugin.t_plugin
  ) return varchar2 is
    attr_app_expand_time   number  := NVL(p_plugin.attribute_01, 200);
    attr_app_collapse_time number  := NVL(p_plugin.attribute_02, 400);
  begin
    apex_json.initialize_clob_output;

    apex_json.open_object;
    apex_json.open_object('plugin');
    apex_json.write('animationTime',      attr_app_expand_time   );
    apex_json.write('closeOtherDuration', attr_app_collapse_time );
    apex_json.close_object;
    apex_json.close_object;

    return apex_json.get_clob_output;

  end getPluginAppAttributes;

  ----------------------------
  function pretius_row_details (
    p_dynamic_action in apex_plugin.t_dynamic_action,
    p_plugin         in apex_plugin.t_plugin 
  ) return apex_plugin.t_dynamic_action_render_result
  is
    l_result apex_plugin.t_dynamic_action_render_result;

    l_attr_nestedQuery      varchar2(32767) := p_dynamic_action.attribute_01;
    l_attr_dc_settings      varchar2(100)   := p_dynamic_action.attribute_02;

    l_attr_mode             varchar2(100)   := p_dynamic_action.attribute_03;
    l_attr_customTemplate   varchar2(32767) := p_dynamic_action.attribute_04;
    l_attr_customCallback   varchar2(32767) := p_dynamic_action.attribute_05;
    l_attr_bgColor          varchar2(20)    := NVL( p_dynamic_action.attribute_06, '#EBEBEB' );
    l_attr_setMaxHeight     number          := p_dynamic_action.attribute_07;
    l_attr_borderColor      varchar2(20)    := NVL( p_dynamic_action.attribute_08, '#c5c5c5' );
    l_attr_highlightColor   varchar2(20)    := NVL( p_dynamic_action.attribute_09, '#F2F2F2' );
    l_attr_cc_settings      varchar2(100)   := p_dynamic_action.attribute_10;
    l_attr_noDataFound      varchar2(32767) := p_dynamic_action.attribute_11;
    l_attr_spinnerOptions   varchar2(100)   := NVL( p_dynamic_action.attribute_12, 'ATR' );
    l_attr_defaultTemplate  varchar2(4000)  := NVL(p_dynamic_action.attribute_13,  '#DEFAULT_TEMPLATE#');
    l_attr_dt_settings      varchar2(100)   := p_dynamic_action.attribute_14;
    /*
    p_dynamic_action.attribute_12;
    p_dynamic_action.attribute_13;
    p_dynamic_action.attribute_14;
    p_dynamic_action.attribute_15;  
    */
    attr_app_embedMustache boolean := CASE WHEN p_plugin.attribute_03 = 'Y' then true else false end;

  begin
    l_result.ajax_identifier     := wwv_flow_plugin.get_ajax_identifier;
    l_result.javascript_function := '
      function(){
        pretiusNestedReport(this, '||getColumnNamesFromQuery( l_attr_nestedQuery )||', '||getBindVariables( l_attr_nestedQuery )||', true, '||getPluginAppAttributes( p_plugin )||');
      }
    ';
    --l_result.attribute_01        := p_dynamic_action.attribute_01; --tajne, bo to zapytaie SQL, ktore mogloby byc dostepne przez this.options
    l_result.attribute_02        := l_attr_dc_settings;
    l_result.attribute_03        := l_attr_mode;
    l_result.attribute_04        := l_attr_customTemplate;
    l_result.attribute_05        := l_attr_customCallback;
    l_result.attribute_06        := l_attr_bgColor;
    l_result.attribute_07        := l_attr_setMaxHeight;
    l_result.attribute_08        := l_attr_borderColor;
    l_result.attribute_09        := l_attr_highlightColor;
    l_result.attribute_10        := l_attr_cc_settings;
    l_result.attribute_11        := l_attr_noDataFound;
    l_result.attribute_12        := l_attr_spinnerOptions;
    l_result.attribute_13        := l_attr_defaultTemplate;
    l_result.attribute_14        := l_attr_dt_settings;
    --l_result.attribute_15        := p_dynamic_action.attribute_15;

    --add mustache library
    if attr_app_embedMustache then

      apex_javascript.add_library(
        p_name => 'mustache', 
        p_directory => p_plugin.file_prefix, 
        p_version => null 
      );

    end if;

    if apex_application.G_DEBUG then

      APEX_PLUGIN_UTIL.DEBUG_DYNAMIC_ACTION (
        p_plugin         => p_plugin,
        p_dynamic_action => p_dynamic_action
      );

      apex_javascript.add_onload_code ('
        apex.debug.info("p_dynamic_action", '||printAttributes( p_dynamic_action )||');
        apex.debug.info("p_plugin",         '||printAttributes( p_plugin )||');
        apex.debug.info("l_result",         '||printAttributes( l_result )||');
      ');

    end if;

    return l_result;

  end pretius_row_details;

  --------------------
  function clean_query( 
    p_query in varchar2 
  ) return varchar2 is
    l_query varchar2(32767) := p_query;
  begin
    loop
      if substr(l_query,-1) in (chr(10),chr(13),';',' ','/') then
        l_query := substr(l_query,1,length(l_query)-1);
      else
        exit;
      end if;
    end loop;

    return l_query;

  end clean_query;

  -----------------------
  function is_valid_query( 
    p_query in varchar2 
  ) return varchar2 is
    l_source_query  varchar2(32767) := p_query;
    l_source_queryv varchar2(32767);
    l_report_cursor integer;
  begin
    if l_source_query is not null then
      if 
        substr(upper(ltrim(l_source_query)),1,6) != 'SELECT'
        and substr(upper(ltrim(l_source_query)),1,4) != 'WITH' 
      then
        return 'Query must begin with SELECT or WITH';
      end if;

      l_source_query := clean_query( l_source_query );
      l_source_queryv := sys.dbms_assert.noop( str => l_source_query );

      begin
        l_report_cursor := sys.dbms_sql.open_cursor;
        sys.dbms_sql.parse( l_report_cursor, l_source_queryv, SYS.DBMS_SQL.NATIVE );
        sys.dbms_sql.close_cursor(l_report_cursor);
      exception 
        when others then
          if sys.dbms_sql.is_open( l_report_cursor ) then
            sys.dbms_sql.close_cursor( l_report_cursor );
          end if;
          return sqlerrm;--||': '||chr(10)||chr(10)||l_source_query;
      end;
    end if;

    return null;
  exception
    when others then
      return SQLERRM;--||':'||chr(10)||chr(10)||p_query;
  end is_valid_query;

  ----------------------------
  function getColumnTypeString(
    p_col_type in number
  ) return varchar2 is 
    l_col_type varchar2(50);
  begin
    if p_col_type = 1 then
      l_col_type := 'VARCHAR2';

    elsif p_col_type = 2 then
      l_col_type := 'NUMBER';

    elsif p_col_type = 12 then
      l_col_type := 'DATE';

    elsif p_col_type in (180,181,231) then
      l_col_type := 'TIMESTAMP';

      if p_col_type = 231 then
          l_col_type := 'TIMESTAMP_LTZ';
      end if;

    elsif p_col_type = 112 then
      l_col_type := 'CLOB';

    elsif p_col_type = 113 then

      l_col_type := 'BLOB';

    elsif p_col_type = 96 then
      l_col_type := 'CHAR';

    else
        l_col_type := 'OTHER';
    end if;

    return l_col_type;

  end getColumnTypeString;

  ---------------------------------
  function pretius_row_details_ajax(
    p_dynamic_action in apex_plugin.t_dynamic_action,
    p_plugin         in apex_plugin.t_plugin 
  ) return apex_plugin.t_dynamic_action_ajax_result
  is
    l_status              number;
    l_desc_col_no         number          := 0;

    l_ajax_column_name    varchar2(4000);
    l_ajax_column_values  varchar2(4000);

    l_sql                 varchar2(32767);
    l_delimeter           varchar2(1)     := ':';
    l_parseResult         varchar2(4000);

    l_result              apex_plugin.t_dynamic_action_ajax_result;

    l_columnNames         apex_application_global.vc_arr2;
    l_columnValues        apex_application_global.vc_arr2;

    l_sys_cursor          sys_refcursor;

    l_cursor              pls_integer;

    l_desc_col_info       sys.dbms_sql.desc_tab2;

    l_apex_items_names    DBMS_SQL.VARCHAR2_TABLE;
  begin

    l_ajax_column_name    := apex_application.g_x01;
    l_ajax_column_values  := apex_application.g_x02;

    l_sql                 := p_dynamic_action.attribute_01;
    l_apex_items_names    := WWV_FLOW_UTILITIES.GET_BINDS( l_sql );

    l_columnNames         := apex_util.string_to_table( l_ajax_column_name  , l_delimeter );
    l_columnValues        := apex_util.string_to_table( l_ajax_column_values, l_delimeter );

    if l_columnNames.count <> l_columnValues.count then
      apex_json.open_object;
      apex_json.write('addInfo', 'The number of column names must be equal to the number of column values.</br>Check whether the query columns exist in parent report.');
      apex_json.write('error', 'Column names = "'||l_ajax_column_name||'"'||chr(10)||'Column values = "'||l_ajax_column_values||'"');
      apex_json.close_object;
      return null;      
    end if;

    --replacing space within column name is required to work with column aliases
    for i in 1..l_columnNames.count loop
      l_sql := replace( l_sql, chr(39)||'#'||l_columnNames(i)||'#'||chr(39) , ':' || replace(l_columnNames(i), ' ', '') );  
      l_sql := replace( l_sql, '#'||l_columnNames(i)||'#'                   , ':' || replace(l_columnNames(i), ' ', '') );  
    end loop;

    l_parseResult := is_valid_query( l_sql );

    if l_parseResult is not null then
      apex_json.open_object;
      apex_json.write('addInfo', 'Nested report SQL query is not valid');
      apex_json.write('error', l_parseResult);
      --apex_json.write('query', l_sql);
      apex_json.close_object;
      return null;
    end if;

    -- open l_cursor;
    l_cursor := dbms_sql.open_cursor;
    dbms_sql.parse (l_cursor, l_sql, dbms_sql.native);

    -- bind items
    begin

      for i in 1..l_apex_items_names.count loop
        dbms_sql.bind_variable (l_cursor, l_apex_items_names(i), v( trim(both ':' from l_apex_items_names(i)) ) );
      end loop;

    exception
      when others then
        apex_json.open_object;
        apex_json.write('addInfo', 'While binding APEX items error occured');
        apex_json.write('error', SQLERRM);
        apex_json.close_object;
        return null;      
    end;

    --bind all the values
    --replacing space within column name is required to work with column aliases
    begin
      for i in 1 .. l_columnNames.count loop
        dbms_sql.bind_variable (l_cursor, replace(l_columnNames(i), ' ', ''), l_columnValues(i));
      end loop;
    exception
      when others then
        apex_json.open_object;
        apex_json.write('addInfo', 'While binding query variables error occured');
        apex_json.write('error', SQLERRM);
        apex_json.close_object;
        return null;      
    end;

    -- describe columns
    sys.dbms_sql.describe_columns2( l_cursor, l_desc_col_no , l_desc_col_info);

    begin
      l_status := dbms_sql.execute(l_cursor);
    exception
      when others then
        apex_json.open_object;
        apex_json.write('addInfo', 'While executing query error occured ');
        apex_json.write('error', SQLERRM);
        apex_json.close_object;
        return null;      
    end;

    l_sys_cursor := dbms_sql.to_refcursor(l_cursor);  

    --apex_json.initialize_clob_output;

    apex_json.open_object;
    apex_json.write( 'data', l_sys_cursor );
    apex_json.open_array('headers');

    for i in 1..l_desc_col_no loop
      apex_json.open_object;
      apex_json.write('COLUMN_NAME', l_desc_col_info(i).col_name);
      apex_json.write('COLUMN_TYPE', getColumnTypeString( l_desc_col_info(i).col_type ) );
      apex_json.close_object;
    end loop;

    apex_json.close_array;

    apex_json.write( 'x01', l_ajax_column_name, true );
    apex_json.write( 'x02', l_ajax_column_values, true );

    apex_json.close_object;

    --htp.p( apex_json.get_clob_output );

    return l_result;
  exception
    when others then
      apex_json.open_object;
      apex_json.write('addInfo', 'Unknown ajax error');
      apex_json.write('error', SQLERRM);
      apex_json.close_object;
      htp.p( apex_json.get_clob_output );
      return l_result;
  end pretius_row_details_ajax;

end "PRETIUS_APEX_NESTED_REPORTS";

/
--------------------------------------------------------
--  DDL for Package Body TAPI_CALENDARIOS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."TAPI_CALENDARIOS" IS

   /**
   * TAPI_CALENDARIOS
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: 24-OCT-2019 11:06
   * Created By: FUNDAUC
   */


   --GLOBAL_PRIVATE_CURSORS
   --By PK
   CURSOR calendarios_cur (
                       p_id_calendario IN calendarios.id_calendario%TYPE
                       )
   IS
      SELECT
            id_calendario,
            descripcion,
            activo,
            tipo_cal,
            tapi_calendarios.hash(id_calendario),
            ROWID
      FROM calendarios
      WHERE
           id_calendario = calendarios_cur.p_id_calendario
      FOR UPDATE;

    --By Rowid
    CURSOR calendarios_rowid_cur (p_rowid IN VARCHAR2)
    IS
      SELECT
             id_calendario,
             descripcion,
             activo,
             tipo_cal,
             tapi_calendarios.hash(id_calendario),
             ROWID
      FROM calendarios
      WHERE ROWID = p_rowid
      FOR UPDATE;


    FUNCTION hash (
                  p_id_calendario IN calendarios.id_calendario%TYPE
                  )
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format VARCHAR2(64);
   BEGIN


     --Get actual NLS_DATE_FORMAT
     SELECT   VALUE
       INTO   l_date_format
       FROM   v$nls_parameters
      WHERE   parameter = 'NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            id_calendario||
            descripcion||
            activo||
            tipo_cal
      INTO l_string
      FROM calendarios
      WHERE
           id_calendario = hash.p_id_calendario
           ;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash;

    FUNCTION hash_rowid (p_rowid IN varchar2)
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format varchar2(64);
   BEGIN

      --Get actual NLS_DATE_FORMAT
      SELECT VALUE INTO l_date_format  FROM v$nls_parameters WHERE parameter ='NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            id_calendario||
            descripcion||
            activo||
            tipo_cal
      INTO l_string
      FROM calendarios
      WHERE  ROWID = hash_rowid.p_rowid;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash_rowid;

   FUNCTION rt (
               p_id_calendario IN calendarios.id_calendario%TYPE
               )
      RETURN calendarios_rt RESULT_CACHE
   IS
      l_calendarios_rec calendarios_rt;
   BEGIN

      SELECT a.*,
             tapi_calendarios.hash(id_calendario),
             rowid
      INTO l_calendarios_rec
      FROM calendarios a
      WHERE
           id_calendario = rt.p_id_calendario
           ;


      RETURN l_calendarios_rec;

   END rt;

   FUNCTION rt_for_update (
                          p_id_calendario IN calendarios.id_calendario%TYPE
                          )
      RETURN calendarios_rt RESULT_CACHE
   IS
      l_calendarios_rec calendarios_rt;
   BEGIN


      SELECT a.*,
             tapi_calendarios.hash(id_calendario),
             rowid
      INTO l_calendarios_rec
      FROM calendarios a
      WHERE
           id_calendario = rt_for_update.p_id_calendario
      FOR UPDATE;


      RETURN l_calendarios_rec;

   END rt_for_update;

    FUNCTION tt (
                p_id_calendario IN calendarios.id_calendario%TYPE DEFAULT NULL
                )
       RETURN calendarios_tt
       PIPELINED
    IS
       l_calendarios_rec   calendarios_rt;
    BEGIN

       FOR c1 IN (SELECT   a.*, ROWID
                    FROM   calendarios a
                   WHERE
                        id_calendario = NVL(tt.p_id_calendario,id_calendario)
                        )
       LOOP
              l_calendarios_rec.id_calendario := c1.id_calendario;
              l_calendarios_rec.descripcion := c1.descripcion;
              l_calendarios_rec.activo := c1.activo;
              l_calendarios_rec.tipo_cal := c1.tipo_cal;
              l_calendarios_rec.hash := tapi_calendarios.hash( c1.id_calendario);
              l_calendarios_rec.row_id := c1.ROWID;
              PIPE ROW (l_calendarios_rec);
       END LOOP;

       RETURN;

    END tt;


    PROCEDURE ins (p_calendarios_rec IN OUT calendarios_rt)
    IS
        l_rowtype     calendarios%ROWTYPE;

    BEGIN


        l_rowtype.id_calendario := ins.p_calendarios_rec.id_calendario;
        l_rowtype.descripcion := ins.p_calendarios_rec.descripcion;
        l_rowtype.activo := ins.p_calendarios_rec.activo;
        l_rowtype.tipo_cal := ins.p_calendarios_rec.tipo_cal;

       INSERT INTO calendarios
          VALUES   l_rowtype
       RETURNING
                   id_calendario ,
                   descripcion ,
                   activo ,
                   tipo_cal 
            INTO   l_rowtype;

         ins.p_calendarios_rec.id_calendario := l_rowtype.id_calendario;
         ins.p_calendarios_rec.descripcion := l_rowtype.descripcion;
         ins.p_calendarios_rec.activo := l_rowtype.activo;
         ins.p_calendarios_rec.tipo_cal := l_rowtype.tipo_cal;



    END ins;

    PROCEDURE upd (
                  p_calendarios_rec         IN calendarios_rt,
                  p_ignore_nulls         IN boolean := FALSE
                  )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   calendarios
             SET id_calendario = NVL(p_calendarios_rec.id_calendario,id_calendario),
                descripcion = NVL(p_calendarios_rec.descripcion,descripcion),
                activo = NVL(p_calendarios_rec.activo,activo),
                tipo_cal = NVL(p_calendarios_rec.tipo_cal,tipo_cal)
           WHERE
                id_calendario = upd.p_calendarios_rec.id_calendario
                ;
       ELSE
          UPDATE   calendarios
             SET id_calendario = p_calendarios_rec.id_calendario,
                descripcion = p_calendarios_rec.descripcion,
                activo = p_calendarios_rec.activo,
                tipo_cal = p_calendarios_rec.tipo_cal
           WHERE
                id_calendario = upd.p_calendarios_rec.id_calendario
                ;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd;


    PROCEDURE upd_rowid (
                         p_calendarios_rec         IN calendarios_rt,
                         p_ignore_nulls         IN boolean := FALSE
                        )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   calendarios
             SET id_calendario = NVL(p_calendarios_rec.id_calendario,id_calendario),
                descripcion = NVL(p_calendarios_rec.descripcion,descripcion),
                activo = NVL(p_calendarios_rec.activo,activo),
                tipo_cal = NVL(p_calendarios_rec.tipo_cal,tipo_cal)
           WHERE  ROWID = p_calendarios_rec.row_id;
       ELSE
          UPDATE   calendarios
             SET id_calendario = p_calendarios_rec.id_calendario,
                descripcion = p_calendarios_rec.descripcion,
                activo = p_calendarios_rec.activo,
                tipo_cal = p_calendarios_rec.tipo_cal
           WHERE  ROWID = p_calendarios_rec.row_id;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd_rowid;

   PROCEDURE web_upd (
                  p_calendarios_rec         IN calendarios_rt,
                  p_ignore_nulls         IN boolean := FALSE
                )
   IS
      l_calendarios_rec calendarios_rt;
   BEGIN

      OPEN calendarios_cur(
                             web_upd.p_calendarios_rec.id_calendario
                        );

      FETCH calendarios_cur INTO l_calendarios_rec;

      IF calendarios_cur%NOTFOUND THEN
         CLOSE calendarios_cur;
         RAISE e_row_missing;
      ELSE
         IF p_calendarios_rec.hash != l_calendarios_rec.hash THEN
            CLOSE calendarios_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(p_ignore_nulls, FALSE)
            THEN

                UPDATE   calendarios
                   SET id_calendario = NVL(p_calendarios_rec.id_calendario,id_calendario),
                       descripcion = NVL(p_calendarios_rec.descripcion,descripcion),
                       activo = NVL(p_calendarios_rec.activo,activo),
                       tipo_cal = NVL(p_calendarios_rec.tipo_cal,tipo_cal)
               WHERE CURRENT OF calendarios_cur;
            ELSE
                UPDATE   calendarios
                   SET id_calendario = p_calendarios_rec.id_calendario,
                       descripcion = p_calendarios_rec.descripcion,
                       activo = p_calendarios_rec.activo,
                       tipo_cal = p_calendarios_rec.tipo_cal
               WHERE CURRENT OF calendarios_cur;
            END IF;

            CLOSE calendarios_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd;

   PROCEDURE web_upd_rowid (
                            p_calendarios_rec    IN calendarios_rt,
                            p_ignore_nulls         IN boolean := FALSE
                           )
   IS
      l_calendarios_rec calendarios_rt;
   BEGIN

      OPEN calendarios_rowid_cur(web_upd_rowid.p_calendarios_rec.row_id);

      FETCH calendarios_rowid_cur INTO l_calendarios_rec;

      IF calendarios_rowid_cur%NOTFOUND THEN
         CLOSE calendarios_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_upd_rowid.p_calendarios_rec.hash != l_calendarios_rec.hash THEN
            CLOSE calendarios_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(web_upd_rowid.p_ignore_nulls, FALSE)
            THEN
                UPDATE   calendarios
                   SET id_calendario = NVL(p_calendarios_rec.id_calendario,id_calendario),
                       descripcion = NVL(p_calendarios_rec.descripcion,descripcion),
                       activo = NVL(p_calendarios_rec.activo,activo),
                       tipo_cal = NVL(p_calendarios_rec.tipo_cal,tipo_cal)
               WHERE CURRENT OF calendarios_rowid_cur;
            ELSE
                UPDATE   calendarios
                   SET id_calendario = p_calendarios_rec.id_calendario,
                       descripcion = p_calendarios_rec.descripcion,
                       activo = p_calendarios_rec.activo,
                       tipo_cal = p_calendarios_rec.tipo_cal
               WHERE CURRENT OF calendarios_rowid_cur;
            END IF;

            CLOSE calendarios_rowid_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd_rowid;

    PROCEDURE del (
                  p_id_calendario IN calendarios.id_calendario%TYPE
                  )
    IS
    BEGIN

       DELETE FROM   calendarios
             WHERE
                  id_calendario = del.p_id_calendario
                   ;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del;

    PROCEDURE del_rowid (p_rowid IN varchar2)
    IS
    BEGIN

       DELETE FROM   calendarios
             WHERE   ROWID = del_rowid.p_rowid;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del_rowid;

    PROCEDURE web_del (
                      p_id_calendario IN calendarios.id_calendario%TYPE,
                      p_hash IN varchar2
                      )
   IS
      l_calendarios_rec calendarios_rt;
   BEGIN


      OPEN calendarios_cur(
                            web_del.p_id_calendario
                            );

      FETCH calendarios_cur INTO l_calendarios_rec;

      IF calendarios_cur%NOTFOUND THEN
         CLOSE calendarios_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del.p_hash != l_calendarios_rec.hash THEN
            CLOSE calendarios_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM calendarios
            WHERE CURRENT OF calendarios_cur;

            CLOSE calendarios_cur;
         END IF;
      END IF;



   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del;

   PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2)
   IS
      l_calendarios_rec calendarios_rt;
   BEGIN


      OPEN calendarios_rowid_cur(web_del_rowid.p_rowid);

      FETCH calendarios_rowid_cur INTO l_calendarios_rec;

      IF calendarios_rowid_cur%NOTFOUND THEN
         CLOSE calendarios_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del_rowid.p_hash != l_calendarios_rec.hash THEN
            CLOSE calendarios_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM calendarios
            WHERE CURRENT OF calendarios_rowid_cur;

            CLOSE calendarios_rowid_cur;
         END IF;
      END IF;

   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del_rowid;

END tapi_calendarios;

/
--------------------------------------------------------
--  DDL for Package Body TAPI_CALENDARIOS_DETALLE
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."TAPI_CALENDARIOS_DETALLE" IS

   /**
   * TAPI_CALENDARIOS_DETALLE
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: 30-JUL-2019 17:33
   * Created By: FUNDAUC
   */


   --GLOBAL_PRIVATE_CURSORS
   --By PK
   CURSOR calendarios_detalle_cur (
                       p_id IN calendarios_detalle.id%TYPE
                       )
   IS
      SELECT
            id_calendario,
            periodo,
            fecha_ini,
            fecha_fin,
            modalidad,
            periodo_activo,
            id,
            tapi_calendarios_detalle.hash(id),
            ROWID
      FROM calendarios_detalle
      WHERE
           id = calendarios_detalle_cur.p_id
      FOR UPDATE;

    --By Rowid
    CURSOR calendarios_detalle_rowid_cur (p_rowid IN VARCHAR2)
    IS
      SELECT
             id_calendario,
             periodo,
             fecha_ini,
             fecha_fin,
             modalidad,
             periodo_activo,
             id,
             tapi_calendarios_detalle.hash(id),
             ROWID
      FROM calendarios_detalle
      WHERE ROWID = p_rowid
      FOR UPDATE;


    FUNCTION hash (
                  p_id IN calendarios_detalle.id%TYPE
                  )
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format VARCHAR2(64);
   BEGIN


     --Get actual NLS_DATE_FORMAT
     SELECT   VALUE
       INTO   l_date_format
       FROM   v$nls_parameters
      WHERE   parameter = 'NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            id_calendario||
            periodo||
            fecha_ini||
            fecha_fin||
            modalidad||
            periodo_activo||
            id
      INTO l_string
      FROM calendarios_detalle
      WHERE
           id = hash.p_id
           ;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash;

    FUNCTION hash_rowid (p_rowid IN varchar2)
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format varchar2(64);
   BEGIN

      --Get actual NLS_DATE_FORMAT
      SELECT VALUE INTO l_date_format  FROM v$nls_parameters WHERE parameter ='NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            id_calendario||
            periodo||
            fecha_ini||
            fecha_fin||
            modalidad||
            periodo_activo||
            id
      INTO l_string
      FROM calendarios_detalle
      WHERE  ROWID = hash_rowid.p_rowid;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash_rowid;

   FUNCTION rt (
               p_id IN calendarios_detalle.id%TYPE
               )
      RETURN calendarios_detalle_rt RESULT_CACHE
   IS
      l_calendarios_detalle_rec calendarios_detalle_rt;
   BEGIN

      SELECT a.*,
             tapi_calendarios_detalle.hash(id),
             rowid
      INTO l_calendarios_detalle_rec
      FROM calendarios_detalle a
      WHERE
           id = rt.p_id
           ;


      RETURN l_calendarios_detalle_rec;

   END rt;

   FUNCTION rt_for_update (
                          p_id IN calendarios_detalle.id%TYPE
                          )
      RETURN calendarios_detalle_rt RESULT_CACHE
   IS
      l_calendarios_detalle_rec calendarios_detalle_rt;
   BEGIN


      SELECT a.*,
             tapi_calendarios_detalle.hash(id),
             rowid
      INTO l_calendarios_detalle_rec
      FROM calendarios_detalle a
      WHERE
           id = rt_for_update.p_id
      FOR UPDATE;


      RETURN l_calendarios_detalle_rec;

   END rt_for_update;

    FUNCTION tt (
                p_id IN calendarios_detalle.id%TYPE DEFAULT NULL
                )
       RETURN calendarios_detalle_tt
       PIPELINED
    IS
       l_calendarios_detalle_rec   calendarios_detalle_rt;
    BEGIN

       FOR c1 IN (SELECT   a.*, ROWID
                    FROM   calendarios_detalle a
                   WHERE
                        id = NVL(tt.p_id,id)
                        )
       LOOP
              l_calendarios_detalle_rec.id_calendario := c1.id_calendario;
              l_calendarios_detalle_rec.periodo := c1.periodo;
              l_calendarios_detalle_rec.fecha_ini := c1.fecha_ini;
              l_calendarios_detalle_rec.fecha_fin := c1.fecha_fin;
              l_calendarios_detalle_rec.modalidad := c1.modalidad;
              l_calendarios_detalle_rec.periodo_activo := c1.periodo_activo;
              l_calendarios_detalle_rec.id := c1.id;
              l_calendarios_detalle_rec.hash := tapi_calendarios_detalle.hash( c1.id);
              l_calendarios_detalle_rec.row_id := c1.ROWID;
              PIPE ROW (l_calendarios_detalle_rec);
       END LOOP;

       RETURN;

    END tt;


    PROCEDURE ins (p_calendarios_detalle_rec IN OUT calendarios_detalle_rt)
    IS
        l_rowtype     calendarios_detalle%ROWTYPE;

    BEGIN


        l_rowtype.id_calendario := ins.p_calendarios_detalle_rec.id_calendario;
        l_rowtype.periodo := ins.p_calendarios_detalle_rec.periodo;
        l_rowtype.fecha_ini := ins.p_calendarios_detalle_rec.fecha_ini;
        l_rowtype.fecha_fin := ins.p_calendarios_detalle_rec.fecha_fin;
        l_rowtype.modalidad := ins.p_calendarios_detalle_rec.modalidad;
        l_rowtype.periodo_activo := ins.p_calendarios_detalle_rec.periodo_activo;
        l_rowtype.id := ins.p_calendarios_detalle_rec.id;

       INSERT INTO calendarios_detalle
          VALUES   l_rowtype
       RETURNING
                   id_calendario ,
                   periodo ,
                   fecha_ini ,
                   fecha_fin ,
                   modalidad ,
                   periodo_activo ,
                   id 
            INTO   l_rowtype;

         ins.p_calendarios_detalle_rec.id_calendario := l_rowtype.id_calendario;
         ins.p_calendarios_detalle_rec.periodo := l_rowtype.periodo;
         ins.p_calendarios_detalle_rec.fecha_ini := l_rowtype.fecha_ini;
         ins.p_calendarios_detalle_rec.fecha_fin := l_rowtype.fecha_fin;
         ins.p_calendarios_detalle_rec.modalidad := l_rowtype.modalidad;
         ins.p_calendarios_detalle_rec.periodo_activo := l_rowtype.periodo_activo;
         ins.p_calendarios_detalle_rec.id := l_rowtype.id;



    END ins;

    PROCEDURE upd (
                  p_calendarios_detalle_rec         IN calendarios_detalle_rt,
                  p_ignore_nulls         IN boolean := FALSE
                  )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   calendarios_detalle
             SET id_calendario = NVL(p_calendarios_detalle_rec.id_calendario,id_calendario),
                periodo = NVL(p_calendarios_detalle_rec.periodo,periodo),
                fecha_ini = NVL(p_calendarios_detalle_rec.fecha_ini,fecha_ini),
                fecha_fin = NVL(p_calendarios_detalle_rec.fecha_fin,fecha_fin),
                modalidad = NVL(p_calendarios_detalle_rec.modalidad,modalidad),
                periodo_activo = NVL(p_calendarios_detalle_rec.periodo_activo,periodo_activo),
                id = NVL(p_calendarios_detalle_rec.id,id)
           WHERE
                id = upd.p_calendarios_detalle_rec.id
                ;
       ELSE
          UPDATE   calendarios_detalle
             SET id_calendario = p_calendarios_detalle_rec.id_calendario,
                periodo = p_calendarios_detalle_rec.periodo,
                fecha_ini = p_calendarios_detalle_rec.fecha_ini,
                fecha_fin = p_calendarios_detalle_rec.fecha_fin,
                modalidad = p_calendarios_detalle_rec.modalidad,
                periodo_activo = p_calendarios_detalle_rec.periodo_activo,
                id = p_calendarios_detalle_rec.id
           WHERE
                id = upd.p_calendarios_detalle_rec.id
                ;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd;


    PROCEDURE upd_rowid (
                         p_calendarios_detalle_rec         IN calendarios_detalle_rt,
                         p_ignore_nulls         IN boolean := FALSE
                        )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   calendarios_detalle
             SET id_calendario = NVL(p_calendarios_detalle_rec.id_calendario,id_calendario),
                periodo = NVL(p_calendarios_detalle_rec.periodo,periodo),
                fecha_ini = NVL(p_calendarios_detalle_rec.fecha_ini,fecha_ini),
                fecha_fin = NVL(p_calendarios_detalle_rec.fecha_fin,fecha_fin),
                modalidad = NVL(p_calendarios_detalle_rec.modalidad,modalidad),
                periodo_activo = NVL(p_calendarios_detalle_rec.periodo_activo,periodo_activo),
                id = NVL(p_calendarios_detalle_rec.id,id)
           WHERE  ROWID = p_calendarios_detalle_rec.row_id;
       ELSE
          UPDATE   calendarios_detalle
             SET id_calendario = p_calendarios_detalle_rec.id_calendario,
                periodo = p_calendarios_detalle_rec.periodo,
                fecha_ini = p_calendarios_detalle_rec.fecha_ini,
                fecha_fin = p_calendarios_detalle_rec.fecha_fin,
                modalidad = p_calendarios_detalle_rec.modalidad,
                periodo_activo = p_calendarios_detalle_rec.periodo_activo,
                id = p_calendarios_detalle_rec.id
           WHERE  ROWID = p_calendarios_detalle_rec.row_id;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd_rowid;

   PROCEDURE web_upd (
                  p_calendarios_detalle_rec         IN calendarios_detalle_rt,
                  p_ignore_nulls         IN boolean := FALSE
                )
   IS
      l_calendarios_detalle_rec calendarios_detalle_rt;
   BEGIN

      OPEN calendarios_detalle_cur(
                             web_upd.p_calendarios_detalle_rec.id
                        );

      FETCH calendarios_detalle_cur INTO l_calendarios_detalle_rec;

      IF calendarios_detalle_cur%NOTFOUND THEN
         CLOSE calendarios_detalle_cur;
         RAISE e_row_missing;
      ELSE
         IF p_calendarios_detalle_rec.hash != l_calendarios_detalle_rec.hash THEN
            CLOSE calendarios_detalle_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(p_ignore_nulls, FALSE)
            THEN

                UPDATE   calendarios_detalle
                   SET id_calendario = NVL(p_calendarios_detalle_rec.id_calendario,id_calendario),
                       periodo = NVL(p_calendarios_detalle_rec.periodo,periodo),
                       fecha_ini = NVL(p_calendarios_detalle_rec.fecha_ini,fecha_ini),
                       fecha_fin = NVL(p_calendarios_detalle_rec.fecha_fin,fecha_fin),
                       modalidad = NVL(p_calendarios_detalle_rec.modalidad,modalidad),
                       periodo_activo = NVL(p_calendarios_detalle_rec.periodo_activo,periodo_activo),
                       id = NVL(p_calendarios_detalle_rec.id,id)
               WHERE CURRENT OF calendarios_detalle_cur;
            ELSE
                UPDATE   calendarios_detalle
                   SET id_calendario = p_calendarios_detalle_rec.id_calendario,
                       periodo = p_calendarios_detalle_rec.periodo,
                       fecha_ini = p_calendarios_detalle_rec.fecha_ini,
                       fecha_fin = p_calendarios_detalle_rec.fecha_fin,
                       modalidad = p_calendarios_detalle_rec.modalidad,
                       periodo_activo = p_calendarios_detalle_rec.periodo_activo,
                       id = p_calendarios_detalle_rec.id
               WHERE CURRENT OF calendarios_detalle_cur;
            END IF;

            CLOSE calendarios_detalle_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd;

   PROCEDURE web_upd_rowid (
                            p_calendarios_detalle_rec    IN calendarios_detalle_rt,
                            p_ignore_nulls         IN boolean := FALSE
                           )
   IS
      l_calendarios_detalle_rec calendarios_detalle_rt;
   BEGIN

      OPEN calendarios_detalle_rowid_cur(web_upd_rowid.p_calendarios_detalle_rec.row_id);

      FETCH calendarios_detalle_rowid_cur INTO l_calendarios_detalle_rec;

      IF calendarios_detalle_rowid_cur%NOTFOUND THEN
         CLOSE calendarios_detalle_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_upd_rowid.p_calendarios_detalle_rec.hash != l_calendarios_detalle_rec.hash THEN
            CLOSE calendarios_detalle_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(web_upd_rowid.p_ignore_nulls, FALSE)
            THEN
                UPDATE   calendarios_detalle
                   SET id_calendario = NVL(p_calendarios_detalle_rec.id_calendario,id_calendario),
                       periodo = NVL(p_calendarios_detalle_rec.periodo,periodo),
                       fecha_ini = NVL(p_calendarios_detalle_rec.fecha_ini,fecha_ini),
                       fecha_fin = NVL(p_calendarios_detalle_rec.fecha_fin,fecha_fin),
                       modalidad = NVL(p_calendarios_detalle_rec.modalidad,modalidad),
                       periodo_activo = NVL(p_calendarios_detalle_rec.periodo_activo,periodo_activo),
                       id = NVL(p_calendarios_detalle_rec.id,id)
               WHERE CURRENT OF calendarios_detalle_rowid_cur;
            ELSE
                UPDATE   calendarios_detalle
                   SET id_calendario = p_calendarios_detalle_rec.id_calendario,
                       periodo = p_calendarios_detalle_rec.periodo,
                       fecha_ini = p_calendarios_detalle_rec.fecha_ini,
                       fecha_fin = p_calendarios_detalle_rec.fecha_fin,
                       modalidad = p_calendarios_detalle_rec.modalidad,
                       periodo_activo = p_calendarios_detalle_rec.periodo_activo,
                       id = p_calendarios_detalle_rec.id
               WHERE CURRENT OF calendarios_detalle_rowid_cur;
            END IF;

            CLOSE calendarios_detalle_rowid_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd_rowid;

    PROCEDURE del (
                  p_id IN calendarios_detalle.id%TYPE
                  )
    IS
    BEGIN

       DELETE FROM   calendarios_detalle
             WHERE
                  id = del.p_id
                   ;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del;

    PROCEDURE del_rowid (p_rowid IN varchar2)
    IS
    BEGIN

       DELETE FROM   calendarios_detalle
             WHERE   ROWID = del_rowid.p_rowid;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del_rowid;

    PROCEDURE web_del (
                      p_id IN calendarios_detalle.id%TYPE,
                      p_hash IN varchar2
                      )
   IS
      l_calendarios_detalle_rec calendarios_detalle_rt;
   BEGIN


      OPEN calendarios_detalle_cur(
                            web_del.p_id
                            );

      FETCH calendarios_detalle_cur INTO l_calendarios_detalle_rec;

      IF calendarios_detalle_cur%NOTFOUND THEN
         CLOSE calendarios_detalle_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del.p_hash != l_calendarios_detalle_rec.hash THEN
            CLOSE calendarios_detalle_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM calendarios_detalle
            WHERE CURRENT OF calendarios_detalle_cur;

            CLOSE calendarios_detalle_cur;
         END IF;
      END IF;



   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del;

   PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2)
   IS
      l_calendarios_detalle_rec calendarios_detalle_rt;
   BEGIN


      OPEN calendarios_detalle_rowid_cur(web_del_rowid.p_rowid);

      FETCH calendarios_detalle_rowid_cur INTO l_calendarios_detalle_rec;

      IF calendarios_detalle_rowid_cur%NOTFOUND THEN
         CLOSE calendarios_detalle_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del_rowid.p_hash != l_calendarios_detalle_rec.hash THEN
            CLOSE calendarios_detalle_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM calendarios_detalle
            WHERE CURRENT OF calendarios_detalle_rowid_cur;

            CLOSE calendarios_detalle_rowid_cur;
         END IF;
      END IF;

   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del_rowid;

END tapi_calendarios_detalle;



/
--------------------------------------------------------
--  DDL for Package Body TAPI_COHORTES
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."TAPI_COHORTES" IS

   /**
   * TAPI_COHORTES
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: 25-FEB-2020 18:34
   * Created By: FUNDAUC
   */


   --GLOBAL_PRIVATE_CURSORS
   --By PK
   CURSOR cohortes_cur (
                       p_id IN cohortes.id%TYPE
                       )
   IS
      SELECT
            codigo,
            id_horario,
            id_modalidad,
            cohorte,
            cupo,
            costo,
            inicial,
            costo_cuota,
            cuotas,
            status,
            id_ciudad,
            id,
            tipo_diplo,
            creado_por,
            creado_el,
            modificado_por,
            modificado_el,
            diplomado_id,
            periodo,
            id_calendario,
            nivel,
            id_metodo,
            empresa,
            facilitador,
            tapi_cohortes.hash(id),
            ROWID
      FROM cohortes
      WHERE
           id = cohortes_cur.p_id
      FOR UPDATE;

    --By Rowid
    CURSOR cohortes_rowid_cur (p_rowid IN VARCHAR2)
    IS
      SELECT
             codigo,
             id_horario,
             id_modalidad,
             cohorte,
             cupo,
             costo,
             inicial,
             costo_cuota,
             cuotas,
             status,
             id_ciudad,
             id,
             tipo_diplo,
             creado_por,
             creado_el,
             modificado_por,
             modificado_el,
             diplomado_id,
             periodo,
             id_calendario,
             nivel,
             id_metodo,
             empresa,
             facilitador,
             tapi_cohortes.hash(id),
             ROWID
      FROM cohortes
      WHERE ROWID = p_rowid
      FOR UPDATE;


    FUNCTION hash (
                  p_id IN cohortes.id%TYPE
                  )
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format VARCHAR2(64);
   BEGIN


     --Get actual NLS_DATE_FORMAT
     SELECT   VALUE
       INTO   l_date_format
       FROM   v$nls_parameters
      WHERE   parameter = 'NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            codigo||
            id_horario||
            id_modalidad||
            cohorte||
            cupo||
            costo||
            inicial||
            costo_cuota||
            cuotas||
            status||
            id_ciudad||
            id||
            tipo_diplo||
            creado_por||
            creado_el||
            modificado_por||
            modificado_el||
            diplomado_id||
            periodo||
            id_calendario||
            nivel||
            id_metodo||
            empresa||
            facilitador
      INTO l_string
      FROM cohortes
      WHERE
           id = hash.p_id
           ;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash;

    FUNCTION hash_rowid (p_rowid IN varchar2)
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format varchar2(64);
   BEGIN

      --Get actual NLS_DATE_FORMAT
      SELECT VALUE INTO l_date_format  FROM v$nls_parameters WHERE parameter ='NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            codigo||
            id_horario||
            id_modalidad||
            cohorte||
            cupo||
            costo||
            inicial||
            costo_cuota||
            cuotas||
            status||
            id_ciudad||
            id||
            tipo_diplo||
            creado_por||
            creado_el||
            modificado_por||
            modificado_el||
            diplomado_id||
            periodo||
            id_calendario||
            nivel||
            id_metodo||
            empresa||
            facilitador
      INTO l_string
      FROM cohortes
      WHERE  ROWID = hash_rowid.p_rowid;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash_rowid;

   FUNCTION rt (
               p_id IN cohortes.id%TYPE
               )
      RETURN cohortes_rt RESULT_CACHE
   IS
      l_cohortes_rec cohortes_rt;
   BEGIN

      SELECT a.*,
             tapi_cohortes.hash(id),
             rowid
      INTO l_cohortes_rec
      FROM cohortes a
      WHERE
           id = rt.p_id
           ;


      RETURN l_cohortes_rec;

   END rt;

   FUNCTION rt_for_update (
                          p_id IN cohortes.id%TYPE
                          )
      RETURN cohortes_rt RESULT_CACHE
   IS
      l_cohortes_rec cohortes_rt;
   BEGIN


      SELECT a.*,
             tapi_cohortes.hash(id),
             rowid
      INTO l_cohortes_rec
      FROM cohortes a
      WHERE
           id = rt_for_update.p_id
      FOR UPDATE;


      RETURN l_cohortes_rec;

   END rt_for_update;

    FUNCTION tt (
                p_id IN cohortes.id%TYPE DEFAULT NULL
                )
       RETURN cohortes_tt
       PIPELINED
    IS
       l_cohortes_rec   cohortes_rt;
    BEGIN

       FOR c1 IN (SELECT   a.*, ROWID
                    FROM   cohortes a
                   WHERE
                        id = NVL(tt.p_id,id)
                        )
       LOOP
              l_cohortes_rec.codigo := c1.codigo;
              l_cohortes_rec.id_horario := c1.id_horario;
              l_cohortes_rec.id_modalidad := c1.id_modalidad;
              l_cohortes_rec.cohorte := c1.cohorte;
              l_cohortes_rec.cupo := c1.cupo;
              l_cohortes_rec.costo := c1.costo;
              l_cohortes_rec.inicial := c1.inicial;
              l_cohortes_rec.costo_cuota := c1.costo_cuota;
              l_cohortes_rec.cuotas := c1.cuotas;
              l_cohortes_rec.status := c1.status;
              l_cohortes_rec.id_ciudad := c1.id_ciudad;
              l_cohortes_rec.id := c1.id;
              l_cohortes_rec.tipo_diplo := c1.tipo_diplo;
              l_cohortes_rec.creado_por := c1.creado_por;
              l_cohortes_rec.creado_el := c1.creado_el;
              l_cohortes_rec.modificado_por := c1.modificado_por;
              l_cohortes_rec.modificado_el := c1.modificado_el;
              l_cohortes_rec.diplomado_id := c1.diplomado_id;
              l_cohortes_rec.periodo := c1.periodo;
              l_cohortes_rec.id_calendario := c1.id_calendario;
              l_cohortes_rec.nivel := c1.nivel;
              l_cohortes_rec.id_metodo := c1.id_metodo;
              l_cohortes_rec.empresa := c1.empresa;
              l_cohortes_rec.facilitador := c1.facilitador;
              l_cohortes_rec.hash := tapi_cohortes.hash( c1.id);
              l_cohortes_rec.row_id := c1.ROWID;
              PIPE ROW (l_cohortes_rec);
       END LOOP;

       RETURN;

    END tt;


    PROCEDURE ins (p_cohortes_rec IN OUT cohortes_rt)
    IS
        l_rowtype     cohortes%ROWTYPE;

    BEGIN


        l_rowtype.codigo := ins.p_cohortes_rec.codigo;
        l_rowtype.id_horario := ins.p_cohortes_rec.id_horario;
        l_rowtype.id_modalidad := ins.p_cohortes_rec.id_modalidad;
        l_rowtype.cohorte := ins.p_cohortes_rec.cohorte;
        l_rowtype.cupo := ins.p_cohortes_rec.cupo;
        l_rowtype.costo := ins.p_cohortes_rec.costo;
        l_rowtype.inicial := ins.p_cohortes_rec.inicial;
        l_rowtype.costo_cuota := ins.p_cohortes_rec.costo_cuota;
        l_rowtype.cuotas := ins.p_cohortes_rec.cuotas;
        l_rowtype.status := ins.p_cohortes_rec.status;
        l_rowtype.id_ciudad := ins.p_cohortes_rec.id_ciudad;
        l_rowtype.id := ins.p_cohortes_rec.id;
        l_rowtype.tipo_diplo := ins.p_cohortes_rec.tipo_diplo;
        l_rowtype.creado_por := ins.p_cohortes_rec.creado_por;
        l_rowtype.creado_el := ins.p_cohortes_rec.creado_el;
        l_rowtype.modificado_por := ins.p_cohortes_rec.modificado_por;
        l_rowtype.modificado_el := ins.p_cohortes_rec.modificado_el;
        l_rowtype.diplomado_id := ins.p_cohortes_rec.diplomado_id;
        l_rowtype.periodo := ins.p_cohortes_rec.periodo;
        l_rowtype.id_calendario := ins.p_cohortes_rec.id_calendario;
        l_rowtype.nivel := ins.p_cohortes_rec.nivel;
        l_rowtype.id_metodo := ins.p_cohortes_rec.id_metodo;
        l_rowtype.empresa := ins.p_cohortes_rec.empresa;
        l_rowtype.facilitador := ins.p_cohortes_rec.facilitador;

       INSERT INTO cohortes
          VALUES   l_rowtype
       RETURNING
                   codigo ,
                   id_horario ,
                   id_modalidad ,
                   cohorte ,
                   cupo ,
                   costo ,
                   inicial ,
                   costo_cuota ,
                   cuotas ,
                   status ,
                   id_ciudad ,
                   id ,
                   tipo_diplo ,
                   creado_por ,
                   creado_el ,
                   modificado_por ,
                   modificado_el ,
                   diplomado_id ,
                   periodo ,
                   id_calendario ,
                   nivel ,
                   id_metodo ,
                   empresa ,
                   facilitador 
            INTO   l_rowtype;

         ins.p_cohortes_rec.codigo := l_rowtype.codigo;
         ins.p_cohortes_rec.id_horario := l_rowtype.id_horario;
         ins.p_cohortes_rec.id_modalidad := l_rowtype.id_modalidad;
         ins.p_cohortes_rec.cohorte := l_rowtype.cohorte;
         ins.p_cohortes_rec.cupo := l_rowtype.cupo;
         ins.p_cohortes_rec.costo := l_rowtype.costo;
         ins.p_cohortes_rec.inicial := l_rowtype.inicial;
         ins.p_cohortes_rec.costo_cuota := l_rowtype.costo_cuota;
         ins.p_cohortes_rec.cuotas := l_rowtype.cuotas;
         ins.p_cohortes_rec.status := l_rowtype.status;
         ins.p_cohortes_rec.id_ciudad := l_rowtype.id_ciudad;
         ins.p_cohortes_rec.id := l_rowtype.id;
         ins.p_cohortes_rec.tipo_diplo := l_rowtype.tipo_diplo;
         ins.p_cohortes_rec.creado_por := l_rowtype.creado_por;
         ins.p_cohortes_rec.creado_el := l_rowtype.creado_el;
         ins.p_cohortes_rec.modificado_por := l_rowtype.modificado_por;
         ins.p_cohortes_rec.modificado_el := l_rowtype.modificado_el;
         ins.p_cohortes_rec.diplomado_id := l_rowtype.diplomado_id;
         ins.p_cohortes_rec.periodo := l_rowtype.periodo;
         ins.p_cohortes_rec.id_calendario := l_rowtype.id_calendario;
         ins.p_cohortes_rec.nivel := l_rowtype.nivel;
         ins.p_cohortes_rec.id_metodo := l_rowtype.id_metodo;
         ins.p_cohortes_rec.empresa := l_rowtype.empresa;
         ins.p_cohortes_rec.facilitador := l_rowtype.facilitador;



    END ins;

    PROCEDURE upd (
                  p_cohortes_rec         IN cohortes_rt,
                  p_ignore_nulls         IN boolean := FALSE
                  )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   cohortes
             SET codigo = NVL(p_cohortes_rec.codigo,codigo),
                id_horario = NVL(p_cohortes_rec.id_horario,id_horario),
                id_modalidad = NVL(p_cohortes_rec.id_modalidad,id_modalidad),
                cohorte = NVL(p_cohortes_rec.cohorte,cohorte),
                cupo = NVL(p_cohortes_rec.cupo,cupo),
                costo = NVL(p_cohortes_rec.costo,costo),
                inicial = NVL(p_cohortes_rec.inicial,inicial),
                costo_cuota = NVL(p_cohortes_rec.costo_cuota,costo_cuota),
                cuotas = NVL(p_cohortes_rec.cuotas,cuotas),
                status = NVL(p_cohortes_rec.status,status),
                id_ciudad = NVL(p_cohortes_rec.id_ciudad,id_ciudad),
                id = NVL(p_cohortes_rec.id,id),
                tipo_diplo = NVL(p_cohortes_rec.tipo_diplo,tipo_diplo),
                creado_por = NVL(p_cohortes_rec.creado_por,creado_por),
                creado_el = NVL(p_cohortes_rec.creado_el,creado_el),
                modificado_por = NVL(p_cohortes_rec.modificado_por,modificado_por),
                modificado_el = NVL(p_cohortes_rec.modificado_el,modificado_el),
                diplomado_id = NVL(p_cohortes_rec.diplomado_id,diplomado_id),
                periodo = NVL(p_cohortes_rec.periodo,periodo),
                id_calendario = NVL(p_cohortes_rec.id_calendario,id_calendario),
                nivel = NVL(p_cohortes_rec.nivel,nivel),
                id_metodo = NVL(p_cohortes_rec.id_metodo,id_metodo),
                empresa = NVL(p_cohortes_rec.empresa,empresa),
                facilitador = NVL(p_cohortes_rec.facilitador,facilitador)
           WHERE
                id = upd.p_cohortes_rec.id
                ;
       ELSE
          UPDATE   cohortes
             SET codigo = p_cohortes_rec.codigo,
                id_horario = p_cohortes_rec.id_horario,
                id_modalidad = p_cohortes_rec.id_modalidad,
                cohorte = p_cohortes_rec.cohorte,
                cupo = p_cohortes_rec.cupo,
                costo = p_cohortes_rec.costo,
                inicial = p_cohortes_rec.inicial,
                costo_cuota = p_cohortes_rec.costo_cuota,
                cuotas = p_cohortes_rec.cuotas,
                status = p_cohortes_rec.status,
                id_ciudad = p_cohortes_rec.id_ciudad,
                id = p_cohortes_rec.id,
                tipo_diplo = p_cohortes_rec.tipo_diplo,
                creado_por = p_cohortes_rec.creado_por,
                creado_el = p_cohortes_rec.creado_el,
                modificado_por = p_cohortes_rec.modificado_por,
                modificado_el = p_cohortes_rec.modificado_el,
                diplomado_id = p_cohortes_rec.diplomado_id,
                periodo = p_cohortes_rec.periodo,
                id_calendario = p_cohortes_rec.id_calendario,
                nivel = p_cohortes_rec.nivel,
                id_metodo = p_cohortes_rec.id_metodo,
                empresa = p_cohortes_rec.empresa,
                facilitador = p_cohortes_rec.facilitador
           WHERE
                id = upd.p_cohortes_rec.id
                ;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd;


    PROCEDURE upd_rowid (
                         p_cohortes_rec         IN cohortes_rt,
                         p_ignore_nulls         IN boolean := FALSE
                        )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   cohortes
             SET codigo = NVL(p_cohortes_rec.codigo,codigo),
                id_horario = NVL(p_cohortes_rec.id_horario,id_horario),
                id_modalidad = NVL(p_cohortes_rec.id_modalidad,id_modalidad),
                cohorte = NVL(p_cohortes_rec.cohorte,cohorte),
                cupo = NVL(p_cohortes_rec.cupo,cupo),
                costo = NVL(p_cohortes_rec.costo,costo),
                inicial = NVL(p_cohortes_rec.inicial,inicial),
                costo_cuota = NVL(p_cohortes_rec.costo_cuota,costo_cuota),
                cuotas = NVL(p_cohortes_rec.cuotas,cuotas),
                status = NVL(p_cohortes_rec.status,status),
                id_ciudad = NVL(p_cohortes_rec.id_ciudad,id_ciudad),
                id = NVL(p_cohortes_rec.id,id),
                tipo_diplo = NVL(p_cohortes_rec.tipo_diplo,tipo_diplo),
                creado_por = NVL(p_cohortes_rec.creado_por,creado_por),
                creado_el = NVL(p_cohortes_rec.creado_el,creado_el),
                modificado_por = NVL(p_cohortes_rec.modificado_por,modificado_por),
                modificado_el = NVL(p_cohortes_rec.modificado_el,modificado_el),
                diplomado_id = NVL(p_cohortes_rec.diplomado_id,diplomado_id),
                periodo = NVL(p_cohortes_rec.periodo,periodo),
                id_calendario = NVL(p_cohortes_rec.id_calendario,id_calendario),
                nivel = NVL(p_cohortes_rec.nivel,nivel),
                id_metodo = NVL(p_cohortes_rec.id_metodo,id_metodo),
                empresa = NVL(p_cohortes_rec.empresa,empresa),
                facilitador = NVL(p_cohortes_rec.facilitador,facilitador)
           WHERE  ROWID = p_cohortes_rec.row_id;
       ELSE
          UPDATE   cohortes
             SET codigo = p_cohortes_rec.codigo,
                id_horario = p_cohortes_rec.id_horario,
                id_modalidad = p_cohortes_rec.id_modalidad,
                cohorte = p_cohortes_rec.cohorte,
                cupo = p_cohortes_rec.cupo,
                costo = p_cohortes_rec.costo,
                inicial = p_cohortes_rec.inicial,
                costo_cuota = p_cohortes_rec.costo_cuota,
                cuotas = p_cohortes_rec.cuotas,
                status = p_cohortes_rec.status,
                id_ciudad = p_cohortes_rec.id_ciudad,
                id = p_cohortes_rec.id,
                tipo_diplo = p_cohortes_rec.tipo_diplo,
                creado_por = p_cohortes_rec.creado_por,
                creado_el = p_cohortes_rec.creado_el,
                modificado_por = p_cohortes_rec.modificado_por,
                modificado_el = p_cohortes_rec.modificado_el,
                diplomado_id = p_cohortes_rec.diplomado_id,
                periodo = p_cohortes_rec.periodo,
                id_calendario = p_cohortes_rec.id_calendario,
                nivel = p_cohortes_rec.nivel,
                id_metodo = p_cohortes_rec.id_metodo,
                empresa = p_cohortes_rec.empresa,
                facilitador = p_cohortes_rec.facilitador
           WHERE  ROWID = p_cohortes_rec.row_id;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd_rowid;

   PROCEDURE web_upd (
                  p_cohortes_rec         IN cohortes_rt,
                  p_ignore_nulls         IN boolean := FALSE
                )
   IS
      l_cohortes_rec cohortes_rt;
   BEGIN

      OPEN cohortes_cur(
                             web_upd.p_cohortes_rec.id
                        );

      FETCH cohortes_cur INTO l_cohortes_rec;

      IF cohortes_cur%NOTFOUND THEN
         CLOSE cohortes_cur;
         RAISE e_row_missing;
      ELSE
         IF p_cohortes_rec.hash != l_cohortes_rec.hash THEN
            CLOSE cohortes_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(p_ignore_nulls, FALSE)
            THEN

                UPDATE   cohortes
                   SET codigo = NVL(p_cohortes_rec.codigo,codigo),
                       id_horario = NVL(p_cohortes_rec.id_horario,id_horario),
                       id_modalidad = NVL(p_cohortes_rec.id_modalidad,id_modalidad),
                       cohorte = NVL(p_cohortes_rec.cohorte,cohorte),
                       cupo = NVL(p_cohortes_rec.cupo,cupo),
                       costo = NVL(p_cohortes_rec.costo,costo),
                       inicial = NVL(p_cohortes_rec.inicial,inicial),
                       costo_cuota = NVL(p_cohortes_rec.costo_cuota,costo_cuota),
                       cuotas = NVL(p_cohortes_rec.cuotas,cuotas),
                       status = NVL(p_cohortes_rec.status,status),
                       id_ciudad = NVL(p_cohortes_rec.id_ciudad,id_ciudad),
                       id = NVL(p_cohortes_rec.id,id),
                       tipo_diplo = NVL(p_cohortes_rec.tipo_diplo,tipo_diplo),
                       creado_por = NVL(p_cohortes_rec.creado_por,creado_por),
                       creado_el = NVL(p_cohortes_rec.creado_el,creado_el),
                       modificado_por = NVL(p_cohortes_rec.modificado_por,modificado_por),
                       modificado_el = NVL(p_cohortes_rec.modificado_el,modificado_el),
                       diplomado_id = NVL(p_cohortes_rec.diplomado_id,diplomado_id),
                       periodo = NVL(p_cohortes_rec.periodo,periodo),
                       id_calendario = NVL(p_cohortes_rec.id_calendario,id_calendario),
                       nivel = NVL(p_cohortes_rec.nivel,nivel),
                       id_metodo = NVL(p_cohortes_rec.id_metodo,id_metodo),
                       empresa = NVL(p_cohortes_rec.empresa,empresa),
                       facilitador = NVL(p_cohortes_rec.facilitador,facilitador)
               WHERE CURRENT OF cohortes_cur;
            ELSE
                UPDATE   cohortes
                   SET codigo = p_cohortes_rec.codigo,
                       id_horario = p_cohortes_rec.id_horario,
                       id_modalidad = p_cohortes_rec.id_modalidad,
                       cohorte = p_cohortes_rec.cohorte,
                       cupo = p_cohortes_rec.cupo,
                       costo = p_cohortes_rec.costo,
                       inicial = p_cohortes_rec.inicial,
                       costo_cuota = p_cohortes_rec.costo_cuota,
                       cuotas = p_cohortes_rec.cuotas,
                       status = p_cohortes_rec.status,
                       id_ciudad = p_cohortes_rec.id_ciudad,
                       id = p_cohortes_rec.id,
                       tipo_diplo = p_cohortes_rec.tipo_diplo,
                       creado_por = p_cohortes_rec.creado_por,
                       creado_el = p_cohortes_rec.creado_el,
                       modificado_por = p_cohortes_rec.modificado_por,
                       modificado_el = p_cohortes_rec.modificado_el,
                       diplomado_id = p_cohortes_rec.diplomado_id,
                       periodo = p_cohortes_rec.periodo,
                       id_calendario = p_cohortes_rec.id_calendario,
                       nivel = p_cohortes_rec.nivel,
                       id_metodo = p_cohortes_rec.id_metodo,
                       empresa = p_cohortes_rec.empresa,
                       facilitador = p_cohortes_rec.facilitador
               WHERE CURRENT OF cohortes_cur;
            END IF;

            CLOSE cohortes_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd;

   PROCEDURE web_upd_rowid (
                            p_cohortes_rec    IN cohortes_rt,
                            p_ignore_nulls         IN boolean := FALSE
                           )
   IS
      l_cohortes_rec cohortes_rt;
   BEGIN

      OPEN cohortes_rowid_cur(web_upd_rowid.p_cohortes_rec.row_id);

      FETCH cohortes_rowid_cur INTO l_cohortes_rec;

      IF cohortes_rowid_cur%NOTFOUND THEN
         CLOSE cohortes_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_upd_rowid.p_cohortes_rec.hash != l_cohortes_rec.hash THEN
            CLOSE cohortes_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(web_upd_rowid.p_ignore_nulls, FALSE)
            THEN
                UPDATE   cohortes
                   SET codigo = NVL(p_cohortes_rec.codigo,codigo),
                       id_horario = NVL(p_cohortes_rec.id_horario,id_horario),
                       id_modalidad = NVL(p_cohortes_rec.id_modalidad,id_modalidad),
                       cohorte = NVL(p_cohortes_rec.cohorte,cohorte),
                       cupo = NVL(p_cohortes_rec.cupo,cupo),
                       costo = NVL(p_cohortes_rec.costo,costo),
                       inicial = NVL(p_cohortes_rec.inicial,inicial),
                       costo_cuota = NVL(p_cohortes_rec.costo_cuota,costo_cuota),
                       cuotas = NVL(p_cohortes_rec.cuotas,cuotas),
                       status = NVL(p_cohortes_rec.status,status),
                       id_ciudad = NVL(p_cohortes_rec.id_ciudad,id_ciudad),
                       id = NVL(p_cohortes_rec.id,id),
                       tipo_diplo = NVL(p_cohortes_rec.tipo_diplo,tipo_diplo),
                       creado_por = NVL(p_cohortes_rec.creado_por,creado_por),
                       creado_el = NVL(p_cohortes_rec.creado_el,creado_el),
                       modificado_por = NVL(p_cohortes_rec.modificado_por,modificado_por),
                       modificado_el = NVL(p_cohortes_rec.modificado_el,modificado_el),
                       diplomado_id = NVL(p_cohortes_rec.diplomado_id,diplomado_id),
                       periodo = NVL(p_cohortes_rec.periodo,periodo),
                       id_calendario = NVL(p_cohortes_rec.id_calendario,id_calendario),
                       nivel = NVL(p_cohortes_rec.nivel,nivel),
                       id_metodo = NVL(p_cohortes_rec.id_metodo,id_metodo),
                       empresa = NVL(p_cohortes_rec.empresa,empresa),
                       facilitador = NVL(p_cohortes_rec.facilitador,facilitador)
               WHERE CURRENT OF cohortes_rowid_cur;
            ELSE
                UPDATE   cohortes
                   SET codigo = p_cohortes_rec.codigo,
                       id_horario = p_cohortes_rec.id_horario,
                       id_modalidad = p_cohortes_rec.id_modalidad,
                       cohorte = p_cohortes_rec.cohorte,
                       cupo = p_cohortes_rec.cupo,
                       costo = p_cohortes_rec.costo,
                       inicial = p_cohortes_rec.inicial,
                       costo_cuota = p_cohortes_rec.costo_cuota,
                       cuotas = p_cohortes_rec.cuotas,
                       status = p_cohortes_rec.status,
                       id_ciudad = p_cohortes_rec.id_ciudad,
                       id = p_cohortes_rec.id,
                       tipo_diplo = p_cohortes_rec.tipo_diplo,
                       creado_por = p_cohortes_rec.creado_por,
                       creado_el = p_cohortes_rec.creado_el,
                       modificado_por = p_cohortes_rec.modificado_por,
                       modificado_el = p_cohortes_rec.modificado_el,
                       diplomado_id = p_cohortes_rec.diplomado_id,
                       periodo = p_cohortes_rec.periodo,
                       id_calendario = p_cohortes_rec.id_calendario,
                       nivel = p_cohortes_rec.nivel,
                       id_metodo = p_cohortes_rec.id_metodo,
                       empresa = p_cohortes_rec.empresa,
                       facilitador = p_cohortes_rec.facilitador
               WHERE CURRENT OF cohortes_rowid_cur;
            END IF;

            CLOSE cohortes_rowid_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd_rowid;

    PROCEDURE del (
                  p_id IN cohortes.id%TYPE
                  )
    IS
    BEGIN

       DELETE FROM   cohortes
             WHERE
                  id = del.p_id
                   ;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del;

    PROCEDURE del_rowid (p_rowid IN varchar2)
    IS
    BEGIN

       DELETE FROM   cohortes
             WHERE   ROWID = del_rowid.p_rowid;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del_rowid;

    PROCEDURE web_del (
                      p_id IN cohortes.id%TYPE,
                      p_hash IN varchar2
                      )
   IS
      l_cohortes_rec cohortes_rt;
   BEGIN


      OPEN cohortes_cur(
                            web_del.p_id
                            );

      FETCH cohortes_cur INTO l_cohortes_rec;

      IF cohortes_cur%NOTFOUND THEN
         CLOSE cohortes_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del.p_hash != l_cohortes_rec.hash THEN
            CLOSE cohortes_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM cohortes
            WHERE CURRENT OF cohortes_cur;

            CLOSE cohortes_cur;
         END IF;
      END IF;



   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del;

   PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2)
   IS
      l_cohortes_rec cohortes_rt;
   BEGIN


      OPEN cohortes_rowid_cur(web_del_rowid.p_rowid);

      FETCH cohortes_rowid_cur INTO l_cohortes_rec;

      IF cohortes_rowid_cur%NOTFOUND THEN
         CLOSE cohortes_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del_rowid.p_hash != l_cohortes_rec.hash THEN
            CLOSE cohortes_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM cohortes
            WHERE CURRENT OF cohortes_rowid_cur;

            CLOSE cohortes_rowid_cur;
         END IF;
      END IF;

   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del_rowid;

END tapi_cohortes;

 

/
--------------------------------------------------------
--  DDL for Package Body TAPI_CONDICIONES_ESPECIALES
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."TAPI_CONDICIONES_ESPECIALES" IS

   /**
   * TAPI_CONDICIONES_ESPECIALES
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: 10-SEP-2019 11:26
   * Created By: FUNDAUC
   */


   --GLOBAL_PRIVATE_CURSORS
   --By PK
   CURSOR condiciones_especiales_cur (
                       p_id_condicion IN condiciones_especiales.id_condicion%TYPE
                       )
   IS
      SELECT
            id_condicion,
            descripcion,
            descuento,
            porcentaje,
            tapi_condiciones_especiales.hash(id_condicion),
            ROWID
      FROM condiciones_especiales
      WHERE
           id_condicion = condiciones_especiales_cur.p_id_condicion
      FOR UPDATE;

    --By Rowid
    CURSOR cond_es_rowid_cur (p_rowid IN VARCHAR2)
    IS
      SELECT
             id_condicion,
             descripcion,
             descuento,
             porcentaje,
             tapi_condiciones_especiales.hash(id_condicion),
             ROWID
      FROM condiciones_especiales
      WHERE ROWID = p_rowid
      FOR UPDATE;


    FUNCTION hash (
                  p_id_condicion IN condiciones_especiales.id_condicion%TYPE
                  )
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format VARCHAR2(64);
   BEGIN


     --Get actual NLS_DATE_FORMAT
     SELECT   VALUE
       INTO   l_date_format
       FROM   v$nls_parameters
      WHERE   parameter = 'NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            id_condicion||
            descripcion||
            descuento||
            porcentaje
      INTO l_string
      FROM condiciones_especiales
      WHERE
           id_condicion = hash.p_id_condicion
           ;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash;

    FUNCTION hash_rowid (p_rowid IN varchar2)
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format varchar2(64);
   BEGIN

      --Get actual NLS_DATE_FORMAT
      SELECT VALUE INTO l_date_format  FROM v$nls_parameters WHERE parameter ='NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            id_condicion||
            descripcion||
            descuento||
            porcentaje
      INTO l_string
      FROM condiciones_especiales
      WHERE  ROWID = hash_rowid.p_rowid;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash_rowid;

   FUNCTION rt (
               p_id_condicion IN condiciones_especiales.id_condicion%TYPE
               )
      RETURN condiciones_especiales_rt RESULT_CACHE
   IS
      l_condiciones_especiales_rec condiciones_especiales_rt;
   BEGIN

      SELECT a.*,
             tapi_condiciones_especiales.hash(id_condicion),
             rowid
      INTO l_condiciones_especiales_rec
      FROM condiciones_especiales a
      WHERE
           id_condicion = rt.p_id_condicion
           ;


      RETURN l_condiciones_especiales_rec;

   END rt;

   FUNCTION rt_for_update (
                          p_id_condicion IN condiciones_especiales.id_condicion%TYPE
                          )
      RETURN condiciones_especiales_rt RESULT_CACHE
   IS
      l_condiciones_especiales_rec condiciones_especiales_rt;
   BEGIN


      SELECT a.*,
             tapi_condiciones_especiales.hash(id_condicion),
             rowid
      INTO l_condiciones_especiales_rec
      FROM condiciones_especiales a
      WHERE
           id_condicion = rt_for_update.p_id_condicion
      FOR UPDATE;


      RETURN l_condiciones_especiales_rec;

   END rt_for_update;

    FUNCTION tt (
                p_id_condicion IN condiciones_especiales.id_condicion%TYPE DEFAULT NULL
                )
       RETURN condiciones_especiales_tt
       PIPELINED
    IS
       l_condiciones_especiales_rec   condiciones_especiales_rt;
    BEGIN

       FOR c1 IN (SELECT   a.*, ROWID
                    FROM   condiciones_especiales a
                   WHERE
                        id_condicion = NVL(tt.p_id_condicion,id_condicion)
                        )
       LOOP
              l_condiciones_especiales_rec.id_condicion := c1.id_condicion;
              l_condiciones_especiales_rec.descripcion := c1.descripcion;
              l_condiciones_especiales_rec.descuento := c1.descuento;
              l_condiciones_especiales_rec.porcentaje := c1.porcentaje;
              l_condiciones_especiales_rec.hash := tapi_condiciones_especiales.hash( c1.id_condicion);
              l_condiciones_especiales_rec.row_id := c1.ROWID;
              PIPE ROW (l_condiciones_especiales_rec);
       END LOOP;

       RETURN;

    END tt;


    PROCEDURE ins (p_condiciones_especiales_rec IN OUT condiciones_especiales_rt)
    IS
        l_rowtype     condiciones_especiales%ROWTYPE;

    BEGIN


        l_rowtype.id_condicion := ins.p_condiciones_especiales_rec.id_condicion;
        l_rowtype.descripcion := ins.p_condiciones_especiales_rec.descripcion;
        l_rowtype.descuento := ins.p_condiciones_especiales_rec.descuento;
        l_rowtype.porcentaje := ins.p_condiciones_especiales_rec.porcentaje;

       INSERT INTO condiciones_especiales
          VALUES   l_rowtype
       RETURNING
                   id_condicion ,
                   descripcion ,
                   descuento ,
                   porcentaje 
            INTO   l_rowtype;

         ins.p_condiciones_especiales_rec.id_condicion := l_rowtype.id_condicion;
         ins.p_condiciones_especiales_rec.descripcion := l_rowtype.descripcion;
         ins.p_condiciones_especiales_rec.descuento := l_rowtype.descuento;
         ins.p_condiciones_especiales_rec.porcentaje := l_rowtype.porcentaje;



    END ins;

    PROCEDURE upd (
                  p_condiciones_especiales_rec         IN condiciones_especiales_rt,
                  p_ignore_nulls         IN boolean := FALSE
                  )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   condiciones_especiales
             SET id_condicion = NVL(p_condiciones_especiales_rec.id_condicion,id_condicion),
                descripcion = NVL(p_condiciones_especiales_rec.descripcion,descripcion),
                descuento = NVL(p_condiciones_especiales_rec.descuento,descuento),
                porcentaje = NVL(p_condiciones_especiales_rec.porcentaje,porcentaje)
           WHERE
                id_condicion = upd.p_condiciones_especiales_rec.id_condicion
                ;
       ELSE
          UPDATE   condiciones_especiales
             SET id_condicion = p_condiciones_especiales_rec.id_condicion,
                descripcion = p_condiciones_especiales_rec.descripcion,
                descuento = p_condiciones_especiales_rec.descuento,
                porcentaje = p_condiciones_especiales_rec.porcentaje
           WHERE
                id_condicion = upd.p_condiciones_especiales_rec.id_condicion
                ;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd;


    PROCEDURE upd_rowid (
                         p_condiciones_especiales_rec         IN condiciones_especiales_rt,
                         p_ignore_nulls         IN boolean := FALSE
                        )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   condiciones_especiales
             SET id_condicion = NVL(p_condiciones_especiales_rec.id_condicion,id_condicion),
                descripcion = NVL(p_condiciones_especiales_rec.descripcion,descripcion),
                descuento = NVL(p_condiciones_especiales_rec.descuento,descuento),
                porcentaje = NVL(p_condiciones_especiales_rec.porcentaje,porcentaje)
           WHERE  ROWID = p_condiciones_especiales_rec.row_id;
       ELSE
          UPDATE   condiciones_especiales
             SET id_condicion = p_condiciones_especiales_rec.id_condicion,
                descripcion = p_condiciones_especiales_rec.descripcion,
                descuento = p_condiciones_especiales_rec.descuento,
                porcentaje = p_condiciones_especiales_rec.porcentaje
           WHERE  ROWID = p_condiciones_especiales_rec.row_id;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd_rowid;

   PROCEDURE web_upd (
                  p_condiciones_especiales_rec         IN condiciones_especiales_rt,
                  p_ignore_nulls         IN boolean := FALSE
                )
   IS
      l_condiciones_especiales_rec condiciones_especiales_rt;
   BEGIN

      OPEN condiciones_especiales_cur(
                             web_upd.p_condiciones_especiales_rec.id_condicion
                        );

      FETCH condiciones_especiales_cur INTO l_condiciones_especiales_rec;

      IF condiciones_especiales_cur%NOTFOUND THEN
         CLOSE condiciones_especiales_cur;
         RAISE e_row_missing;
      ELSE
         IF p_condiciones_especiales_rec.hash != l_condiciones_especiales_rec.hash THEN
            CLOSE condiciones_especiales_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(p_ignore_nulls, FALSE)
            THEN

                UPDATE   condiciones_especiales
                   SET id_condicion = NVL(p_condiciones_especiales_rec.id_condicion,id_condicion),
                       descripcion = NVL(p_condiciones_especiales_rec.descripcion,descripcion),
                       descuento = NVL(p_condiciones_especiales_rec.descuento,descuento),
                       porcentaje = NVL(p_condiciones_especiales_rec.porcentaje,porcentaje)
               WHERE CURRENT OF condiciones_especiales_cur;
            ELSE
                UPDATE   condiciones_especiales
                   SET id_condicion = p_condiciones_especiales_rec.id_condicion,
                       descripcion = p_condiciones_especiales_rec.descripcion,
                       descuento = p_condiciones_especiales_rec.descuento,
                       porcentaje = p_condiciones_especiales_rec.porcentaje
               WHERE CURRENT OF condiciones_especiales_cur;
            END IF;

            CLOSE condiciones_especiales_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd;

   PROCEDURE web_upd_rowid (
                            p_condiciones_especiales_rec    IN condiciones_especiales_rt,
                            p_ignore_nulls         IN boolean := FALSE
                           )
   IS
      l_condiciones_especiales_rec condiciones_especiales_rt;
   BEGIN

      OPEN cond_es_rowid_cur(web_upd_rowid.p_condiciones_especiales_rec.row_id);

      FETCH cond_es_rowid_cur INTO l_condiciones_especiales_rec;

      IF cond_es_rowid_cur%NOTFOUND THEN
         CLOSE cond_es_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_upd_rowid.p_condiciones_especiales_rec.hash != l_condiciones_especiales_rec.hash THEN
            CLOSE cond_es_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(web_upd_rowid.p_ignore_nulls, FALSE)
            THEN
                UPDATE   condiciones_especiales
                   SET id_condicion = NVL(p_condiciones_especiales_rec.id_condicion,id_condicion),
                       descripcion = NVL(p_condiciones_especiales_rec.descripcion,descripcion),
                       descuento = NVL(p_condiciones_especiales_rec.descuento,descuento),
                       porcentaje = NVL(p_condiciones_especiales_rec.porcentaje,porcentaje)
               WHERE CURRENT OF cond_es_rowid_cur;
            ELSE
                UPDATE   condiciones_especiales
                   SET id_condicion = p_condiciones_especiales_rec.id_condicion,
                       descripcion = p_condiciones_especiales_rec.descripcion,
                       descuento = p_condiciones_especiales_rec.descuento,
                       porcentaje = p_condiciones_especiales_rec.porcentaje
               WHERE CURRENT OF cond_es_rowid_cur;
            END IF;

            CLOSE cond_es_rowid_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd_rowid;

    PROCEDURE del (
                  p_id_condicion IN condiciones_especiales.id_condicion%TYPE
                  )
    IS
    BEGIN

       DELETE FROM   condiciones_especiales
             WHERE
                  id_condicion = del.p_id_condicion
                   ;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del;

    PROCEDURE del_rowid (p_rowid IN varchar2)
    IS
    BEGIN

       DELETE FROM   condiciones_especiales
             WHERE   ROWID = del_rowid.p_rowid;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del_rowid;

    PROCEDURE web_del (
                      p_id_condicion IN condiciones_especiales.id_condicion%TYPE,
                      p_hash IN varchar2
                      )
   IS
      l_condiciones_especiales_rec condiciones_especiales_rt;
   BEGIN


      OPEN condiciones_especiales_cur(
                            web_del.p_id_condicion
                            );

      FETCH condiciones_especiales_cur INTO l_condiciones_especiales_rec;

      IF condiciones_especiales_cur%NOTFOUND THEN
         CLOSE condiciones_especiales_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del.p_hash != l_condiciones_especiales_rec.hash THEN
            CLOSE condiciones_especiales_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM condiciones_especiales
            WHERE CURRENT OF condiciones_especiales_cur;

            CLOSE condiciones_especiales_cur;
         END IF;
      END IF;



   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del;

   PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2)
   IS
      l_condiciones_especiales_rec condiciones_especiales_rt;
   BEGIN


      OPEN cond_es_rowid_cur(web_del_rowid.p_rowid);

      FETCH cond_es_rowid_cur INTO l_condiciones_especiales_rec;

      IF cond_es_rowid_cur%NOTFOUND THEN
         CLOSE cond_es_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del_rowid.p_hash != l_condiciones_especiales_rec.hash THEN
            CLOSE cond_es_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM condiciones_especiales
            WHERE CURRENT OF cond_es_rowid_cur;

            CLOSE cond_es_rowid_cur;
         END IF;
      END IF;

   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del_rowid;

END tapi_condiciones_especiales;

/
--------------------------------------------------------
--  DDL for Package Body TAPI_CTAXCOB
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."TAPI_CTAXCOB" IS

   /**
   * TAPI_CTAXCOB
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: 23-OCT-2019 08:56
   * Created By: FUNDAUC
   */


   --GLOBAL_PRIVATE_CURSORS
   --By PK
   CURSOR ctaxcob_cur (
                       p_id IN ctaxcob.id%TYPE
                       )
   IS
      SELECT
            id,
            cliente_id,
            fecha,
            factura_id,
            deposito_id,
            credito,
            monto,
            tapi_ctaxcob.hash(id),
            ROWID
      FROM ctaxcob
      WHERE
           id = ctaxcob_cur.p_id
      FOR UPDATE;

    --By Rowid
    CURSOR ctaxcob_rowid_cur (p_rowid IN VARCHAR2)
    IS
      SELECT
             id,
             cliente_id,
             fecha,
             factura_id,
             deposito_id,
             credito,
             monto,
             tapi_ctaxcob.hash(id),
             ROWID
      FROM ctaxcob
      WHERE ROWID = p_rowid
      FOR UPDATE;


    FUNCTION hash (
                  p_id IN ctaxcob.id%TYPE
                  )
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format VARCHAR2(64);
   BEGIN


     --Get actual NLS_DATE_FORMAT
     SELECT   VALUE
       INTO   l_date_format
       FROM   v$nls_parameters
      WHERE   parameter = 'NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            id||
            cliente_id||
            fecha||
            factura_id||
            deposito_id||
            credito||
            monto
      INTO l_string
      FROM ctaxcob
      WHERE
           id = hash.p_id
           ;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash;

    FUNCTION hash_rowid (p_rowid IN varchar2)
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format varchar2(64);
   BEGIN

      --Get actual NLS_DATE_FORMAT
      SELECT VALUE INTO l_date_format  FROM v$nls_parameters WHERE parameter ='NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            id||
            cliente_id||
            fecha||
            factura_id||
            deposito_id||
            credito||
            monto
      INTO l_string
      FROM ctaxcob
      WHERE  ROWID = hash_rowid.p_rowid;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash_rowid;

   FUNCTION rt (
               p_id IN ctaxcob.id%TYPE
               )
      RETURN ctaxcob_rt RESULT_CACHE
   IS
      l_ctaxcob_rec ctaxcob_rt;
   BEGIN

      SELECT a.*,
             tapi_ctaxcob.hash(id),
             rowid
      INTO l_ctaxcob_rec
      FROM ctaxcob a
      WHERE
           id = rt.p_id
           ;


      RETURN l_ctaxcob_rec;

   END rt;

   FUNCTION rt_for_update (
                          p_id IN ctaxcob.id%TYPE
                          )
      RETURN ctaxcob_rt RESULT_CACHE
   IS
      l_ctaxcob_rec ctaxcob_rt;
   BEGIN


      SELECT a.*,
             tapi_ctaxcob.hash(id),
             rowid
      INTO l_ctaxcob_rec
      FROM ctaxcob a
      WHERE
           id = rt_for_update.p_id
      FOR UPDATE;


      RETURN l_ctaxcob_rec;

   END rt_for_update;

    FUNCTION tt (
                p_id IN ctaxcob.id%TYPE DEFAULT NULL
                )
       RETURN ctaxcob_tt
       PIPELINED
    IS
       l_ctaxcob_rec   ctaxcob_rt;
    BEGIN

       FOR c1 IN (SELECT   a.*, ROWID
                    FROM   ctaxcob a
                   WHERE
                        id = NVL(tt.p_id,id)
                        )
       LOOP
              l_ctaxcob_rec.id := c1.id;
              l_ctaxcob_rec.cliente_id := c1.cliente_id;
              l_ctaxcob_rec.fecha := c1.fecha;
              l_ctaxcob_rec.factura_id := c1.factura_id;
              l_ctaxcob_rec.deposito_id := c1.deposito_id;
              l_ctaxcob_rec.credito := c1.credito;
              l_ctaxcob_rec.monto := c1.monto;
              l_ctaxcob_rec.hash := tapi_ctaxcob.hash( c1.id);
              l_ctaxcob_rec.row_id := c1.ROWID;
              PIPE ROW (l_ctaxcob_rec);
       END LOOP;

       RETURN;

    END tt;


    PROCEDURE ins (p_ctaxcob_rec IN OUT ctaxcob_rt)
    IS
        l_rowtype     ctaxcob%ROWTYPE;

    BEGIN


        l_rowtype.id := ins.p_ctaxcob_rec.id;
        l_rowtype.cliente_id := ins.p_ctaxcob_rec.cliente_id;
        l_rowtype.fecha := ins.p_ctaxcob_rec.fecha;
        l_rowtype.factura_id := ins.p_ctaxcob_rec.factura_id;
        l_rowtype.deposito_id := ins.p_ctaxcob_rec.deposito_id;
        l_rowtype.credito := ins.p_ctaxcob_rec.credito;
        l_rowtype.monto := ins.p_ctaxcob_rec.monto;

       INSERT INTO ctaxcob
          VALUES   l_rowtype
       RETURNING
                   id ,
                   cliente_id ,
                   fecha ,
                   factura_id ,
                   deposito_id ,
                   credito ,
                   monto 
            INTO   l_rowtype;

         ins.p_ctaxcob_rec.id := l_rowtype.id;
         ins.p_ctaxcob_rec.cliente_id := l_rowtype.cliente_id;
         ins.p_ctaxcob_rec.fecha := l_rowtype.fecha;
         ins.p_ctaxcob_rec.factura_id := l_rowtype.factura_id;
         ins.p_ctaxcob_rec.deposito_id := l_rowtype.deposito_id;
         ins.p_ctaxcob_rec.credito := l_rowtype.credito;
         ins.p_ctaxcob_rec.monto := l_rowtype.monto;



    END ins;

    PROCEDURE upd (
                  p_ctaxcob_rec         IN ctaxcob_rt,
                  p_ignore_nulls         IN boolean := FALSE
                  )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   ctaxcob
             SET id = NVL(p_ctaxcob_rec.id,id),
                cliente_id = NVL(p_ctaxcob_rec.cliente_id,cliente_id),
                fecha = NVL(p_ctaxcob_rec.fecha,fecha),
                factura_id = NVL(p_ctaxcob_rec.factura_id,factura_id),
                deposito_id = NVL(p_ctaxcob_rec.deposito_id,deposito_id),
                credito = NVL(p_ctaxcob_rec.credito,credito),
                monto = NVL(p_ctaxcob_rec.monto,monto)
           WHERE
                id = upd.p_ctaxcob_rec.id
                ;
       ELSE
          UPDATE   ctaxcob
             SET id = p_ctaxcob_rec.id,
                cliente_id = p_ctaxcob_rec.cliente_id,
                fecha = p_ctaxcob_rec.fecha,
                factura_id = p_ctaxcob_rec.factura_id,
                deposito_id = p_ctaxcob_rec.deposito_id,
                credito = p_ctaxcob_rec.credito,
                monto = p_ctaxcob_rec.monto
           WHERE
                id = upd.p_ctaxcob_rec.id
                ;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd;


    PROCEDURE upd_rowid (
                         p_ctaxcob_rec         IN ctaxcob_rt,
                         p_ignore_nulls         IN boolean := FALSE
                        )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   ctaxcob
             SET id = NVL(p_ctaxcob_rec.id,id),
                cliente_id = NVL(p_ctaxcob_rec.cliente_id,cliente_id),
                fecha = NVL(p_ctaxcob_rec.fecha,fecha),
                factura_id = NVL(p_ctaxcob_rec.factura_id,factura_id),
                deposito_id = NVL(p_ctaxcob_rec.deposito_id,deposito_id),
                credito = NVL(p_ctaxcob_rec.credito,credito),
                monto = NVL(p_ctaxcob_rec.monto,monto)
           WHERE  ROWID = p_ctaxcob_rec.row_id;
       ELSE
          UPDATE   ctaxcob
             SET id = p_ctaxcob_rec.id,
                cliente_id = p_ctaxcob_rec.cliente_id,
                fecha = p_ctaxcob_rec.fecha,
                factura_id = p_ctaxcob_rec.factura_id,
                deposito_id = p_ctaxcob_rec.deposito_id,
                credito = p_ctaxcob_rec.credito,
                monto = p_ctaxcob_rec.monto
           WHERE  ROWID = p_ctaxcob_rec.row_id;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd_rowid;

   PROCEDURE web_upd (
                  p_ctaxcob_rec         IN ctaxcob_rt,
                  p_ignore_nulls         IN boolean := FALSE
                )
   IS
      l_ctaxcob_rec ctaxcob_rt;
   BEGIN

      OPEN ctaxcob_cur(
                             web_upd.p_ctaxcob_rec.id
                        );

      FETCH ctaxcob_cur INTO l_ctaxcob_rec;

      IF ctaxcob_cur%NOTFOUND THEN
         CLOSE ctaxcob_cur;
         RAISE e_row_missing;
      ELSE
         IF p_ctaxcob_rec.hash != l_ctaxcob_rec.hash THEN
            CLOSE ctaxcob_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(p_ignore_nulls, FALSE)
            THEN

                UPDATE   ctaxcob
                   SET id = NVL(p_ctaxcob_rec.id,id),
                       cliente_id = NVL(p_ctaxcob_rec.cliente_id,cliente_id),
                       fecha = NVL(p_ctaxcob_rec.fecha,fecha),
                       factura_id = NVL(p_ctaxcob_rec.factura_id,factura_id),
                       deposito_id = NVL(p_ctaxcob_rec.deposito_id,deposito_id),
                       credito = NVL(p_ctaxcob_rec.credito,credito),
                       monto = NVL(p_ctaxcob_rec.monto,monto)
               WHERE CURRENT OF ctaxcob_cur;
            ELSE
                UPDATE   ctaxcob
                   SET id = p_ctaxcob_rec.id,
                       cliente_id = p_ctaxcob_rec.cliente_id,
                       fecha = p_ctaxcob_rec.fecha,
                       factura_id = p_ctaxcob_rec.factura_id,
                       deposito_id = p_ctaxcob_rec.deposito_id,
                       credito = p_ctaxcob_rec.credito,
                       monto = p_ctaxcob_rec.monto
               WHERE CURRENT OF ctaxcob_cur;
            END IF;

            CLOSE ctaxcob_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd;

   PROCEDURE web_upd_rowid (
                            p_ctaxcob_rec    IN ctaxcob_rt,
                            p_ignore_nulls         IN boolean := FALSE
                           )
   IS
      l_ctaxcob_rec ctaxcob_rt;
   BEGIN

      OPEN ctaxcob_rowid_cur(web_upd_rowid.p_ctaxcob_rec.row_id);

      FETCH ctaxcob_rowid_cur INTO l_ctaxcob_rec;

      IF ctaxcob_rowid_cur%NOTFOUND THEN
         CLOSE ctaxcob_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_upd_rowid.p_ctaxcob_rec.hash != l_ctaxcob_rec.hash THEN
            CLOSE ctaxcob_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(web_upd_rowid.p_ignore_nulls, FALSE)
            THEN
                UPDATE   ctaxcob
                   SET id = NVL(p_ctaxcob_rec.id,id),
                       cliente_id = NVL(p_ctaxcob_rec.cliente_id,cliente_id),
                       fecha = NVL(p_ctaxcob_rec.fecha,fecha),
                       factura_id = NVL(p_ctaxcob_rec.factura_id,factura_id),
                       deposito_id = NVL(p_ctaxcob_rec.deposito_id,deposito_id),
                       credito = NVL(p_ctaxcob_rec.credito,credito),
                       monto = NVL(p_ctaxcob_rec.monto,monto)
               WHERE CURRENT OF ctaxcob_rowid_cur;
            ELSE
                UPDATE   ctaxcob
                   SET id = p_ctaxcob_rec.id,
                       cliente_id = p_ctaxcob_rec.cliente_id,
                       fecha = p_ctaxcob_rec.fecha,
                       factura_id = p_ctaxcob_rec.factura_id,
                       deposito_id = p_ctaxcob_rec.deposito_id,
                       credito = p_ctaxcob_rec.credito,
                       monto = p_ctaxcob_rec.monto
               WHERE CURRENT OF ctaxcob_rowid_cur;
            END IF;

            CLOSE ctaxcob_rowid_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd_rowid;

    PROCEDURE del (
                  p_id IN ctaxcob.id%TYPE
                  )
    IS
    BEGIN

       DELETE FROM   ctaxcob
             WHERE
                  id = del.p_id
                   ;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del;

    PROCEDURE del_rowid (p_rowid IN varchar2)
    IS
    BEGIN

       DELETE FROM   ctaxcob
             WHERE   ROWID = del_rowid.p_rowid;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del_rowid;

    PROCEDURE web_del (
                      p_id IN ctaxcob.id%TYPE,
                      p_hash IN varchar2
                      )
   IS
      l_ctaxcob_rec ctaxcob_rt;
   BEGIN


      OPEN ctaxcob_cur(
                            web_del.p_id
                            );

      FETCH ctaxcob_cur INTO l_ctaxcob_rec;

      IF ctaxcob_cur%NOTFOUND THEN
         CLOSE ctaxcob_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del.p_hash != l_ctaxcob_rec.hash THEN
            CLOSE ctaxcob_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM ctaxcob
            WHERE CURRENT OF ctaxcob_cur;

            CLOSE ctaxcob_cur;
         END IF;
      END IF;



   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del;

   PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2)
   IS
      l_ctaxcob_rec ctaxcob_rt;
   BEGIN


      OPEN ctaxcob_rowid_cur(web_del_rowid.p_rowid);

      FETCH ctaxcob_rowid_cur INTO l_ctaxcob_rec;

      IF ctaxcob_rowid_cur%NOTFOUND THEN
         CLOSE ctaxcob_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del_rowid.p_hash != l_ctaxcob_rec.hash THEN
            CLOSE ctaxcob_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM ctaxcob
            WHERE CURRENT OF ctaxcob_rowid_cur;

            CLOSE ctaxcob_rowid_cur;
         END IF;
      END IF;

   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del_rowid;

END tapi_ctaxcob;

 

/
--------------------------------------------------------
--  DDL for Package Body TAPI_DEPOSITO
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."TAPI_DEPOSITO" IS

   /**
   * TAPI_DEPOSITO
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: 05-OCT-2019 09:51
   * Created By: FUNDAUC
   */


   --GLOBAL_PRIVATE_CURSORS
   --By PK
   CURSOR deposito_cur (
                       p_id IN deposito.id%TYPE
                       )
   IS
      SELECT
            referencia,
            fecha_emi,
            id_banco,
            monto,
            sede,
            usuario,
            status,
            forma_pago,
            id,
            tapi_deposito.hash(id),
            ROWID
      FROM deposito
      WHERE
           id = deposito_cur.p_id
      FOR UPDATE;

    --By Rowid
    CURSOR deposito_rowid_cur (p_rowid IN VARCHAR2)
    IS
      SELECT
             referencia,
             fecha_emi,
             id_banco,
             monto,
             sede,
             usuario,
             status,
             forma_pago,
             id,
             tapi_deposito.hash(id),
             ROWID
      FROM deposito
      WHERE ROWID = p_rowid
      FOR UPDATE;


    FUNCTION hash (
                  p_id IN deposito.id%TYPE
                  )
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format VARCHAR2(64);
   BEGIN


     --Get actual NLS_DATE_FORMAT
     SELECT   VALUE
       INTO   l_date_format
       FROM   v$nls_parameters
      WHERE   parameter = 'NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            referencia||
            fecha_emi||
            id_banco||
            monto||
            sede||
            usuario||
            status||
            forma_pago||
            id
      INTO l_string
      FROM deposito
      WHERE
           id = hash.p_id
           ;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash;

    FUNCTION hash_rowid (p_rowid IN varchar2)
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format varchar2(64);
   BEGIN

      --Get actual NLS_DATE_FORMAT
      SELECT VALUE INTO l_date_format  FROM v$nls_parameters WHERE parameter ='NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            referencia||
            fecha_emi||
            id_banco||
            monto||
            sede||
            usuario||
            status||
            forma_pago||
            id
      INTO l_string
      FROM deposito
      WHERE  ROWID = hash_rowid.p_rowid;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash_rowid;

   FUNCTION rt (
               p_id IN deposito.id%TYPE
               )
      RETURN deposito_rt RESULT_CACHE
   IS
      l_deposito_rec deposito_rt;
   BEGIN

      SELECT a.*,
             tapi_deposito.hash(id),
             rowid
      INTO l_deposito_rec
      FROM deposito a
      WHERE
           id = rt.p_id
           ;


      RETURN l_deposito_rec;

   END rt;

   FUNCTION rt_for_update (
                          p_id IN deposito.id%TYPE
                          )
      RETURN deposito_rt RESULT_CACHE
   IS
      l_deposito_rec deposito_rt;
   BEGIN


      SELECT a.*,
             tapi_deposito.hash(id),
             rowid
      INTO l_deposito_rec
      FROM deposito a
      WHERE
           id = rt_for_update.p_id
      FOR UPDATE;


      RETURN l_deposito_rec;

   END rt_for_update;

    FUNCTION tt (
                p_id IN deposito.id%TYPE DEFAULT NULL
                )
       RETURN deposito_tt
       PIPELINED
    IS
       l_deposito_rec   deposito_rt;
    BEGIN

       FOR c1 IN (SELECT   a.*, ROWID
                    FROM   deposito a
                   WHERE
                        id = NVL(tt.p_id,id)
                        )
       LOOP
              l_deposito_rec.referencia := c1.referencia;
              l_deposito_rec.fecha_emi := c1.fecha_emi;
              l_deposito_rec.id_banco := c1.id_banco;
              l_deposito_rec.monto := c1.monto;
              l_deposito_rec.sede := c1.sede;
              l_deposito_rec.usuario := c1.usuario;
              l_deposito_rec.status := c1.status;
              l_deposito_rec.forma_pago := c1.forma_pago;
              l_deposito_rec.id := c1.id;
              l_deposito_rec.hash := tapi_deposito.hash( c1.id);
              l_deposito_rec.row_id := c1.ROWID;
              PIPE ROW (l_deposito_rec);
       END LOOP;

       RETURN;

    END tt;


    PROCEDURE ins (p_deposito_rec IN OUT deposito_rt)
    IS
        l_rowtype     deposito%ROWTYPE;

    BEGIN


        l_rowtype.referencia := ins.p_deposito_rec.referencia;
        l_rowtype.fecha_emi := ins.p_deposito_rec.fecha_emi;
        l_rowtype.id_banco := ins.p_deposito_rec.id_banco;
        l_rowtype.monto := ins.p_deposito_rec.monto;
        l_rowtype.sede := ins.p_deposito_rec.sede;
        l_rowtype.usuario := ins.p_deposito_rec.usuario;
        l_rowtype.status := ins.p_deposito_rec.status;
        l_rowtype.forma_pago := ins.p_deposito_rec.forma_pago;
        l_rowtype.id := ins.p_deposito_rec.id;

       INSERT INTO deposito
          VALUES   l_rowtype
       RETURNING
                   referencia ,
                   fecha_emi ,
                   id_banco ,
                   monto ,
                   sede ,
                   usuario ,
                   status ,
                   forma_pago ,
                   id 
            INTO   l_rowtype;

         ins.p_deposito_rec.referencia := l_rowtype.referencia;
         ins.p_deposito_rec.fecha_emi := l_rowtype.fecha_emi;
         ins.p_deposito_rec.id_banco := l_rowtype.id_banco;
         ins.p_deposito_rec.monto := l_rowtype.monto;
         ins.p_deposito_rec.sede := l_rowtype.sede;
         ins.p_deposito_rec.usuario := l_rowtype.usuario;
         ins.p_deposito_rec.status := l_rowtype.status;
         ins.p_deposito_rec.forma_pago := l_rowtype.forma_pago;
         ins.p_deposito_rec.id := l_rowtype.id;



    END ins;

    PROCEDURE upd (
                  p_deposito_rec         IN deposito_rt,
                  p_ignore_nulls         IN boolean := FALSE
                  )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   deposito
             SET referencia = NVL(p_deposito_rec.referencia,referencia),
                fecha_emi = NVL(p_deposito_rec.fecha_emi,fecha_emi),
                id_banco = NVL(p_deposito_rec.id_banco,id_banco),
                monto = NVL(p_deposito_rec.monto,monto),
                sede = NVL(p_deposito_rec.sede,sede),
                usuario = NVL(p_deposito_rec.usuario,usuario),
                status = NVL(p_deposito_rec.status,status),
                forma_pago = NVL(p_deposito_rec.forma_pago,forma_pago),
                id = NVL(p_deposito_rec.id,id)
           WHERE
                id = upd.p_deposito_rec.id
                ;
       ELSE
          UPDATE   deposito
             SET referencia = p_deposito_rec.referencia,
                fecha_emi = p_deposito_rec.fecha_emi,
                id_banco = p_deposito_rec.id_banco,
                monto = p_deposito_rec.monto,
                sede = p_deposito_rec.sede,
                usuario = p_deposito_rec.usuario,
                status = p_deposito_rec.status,
                forma_pago = p_deposito_rec.forma_pago,
                id = p_deposito_rec.id
           WHERE
                id = upd.p_deposito_rec.id
                ;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd;


    PROCEDURE upd_rowid (
                         p_deposito_rec         IN deposito_rt,
                         p_ignore_nulls         IN boolean := FALSE
                        )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   deposito
             SET referencia = NVL(p_deposito_rec.referencia,referencia),
                fecha_emi = NVL(p_deposito_rec.fecha_emi,fecha_emi),
                id_banco = NVL(p_deposito_rec.id_banco,id_banco),
                monto = NVL(p_deposito_rec.monto,monto),
                sede = NVL(p_deposito_rec.sede,sede),
                usuario = NVL(p_deposito_rec.usuario,usuario),
                status = NVL(p_deposito_rec.status,status),
                forma_pago = NVL(p_deposito_rec.forma_pago,forma_pago),
                id = NVL(p_deposito_rec.id,id)
           WHERE  ROWID = p_deposito_rec.row_id;
       ELSE
          UPDATE   deposito
             SET referencia = p_deposito_rec.referencia,
                fecha_emi = p_deposito_rec.fecha_emi,
                id_banco = p_deposito_rec.id_banco,
                monto = p_deposito_rec.monto,
                sede = p_deposito_rec.sede,
                usuario = p_deposito_rec.usuario,
                status = p_deposito_rec.status,
                forma_pago = p_deposito_rec.forma_pago,
                id = p_deposito_rec.id
           WHERE  ROWID = p_deposito_rec.row_id;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd_rowid;

   PROCEDURE web_upd (
                  p_deposito_rec         IN deposito_rt,
                  p_ignore_nulls         IN boolean := FALSE
                )
   IS
      l_deposito_rec deposito_rt;
   BEGIN

      OPEN deposito_cur(
                             web_upd.p_deposito_rec.id
                        );

      FETCH deposito_cur INTO l_deposito_rec;

      IF deposito_cur%NOTFOUND THEN
         CLOSE deposito_cur;
         RAISE e_row_missing;
      ELSE
         IF p_deposito_rec.hash != l_deposito_rec.hash THEN
            CLOSE deposito_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(p_ignore_nulls, FALSE)
            THEN

                UPDATE   deposito
                   SET referencia = NVL(p_deposito_rec.referencia,referencia),
                       fecha_emi = NVL(p_deposito_rec.fecha_emi,fecha_emi),
                       id_banco = NVL(p_deposito_rec.id_banco,id_banco),
                       monto = NVL(p_deposito_rec.monto,monto),
                       sede = NVL(p_deposito_rec.sede,sede),
                       usuario = NVL(p_deposito_rec.usuario,usuario),
                       status = NVL(p_deposito_rec.status,status),
                       forma_pago = NVL(p_deposito_rec.forma_pago,forma_pago),
                       id = NVL(p_deposito_rec.id,id)
               WHERE CURRENT OF deposito_cur;
            ELSE
                UPDATE   deposito
                   SET referencia = p_deposito_rec.referencia,
                       fecha_emi = p_deposito_rec.fecha_emi,
                       id_banco = p_deposito_rec.id_banco,
                       monto = p_deposito_rec.monto,
                       sede = p_deposito_rec.sede,
                       usuario = p_deposito_rec.usuario,
                       status = p_deposito_rec.status,
                       forma_pago = p_deposito_rec.forma_pago,
                       id = p_deposito_rec.id
               WHERE CURRENT OF deposito_cur;
            END IF;

            CLOSE deposito_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd;

   PROCEDURE web_upd_rowid (
                            p_deposito_rec    IN deposito_rt,
                            p_ignore_nulls         IN boolean := FALSE
                           )
   IS
      l_deposito_rec deposito_rt;
   BEGIN

      OPEN deposito_rowid_cur(web_upd_rowid.p_deposito_rec.row_id);

      FETCH deposito_rowid_cur INTO l_deposito_rec;

      IF deposito_rowid_cur%NOTFOUND THEN
         CLOSE deposito_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_upd_rowid.p_deposito_rec.hash != l_deposito_rec.hash THEN
            CLOSE deposito_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(web_upd_rowid.p_ignore_nulls, FALSE)
            THEN
                UPDATE   deposito
                   SET referencia = NVL(p_deposito_rec.referencia,referencia),
                       fecha_emi = NVL(p_deposito_rec.fecha_emi,fecha_emi),
                       id_banco = NVL(p_deposito_rec.id_banco,id_banco),
                       monto = NVL(p_deposito_rec.monto,monto),
                       sede = NVL(p_deposito_rec.sede,sede),
                       usuario = NVL(p_deposito_rec.usuario,usuario),
                       status = NVL(p_deposito_rec.status,status),
                       forma_pago = NVL(p_deposito_rec.forma_pago,forma_pago),
                       id = NVL(p_deposito_rec.id,id)
               WHERE CURRENT OF deposito_rowid_cur;
            ELSE
                UPDATE   deposito
                   SET referencia = p_deposito_rec.referencia,
                       fecha_emi = p_deposito_rec.fecha_emi,
                       id_banco = p_deposito_rec.id_banco,
                       monto = p_deposito_rec.monto,
                       sede = p_deposito_rec.sede,
                       usuario = p_deposito_rec.usuario,
                       status = p_deposito_rec.status,
                       forma_pago = p_deposito_rec.forma_pago,
                       id = p_deposito_rec.id
               WHERE CURRENT OF deposito_rowid_cur;
            END IF;

            CLOSE deposito_rowid_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd_rowid;

    PROCEDURE del (
                  p_id IN deposito.id%TYPE
                  )
    IS
    BEGIN

       DELETE FROM   deposito
             WHERE
                  id = del.p_id
                   ;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del;

    PROCEDURE del_rowid (p_rowid IN varchar2)
    IS
    BEGIN

       DELETE FROM   deposito
             WHERE   ROWID = del_rowid.p_rowid;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del_rowid;

    PROCEDURE web_del (
                      p_id IN deposito.id%TYPE,
                      p_hash IN varchar2
                      )
   IS
      l_deposito_rec deposito_rt;
   BEGIN


      OPEN deposito_cur(
                            web_del.p_id
                            );

      FETCH deposito_cur INTO l_deposito_rec;

      IF deposito_cur%NOTFOUND THEN
         CLOSE deposito_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del.p_hash != l_deposito_rec.hash THEN
            CLOSE deposito_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM deposito
            WHERE CURRENT OF deposito_cur;

            CLOSE deposito_cur;
         END IF;
      END IF;



   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del;

   PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2)
   IS
      l_deposito_rec deposito_rt;
   BEGIN


      OPEN deposito_rowid_cur(web_del_rowid.p_rowid);

      FETCH deposito_rowid_cur INTO l_deposito_rec;

      IF deposito_rowid_cur%NOTFOUND THEN
         CLOSE deposito_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del_rowid.p_hash != l_deposito_rec.hash THEN
            CLOSE deposito_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM deposito
            WHERE CURRENT OF deposito_rowid_cur;

            CLOSE deposito_rowid_cur;
         END IF;
      END IF;

   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del_rowid;

END tapi_deposito;

 

/
--------------------------------------------------------
--  DDL for Package Body TAPI_DETALLE_FACTURA
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."TAPI_DETALLE_FACTURA" IS

   /**
   * TAPI_DETALLE_FACTURA
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: 25-FEB-2020 18:39
   * Created By: FUNDAUC
   */


   --GLOBAL_PRIVATE_CURSORS
   --By PK
   CURSOR detalle_factura_cur (
                       p_renglon IN detalle_factura.renglon%TYPE
                       )
   IS
      SELECT
            renglon,
            tipo_item,
            item,
            descripcion,
            cantidad,
            p_unidad,
            bs_descuento,
            subtotal,
            materiales_id,
            factura_id,
            tapi_detalle_factura.hash(renglon),
            ROWID
      FROM detalle_factura
      WHERE
           renglon = detalle_factura_cur.p_renglon
      FOR UPDATE;

    --By Rowid
    CURSOR detalle_factura_rowid_cur (p_rowid IN VARCHAR2)
    IS
      SELECT
             renglon,
             tipo_item,
             item,
             descripcion,
             cantidad,
             p_unidad,
             bs_descuento,
             subtotal,
             materiales_id,
             factura_id,
             tapi_detalle_factura.hash(renglon),
             ROWID
      FROM detalle_factura
      WHERE ROWID = p_rowid
      FOR UPDATE;


    FUNCTION hash (
                  p_renglon IN detalle_factura.renglon%TYPE
                  )
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format VARCHAR2(64);
   BEGIN


     --Get actual NLS_DATE_FORMAT
     SELECT   VALUE
       INTO   l_date_format
       FROM   v$nls_parameters
      WHERE   parameter = 'NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            renglon||
            tipo_item||
            item||
            descripcion||
            cantidad||
            p_unidad||
            bs_descuento||
            subtotal||
            materiales_id||
            factura_id
      INTO l_string
      FROM detalle_factura
      WHERE
           renglon = hash.p_renglon
           ;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash;

    FUNCTION hash_rowid (p_rowid IN varchar2)
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format varchar2(64);
   BEGIN

      --Get actual NLS_DATE_FORMAT
      SELECT VALUE INTO l_date_format  FROM v$nls_parameters WHERE parameter ='NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            renglon||
            tipo_item||
            item||
            descripcion||
            cantidad||
            p_unidad||
            bs_descuento||
            subtotal||
            materiales_id||
            factura_id
      INTO l_string
      FROM detalle_factura
      WHERE  ROWID = hash_rowid.p_rowid;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash_rowid;

   FUNCTION rt (
               p_renglon IN detalle_factura.renglon%TYPE
               )
      RETURN detalle_factura_rt RESULT_CACHE
   IS
      l_detalle_factura_rec detalle_factura_rt;
   BEGIN

      SELECT a.*,
             tapi_detalle_factura.hash(renglon),
             rowid
      INTO l_detalle_factura_rec
      FROM detalle_factura a
      WHERE
           renglon = rt.p_renglon
           ;


      RETURN l_detalle_factura_rec;

   END rt;

   FUNCTION rt_for_update (
                          p_renglon IN detalle_factura.renglon%TYPE
                          )
      RETURN detalle_factura_rt RESULT_CACHE
   IS
      l_detalle_factura_rec detalle_factura_rt;
   BEGIN


      SELECT a.*,
             tapi_detalle_factura.hash(renglon),
             rowid
      INTO l_detalle_factura_rec
      FROM detalle_factura a
      WHERE
           renglon = rt_for_update.p_renglon
      FOR UPDATE;


      RETURN l_detalle_factura_rec;

   END rt_for_update;

    FUNCTION tt (
                p_renglon IN detalle_factura.renglon%TYPE DEFAULT NULL
                )
       RETURN detalle_factura_tt
       PIPELINED
    IS
       l_detalle_factura_rec   detalle_factura_rt;
    BEGIN

       FOR c1 IN (SELECT   a.*, ROWID
                    FROM   detalle_factura a
                   WHERE
                        renglon = NVL(tt.p_renglon,renglon)
                        )
       LOOP
              l_detalle_factura_rec.renglon := c1.renglon;
              l_detalle_factura_rec.tipo_item := c1.tipo_item;
              l_detalle_factura_rec.item := c1.item;
              l_detalle_factura_rec.descripcion := c1.descripcion;
              l_detalle_factura_rec.cantidad := c1.cantidad;
              l_detalle_factura_rec.p_unidad := c1.p_unidad;
              l_detalle_factura_rec.bs_descuento := c1.bs_descuento;
              l_detalle_factura_rec.subtotal := c1.subtotal;
              l_detalle_factura_rec.materiales_id := c1.materiales_id;
              l_detalle_factura_rec.factura_id := c1.factura_id;
              l_detalle_factura_rec.hash := tapi_detalle_factura.hash( c1.renglon);
              l_detalle_factura_rec.row_id := c1.ROWID;
              PIPE ROW (l_detalle_factura_rec);
       END LOOP;

       RETURN;

    END tt;


    PROCEDURE ins (p_detalle_factura_rec IN OUT detalle_factura_rt)
    IS
        l_rowtype     detalle_factura%ROWTYPE;

    BEGIN


        l_rowtype.renglon := ins.p_detalle_factura_rec.renglon;
        l_rowtype.tipo_item := ins.p_detalle_factura_rec.tipo_item;
        l_rowtype.item := ins.p_detalle_factura_rec.item;
        l_rowtype.descripcion := ins.p_detalle_factura_rec.descripcion;
        l_rowtype.cantidad := ins.p_detalle_factura_rec.cantidad;
        l_rowtype.p_unidad := ins.p_detalle_factura_rec.p_unidad;
        l_rowtype.bs_descuento := ins.p_detalle_factura_rec.bs_descuento;
        l_rowtype.subtotal := ins.p_detalle_factura_rec.subtotal;
        l_rowtype.materiales_id := ins.p_detalle_factura_rec.materiales_id;
        l_rowtype.factura_id := ins.p_detalle_factura_rec.factura_id;

       INSERT INTO detalle_factura
          VALUES   l_rowtype
       RETURNING
                   renglon ,
                   tipo_item ,
                   item ,
                   descripcion ,
                   cantidad ,
                   p_unidad ,
                   bs_descuento ,
                   subtotal ,
                   materiales_id ,
                   factura_id 
            INTO   l_rowtype;

         ins.p_detalle_factura_rec.renglon := l_rowtype.renglon;
         ins.p_detalle_factura_rec.tipo_item := l_rowtype.tipo_item;
         ins.p_detalle_factura_rec.item := l_rowtype.item;
         ins.p_detalle_factura_rec.descripcion := l_rowtype.descripcion;
         ins.p_detalle_factura_rec.cantidad := l_rowtype.cantidad;
         ins.p_detalle_factura_rec.p_unidad := l_rowtype.p_unidad;
         ins.p_detalle_factura_rec.bs_descuento := l_rowtype.bs_descuento;
         ins.p_detalle_factura_rec.subtotal := l_rowtype.subtotal;
         ins.p_detalle_factura_rec.materiales_id := l_rowtype.materiales_id;
         ins.p_detalle_factura_rec.factura_id := l_rowtype.factura_id;



    END ins;

    PROCEDURE upd (
                  p_detalle_factura_rec         IN detalle_factura_rt,
                  p_ignore_nulls         IN boolean := FALSE
                  )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   detalle_factura
             SET renglon = NVL(p_detalle_factura_rec.renglon,renglon),
                tipo_item = NVL(p_detalle_factura_rec.tipo_item,tipo_item),
                item = NVL(p_detalle_factura_rec.item,item),
                descripcion = NVL(p_detalle_factura_rec.descripcion,descripcion),
                cantidad = NVL(p_detalle_factura_rec.cantidad,cantidad),
                p_unidad = NVL(p_detalle_factura_rec.p_unidad,p_unidad),
                bs_descuento = NVL(p_detalle_factura_rec.bs_descuento,bs_descuento),
                subtotal = NVL(p_detalle_factura_rec.subtotal,subtotal),
                materiales_id = NVL(p_detalle_factura_rec.materiales_id,materiales_id),
                factura_id = NVL(p_detalle_factura_rec.factura_id,factura_id)
           WHERE
                renglon = upd.p_detalle_factura_rec.renglon
                ;
       ELSE
          UPDATE   detalle_factura
             SET renglon = p_detalle_factura_rec.renglon,
                tipo_item = p_detalle_factura_rec.tipo_item,
                item = p_detalle_factura_rec.item,
                descripcion = p_detalle_factura_rec.descripcion,
                cantidad = p_detalle_factura_rec.cantidad,
                p_unidad = p_detalle_factura_rec.p_unidad,
                bs_descuento = p_detalle_factura_rec.bs_descuento,
                subtotal = p_detalle_factura_rec.subtotal,
                materiales_id = p_detalle_factura_rec.materiales_id,
                factura_id = p_detalle_factura_rec.factura_id
           WHERE
                renglon = upd.p_detalle_factura_rec.renglon
                ;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd;


    PROCEDURE upd_rowid (
                         p_detalle_factura_rec         IN detalle_factura_rt,
                         p_ignore_nulls         IN boolean := FALSE
                        )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   detalle_factura
             SET renglon = NVL(p_detalle_factura_rec.renglon,renglon),
                tipo_item = NVL(p_detalle_factura_rec.tipo_item,tipo_item),
                item = NVL(p_detalle_factura_rec.item,item),
                descripcion = NVL(p_detalle_factura_rec.descripcion,descripcion),
                cantidad = NVL(p_detalle_factura_rec.cantidad,cantidad),
                p_unidad = NVL(p_detalle_factura_rec.p_unidad,p_unidad),
                bs_descuento = NVL(p_detalle_factura_rec.bs_descuento,bs_descuento),
                subtotal = NVL(p_detalle_factura_rec.subtotal,subtotal),
                materiales_id = NVL(p_detalle_factura_rec.materiales_id,materiales_id),
                factura_id = NVL(p_detalle_factura_rec.factura_id,factura_id)
           WHERE  ROWID = p_detalle_factura_rec.row_id;
       ELSE
          UPDATE   detalle_factura
             SET renglon = p_detalle_factura_rec.renglon,
                tipo_item = p_detalle_factura_rec.tipo_item,
                item = p_detalle_factura_rec.item,
                descripcion = p_detalle_factura_rec.descripcion,
                cantidad = p_detalle_factura_rec.cantidad,
                p_unidad = p_detalle_factura_rec.p_unidad,
                bs_descuento = p_detalle_factura_rec.bs_descuento,
                subtotal = p_detalle_factura_rec.subtotal,
                materiales_id = p_detalle_factura_rec.materiales_id,
                factura_id = p_detalle_factura_rec.factura_id
           WHERE  ROWID = p_detalle_factura_rec.row_id;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd_rowid;

   PROCEDURE web_upd (
                  p_detalle_factura_rec         IN detalle_factura_rt,
                  p_ignore_nulls         IN boolean := FALSE
                )
   IS
      l_detalle_factura_rec detalle_factura_rt;
   BEGIN

      OPEN detalle_factura_cur(
                             web_upd.p_detalle_factura_rec.renglon
                        );

      FETCH detalle_factura_cur INTO l_detalle_factura_rec;

      IF detalle_factura_cur%NOTFOUND THEN
         CLOSE detalle_factura_cur;
         RAISE e_row_missing;
      ELSE
         IF p_detalle_factura_rec.hash != l_detalle_factura_rec.hash THEN
            CLOSE detalle_factura_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(p_ignore_nulls, FALSE)
            THEN

                UPDATE   detalle_factura
                   SET renglon = NVL(p_detalle_factura_rec.renglon,renglon),
                       tipo_item = NVL(p_detalle_factura_rec.tipo_item,tipo_item),
                       item = NVL(p_detalle_factura_rec.item,item),
                       descripcion = NVL(p_detalle_factura_rec.descripcion,descripcion),
                       cantidad = NVL(p_detalle_factura_rec.cantidad,cantidad),
                       p_unidad = NVL(p_detalle_factura_rec.p_unidad,p_unidad),
                       bs_descuento = NVL(p_detalle_factura_rec.bs_descuento,bs_descuento),
                       subtotal = NVL(p_detalle_factura_rec.subtotal,subtotal),
                       materiales_id = NVL(p_detalle_factura_rec.materiales_id,materiales_id),
                       factura_id = NVL(p_detalle_factura_rec.factura_id,factura_id)
               WHERE CURRENT OF detalle_factura_cur;
            ELSE
                UPDATE   detalle_factura
                   SET renglon = p_detalle_factura_rec.renglon,
                       tipo_item = p_detalle_factura_rec.tipo_item,
                       item = p_detalle_factura_rec.item,
                       descripcion = p_detalle_factura_rec.descripcion,
                       cantidad = p_detalle_factura_rec.cantidad,
                       p_unidad = p_detalle_factura_rec.p_unidad,
                       bs_descuento = p_detalle_factura_rec.bs_descuento,
                       subtotal = p_detalle_factura_rec.subtotal,
                       materiales_id = p_detalle_factura_rec.materiales_id,
                       factura_id = p_detalle_factura_rec.factura_id
               WHERE CURRENT OF detalle_factura_cur;
            END IF;

            CLOSE detalle_factura_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd;

   PROCEDURE web_upd_rowid (
                            p_detalle_factura_rec    IN detalle_factura_rt,
                            p_ignore_nulls         IN boolean := FALSE
                           )
   IS
      l_detalle_factura_rec detalle_factura_rt;
   BEGIN

      OPEN detalle_factura_rowid_cur(web_upd_rowid.p_detalle_factura_rec.row_id);

      FETCH detalle_factura_rowid_cur INTO l_detalle_factura_rec;

      IF detalle_factura_rowid_cur%NOTFOUND THEN
         CLOSE detalle_factura_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_upd_rowid.p_detalle_factura_rec.hash != l_detalle_factura_rec.hash THEN
            CLOSE detalle_factura_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(web_upd_rowid.p_ignore_nulls, FALSE)
            THEN
                UPDATE   detalle_factura
                   SET renglon = NVL(p_detalle_factura_rec.renglon,renglon),
                       tipo_item = NVL(p_detalle_factura_rec.tipo_item,tipo_item),
                       item = NVL(p_detalle_factura_rec.item,item),
                       descripcion = NVL(p_detalle_factura_rec.descripcion,descripcion),
                       cantidad = NVL(p_detalle_factura_rec.cantidad,cantidad),
                       p_unidad = NVL(p_detalle_factura_rec.p_unidad,p_unidad),
                       bs_descuento = NVL(p_detalle_factura_rec.bs_descuento,bs_descuento),
                       subtotal = NVL(p_detalle_factura_rec.subtotal,subtotal),
                       materiales_id = NVL(p_detalle_factura_rec.materiales_id,materiales_id),
                       factura_id = NVL(p_detalle_factura_rec.factura_id,factura_id)
               WHERE CURRENT OF detalle_factura_rowid_cur;
            ELSE
                UPDATE   detalle_factura
                   SET renglon = p_detalle_factura_rec.renglon,
                       tipo_item = p_detalle_factura_rec.tipo_item,
                       item = p_detalle_factura_rec.item,
                       descripcion = p_detalle_factura_rec.descripcion,
                       cantidad = p_detalle_factura_rec.cantidad,
                       p_unidad = p_detalle_factura_rec.p_unidad,
                       bs_descuento = p_detalle_factura_rec.bs_descuento,
                       subtotal = p_detalle_factura_rec.subtotal,
                       materiales_id = p_detalle_factura_rec.materiales_id,
                       factura_id = p_detalle_factura_rec.factura_id
               WHERE CURRENT OF detalle_factura_rowid_cur;
            END IF;

            CLOSE detalle_factura_rowid_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd_rowid;

    PROCEDURE del (
                  p_renglon IN detalle_factura.renglon%TYPE
                  )
    IS
    BEGIN

       DELETE FROM   detalle_factura
             WHERE
                  renglon = del.p_renglon
                   ;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del;

    PROCEDURE del_rowid (p_rowid IN varchar2)
    IS
    BEGIN

       DELETE FROM   detalle_factura
             WHERE   ROWID = del_rowid.p_rowid;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del_rowid;

    PROCEDURE web_del (
                      p_renglon IN detalle_factura.renglon%TYPE,
                      p_hash IN varchar2
                      )
   IS
      l_detalle_factura_rec detalle_factura_rt;
   BEGIN


      OPEN detalle_factura_cur(
                            web_del.p_renglon
                            );

      FETCH detalle_factura_cur INTO l_detalle_factura_rec;

      IF detalle_factura_cur%NOTFOUND THEN
         CLOSE detalle_factura_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del.p_hash != l_detalle_factura_rec.hash THEN
            CLOSE detalle_factura_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM detalle_factura
            WHERE CURRENT OF detalle_factura_cur;

            CLOSE detalle_factura_cur;
         END IF;
      END IF;



   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del;

   PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2)
   IS
      l_detalle_factura_rec detalle_factura_rt;
   BEGIN


      OPEN detalle_factura_rowid_cur(web_del_rowid.p_rowid);

      FETCH detalle_factura_rowid_cur INTO l_detalle_factura_rec;

      IF detalle_factura_rowid_cur%NOTFOUND THEN
         CLOSE detalle_factura_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del_rowid.p_hash != l_detalle_factura_rec.hash THEN
            CLOSE detalle_factura_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM detalle_factura
            WHERE CURRENT OF detalle_factura_rowid_cur;

            CLOSE detalle_factura_rowid_cur;
         END IF;
      END IF;

   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del_rowid;

END tapi_detalle_factura;

 

/
--------------------------------------------------------
--  DDL for Package Body TAPI_ESTUDIANTE
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."TAPI_ESTUDIANTE" IS

   /**
   * TAPI_ESTUDIANTE
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: 13-SEP-2019 10:24
   * Created By: FUNDAUC
   */


   --GLOBAL_PRIVATE_CURSORS
   --By PK
   CURSOR estudiante_cur (
                       p_matricula IN estudiante.matricula%TYPE
                       )
   IS
      SELECT
            cedula_est,
            nacionalidad,
            nombre,
            telf_hab,
            telf_cel,
            ciudad,
            estado,
            email,
            sexo,
            edo_civil,
            grado_ins,
            profesion,
            fecha_nac,
            status,
            id_tipo_est,
            rif,
            matricula,
            sede,
            condicion_especial,
            apellido,
            zona,
            cedula_rep,
            direccion,
            creado_por,
            creado_el,
            modificado_por,
            modificado_el,
            tapi_estudiante.hash(matricula),
            ROWID
      FROM estudiante
      WHERE
           matricula = estudiante_cur.p_matricula
      FOR UPDATE;

    --By Rowid
    CURSOR estudiante_rowid_cur (p_rowid IN VARCHAR2)
    IS
      SELECT
             cedula_est,
             nacionalidad,
             nombre,
             telf_hab,
             telf_cel,
             ciudad,
             estado,
             email,
             sexo,
             edo_civil,
             grado_ins,
             profesion,
             fecha_nac,
             status,
             id_tipo_est,
             rif,
             matricula,
             sede,
             condicion_especial,
             apellido,
             zona,
             cedula_rep,
             direccion,
             creado_por,
             creado_el,
             modificado_por,
             modificado_el,
             tapi_estudiante.hash(matricula),
             ROWID
      FROM estudiante
      WHERE ROWID = p_rowid
      FOR UPDATE;


    FUNCTION hash (
                  p_matricula IN estudiante.matricula%TYPE
                  )
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format VARCHAR2(64);
   BEGIN


     --Get actual NLS_DATE_FORMAT
     SELECT   VALUE
       INTO   l_date_format
       FROM   v$nls_parameters
      WHERE   parameter = 'NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            cedula_est||
            nacionalidad||
            nombre||
            telf_hab||
            telf_cel||
            ciudad||
            estado||
            email||
            sexo||
            edo_civil||
            grado_ins||
            profesion||
            fecha_nac||
            status||
            id_tipo_est||
            rif||
            matricula||
            sede||
            condicion_especial||
            apellido||
            zona||
            cedula_rep||
            direccion||
            creado_por||
            creado_el||
            modificado_por||
            modificado_el
      INTO l_string
      FROM estudiante
      WHERE
           matricula = hash.p_matricula
           ;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash;

    FUNCTION hash_rowid (p_rowid IN varchar2)
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format varchar2(64);
   BEGIN

      --Get actual NLS_DATE_FORMAT
      SELECT VALUE INTO l_date_format  FROM v$nls_parameters WHERE parameter ='NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            cedula_est||
            nacionalidad||
            nombre||
            telf_hab||
            telf_cel||
            ciudad||
            estado||
            email||
            sexo||
            edo_civil||
            grado_ins||
            profesion||
            fecha_nac||
            status||
            id_tipo_est||
            rif||
            matricula||
            sede||
            condicion_especial||
            apellido||
            zona||
            cedula_rep||
            direccion||
            creado_por||
            creado_el||
            modificado_por||
            modificado_el
      INTO l_string
      FROM estudiante
      WHERE  ROWID = hash_rowid.p_rowid;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash_rowid;

   FUNCTION rt (
               p_matricula IN estudiante.matricula%TYPE
               )
      RETURN estudiante_rt RESULT_CACHE
   IS
      l_estudiante_rec estudiante_rt;
   BEGIN

      SELECT a.*,
             tapi_estudiante.hash(matricula),
             rowid
      INTO l_estudiante_rec
      FROM estudiante a
      WHERE
           matricula = rt.p_matricula
           ;


      RETURN l_estudiante_rec;

   END rt;

   FUNCTION rt_for_update (
                          p_matricula IN estudiante.matricula%TYPE
                          )
      RETURN estudiante_rt RESULT_CACHE
   IS
      l_estudiante_rec estudiante_rt;
   BEGIN


      SELECT a.*,
             tapi_estudiante.hash(matricula),
             rowid
      INTO l_estudiante_rec
      FROM estudiante a
      WHERE
           matricula = rt_for_update.p_matricula
      FOR UPDATE;


      RETURN l_estudiante_rec;

   END rt_for_update;

    FUNCTION tt (
                p_matricula IN estudiante.matricula%TYPE DEFAULT NULL
                )
       RETURN estudiante_tt
       PIPELINED
    IS
       l_estudiante_rec   estudiante_rt;
    BEGIN

       FOR c1 IN (SELECT   a.*, ROWID
                    FROM   estudiante a
                   WHERE
                        matricula = NVL(tt.p_matricula,matricula)
                        )
       LOOP
              l_estudiante_rec.cedula_est := c1.cedula_est;
              l_estudiante_rec.nacionalidad := c1.nacionalidad;
              l_estudiante_rec.nombre := c1.nombre;
              l_estudiante_rec.telf_hab := c1.telf_hab;
              l_estudiante_rec.telf_cel := c1.telf_cel;
              l_estudiante_rec.ciudad := c1.ciudad;
              l_estudiante_rec.estado := c1.estado;
              l_estudiante_rec.email := c1.email;
              l_estudiante_rec.sexo := c1.sexo;
              l_estudiante_rec.edo_civil := c1.edo_civil;
              l_estudiante_rec.grado_ins := c1.grado_ins;
              l_estudiante_rec.profesion := c1.profesion;
              l_estudiante_rec.fecha_nac := c1.fecha_nac;
              l_estudiante_rec.status := c1.status;
              l_estudiante_rec.id_tipo_est := c1.id_tipo_est;
              l_estudiante_rec.rif := c1.rif;
              l_estudiante_rec.matricula := c1.matricula;
              l_estudiante_rec.sede := c1.sede;
              l_estudiante_rec.condicion_especial := c1.condicion_especial;
              l_estudiante_rec.apellido := c1.apellido;
              l_estudiante_rec.zona := c1.zona;
              l_estudiante_rec.cedula_rep := c1.cedula_rep;
              l_estudiante_rec.direccion := c1.direccion;
              l_estudiante_rec.creado_por := c1.creado_por;
              l_estudiante_rec.creado_el := c1.creado_el;
              l_estudiante_rec.modificado_por := c1.modificado_por;
              l_estudiante_rec.modificado_el := c1.modificado_el;
              l_estudiante_rec.hash := tapi_estudiante.hash( c1.matricula);
              l_estudiante_rec.row_id := c1.ROWID;
              PIPE ROW (l_estudiante_rec);
       END LOOP;

       RETURN;

    END tt;


    PROCEDURE ins (p_estudiante_rec IN OUT estudiante_rt)
    IS
        l_rowtype     estudiante%ROWTYPE;

    BEGIN


        l_rowtype.cedula_est := ins.p_estudiante_rec.cedula_est;
        l_rowtype.nacionalidad := ins.p_estudiante_rec.nacionalidad;
        l_rowtype.nombre := ins.p_estudiante_rec.nombre;
        l_rowtype.telf_hab := ins.p_estudiante_rec.telf_hab;
        l_rowtype.telf_cel := ins.p_estudiante_rec.telf_cel;
        l_rowtype.ciudad := ins.p_estudiante_rec.ciudad;
        l_rowtype.estado := ins.p_estudiante_rec.estado;
        l_rowtype.email := ins.p_estudiante_rec.email;
        l_rowtype.sexo := ins.p_estudiante_rec.sexo;
        l_rowtype.edo_civil := ins.p_estudiante_rec.edo_civil;
        l_rowtype.grado_ins := ins.p_estudiante_rec.grado_ins;
        l_rowtype.profesion := ins.p_estudiante_rec.profesion;
        l_rowtype.fecha_nac := ins.p_estudiante_rec.fecha_nac;
        l_rowtype.status := ins.p_estudiante_rec.status;
        l_rowtype.id_tipo_est := ins.p_estudiante_rec.id_tipo_est;
        l_rowtype.rif := ins.p_estudiante_rec.rif;
        l_rowtype.matricula := ins.p_estudiante_rec.matricula;
        l_rowtype.sede := ins.p_estudiante_rec.sede;
        l_rowtype.condicion_especial := ins.p_estudiante_rec.condicion_especial;
        l_rowtype.apellido := ins.p_estudiante_rec.apellido;
        l_rowtype.zona := ins.p_estudiante_rec.zona;
        l_rowtype.cedula_rep := ins.p_estudiante_rec.cedula_rep;
        l_rowtype.direccion := ins.p_estudiante_rec.direccion;
        l_rowtype.creado_por := ins.p_estudiante_rec.creado_por;
        l_rowtype.creado_el := ins.p_estudiante_rec.creado_el;
        l_rowtype.modificado_por := ins.p_estudiante_rec.modificado_por;
        l_rowtype.modificado_el := ins.p_estudiante_rec.modificado_el;

       INSERT INTO estudiante
          VALUES   l_rowtype
       RETURNING
                   cedula_est ,
                   nacionalidad ,
                   nombre ,
                   telf_hab ,
                   telf_cel ,
                   ciudad ,
                   estado ,
                   email ,
                   sexo ,
                   edo_civil ,
                   grado_ins ,
                   profesion ,
                   fecha_nac ,
                   status ,
                   id_tipo_est ,
                   rif ,
                   matricula ,
                   sede ,
                   condicion_especial ,
                   apellido ,
                   zona ,
                   cedula_rep ,
                   direccion ,
                   creado_por ,
                   creado_el ,
                   modificado_por ,
                   modificado_el 
            INTO   l_rowtype;

         ins.p_estudiante_rec.cedula_est := l_rowtype.cedula_est;
         ins.p_estudiante_rec.nacionalidad := l_rowtype.nacionalidad;
         ins.p_estudiante_rec.nombre := l_rowtype.nombre;
         ins.p_estudiante_rec.telf_hab := l_rowtype.telf_hab;
         ins.p_estudiante_rec.telf_cel := l_rowtype.telf_cel;
         ins.p_estudiante_rec.ciudad := l_rowtype.ciudad;
         ins.p_estudiante_rec.estado := l_rowtype.estado;
         ins.p_estudiante_rec.email := l_rowtype.email;
         ins.p_estudiante_rec.sexo := l_rowtype.sexo;
         ins.p_estudiante_rec.edo_civil := l_rowtype.edo_civil;
         ins.p_estudiante_rec.grado_ins := l_rowtype.grado_ins;
         ins.p_estudiante_rec.profesion := l_rowtype.profesion;
         ins.p_estudiante_rec.fecha_nac := l_rowtype.fecha_nac;
         ins.p_estudiante_rec.status := l_rowtype.status;
         ins.p_estudiante_rec.id_tipo_est := l_rowtype.id_tipo_est;
         ins.p_estudiante_rec.rif := l_rowtype.rif;
         ins.p_estudiante_rec.matricula := l_rowtype.matricula;
         ins.p_estudiante_rec.sede := l_rowtype.sede;
         ins.p_estudiante_rec.condicion_especial := l_rowtype.condicion_especial;
         ins.p_estudiante_rec.apellido := l_rowtype.apellido;
         ins.p_estudiante_rec.zona := l_rowtype.zona;
         ins.p_estudiante_rec.cedula_rep := l_rowtype.cedula_rep;
         ins.p_estudiante_rec.direccion := l_rowtype.direccion;
         ins.p_estudiante_rec.creado_por := l_rowtype.creado_por;
         ins.p_estudiante_rec.creado_el := l_rowtype.creado_el;
         ins.p_estudiante_rec.modificado_por := l_rowtype.modificado_por;
         ins.p_estudiante_rec.modificado_el := l_rowtype.modificado_el;



    END ins;

    PROCEDURE upd (
                  p_estudiante_rec         IN estudiante_rt,
                  p_ignore_nulls         IN boolean := FALSE
                  )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   estudiante
             SET cedula_est = NVL(p_estudiante_rec.cedula_est,cedula_est),
                nacionalidad = NVL(p_estudiante_rec.nacionalidad,nacionalidad),
                nombre = NVL(p_estudiante_rec.nombre,nombre),
                telf_hab = NVL(p_estudiante_rec.telf_hab,telf_hab),
                telf_cel = NVL(p_estudiante_rec.telf_cel,telf_cel),
                ciudad = NVL(p_estudiante_rec.ciudad,ciudad),
                estado = NVL(p_estudiante_rec.estado,estado),
                email = NVL(p_estudiante_rec.email,email),
                sexo = NVL(p_estudiante_rec.sexo,sexo),
                edo_civil = NVL(p_estudiante_rec.edo_civil,edo_civil),
                grado_ins = NVL(p_estudiante_rec.grado_ins,grado_ins),
                profesion = NVL(p_estudiante_rec.profesion,profesion),
                fecha_nac = NVL(p_estudiante_rec.fecha_nac,fecha_nac),
                status = NVL(p_estudiante_rec.status,status),
                id_tipo_est = NVL(p_estudiante_rec.id_tipo_est,id_tipo_est),
                rif = NVL(p_estudiante_rec.rif,rif),
                matricula = NVL(p_estudiante_rec.matricula,matricula),
                sede = NVL(p_estudiante_rec.sede,sede),
                condicion_especial = NVL(p_estudiante_rec.condicion_especial,condicion_especial),
                apellido = NVL(p_estudiante_rec.apellido,apellido),
                zona = NVL(p_estudiante_rec.zona,zona),
                cedula_rep = NVL(p_estudiante_rec.cedula_rep,cedula_rep),
                direccion = NVL(p_estudiante_rec.direccion,direccion),
                creado_por = NVL(p_estudiante_rec.creado_por,creado_por),
                creado_el = NVL(p_estudiante_rec.creado_el,creado_el),
                modificado_por = NVL(p_estudiante_rec.modificado_por,modificado_por),
                modificado_el = NVL(p_estudiante_rec.modificado_el,modificado_el)
           WHERE
                matricula = upd.p_estudiante_rec.matricula
                ;
       ELSE
          UPDATE   estudiante
             SET cedula_est = p_estudiante_rec.cedula_est,
                nacionalidad = p_estudiante_rec.nacionalidad,
                nombre = p_estudiante_rec.nombre,
                telf_hab = p_estudiante_rec.telf_hab,
                telf_cel = p_estudiante_rec.telf_cel,
                ciudad = p_estudiante_rec.ciudad,
                estado = p_estudiante_rec.estado,
                email = p_estudiante_rec.email,
                sexo = p_estudiante_rec.sexo,
                edo_civil = p_estudiante_rec.edo_civil,
                grado_ins = p_estudiante_rec.grado_ins,
                profesion = p_estudiante_rec.profesion,
                fecha_nac = p_estudiante_rec.fecha_nac,
                status = p_estudiante_rec.status,
                id_tipo_est = p_estudiante_rec.id_tipo_est,
                rif = p_estudiante_rec.rif,
                matricula = p_estudiante_rec.matricula,
                sede = p_estudiante_rec.sede,
                condicion_especial = p_estudiante_rec.condicion_especial,
                apellido = p_estudiante_rec.apellido,
                zona = p_estudiante_rec.zona,
                cedula_rep = p_estudiante_rec.cedula_rep,
                direccion = p_estudiante_rec.direccion,
                creado_por = p_estudiante_rec.creado_por,
                creado_el = p_estudiante_rec.creado_el,
                modificado_por = p_estudiante_rec.modificado_por,
                modificado_el = p_estudiante_rec.modificado_el
           WHERE
                matricula = upd.p_estudiante_rec.matricula
                ;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd;


    PROCEDURE upd_rowid (
                         p_estudiante_rec         IN estudiante_rt,
                         p_ignore_nulls         IN boolean := FALSE
                        )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   estudiante
             SET cedula_est = NVL(p_estudiante_rec.cedula_est,cedula_est),
                nacionalidad = NVL(p_estudiante_rec.nacionalidad,nacionalidad),
                nombre = NVL(p_estudiante_rec.nombre,nombre),
                telf_hab = NVL(p_estudiante_rec.telf_hab,telf_hab),
                telf_cel = NVL(p_estudiante_rec.telf_cel,telf_cel),
                ciudad = NVL(p_estudiante_rec.ciudad,ciudad),
                estado = NVL(p_estudiante_rec.estado,estado),
                email = NVL(p_estudiante_rec.email,email),
                sexo = NVL(p_estudiante_rec.sexo,sexo),
                edo_civil = NVL(p_estudiante_rec.edo_civil,edo_civil),
                grado_ins = NVL(p_estudiante_rec.grado_ins,grado_ins),
                profesion = NVL(p_estudiante_rec.profesion,profesion),
                fecha_nac = NVL(p_estudiante_rec.fecha_nac,fecha_nac),
                status = NVL(p_estudiante_rec.status,status),
                id_tipo_est = NVL(p_estudiante_rec.id_tipo_est,id_tipo_est),
                rif = NVL(p_estudiante_rec.rif,rif),
                matricula = NVL(p_estudiante_rec.matricula,matricula),
                sede = NVL(p_estudiante_rec.sede,sede),
                condicion_especial = NVL(p_estudiante_rec.condicion_especial,condicion_especial),
                apellido = NVL(p_estudiante_rec.apellido,apellido),
                zona = NVL(p_estudiante_rec.zona,zona),
                cedula_rep = NVL(p_estudiante_rec.cedula_rep,cedula_rep),
                direccion = NVL(p_estudiante_rec.direccion,direccion),
                creado_por = NVL(p_estudiante_rec.creado_por,creado_por),
                creado_el = NVL(p_estudiante_rec.creado_el,creado_el),
                modificado_por = NVL(p_estudiante_rec.modificado_por,modificado_por),
                modificado_el = NVL(p_estudiante_rec.modificado_el,modificado_el)
           WHERE  ROWID = p_estudiante_rec.row_id;
       ELSE
          UPDATE   estudiante
             SET cedula_est = p_estudiante_rec.cedula_est,
                nacionalidad = p_estudiante_rec.nacionalidad,
                nombre = p_estudiante_rec.nombre,
                telf_hab = p_estudiante_rec.telf_hab,
                telf_cel = p_estudiante_rec.telf_cel,
                ciudad = p_estudiante_rec.ciudad,
                estado = p_estudiante_rec.estado,
                email = p_estudiante_rec.email,
                sexo = p_estudiante_rec.sexo,
                edo_civil = p_estudiante_rec.edo_civil,
                grado_ins = p_estudiante_rec.grado_ins,
                profesion = p_estudiante_rec.profesion,
                fecha_nac = p_estudiante_rec.fecha_nac,
                status = p_estudiante_rec.status,
                id_tipo_est = p_estudiante_rec.id_tipo_est,
                rif = p_estudiante_rec.rif,
                matricula = p_estudiante_rec.matricula,
                sede = p_estudiante_rec.sede,
                condicion_especial = p_estudiante_rec.condicion_especial,
                apellido = p_estudiante_rec.apellido,
                zona = p_estudiante_rec.zona,
                cedula_rep = p_estudiante_rec.cedula_rep,
                direccion = p_estudiante_rec.direccion,
                creado_por = p_estudiante_rec.creado_por,
                creado_el = p_estudiante_rec.creado_el,
                modificado_por = p_estudiante_rec.modificado_por,
                modificado_el = p_estudiante_rec.modificado_el
           WHERE  ROWID = p_estudiante_rec.row_id;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd_rowid;

   PROCEDURE web_upd (
                  p_estudiante_rec         IN estudiante_rt,
                  p_ignore_nulls         IN boolean := FALSE
                )
   IS
      l_estudiante_rec estudiante_rt;
   BEGIN

      OPEN estudiante_cur(
                             web_upd.p_estudiante_rec.matricula
                        );

      FETCH estudiante_cur INTO l_estudiante_rec;

      IF estudiante_cur%NOTFOUND THEN
         CLOSE estudiante_cur;
         RAISE e_row_missing;
      ELSE
         IF p_estudiante_rec.hash != l_estudiante_rec.hash THEN
            CLOSE estudiante_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(p_ignore_nulls, FALSE)
            THEN

                UPDATE   estudiante
                   SET cedula_est = NVL(p_estudiante_rec.cedula_est,cedula_est),
                       nacionalidad = NVL(p_estudiante_rec.nacionalidad,nacionalidad),
                       nombre = NVL(p_estudiante_rec.nombre,nombre),
                       telf_hab = NVL(p_estudiante_rec.telf_hab,telf_hab),
                       telf_cel = NVL(p_estudiante_rec.telf_cel,telf_cel),
                       ciudad = NVL(p_estudiante_rec.ciudad,ciudad),
                       estado = NVL(p_estudiante_rec.estado,estado),
                       email = NVL(p_estudiante_rec.email,email),
                       sexo = NVL(p_estudiante_rec.sexo,sexo),
                       edo_civil = NVL(p_estudiante_rec.edo_civil,edo_civil),
                       grado_ins = NVL(p_estudiante_rec.grado_ins,grado_ins),
                       profesion = NVL(p_estudiante_rec.profesion,profesion),
                       fecha_nac = NVL(p_estudiante_rec.fecha_nac,fecha_nac),
                       status = NVL(p_estudiante_rec.status,status),
                       id_tipo_est = NVL(p_estudiante_rec.id_tipo_est,id_tipo_est),
                       rif = NVL(p_estudiante_rec.rif,rif),
                       matricula = NVL(p_estudiante_rec.matricula,matricula),
                       sede = NVL(p_estudiante_rec.sede,sede),
                       condicion_especial = NVL(p_estudiante_rec.condicion_especial,condicion_especial),
                       apellido = NVL(p_estudiante_rec.apellido,apellido),
                       zona = NVL(p_estudiante_rec.zona,zona),
                       cedula_rep = NVL(p_estudiante_rec.cedula_rep,cedula_rep),
                       direccion = NVL(p_estudiante_rec.direccion,direccion),
                       creado_por = NVL(p_estudiante_rec.creado_por,creado_por),
                       creado_el = NVL(p_estudiante_rec.creado_el,creado_el),
                       modificado_por = NVL(p_estudiante_rec.modificado_por,modificado_por),
                       modificado_el = NVL(p_estudiante_rec.modificado_el,modificado_el)
               WHERE CURRENT OF estudiante_cur;
            ELSE
                UPDATE   estudiante
                   SET cedula_est = p_estudiante_rec.cedula_est,
                       nacionalidad = p_estudiante_rec.nacionalidad,
                       nombre = p_estudiante_rec.nombre,
                       telf_hab = p_estudiante_rec.telf_hab,
                       telf_cel = p_estudiante_rec.telf_cel,
                       ciudad = p_estudiante_rec.ciudad,
                       estado = p_estudiante_rec.estado,
                       email = p_estudiante_rec.email,
                       sexo = p_estudiante_rec.sexo,
                       edo_civil = p_estudiante_rec.edo_civil,
                       grado_ins = p_estudiante_rec.grado_ins,
                       profesion = p_estudiante_rec.profesion,
                       fecha_nac = p_estudiante_rec.fecha_nac,
                       status = p_estudiante_rec.status,
                       id_tipo_est = p_estudiante_rec.id_tipo_est,
                       rif = p_estudiante_rec.rif,
                       matricula = p_estudiante_rec.matricula,
                       sede = p_estudiante_rec.sede,
                       condicion_especial = p_estudiante_rec.condicion_especial,
                       apellido = p_estudiante_rec.apellido,
                       zona = p_estudiante_rec.zona,
                       cedula_rep = p_estudiante_rec.cedula_rep,
                       direccion = p_estudiante_rec.direccion,
                       creado_por = p_estudiante_rec.creado_por,
                       creado_el = p_estudiante_rec.creado_el,
                       modificado_por = p_estudiante_rec.modificado_por,
                       modificado_el = p_estudiante_rec.modificado_el
               WHERE CURRENT OF estudiante_cur;
            END IF;

            CLOSE estudiante_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd;

   PROCEDURE web_upd_rowid (
                            p_estudiante_rec    IN estudiante_rt,
                            p_ignore_nulls         IN boolean := FALSE
                           )
   IS
      l_estudiante_rec estudiante_rt;
   BEGIN

      OPEN estudiante_rowid_cur(web_upd_rowid.p_estudiante_rec.row_id);

      FETCH estudiante_rowid_cur INTO l_estudiante_rec;

      IF estudiante_rowid_cur%NOTFOUND THEN
         CLOSE estudiante_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_upd_rowid.p_estudiante_rec.hash != l_estudiante_rec.hash THEN
            CLOSE estudiante_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(web_upd_rowid.p_ignore_nulls, FALSE)
            THEN
                UPDATE   estudiante
                   SET cedula_est = NVL(p_estudiante_rec.cedula_est,cedula_est),
                       nacionalidad = NVL(p_estudiante_rec.nacionalidad,nacionalidad),
                       nombre = NVL(p_estudiante_rec.nombre,nombre),
                       telf_hab = NVL(p_estudiante_rec.telf_hab,telf_hab),
                       telf_cel = NVL(p_estudiante_rec.telf_cel,telf_cel),
                       ciudad = NVL(p_estudiante_rec.ciudad,ciudad),
                       estado = NVL(p_estudiante_rec.estado,estado),
                       email = NVL(p_estudiante_rec.email,email),
                       sexo = NVL(p_estudiante_rec.sexo,sexo),
                       edo_civil = NVL(p_estudiante_rec.edo_civil,edo_civil),
                       grado_ins = NVL(p_estudiante_rec.grado_ins,grado_ins),
                       profesion = NVL(p_estudiante_rec.profesion,profesion),
                       fecha_nac = NVL(p_estudiante_rec.fecha_nac,fecha_nac),
                       status = NVL(p_estudiante_rec.status,status),
                       id_tipo_est = NVL(p_estudiante_rec.id_tipo_est,id_tipo_est),
                       rif = NVL(p_estudiante_rec.rif,rif),
                       matricula = NVL(p_estudiante_rec.matricula,matricula),
                       sede = NVL(p_estudiante_rec.sede,sede),
                       condicion_especial = NVL(p_estudiante_rec.condicion_especial,condicion_especial),
                       apellido = NVL(p_estudiante_rec.apellido,apellido),
                       zona = NVL(p_estudiante_rec.zona,zona),
                       cedula_rep = NVL(p_estudiante_rec.cedula_rep,cedula_rep),
                       direccion = NVL(p_estudiante_rec.direccion,direccion),
                       creado_por = NVL(p_estudiante_rec.creado_por,creado_por),
                       creado_el = NVL(p_estudiante_rec.creado_el,creado_el),
                       modificado_por = NVL(p_estudiante_rec.modificado_por,modificado_por),
                       modificado_el = NVL(p_estudiante_rec.modificado_el,modificado_el)
               WHERE CURRENT OF estudiante_rowid_cur;
            ELSE
                UPDATE   estudiante
                   SET cedula_est = p_estudiante_rec.cedula_est,
                       nacionalidad = p_estudiante_rec.nacionalidad,
                       nombre = p_estudiante_rec.nombre,
                       telf_hab = p_estudiante_rec.telf_hab,
                       telf_cel = p_estudiante_rec.telf_cel,
                       ciudad = p_estudiante_rec.ciudad,
                       estado = p_estudiante_rec.estado,
                       email = p_estudiante_rec.email,
                       sexo = p_estudiante_rec.sexo,
                       edo_civil = p_estudiante_rec.edo_civil,
                       grado_ins = p_estudiante_rec.grado_ins,
                       profesion = p_estudiante_rec.profesion,
                       fecha_nac = p_estudiante_rec.fecha_nac,
                       status = p_estudiante_rec.status,
                       id_tipo_est = p_estudiante_rec.id_tipo_est,
                       rif = p_estudiante_rec.rif,
                       matricula = p_estudiante_rec.matricula,
                       sede = p_estudiante_rec.sede,
                       condicion_especial = p_estudiante_rec.condicion_especial,
                       apellido = p_estudiante_rec.apellido,
                       zona = p_estudiante_rec.zona,
                       cedula_rep = p_estudiante_rec.cedula_rep,
                       direccion = p_estudiante_rec.direccion,
                       creado_por = p_estudiante_rec.creado_por,
                       creado_el = p_estudiante_rec.creado_el,
                       modificado_por = p_estudiante_rec.modificado_por,
                       modificado_el = p_estudiante_rec.modificado_el
               WHERE CURRENT OF estudiante_rowid_cur;
            END IF;

            CLOSE estudiante_rowid_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd_rowid;

    PROCEDURE del (
                  p_matricula IN estudiante.matricula%TYPE
                  )
    IS
    BEGIN

       DELETE FROM   estudiante
             WHERE
                  matricula = del.p_matricula
                   ;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del;

    PROCEDURE del_rowid (p_rowid IN varchar2)
    IS
    BEGIN

       DELETE FROM   estudiante
             WHERE   ROWID = del_rowid.p_rowid;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del_rowid;

    PROCEDURE web_del (
                      p_matricula IN estudiante.matricula%TYPE,
                      p_hash IN varchar2
                      )
   IS
      l_estudiante_rec estudiante_rt;
   BEGIN


      OPEN estudiante_cur(
                            web_del.p_matricula
                            );

      FETCH estudiante_cur INTO l_estudiante_rec;

      IF estudiante_cur%NOTFOUND THEN
         CLOSE estudiante_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del.p_hash != l_estudiante_rec.hash THEN
            CLOSE estudiante_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM estudiante
            WHERE CURRENT OF estudiante_cur;

            CLOSE estudiante_cur;
         END IF;
      END IF;



   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del;

   PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2)
   IS
      l_estudiante_rec estudiante_rt;
   BEGIN


      OPEN estudiante_rowid_cur(web_del_rowid.p_rowid);

      FETCH estudiante_rowid_cur INTO l_estudiante_rec;

      IF estudiante_rowid_cur%NOTFOUND THEN
         CLOSE estudiante_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del_rowid.p_hash != l_estudiante_rec.hash THEN
            CLOSE estudiante_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM estudiante
            WHERE CURRENT OF estudiante_rowid_cur;

            CLOSE estudiante_rowid_cur;
         END IF;
      END IF;

   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del_rowid;

END tapi_estudiante;

/
--------------------------------------------------------
--  DDL for Package Body TAPI_FACTURA
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."TAPI_FACTURA" IS

   /**
   * TAPI_FACTURA
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: 25-SEP-2019 08:27
   * Created By: FUNDAUC
   */


   --GLOBAL_PRIVATE_CURSORS
   --By PK
   CURSOR factura_cur (
                       p_id IN factura.id%TYPE
                       )
   IS
      SELECT
            id_fact,
            tipo,
            cedula_est,
            nombre_cliente,
            fecha_emi,
            monto,
            p_iva,
            monto_iva,
            flete,
            bs_descuento,
            dir_fiscal,
            rif,
            status,
            programa,
            prog_academico,
            creado_por,
            monto_exento,
            base_imponible,
            id,
            creado_el,
            facturado_por,
            observaciones,
            escredito,
            tapi_factura.hash(id),
            ROWID
      FROM factura
      WHERE
           id = factura_cur.p_id
      FOR UPDATE;

    --By Rowid
    CURSOR factura_rowid_cur (p_rowid IN VARCHAR2)
    IS
      SELECT
             id_fact,
             tipo,
             cedula_est,
             nombre_cliente,
             fecha_emi,
             monto,
             p_iva,
             monto_iva,
             flete,
             bs_descuento,
             dir_fiscal,
             rif,
             status,
             programa,
             prog_academico,
             creado_por,
             monto_exento,
             base_imponible,
             id,
             creado_el,
             facturado_por,
             observaciones,
             escredito,
             tapi_factura.hash(id),
             ROWID
      FROM factura
      WHERE ROWID = p_rowid
      FOR UPDATE;


    FUNCTION hash (
                  p_id IN factura.id%TYPE
                  )
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format VARCHAR2(64);
   BEGIN


     --Get actual NLS_DATE_FORMAT
     SELECT   VALUE
       INTO   l_date_format
       FROM   v$nls_parameters
      WHERE   parameter = 'NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            id_fact||
            tipo||
            cedula_est||
            nombre_cliente||
            fecha_emi||
            monto||
            p_iva||
            monto_iva||
            flete||
            bs_descuento||
            dir_fiscal||
            rif||
            status||
            programa||
            prog_academico||
            creado_por||
            monto_exento||
            base_imponible||
            id||
            creado_el||
            facturado_por||
            observaciones||
            escredito
      INTO l_string
      FROM factura
      WHERE
           id = hash.p_id
           ;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash;

    FUNCTION hash_rowid (p_rowid IN varchar2)
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format varchar2(64);
   BEGIN

      --Get actual NLS_DATE_FORMAT
      SELECT VALUE INTO l_date_format  FROM v$nls_parameters WHERE parameter ='NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            id_fact||
            tipo||
            cedula_est||
            nombre_cliente||
            fecha_emi||
            monto||
            p_iva||
            monto_iva||
            flete||
            bs_descuento||
            dir_fiscal||
            rif||
            status||
            programa||
            prog_academico||
            creado_por||
            monto_exento||
            base_imponible||
            id||
            creado_el||
            facturado_por||
            observaciones||
            escredito
      INTO l_string
      FROM factura
      WHERE  ROWID = hash_rowid.p_rowid;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash_rowid;

   FUNCTION rt (
               p_id IN factura.id%TYPE
               )
      RETURN factura_rt RESULT_CACHE
   IS
      l_factura_rec factura_rt;
   BEGIN

      SELECT a.*,
             tapi_factura.hash(id),
             rowid
      INTO l_factura_rec
      FROM factura a
      WHERE
           id = rt.p_id
           ;


      RETURN l_factura_rec;

   END rt;

   FUNCTION rt_for_update (
                          p_id IN factura.id%TYPE
                          )
      RETURN factura_rt RESULT_CACHE
   IS
      l_factura_rec factura_rt;
   BEGIN


      SELECT a.*,
             tapi_factura.hash(id),
             rowid
      INTO l_factura_rec
      FROM factura a
      WHERE
           id = rt_for_update.p_id
      FOR UPDATE;


      RETURN l_factura_rec;

   END rt_for_update;

    FUNCTION tt (
                p_id IN factura.id%TYPE DEFAULT NULL
                )
       RETURN factura_tt
       PIPELINED
    IS
       l_factura_rec   factura_rt;
    BEGIN

       FOR c1 IN (SELECT   a.*, ROWID
                    FROM   factura a
                   WHERE
                        id = NVL(tt.p_id,id)
                        )
       LOOP
              l_factura_rec.id_fact := c1.id_fact;
              l_factura_rec.tipo := c1.tipo;
              l_factura_rec.cedula_est := c1.cedula_est;
              l_factura_rec.nombre_cliente := c1.nombre_cliente;
              l_factura_rec.fecha_emi := c1.fecha_emi;
              l_factura_rec.monto := c1.monto;
              l_factura_rec.p_iva := c1.p_iva;
              l_factura_rec.monto_iva := c1.monto_iva;
              l_factura_rec.flete := c1.flete;
              l_factura_rec.bs_descuento := c1.bs_descuento;
              l_factura_rec.dir_fiscal := c1.dir_fiscal;
              l_factura_rec.rif := c1.rif;
              l_factura_rec.status := c1.status;
              l_factura_rec.programa := c1.programa;
              l_factura_rec.prog_academico := c1.prog_academico;
              l_factura_rec.creado_por := c1.creado_por;
              l_factura_rec.monto_exento := c1.monto_exento;
              l_factura_rec.base_imponible := c1.base_imponible;
              l_factura_rec.id := c1.id;
              l_factura_rec.creado_el := c1.creado_el;
              l_factura_rec.facturado_por := c1.facturado_por;
              l_factura_rec.observaciones := c1.observaciones;
              l_factura_rec.escredito := c1.escredito;
              l_factura_rec.hash := tapi_factura.hash( c1.id);
              l_factura_rec.row_id := c1.ROWID;
              PIPE ROW (l_factura_rec);
       END LOOP;

       RETURN;

    END tt;


    PROCEDURE ins (p_factura_rec IN OUT factura_rt)
    IS
        l_rowtype     factura%ROWTYPE;

    BEGIN


        l_rowtype.id_fact := ins.p_factura_rec.id_fact;
        l_rowtype.tipo := ins.p_factura_rec.tipo;
        l_rowtype.cedula_est := ins.p_factura_rec.cedula_est;
        l_rowtype.nombre_cliente := ins.p_factura_rec.nombre_cliente;
        l_rowtype.fecha_emi := ins.p_factura_rec.fecha_emi;
        l_rowtype.monto := ins.p_factura_rec.monto;
        l_rowtype.p_iva := ins.p_factura_rec.p_iva;
        l_rowtype.monto_iva := ins.p_factura_rec.monto_iva;
        l_rowtype.flete := ins.p_factura_rec.flete;
        l_rowtype.bs_descuento := ins.p_factura_rec.bs_descuento;
        l_rowtype.dir_fiscal := ins.p_factura_rec.dir_fiscal;
        l_rowtype.rif := ins.p_factura_rec.rif;
        l_rowtype.status := ins.p_factura_rec.status;
        l_rowtype.programa := ins.p_factura_rec.programa;
        l_rowtype.prog_academico := ins.p_factura_rec.prog_academico;
        l_rowtype.creado_por := ins.p_factura_rec.creado_por;
        l_rowtype.monto_exento := ins.p_factura_rec.monto_exento;
        l_rowtype.base_imponible := ins.p_factura_rec.base_imponible;
        l_rowtype.id := ins.p_factura_rec.id;
        l_rowtype.creado_el := ins.p_factura_rec.creado_el;
        l_rowtype.facturado_por := ins.p_factura_rec.facturado_por;
        l_rowtype.observaciones := ins.p_factura_rec.observaciones;
        l_rowtype.escredito := ins.p_factura_rec.escredito;

       INSERT INTO factura
          VALUES   l_rowtype
       RETURNING
                   id_fact ,
                   tipo ,
                   cedula_est ,
                   nombre_cliente ,
                   fecha_emi ,
                   monto ,
                   p_iva ,
                   monto_iva ,
                   flete ,
                   bs_descuento ,
                   dir_fiscal ,
                   rif ,
                   status ,
                   programa ,
                   prog_academico ,
                   creado_por ,
                   monto_exento ,
                   base_imponible ,
                   id ,
                   creado_el ,
                   facturado_por ,
                   observaciones ,
                   escredito 
            INTO   l_rowtype;

         ins.p_factura_rec.id_fact := l_rowtype.id_fact;
         ins.p_factura_rec.tipo := l_rowtype.tipo;
         ins.p_factura_rec.cedula_est := l_rowtype.cedula_est;
         ins.p_factura_rec.nombre_cliente := l_rowtype.nombre_cliente;
         ins.p_factura_rec.fecha_emi := l_rowtype.fecha_emi;
         ins.p_factura_rec.monto := l_rowtype.monto;
         ins.p_factura_rec.p_iva := l_rowtype.p_iva;
         ins.p_factura_rec.monto_iva := l_rowtype.monto_iva;
         ins.p_factura_rec.flete := l_rowtype.flete;
         ins.p_factura_rec.bs_descuento := l_rowtype.bs_descuento;
         ins.p_factura_rec.dir_fiscal := l_rowtype.dir_fiscal;
         ins.p_factura_rec.rif := l_rowtype.rif;
         ins.p_factura_rec.status := l_rowtype.status;
         ins.p_factura_rec.programa := l_rowtype.programa;
         ins.p_factura_rec.prog_academico := l_rowtype.prog_academico;
         ins.p_factura_rec.creado_por := l_rowtype.creado_por;
         ins.p_factura_rec.monto_exento := l_rowtype.monto_exento;
         ins.p_factura_rec.base_imponible := l_rowtype.base_imponible;
         ins.p_factura_rec.id := l_rowtype.id;
         ins.p_factura_rec.creado_el := l_rowtype.creado_el;
         ins.p_factura_rec.facturado_por := l_rowtype.facturado_por;
         ins.p_factura_rec.observaciones := l_rowtype.observaciones;
         ins.p_factura_rec.escredito := l_rowtype.escredito;



    END ins;

    PROCEDURE upd (
                  p_factura_rec         IN factura_rt,
                  p_ignore_nulls         IN boolean := FALSE
                  )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   factura
             SET id_fact = NVL(p_factura_rec.id_fact,id_fact),
                tipo = NVL(p_factura_rec.tipo,tipo),
                cedula_est = NVL(p_factura_rec.cedula_est,cedula_est),
                nombre_cliente = NVL(p_factura_rec.nombre_cliente,nombre_cliente),
                fecha_emi = NVL(p_factura_rec.fecha_emi,fecha_emi),
                monto = NVL(p_factura_rec.monto,monto),
                p_iva = NVL(p_factura_rec.p_iva,p_iva),
                monto_iva = NVL(p_factura_rec.monto_iva,monto_iva),
                flete = NVL(p_factura_rec.flete,flete),
                bs_descuento = NVL(p_factura_rec.bs_descuento,bs_descuento),
                dir_fiscal = NVL(p_factura_rec.dir_fiscal,dir_fiscal),
                rif = NVL(p_factura_rec.rif,rif),
                status = NVL(p_factura_rec.status,status),
                programa = NVL(p_factura_rec.programa,programa),
                prog_academico = NVL(p_factura_rec.prog_academico,prog_academico),
                creado_por = NVL(p_factura_rec.creado_por,creado_por),
                monto_exento = NVL(p_factura_rec.monto_exento,monto_exento),
                base_imponible = NVL(p_factura_rec.base_imponible,base_imponible),
                id = NVL(p_factura_rec.id,id),
                creado_el = NVL(p_factura_rec.creado_el,creado_el),
                facturado_por = NVL(p_factura_rec.facturado_por,facturado_por),
                observaciones = NVL(p_factura_rec.observaciones,observaciones),
                escredito = NVL(p_factura_rec.escredito,escredito)
           WHERE
                id = upd.p_factura_rec.id
                ;
       ELSE
          UPDATE   factura
             SET id_fact = p_factura_rec.id_fact,
                tipo = p_factura_rec.tipo,
                cedula_est = p_factura_rec.cedula_est,
                nombre_cliente = p_factura_rec.nombre_cliente,
                fecha_emi = p_factura_rec.fecha_emi,
                monto = p_factura_rec.monto,
                p_iva = p_factura_rec.p_iva,
                monto_iva = p_factura_rec.monto_iva,
                flete = p_factura_rec.flete,
                bs_descuento = p_factura_rec.bs_descuento,
                dir_fiscal = p_factura_rec.dir_fiscal,
                rif = p_factura_rec.rif,
                status = p_factura_rec.status,
                programa = p_factura_rec.programa,
                prog_academico = p_factura_rec.prog_academico,
                creado_por = p_factura_rec.creado_por,
                monto_exento = p_factura_rec.monto_exento,
                base_imponible = p_factura_rec.base_imponible,
                id = p_factura_rec.id,
                creado_el = p_factura_rec.creado_el,
                facturado_por = p_factura_rec.facturado_por,
                observaciones = p_factura_rec.observaciones,
                escredito = p_factura_rec.escredito
           WHERE
                id = upd.p_factura_rec.id
                ;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd;


    PROCEDURE upd_rowid (
                         p_factura_rec         IN factura_rt,
                         p_ignore_nulls         IN boolean := FALSE
                        )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   factura
             SET id_fact = NVL(p_factura_rec.id_fact,id_fact),
                tipo = NVL(p_factura_rec.tipo,tipo),
                cedula_est = NVL(p_factura_rec.cedula_est,cedula_est),
                nombre_cliente = NVL(p_factura_rec.nombre_cliente,nombre_cliente),
                fecha_emi = NVL(p_factura_rec.fecha_emi,fecha_emi),
                monto = NVL(p_factura_rec.monto,monto),
                p_iva = NVL(p_factura_rec.p_iva,p_iva),
                monto_iva = NVL(p_factura_rec.monto_iva,monto_iva),
                flete = NVL(p_factura_rec.flete,flete),
                bs_descuento = NVL(p_factura_rec.bs_descuento,bs_descuento),
                dir_fiscal = NVL(p_factura_rec.dir_fiscal,dir_fiscal),
                rif = NVL(p_factura_rec.rif,rif),
                status = NVL(p_factura_rec.status,status),
                programa = NVL(p_factura_rec.programa,programa),
                prog_academico = NVL(p_factura_rec.prog_academico,prog_academico),
                creado_por = NVL(p_factura_rec.creado_por,creado_por),
                monto_exento = NVL(p_factura_rec.monto_exento,monto_exento),
                base_imponible = NVL(p_factura_rec.base_imponible,base_imponible),
                id = NVL(p_factura_rec.id,id),
                creado_el = NVL(p_factura_rec.creado_el,creado_el),
                facturado_por = NVL(p_factura_rec.facturado_por,facturado_por),
                observaciones = NVL(p_factura_rec.observaciones,observaciones),
                escredito = NVL(p_factura_rec.escredito,escredito)
           WHERE  ROWID = p_factura_rec.row_id;
       ELSE
          UPDATE   factura
             SET id_fact = p_factura_rec.id_fact,
                tipo = p_factura_rec.tipo,
                cedula_est = p_factura_rec.cedula_est,
                nombre_cliente = p_factura_rec.nombre_cliente,
                fecha_emi = p_factura_rec.fecha_emi,
                monto = p_factura_rec.monto,
                p_iva = p_factura_rec.p_iva,
                monto_iva = p_factura_rec.monto_iva,
                flete = p_factura_rec.flete,
                bs_descuento = p_factura_rec.bs_descuento,
                dir_fiscal = p_factura_rec.dir_fiscal,
                rif = p_factura_rec.rif,
                status = p_factura_rec.status,
                programa = p_factura_rec.programa,
                prog_academico = p_factura_rec.prog_academico,
                creado_por = p_factura_rec.creado_por,
                monto_exento = p_factura_rec.monto_exento,
                base_imponible = p_factura_rec.base_imponible,
                id = p_factura_rec.id,
                creado_el = p_factura_rec.creado_el,
                facturado_por = p_factura_rec.facturado_por,
                observaciones = p_factura_rec.observaciones,
                escredito = p_factura_rec.escredito
           WHERE  ROWID = p_factura_rec.row_id;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd_rowid;

   PROCEDURE web_upd (
                  p_factura_rec         IN factura_rt,
                  p_ignore_nulls         IN boolean := FALSE
                )
   IS
      l_factura_rec factura_rt;
   BEGIN

      OPEN factura_cur(
                             web_upd.p_factura_rec.id
                        );

      FETCH factura_cur INTO l_factura_rec;

      IF factura_cur%NOTFOUND THEN
         CLOSE factura_cur;
         RAISE e_row_missing;
      ELSE
         IF p_factura_rec.hash != l_factura_rec.hash THEN
            CLOSE factura_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(p_ignore_nulls, FALSE)
            THEN

                UPDATE   factura
                   SET id_fact = NVL(p_factura_rec.id_fact,id_fact),
                       tipo = NVL(p_factura_rec.tipo,tipo),
                       cedula_est = NVL(p_factura_rec.cedula_est,cedula_est),
                       nombre_cliente = NVL(p_factura_rec.nombre_cliente,nombre_cliente),
                       fecha_emi = NVL(p_factura_rec.fecha_emi,fecha_emi),
                       monto = NVL(p_factura_rec.monto,monto),
                       p_iva = NVL(p_factura_rec.p_iva,p_iva),
                       monto_iva = NVL(p_factura_rec.monto_iva,monto_iva),
                       flete = NVL(p_factura_rec.flete,flete),
                       bs_descuento = NVL(p_factura_rec.bs_descuento,bs_descuento),
                       dir_fiscal = NVL(p_factura_rec.dir_fiscal,dir_fiscal),
                       rif = NVL(p_factura_rec.rif,rif),
                       status = NVL(p_factura_rec.status,status),
                       programa = NVL(p_factura_rec.programa,programa),
                       prog_academico = NVL(p_factura_rec.prog_academico,prog_academico),
                       creado_por = NVL(p_factura_rec.creado_por,creado_por),
                       monto_exento = NVL(p_factura_rec.monto_exento,monto_exento),
                       base_imponible = NVL(p_factura_rec.base_imponible,base_imponible),
                       id = NVL(p_factura_rec.id,id),
                       creado_el = NVL(p_factura_rec.creado_el,creado_el),
                       facturado_por = NVL(p_factura_rec.facturado_por,facturado_por),
                       observaciones = NVL(p_factura_rec.observaciones,observaciones),
                       escredito = NVL(p_factura_rec.escredito,escredito)
               WHERE CURRENT OF factura_cur;
            ELSE
                UPDATE   factura
                   SET id_fact = p_factura_rec.id_fact,
                       tipo = p_factura_rec.tipo,
                       cedula_est = p_factura_rec.cedula_est,
                       nombre_cliente = p_factura_rec.nombre_cliente,
                       fecha_emi = p_factura_rec.fecha_emi,
                       monto = p_factura_rec.monto,
                       p_iva = p_factura_rec.p_iva,
                       monto_iva = p_factura_rec.monto_iva,
                       flete = p_factura_rec.flete,
                       bs_descuento = p_factura_rec.bs_descuento,
                       dir_fiscal = p_factura_rec.dir_fiscal,
                       rif = p_factura_rec.rif,
                       status = p_factura_rec.status,
                       programa = p_factura_rec.programa,
                       prog_academico = p_factura_rec.prog_academico,
                       creado_por = p_factura_rec.creado_por,
                       monto_exento = p_factura_rec.monto_exento,
                       base_imponible = p_factura_rec.base_imponible,
                       id = p_factura_rec.id,
                       creado_el = p_factura_rec.creado_el,
                       facturado_por = p_factura_rec.facturado_por,
                       observaciones = p_factura_rec.observaciones,
                       escredito = p_factura_rec.escredito
               WHERE CURRENT OF factura_cur;
            END IF;

            CLOSE factura_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd;

   PROCEDURE web_upd_rowid (
                            p_factura_rec    IN factura_rt,
                            p_ignore_nulls         IN boolean := FALSE
                           )
   IS
      l_factura_rec factura_rt;
   BEGIN

      OPEN factura_rowid_cur(web_upd_rowid.p_factura_rec.row_id);

      FETCH factura_rowid_cur INTO l_factura_rec;

      IF factura_rowid_cur%NOTFOUND THEN
         CLOSE factura_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_upd_rowid.p_factura_rec.hash != l_factura_rec.hash THEN
            CLOSE factura_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(web_upd_rowid.p_ignore_nulls, FALSE)
            THEN
                UPDATE   factura
                   SET id_fact = NVL(p_factura_rec.id_fact,id_fact),
                       tipo = NVL(p_factura_rec.tipo,tipo),
                       cedula_est = NVL(p_factura_rec.cedula_est,cedula_est),
                       nombre_cliente = NVL(p_factura_rec.nombre_cliente,nombre_cliente),
                       fecha_emi = NVL(p_factura_rec.fecha_emi,fecha_emi),
                       monto = NVL(p_factura_rec.monto,monto),
                       p_iva = NVL(p_factura_rec.p_iva,p_iva),
                       monto_iva = NVL(p_factura_rec.monto_iva,monto_iva),
                       flete = NVL(p_factura_rec.flete,flete),
                       bs_descuento = NVL(p_factura_rec.bs_descuento,bs_descuento),
                       dir_fiscal = NVL(p_factura_rec.dir_fiscal,dir_fiscal),
                       rif = NVL(p_factura_rec.rif,rif),
                       status = NVL(p_factura_rec.status,status),
                       programa = NVL(p_factura_rec.programa,programa),
                       prog_academico = NVL(p_factura_rec.prog_academico,prog_academico),
                       creado_por = NVL(p_factura_rec.creado_por,creado_por),
                       monto_exento = NVL(p_factura_rec.monto_exento,monto_exento),
                       base_imponible = NVL(p_factura_rec.base_imponible,base_imponible),
                       id = NVL(p_factura_rec.id,id),
                       creado_el = NVL(p_factura_rec.creado_el,creado_el),
                       facturado_por = NVL(p_factura_rec.facturado_por,facturado_por),
                       observaciones = NVL(p_factura_rec.observaciones,observaciones),
                       escredito = NVL(p_factura_rec.escredito,escredito)
               WHERE CURRENT OF factura_rowid_cur;
            ELSE
                UPDATE   factura
                   SET id_fact = p_factura_rec.id_fact,
                       tipo = p_factura_rec.tipo,
                       cedula_est = p_factura_rec.cedula_est,
                       nombre_cliente = p_factura_rec.nombre_cliente,
                       fecha_emi = p_factura_rec.fecha_emi,
                       monto = p_factura_rec.monto,
                       p_iva = p_factura_rec.p_iva,
                       monto_iva = p_factura_rec.monto_iva,
                       flete = p_factura_rec.flete,
                       bs_descuento = p_factura_rec.bs_descuento,
                       dir_fiscal = p_factura_rec.dir_fiscal,
                       rif = p_factura_rec.rif,
                       status = p_factura_rec.status,
                       programa = p_factura_rec.programa,
                       prog_academico = p_factura_rec.prog_academico,
                       creado_por = p_factura_rec.creado_por,
                       monto_exento = p_factura_rec.monto_exento,
                       base_imponible = p_factura_rec.base_imponible,
                       id = p_factura_rec.id,
                       creado_el = p_factura_rec.creado_el,
                       facturado_por = p_factura_rec.facturado_por,
                       observaciones = p_factura_rec.observaciones,
                       escredito = p_factura_rec.escredito
               WHERE CURRENT OF factura_rowid_cur;
            END IF;

            CLOSE factura_rowid_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd_rowid;

    PROCEDURE del (
                  p_id IN factura.id%TYPE
                  )
    IS
    BEGIN

       DELETE FROM   factura
             WHERE
                  id = del.p_id
                   ;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del;

    PROCEDURE del_rowid (p_rowid IN varchar2)
    IS
    BEGIN

       DELETE FROM   factura
             WHERE   ROWID = del_rowid.p_rowid;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del_rowid;

    PROCEDURE web_del (
                      p_id IN factura.id%TYPE,
                      p_hash IN varchar2
                      )
   IS
      l_factura_rec factura_rt;
   BEGIN


      OPEN factura_cur(
                            web_del.p_id
                            );

      FETCH factura_cur INTO l_factura_rec;

      IF factura_cur%NOTFOUND THEN
         CLOSE factura_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del.p_hash != l_factura_rec.hash THEN
            CLOSE factura_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM factura
            WHERE CURRENT OF factura_cur;

            CLOSE factura_cur;
         END IF;
      END IF;



   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del;

   PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2)
   IS
      l_factura_rec factura_rt;
   BEGIN


      OPEN factura_rowid_cur(web_del_rowid.p_rowid);

      FETCH factura_rowid_cur INTO l_factura_rec;

      IF factura_rowid_cur%NOTFOUND THEN
         CLOSE factura_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del_rowid.p_hash != l_factura_rec.hash THEN
            CLOSE factura_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM factura
            WHERE CURRENT OF factura_rowid_cur;

            CLOSE factura_rowid_cur;
         END IF;
      END IF;

   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del_rowid;

END tapi_factura;

 

/
--------------------------------------------------------
--  DDL for Package Body TAPI_FACTURA_DEPOSITO
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."TAPI_FACTURA_DEPOSITO" IS

   /**
   * TAPI_FACTURA_DEPOSITO
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: 04-AGO-2019 21:41
   * Created By: FUNDAUC
   */


   --GLOBAL_PRIVATE_CURSORS
   --By PK
   CURSOR factura_deposito_cur (
                       p_deposito_id IN factura_deposito.deposito_id%TYPE,
                       p_factura_id IN factura_deposito.factura_id%TYPE
                       )
   IS
      SELECT
            deposito_id,
            factura_id,
            tapi_factura_deposito.hash(deposito_id,factura_id),
            ROWID
      FROM factura_deposito
      WHERE
           deposito_id = factura_deposito_cur.p_deposito_id AND 
           factura_id = factura_deposito_cur.p_factura_id
      FOR UPDATE;

    --By Rowid
    CURSOR factura_deposito_rowid_cur (p_rowid IN VARCHAR2)
    IS
      SELECT
             deposito_id,
             factura_id,
             tapi_factura_deposito.hash(deposito_id,factura_id),
             ROWID
      FROM factura_deposito
      WHERE ROWID = p_rowid
      FOR UPDATE;


    FUNCTION hash (
                  p_deposito_id IN factura_deposito.deposito_id%TYPE,
                  p_factura_id IN factura_deposito.factura_id%TYPE
                  )
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format VARCHAR2(64);
   BEGIN


     --Get actual NLS_DATE_FORMAT
     SELECT   VALUE
       INTO   l_date_format
       FROM   v$nls_parameters
      WHERE   parameter = 'NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            deposito_id||
            factura_id
      INTO l_string
      FROM factura_deposito
      WHERE
           deposito_id = hash.p_deposito_id AND 
           factura_id = hash.p_factura_id
           ;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash;

    FUNCTION hash_rowid (p_rowid IN varchar2)
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format varchar2(64);
   BEGIN

      --Get actual NLS_DATE_FORMAT
      SELECT VALUE INTO l_date_format  FROM v$nls_parameters WHERE parameter ='NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            deposito_id||
            factura_id
      INTO l_string
      FROM factura_deposito
      WHERE  ROWID = hash_rowid.p_rowid;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash_rowid;

   FUNCTION rt (
               p_deposito_id IN factura_deposito.deposito_id%TYPE,
               p_factura_id IN factura_deposito.factura_id%TYPE
               )
      RETURN factura_deposito_rt RESULT_CACHE
   IS
      l_factura_deposito_rec factura_deposito_rt;
   BEGIN

      SELECT a.*,
             tapi_factura_deposito.hash(deposito_id,factura_id),
             rowid
      INTO l_factura_deposito_rec
      FROM factura_deposito a
      WHERE
           deposito_id = rt.p_deposito_id AND 
           factura_id = rt.p_factura_id
           ;


      RETURN l_factura_deposito_rec;

   END rt;

   FUNCTION rt_for_update (
                          p_deposito_id IN factura_deposito.deposito_id%TYPE,
                          p_factura_id IN factura_deposito.factura_id%TYPE
                          )
      RETURN factura_deposito_rt RESULT_CACHE
   IS
      l_factura_deposito_rec factura_deposito_rt;
   BEGIN


      SELECT a.*,
             tapi_factura_deposito.hash(deposito_id,factura_id),
             rowid
      INTO l_factura_deposito_rec
      FROM factura_deposito a
      WHERE
           deposito_id = rt_for_update.p_deposito_id AND 
           factura_id = rt_for_update.p_factura_id
      FOR UPDATE;


      RETURN l_factura_deposito_rec;

   END rt_for_update;

    FUNCTION tt (
                p_deposito_id IN factura_deposito.deposito_id%TYPE DEFAULT NULL,
                p_factura_id IN factura_deposito.factura_id%TYPE DEFAULT NULL
                )
       RETURN factura_deposito_tt
       PIPELINED
    IS
       l_factura_deposito_rec   factura_deposito_rt;
    BEGIN

       FOR c1 IN (SELECT   a.*, ROWID
                    FROM   factura_deposito a
                   WHERE
                        deposito_id = NVL(tt.p_deposito_id,deposito_id) AND 
                        factura_id = NVL(tt.p_factura_id,factura_id)
                        )
       LOOP
              l_factura_deposito_rec.deposito_id := c1.deposito_id;
              l_factura_deposito_rec.factura_id := c1.factura_id;
              l_factura_deposito_rec.hash := tapi_factura_deposito.hash( c1.deposito_id, c1.factura_id);
              l_factura_deposito_rec.row_id := c1.ROWID;
              PIPE ROW (l_factura_deposito_rec);
       END LOOP;

       RETURN;

    END tt;


    PROCEDURE ins (p_factura_deposito_rec IN OUT factura_deposito_rt)
    IS
        l_rowtype     factura_deposito%ROWTYPE;

    BEGIN


        l_rowtype.deposito_id := ins.p_factura_deposito_rec.deposito_id;
        l_rowtype.factura_id := ins.p_factura_deposito_rec.factura_id;

       INSERT INTO factura_deposito
          VALUES   l_rowtype
       RETURNING
                   deposito_id ,
                   factura_id 
            INTO   l_rowtype;

         ins.p_factura_deposito_rec.deposito_id := l_rowtype.deposito_id;
         ins.p_factura_deposito_rec.factura_id := l_rowtype.factura_id;



    END ins;

    PROCEDURE upd (
                  p_factura_deposito_rec         IN factura_deposito_rt,
                  p_ignore_nulls         IN boolean := FALSE
                  )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   factura_deposito
             SET deposito_id = NVL(p_factura_deposito_rec.deposito_id,deposito_id),
                factura_id = NVL(p_factura_deposito_rec.factura_id,factura_id)
           WHERE
                deposito_id = upd.p_factura_deposito_rec.deposito_id AND 
                factura_id = upd.p_factura_deposito_rec.factura_id
                ;
       ELSE
          UPDATE   factura_deposito
             SET deposito_id = p_factura_deposito_rec.deposito_id,
                factura_id = p_factura_deposito_rec.factura_id
           WHERE
                deposito_id = upd.p_factura_deposito_rec.deposito_id AND 
                factura_id = upd.p_factura_deposito_rec.factura_id
                ;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd;


    PROCEDURE upd_rowid (
                         p_factura_deposito_rec         IN factura_deposito_rt,
                         p_ignore_nulls         IN boolean := FALSE
                        )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   factura_deposito
             SET deposito_id = NVL(p_factura_deposito_rec.deposito_id,deposito_id),
                factura_id = NVL(p_factura_deposito_rec.factura_id,factura_id)
           WHERE  ROWID = p_factura_deposito_rec.row_id;
       ELSE
          UPDATE   factura_deposito
             SET deposito_id = p_factura_deposito_rec.deposito_id,
                factura_id = p_factura_deposito_rec.factura_id
           WHERE  ROWID = p_factura_deposito_rec.row_id;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd_rowid;

   PROCEDURE web_upd (
                  p_factura_deposito_rec         IN factura_deposito_rt,
                  p_ignore_nulls         IN boolean := FALSE
                )
   IS
      l_factura_deposito_rec factura_deposito_rt;
   BEGIN

      OPEN factura_deposito_cur(
                             web_upd.p_factura_deposito_rec.deposito_id,
                             web_upd.p_factura_deposito_rec.factura_id
                        );

      FETCH factura_deposito_cur INTO l_factura_deposito_rec;

      IF factura_deposito_cur%NOTFOUND THEN
         CLOSE factura_deposito_cur;
         RAISE e_row_missing;
      ELSE
         IF p_factura_deposito_rec.hash != l_factura_deposito_rec.hash THEN
            CLOSE factura_deposito_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(p_ignore_nulls, FALSE)
            THEN

                UPDATE   factura_deposito
                   SET deposito_id = NVL(p_factura_deposito_rec.deposito_id,deposito_id),
                       factura_id = NVL(p_factura_deposito_rec.factura_id,factura_id)
               WHERE CURRENT OF factura_deposito_cur;
            ELSE
                UPDATE   factura_deposito
                   SET deposito_id = p_factura_deposito_rec.deposito_id,
                       factura_id = p_factura_deposito_rec.factura_id
               WHERE CURRENT OF factura_deposito_cur;
            END IF;

            CLOSE factura_deposito_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd;

   PROCEDURE web_upd_rowid (
                            p_factura_deposito_rec    IN factura_deposito_rt,
                            p_ignore_nulls         IN boolean := FALSE
                           )
   IS
      l_factura_deposito_rec factura_deposito_rt;
   BEGIN

      OPEN factura_deposito_rowid_cur(web_upd_rowid.p_factura_deposito_rec.row_id);

      FETCH factura_deposito_rowid_cur INTO l_factura_deposito_rec;

      IF factura_deposito_rowid_cur%NOTFOUND THEN
         CLOSE factura_deposito_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_upd_rowid.p_factura_deposito_rec.hash != l_factura_deposito_rec.hash THEN
            CLOSE factura_deposito_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(web_upd_rowid.p_ignore_nulls, FALSE)
            THEN
                UPDATE   factura_deposito
                   SET deposito_id = NVL(p_factura_deposito_rec.deposito_id,deposito_id),
                       factura_id = NVL(p_factura_deposito_rec.factura_id,factura_id)
               WHERE CURRENT OF factura_deposito_rowid_cur;
            ELSE
                UPDATE   factura_deposito
                   SET deposito_id = p_factura_deposito_rec.deposito_id,
                       factura_id = p_factura_deposito_rec.factura_id
               WHERE CURRENT OF factura_deposito_rowid_cur;
            END IF;

            CLOSE factura_deposito_rowid_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd_rowid;

    PROCEDURE del (
                  p_deposito_id IN factura_deposito.deposito_id%TYPE,
                  p_factura_id IN factura_deposito.factura_id%TYPE
                  )
    IS
    BEGIN

       DELETE FROM   factura_deposito
             WHERE
                  deposito_id = del.p_deposito_id AND 
                  factura_id = del.p_factura_id
                   ;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del;

    PROCEDURE del_rowid (p_rowid IN varchar2)
    IS
    BEGIN

       DELETE FROM   factura_deposito
             WHERE   ROWID = del_rowid.p_rowid;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del_rowid;

    PROCEDURE web_del (
                      p_deposito_id IN factura_deposito.deposito_id%TYPE,
                      p_factura_id IN factura_deposito.factura_id%TYPE,
                      p_hash IN varchar2
                      )
   IS
      l_factura_deposito_rec factura_deposito_rt;
   BEGIN


      OPEN factura_deposito_cur(
                            web_del.p_deposito_id,
                            web_del.p_factura_id
                            );

      FETCH factura_deposito_cur INTO l_factura_deposito_rec;

      IF factura_deposito_cur%NOTFOUND THEN
         CLOSE factura_deposito_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del.p_hash != l_factura_deposito_rec.hash THEN
            CLOSE factura_deposito_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM factura_deposito
            WHERE CURRENT OF factura_deposito_cur;

            CLOSE factura_deposito_cur;
         END IF;
      END IF;



   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del;

   PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2)
   IS
      l_factura_deposito_rec factura_deposito_rt;
   BEGIN


      OPEN factura_deposito_rowid_cur(web_del_rowid.p_rowid);

      FETCH factura_deposito_rowid_cur INTO l_factura_deposito_rec;

      IF factura_deposito_rowid_cur%NOTFOUND THEN
         CLOSE factura_deposito_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del_rowid.p_hash != l_factura_deposito_rec.hash THEN
            CLOSE factura_deposito_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM factura_deposito
            WHERE CURRENT OF factura_deposito_rowid_cur;

            CLOSE factura_deposito_rowid_cur;
         END IF;
      END IF;

   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del_rowid;

END tapi_factura_deposito;



/
--------------------------------------------------------
--  DDL for Package Body TAPI_GEN2
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."TAPI_GEN2" 
AS
   --Global private variables
   g_unque_key   dbo_name_t;

   PROCEDURE create_tapi_package (p_table_name               IN VARCHAR2
                                , p_compile_table_api        IN BOOLEAN DEFAULT TRUE
                                , p_unique_key               IN VARCHAR2 DEFAULT NULL
                                , p_created_by_col_name      IN VARCHAR2 DEFAULT NULL
                                , p_created_date_col_name    IN VARCHAR2 DEFAULT NULL
                                , p_modified_by_col_name     IN VARCHAR2 DEFAULT NULL
                                , p_modified_date_col_name   IN VARCHAR2 DEFAULT NULL
                                , p_raise_exceptions         IN BOOLEAN DEFAULT FALSE )
   AS
      l_count        PLS_INTEGER := 0;
      l_table_name   dbo_name_t := LOWER (p_table_name);
      l_vars         teplsql.t_assoc_array;
      l_spec_tapi    CLOB;
      l_body_tapi    CLOB;
   BEGIN
      /*Validations*/

      --check_table_exists
      SELECT   COUNT ( * )
        INTO   l_count
        FROM   user_tables
       WHERE   UPPER (table_name) = UPPER (l_table_name);

      IF l_count = 0
      THEN
         raise_application_error (-20000, 'Table ' || l_table_name || ' does not exist!');
      END IF;

      --Check table hash PK or p_unique_key is not null
      IF p_unique_key IS NULL
      THEN
         SELECT   COUNT ( * )
           INTO   l_count
           FROM   user_constraints
          WHERE   UPPER (table_name) = UPPER (l_table_name) AND constraint_type = 'P';

         IF l_count = 0
         THEN
            raise_application_error (-20000
                                   ,    'Table '
                                     || l_table_name
                                     || ' does not have a Primary Key'
                                     || ' and P_UNIQUE_KEY parameter is null');
         END IF;
      END IF;

      --Init variables for render template
      l_vars ('date') := TO_CHAR (SYSDATE, 'DD-MON-YYYY HH24:MI');
      l_vars ('table_name') := l_table_name;
      l_vars ('user') := USER;
      l_vars ('created_by_col_name') := p_created_by_col_name;
      l_vars ('created_date_col_name') := p_created_date_col_name;
      l_vars ('modified_by_col_name') := p_modified_by_col_name;
      l_vars ('modified_date_col_name') := p_modified_date_col_name;
      l_vars ('result_cache') := 'RESULT_CACHE';

      IF p_raise_exceptions
      THEN
         l_vars ('raise_exceptions') := 'TRUE';
      ELSE
         l_vars ('raise_exceptions') := '';
      END IF;

      --If the table hash LOBS columns, disable result_cache.
      FOR c1 IN (SELECT   *
                   FROM   user_tab_cols
                  WHERE   table_name = UPPER (l_table_name) AND data_type IN ('BLOB', 'CLOB'))
      LOOP
         l_vars ('result_cache') := '';
      END LOOP;

      --Define unique key if table don't hace primary key
      g_unque_key := p_unique_key;

      -- Spec --
      --Process template
      l_spec_tapi := teplsql.process (l_vars, 'spec', 'TAPI_GEN2');

      -- Body --
      --Process template
      l_body_tapi := teplsql.process (l_vars, 'body', 'TAPI_GEN2');

      IF p_compile_table_api
      THEN
         BEGIN
            EXECUTE IMMEDIATE l_spec_tapi;
         EXCEPTION
            WHEN OTHERS
            THEN
               DBMS_OUTPUT.put_line (l_spec_tapi);
               raise_application_error (-20000, 'Spec compiled with error(s)! ' || SQLERRM);
         END;

         BEGIN
            EXECUTE IMMEDIATE l_body_tapi;
         EXCEPTION
            WHEN OTHERS
            THEN
               raise_application_error (-20000, ' Body compiled with error(s)! ' || SQLERRM);
         END;

         DBMS_OUTPUT.put_line('Creation of Table API package for ' || l_table_name || ' table completed successfully!');
      ELSE
         DBMS_OUTPUT.put_line (l_spec_tapi);
         DBMS_OUTPUT.put_line (l_body_tapi);
      END IF;
   END create_tapi_package;


   FUNCTION get_all_columns (p_tab_name VARCHAR2)
      RETURN column_tt
   IS
      l_tt   column_tt;
   BEGIN
        SELECT   c.table_name
               , LOWER (c.column_name)
               , c.nullable
               , '' constraint_type
          BULK   COLLECT
          INTO   l_tt
          FROM   user_tab_columns c
         WHERE   c.table_name = UPPER (p_tab_name)
      ORDER BY   c.column_id;

      RETURN l_tt;
   END;

   FUNCTION get_pk_columns (p_tab_name VARCHAR2)
      RETURN column_tt
   IS
      l_tt   column_tt;
   BEGIN
      IF g_unque_key IS NOT NULL
      THEN
         IF NOT l_tt.EXISTS (1)
         THEN
            l_tt        := column_tt (NULL);
         END IF;

         l_tt (1).table_name := p_tab_name;
         l_tt (1).column_name := LOWER (g_unque_key);
         l_tt (1).nullable := 'N';
         l_tt (1).constraint_type := 'P';
      ELSE
           SELECT   c.table_name
                  , LOWER (c.column_name)
                  , c.nullable
                  , cs.constraint_type
             BULK   COLLECT
             INTO   l_tt
             FROM         user_tab_columns c
                       LEFT JOIN
                          user_cons_columns cc
                       ON c.table_name = cc.table_name AND c.column_name = cc.column_name
                    LEFT JOIN
                       user_constraints cs
                    ON cc.constraint_name = cs.constraint_name
            WHERE   c.table_name = UPPER (p_tab_name) AND cs.constraint_type = 'P'
         ORDER BY   c.column_id;
      END IF;

      RETURN l_tt;
   END;


   FUNCTION get_noblob_columns (p_tab_name VARCHAR2)
      RETURN column_tt
   IS
      l_tt   column_tt;
   BEGIN
        SELECT   c.table_name
               , LOWER (c.column_name)
               , c.nullable
               , '' constraint_type
          BULK   COLLECT
          INTO   l_tt
          FROM   user_tab_columns c
         WHERE   table_name = UPPER (p_tab_name)
                 AND column_name NOT IN (SELECT   column_name
                                           FROM   user_tab_cols
                                          WHERE   table_name = UPPER (p_tab_name) AND data_type = 'BLOB')
      ORDER BY   column_id;

      RETURN l_tt;
   END;
END tapi_gen2;

/
--------------------------------------------------------
--  DDL for Package Body TAPI_HOJA_VIDA_EST
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."TAPI_HOJA_VIDA_EST" IS

   /**
   * TAPI_HOJA_VIDA_EST
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: 16-SEP-2019 13:22
   * Created By: FUNDAUC
   */


   --GLOBAL_PRIVATE_CURSORS
   --By PK
   CURSOR hoja_vida_est_cur (
                       p_id IN hoja_vida_est.id%TYPE
                       )
   IS
      SELECT
            id,
            matricula,
            evento_id,
            fecha,
            metadata,
            observacion,
            tapi_hoja_vida_est.hash(id),
            ROWID
      FROM hoja_vida_est
      WHERE
           id = hoja_vida_est_cur.p_id
      FOR UPDATE;

    --By Rowid
    CURSOR hoja_vida_est_rowid_cur (p_rowid IN VARCHAR2)
    IS
      SELECT
             id,
             matricula,
             evento_id,
             fecha,
             metadata,
             observacion,
             tapi_hoja_vida_est.hash(id),
             ROWID
      FROM hoja_vida_est
      WHERE ROWID = p_rowid
      FOR UPDATE;


    FUNCTION hash (
                  p_id IN hoja_vida_est.id%TYPE
                  )
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format VARCHAR2(64);
   BEGIN


     --Get actual NLS_DATE_FORMAT
     SELECT   VALUE
       INTO   l_date_format
       FROM   v$nls_parameters
      WHERE   parameter = 'NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            id||
            matricula||
            evento_id||
            fecha||
            metadata||
            observacion
      INTO l_string
      FROM hoja_vida_est
      WHERE
           id = hash.p_id
           ;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash;

    FUNCTION hash_rowid (p_rowid IN varchar2)
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format varchar2(64);
   BEGIN

      --Get actual NLS_DATE_FORMAT
      SELECT VALUE INTO l_date_format  FROM v$nls_parameters WHERE parameter ='NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            id||
            matricula||
            evento_id||
            fecha||
            metadata||
            observacion
      INTO l_string
      FROM hoja_vida_est
      WHERE  ROWID = hash_rowid.p_rowid;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash_rowid;

   FUNCTION rt (
               p_id IN hoja_vida_est.id%TYPE
               )
      RETURN hoja_vida_est_rt 
   IS
      l_hoja_vida_est_rec hoja_vida_est_rt;
   BEGIN

      SELECT a.*,
             tapi_hoja_vida_est.hash(id),
             rowid
      INTO l_hoja_vida_est_rec
      FROM hoja_vida_est a
      WHERE
           id = rt.p_id
           ;


      RETURN l_hoja_vida_est_rec;

   END rt;

   FUNCTION rt_for_update (
                          p_id IN hoja_vida_est.id%TYPE
                          )
      RETURN hoja_vida_est_rt 
   IS
      l_hoja_vida_est_rec hoja_vida_est_rt;
   BEGIN


      SELECT a.*,
             tapi_hoja_vida_est.hash(id),
             rowid
      INTO l_hoja_vida_est_rec
      FROM hoja_vida_est a
      WHERE
           id = rt_for_update.p_id
      FOR UPDATE;


      RETURN l_hoja_vida_est_rec;

   END rt_for_update;

    FUNCTION tt (
                p_id IN hoja_vida_est.id%TYPE DEFAULT NULL
                )
       RETURN hoja_vida_est_tt
       PIPELINED
    IS
       l_hoja_vida_est_rec   hoja_vida_est_rt;
    BEGIN

       FOR c1 IN (SELECT   a.*, ROWID
                    FROM   hoja_vida_est a
                   WHERE
                        id = NVL(tt.p_id,id)
                        )
       LOOP
              l_hoja_vida_est_rec.id := c1.id;
              l_hoja_vida_est_rec.matricula := c1.matricula;
              l_hoja_vida_est_rec.evento_id := c1.evento_id;
              l_hoja_vida_est_rec.fecha := c1.fecha;
              l_hoja_vida_est_rec.metadata := c1.metadata;
              l_hoja_vida_est_rec.observacion := c1.observacion;
              l_hoja_vida_est_rec.hash := tapi_hoja_vida_est.hash( c1.id);
              l_hoja_vida_est_rec.row_id := c1.ROWID;
              PIPE ROW (l_hoja_vida_est_rec);
       END LOOP;

       RETURN;

    END tt;


    PROCEDURE ins (p_hoja_vida_est_rec IN OUT hoja_vida_est_rt)
    IS
        l_rowtype     hoja_vida_est%ROWTYPE;

    BEGIN


        l_rowtype.id := ins.p_hoja_vida_est_rec.id;
        l_rowtype.matricula := ins.p_hoja_vida_est_rec.matricula;
        l_rowtype.evento_id := ins.p_hoja_vida_est_rec.evento_id;
        l_rowtype.fecha := ins.p_hoja_vida_est_rec.fecha;
        l_rowtype.metadata := ins.p_hoja_vida_est_rec.metadata;
        l_rowtype.observacion := ins.p_hoja_vida_est_rec.observacion;

       INSERT INTO hoja_vida_est
          VALUES   l_rowtype
       RETURNING
                   id ,
                   matricula ,
                   evento_id ,
                   fecha ,
                   metadata ,
                   observacion 
            INTO   l_rowtype;

         ins.p_hoja_vida_est_rec.id := l_rowtype.id;
         ins.p_hoja_vida_est_rec.matricula := l_rowtype.matricula;
         ins.p_hoja_vida_est_rec.evento_id := l_rowtype.evento_id;
         ins.p_hoja_vida_est_rec.fecha := l_rowtype.fecha;
         ins.p_hoja_vida_est_rec.metadata := l_rowtype.metadata;
         ins.p_hoja_vida_est_rec.observacion := l_rowtype.observacion;



    END ins;

    PROCEDURE upd (
                  p_hoja_vida_est_rec         IN hoja_vida_est_rt,
                  p_ignore_nulls         IN boolean := FALSE
                  )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   hoja_vida_est
             SET id = NVL(p_hoja_vida_est_rec.id,id),
                matricula = NVL(p_hoja_vida_est_rec.matricula,matricula),
                evento_id = NVL(p_hoja_vida_est_rec.evento_id,evento_id),
                fecha = NVL(p_hoja_vida_est_rec.fecha,fecha),
                metadata = NVL(p_hoja_vida_est_rec.metadata,metadata),
                observacion = NVL(p_hoja_vida_est_rec.observacion,observacion)
           WHERE
                id = upd.p_hoja_vida_est_rec.id
                ;
       ELSE
          UPDATE   hoja_vida_est
             SET id = p_hoja_vida_est_rec.id,
                matricula = p_hoja_vida_est_rec.matricula,
                evento_id = p_hoja_vida_est_rec.evento_id,
                fecha = p_hoja_vida_est_rec.fecha,
                metadata = p_hoja_vida_est_rec.metadata,
                observacion = p_hoja_vida_est_rec.observacion
           WHERE
                id = upd.p_hoja_vida_est_rec.id
                ;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd;


    PROCEDURE upd_rowid (
                         p_hoja_vida_est_rec         IN hoja_vida_est_rt,
                         p_ignore_nulls         IN boolean := FALSE
                        )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   hoja_vida_est
             SET id = NVL(p_hoja_vida_est_rec.id,id),
                matricula = NVL(p_hoja_vida_est_rec.matricula,matricula),
                evento_id = NVL(p_hoja_vida_est_rec.evento_id,evento_id),
                fecha = NVL(p_hoja_vida_est_rec.fecha,fecha),
                metadata = NVL(p_hoja_vida_est_rec.metadata,metadata),
                observacion = NVL(p_hoja_vida_est_rec.observacion,observacion)
           WHERE  ROWID = p_hoja_vida_est_rec.row_id;
       ELSE
          UPDATE   hoja_vida_est
             SET id = p_hoja_vida_est_rec.id,
                matricula = p_hoja_vida_est_rec.matricula,
                evento_id = p_hoja_vida_est_rec.evento_id,
                fecha = p_hoja_vida_est_rec.fecha,
                metadata = p_hoja_vida_est_rec.metadata,
                observacion = p_hoja_vida_est_rec.observacion
           WHERE  ROWID = p_hoja_vida_est_rec.row_id;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd_rowid;

   PROCEDURE web_upd (
                  p_hoja_vida_est_rec         IN hoja_vida_est_rt,
                  p_ignore_nulls         IN boolean := FALSE
                )
   IS
      l_hoja_vida_est_rec hoja_vida_est_rt;
   BEGIN

      OPEN hoja_vida_est_cur(
                             web_upd.p_hoja_vida_est_rec.id
                        );

      FETCH hoja_vida_est_cur INTO l_hoja_vida_est_rec;

      IF hoja_vida_est_cur%NOTFOUND THEN
         CLOSE hoja_vida_est_cur;
         RAISE e_row_missing;
      ELSE
         IF p_hoja_vida_est_rec.hash != l_hoja_vida_est_rec.hash THEN
            CLOSE hoja_vida_est_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(p_ignore_nulls, FALSE)
            THEN

                UPDATE   hoja_vida_est
                   SET id = NVL(p_hoja_vida_est_rec.id,id),
                       matricula = NVL(p_hoja_vida_est_rec.matricula,matricula),
                       evento_id = NVL(p_hoja_vida_est_rec.evento_id,evento_id),
                       fecha = NVL(p_hoja_vida_est_rec.fecha,fecha),
                       metadata = NVL(p_hoja_vida_est_rec.metadata,metadata),
                       observacion = NVL(p_hoja_vida_est_rec.observacion,observacion)
               WHERE CURRENT OF hoja_vida_est_cur;
            ELSE
                UPDATE   hoja_vida_est
                   SET id = p_hoja_vida_est_rec.id,
                       matricula = p_hoja_vida_est_rec.matricula,
                       evento_id = p_hoja_vida_est_rec.evento_id,
                       fecha = p_hoja_vida_est_rec.fecha,
                       metadata = p_hoja_vida_est_rec.metadata,
                       observacion = p_hoja_vida_est_rec.observacion
               WHERE CURRENT OF hoja_vida_est_cur;
            END IF;

            CLOSE hoja_vida_est_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd;

   PROCEDURE web_upd_rowid (
                            p_hoja_vida_est_rec    IN hoja_vida_est_rt,
                            p_ignore_nulls         IN boolean := FALSE
                           )
   IS
      l_hoja_vida_est_rec hoja_vida_est_rt;
   BEGIN

      OPEN hoja_vida_est_rowid_cur(web_upd_rowid.p_hoja_vida_est_rec.row_id);

      FETCH hoja_vida_est_rowid_cur INTO l_hoja_vida_est_rec;

      IF hoja_vida_est_rowid_cur%NOTFOUND THEN
         CLOSE hoja_vida_est_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_upd_rowid.p_hoja_vida_est_rec.hash != l_hoja_vida_est_rec.hash THEN
            CLOSE hoja_vida_est_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(web_upd_rowid.p_ignore_nulls, FALSE)
            THEN
                UPDATE   hoja_vida_est
                   SET id = NVL(p_hoja_vida_est_rec.id,id),
                       matricula = NVL(p_hoja_vida_est_rec.matricula,matricula),
                       evento_id = NVL(p_hoja_vida_est_rec.evento_id,evento_id),
                       fecha = NVL(p_hoja_vida_est_rec.fecha,fecha),
                       metadata = NVL(p_hoja_vida_est_rec.metadata,metadata),
                       observacion = NVL(p_hoja_vida_est_rec.observacion,observacion)
               WHERE CURRENT OF hoja_vida_est_rowid_cur;
            ELSE
                UPDATE   hoja_vida_est
                   SET id = p_hoja_vida_est_rec.id,
                       matricula = p_hoja_vida_est_rec.matricula,
                       evento_id = p_hoja_vida_est_rec.evento_id,
                       fecha = p_hoja_vida_est_rec.fecha,
                       metadata = p_hoja_vida_est_rec.metadata,
                       observacion = p_hoja_vida_est_rec.observacion
               WHERE CURRENT OF hoja_vida_est_rowid_cur;
            END IF;

            CLOSE hoja_vida_est_rowid_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd_rowid;

    PROCEDURE del (
                  p_id IN hoja_vida_est.id%TYPE
                  )
    IS
    BEGIN

       DELETE FROM   hoja_vida_est
             WHERE
                  id = del.p_id
                   ;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del;

    PROCEDURE del_rowid (p_rowid IN varchar2)
    IS
    BEGIN

       DELETE FROM   hoja_vida_est
             WHERE   ROWID = del_rowid.p_rowid;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del_rowid;

    PROCEDURE web_del (
                      p_id IN hoja_vida_est.id%TYPE,
                      p_hash IN varchar2
                      )
   IS
      l_hoja_vida_est_rec hoja_vida_est_rt;
   BEGIN


      OPEN hoja_vida_est_cur(
                            web_del.p_id
                            );

      FETCH hoja_vida_est_cur INTO l_hoja_vida_est_rec;

      IF hoja_vida_est_cur%NOTFOUND THEN
         CLOSE hoja_vida_est_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del.p_hash != l_hoja_vida_est_rec.hash THEN
            CLOSE hoja_vida_est_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM hoja_vida_est
            WHERE CURRENT OF hoja_vida_est_cur;

            CLOSE hoja_vida_est_cur;
         END IF;
      END IF;



   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del;

   PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2)
   IS
      l_hoja_vida_est_rec hoja_vida_est_rt;
   BEGIN


      OPEN hoja_vida_est_rowid_cur(web_del_rowid.p_rowid);

      FETCH hoja_vida_est_rowid_cur INTO l_hoja_vida_est_rec;

      IF hoja_vida_est_rowid_cur%NOTFOUND THEN
         CLOSE hoja_vida_est_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del_rowid.p_hash != l_hoja_vida_est_rec.hash THEN
            CLOSE hoja_vida_est_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM hoja_vida_est
            WHERE CURRENT OF hoja_vida_est_rowid_cur;

            CLOSE hoja_vida_est_rowid_cur;
         END IF;
      END IF;

   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del_rowid;

END tapi_hoja_vida_est;

/
--------------------------------------------------------
--  DDL for Package Body TAPI_INSCRIPCIONES
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."TAPI_INSCRIPCIONES" IS

   /**
   * TAPI_INSCRIPCIONES
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: 22-FEB-2020 03:12
   * Created By: FUNDAUC
   */


   --GLOBAL_PRIVATE_CURSORS
   --By PK
   CURSOR inscripciones_cur (
                       p_id IN inscripciones.id%TYPE
                       )
   IS
      SELECT
            id,
            fecha_ins,
            est_matricula,
            fecha_pago,
            estatus,
            seccion_id,
            periodo_id,
            creado_por,
            es_exonerado,
            prog_academico,
            es_suspendido,
            cohorte_id,
            horario_id,
            modificado_por,
            modificado_el,
            tapi_inscripciones.hash(id),
            ROWID
      FROM inscripciones
      WHERE
           id = inscripciones_cur.p_id
      FOR UPDATE;

    --By Rowid
    CURSOR inscripciones_rowid_cur (p_rowid IN VARCHAR2)
    IS
      SELECT
             id,
             fecha_ins,
             est_matricula,
             fecha_pago,
             estatus,
             seccion_id,
             periodo_id,
             creado_por,
             es_exonerado,
             prog_academico,
             es_suspendido,
             cohorte_id,
             horario_id,
             modificado_por,
             modificado_el,
             tapi_inscripciones.hash(id),
             ROWID
      FROM inscripciones
      WHERE ROWID = p_rowid
      FOR UPDATE;


    FUNCTION hash (
                  p_id IN inscripciones.id%TYPE
                  )
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format VARCHAR2(64);
   BEGIN


     --Get actual NLS_DATE_FORMAT
     SELECT   VALUE
       INTO   l_date_format
       FROM   v$nls_parameters
      WHERE   parameter = 'NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            id||
            fecha_ins||
            est_matricula||
            fecha_pago||
            estatus||
            seccion_id||
            periodo_id||
            creado_por||
            es_exonerado||
            prog_academico||
            es_suspendido||
            cohorte_id||
            horario_id||
            modificado_por||
            modificado_el
      INTO l_string
      FROM inscripciones
      WHERE
           id = hash.p_id
           ;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash;

    FUNCTION hash_rowid (p_rowid IN varchar2)
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format varchar2(64);
   BEGIN

      --Get actual NLS_DATE_FORMAT
      SELECT VALUE INTO l_date_format  FROM v$nls_parameters WHERE parameter ='NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            id||
            fecha_ins||
            est_matricula||
            fecha_pago||
            estatus||
            seccion_id||
            periodo_id||
            creado_por||
            es_exonerado||
            prog_academico||
            es_suspendido||
            cohorte_id||
            horario_id||
            modificado_por||
            modificado_el
      INTO l_string
      FROM inscripciones
      WHERE  ROWID = hash_rowid.p_rowid;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash_rowid;

   FUNCTION rt (
               p_id IN inscripciones.id%TYPE
               )
      RETURN inscripciones_rt RESULT_CACHE
   IS
      l_inscripciones_rec inscripciones_rt;
   BEGIN

      SELECT a.*,
             tapi_inscripciones.hash(id),
             rowid
      INTO l_inscripciones_rec
      FROM inscripciones a
      WHERE
           id = rt.p_id
           ;


      RETURN l_inscripciones_rec;

   END rt;

   FUNCTION rt_for_update (
                          p_id IN inscripciones.id%TYPE
                          )
      RETURN inscripciones_rt RESULT_CACHE
   IS
      l_inscripciones_rec inscripciones_rt;
   BEGIN


      SELECT a.*,
             tapi_inscripciones.hash(id),
             rowid
      INTO l_inscripciones_rec
      FROM inscripciones a
      WHERE
           id = rt_for_update.p_id
      FOR UPDATE;


      RETURN l_inscripciones_rec;

   END rt_for_update;

    FUNCTION tt (
                p_id IN inscripciones.id%TYPE DEFAULT NULL
                )
       RETURN inscripciones_tt
       PIPELINED
    IS
       l_inscripciones_rec   inscripciones_rt;
    BEGIN

       FOR c1 IN (SELECT   a.*, ROWID
                    FROM   inscripciones a
                   WHERE
                        id = NVL(tt.p_id,id)
                        )
       LOOP
              l_inscripciones_rec.id := c1.id;
              l_inscripciones_rec.fecha_ins := c1.fecha_ins;
              l_inscripciones_rec.est_matricula := c1.est_matricula;
              l_inscripciones_rec.fecha_pago := c1.fecha_pago;
              l_inscripciones_rec.estatus := c1.estatus;
              l_inscripciones_rec.seccion_id := c1.seccion_id;
              l_inscripciones_rec.periodo_id := c1.periodo_id;
              l_inscripciones_rec.creado_por := c1.creado_por;
              l_inscripciones_rec.es_exonerado := c1.es_exonerado;
              l_inscripciones_rec.prog_academico := c1.prog_academico;
              l_inscripciones_rec.es_suspendido := c1.es_suspendido;
              l_inscripciones_rec.cohorte_id := c1.cohorte_id;
              l_inscripciones_rec.horario_id := c1.horario_id;
              l_inscripciones_rec.modificado_por := c1.modificado_por;
              l_inscripciones_rec.modificado_el := c1.modificado_el;
              l_inscripciones_rec.hash := tapi_inscripciones.hash( c1.id);
              l_inscripciones_rec.row_id := c1.ROWID;
              PIPE ROW (l_inscripciones_rec);
       END LOOP;

       RETURN;

    END tt;


    PROCEDURE ins (p_inscripciones_rec IN OUT inscripciones_rt)
    IS
        l_rowtype     inscripciones%ROWTYPE;

    BEGIN


        l_rowtype.id := ins.p_inscripciones_rec.id;
        l_rowtype.fecha_ins := ins.p_inscripciones_rec.fecha_ins;
        l_rowtype.est_matricula := ins.p_inscripciones_rec.est_matricula;
        l_rowtype.fecha_pago := ins.p_inscripciones_rec.fecha_pago;
        l_rowtype.estatus := ins.p_inscripciones_rec.estatus;
        l_rowtype.seccion_id := ins.p_inscripciones_rec.seccion_id;
        l_rowtype.periodo_id := ins.p_inscripciones_rec.periodo_id;
        l_rowtype.creado_por := ins.p_inscripciones_rec.creado_por;
        l_rowtype.es_exonerado := ins.p_inscripciones_rec.es_exonerado;
        l_rowtype.prog_academico := ins.p_inscripciones_rec.prog_academico;
        l_rowtype.es_suspendido := ins.p_inscripciones_rec.es_suspendido;
        l_rowtype.cohorte_id := ins.p_inscripciones_rec.cohorte_id;
        l_rowtype.horario_id := ins.p_inscripciones_rec.horario_id;
        l_rowtype.modificado_por := ins.p_inscripciones_rec.modificado_por;
        l_rowtype.modificado_el := ins.p_inscripciones_rec.modificado_el;

       INSERT INTO inscripciones
          VALUES   l_rowtype
       RETURNING
                   id ,
                   fecha_ins ,
                   est_matricula ,
                   fecha_pago ,
                   estatus ,
                   seccion_id ,
                   periodo_id ,
                   creado_por ,
                   es_exonerado ,
                   prog_academico ,
                   es_suspendido ,
                   cohorte_id ,
                   horario_id ,
                   modificado_por ,
                   modificado_el 
            INTO   l_rowtype;

         ins.p_inscripciones_rec.id := l_rowtype.id;
         ins.p_inscripciones_rec.fecha_ins := l_rowtype.fecha_ins;
         ins.p_inscripciones_rec.est_matricula := l_rowtype.est_matricula;
         ins.p_inscripciones_rec.fecha_pago := l_rowtype.fecha_pago;
         ins.p_inscripciones_rec.estatus := l_rowtype.estatus;
         ins.p_inscripciones_rec.seccion_id := l_rowtype.seccion_id;
         ins.p_inscripciones_rec.periodo_id := l_rowtype.periodo_id;
         ins.p_inscripciones_rec.creado_por := l_rowtype.creado_por;
         ins.p_inscripciones_rec.es_exonerado := l_rowtype.es_exonerado;
         ins.p_inscripciones_rec.prog_academico := l_rowtype.prog_academico;
         ins.p_inscripciones_rec.es_suspendido := l_rowtype.es_suspendido;
         ins.p_inscripciones_rec.cohorte_id := l_rowtype.cohorte_id;
         ins.p_inscripciones_rec.horario_id := l_rowtype.horario_id;
         ins.p_inscripciones_rec.modificado_por := l_rowtype.modificado_por;
         ins.p_inscripciones_rec.modificado_el := l_rowtype.modificado_el;



    END ins;

    PROCEDURE upd (
                  p_inscripciones_rec         IN inscripciones_rt,
                  p_ignore_nulls         IN boolean := FALSE
                  )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   inscripciones
             SET id = NVL(p_inscripciones_rec.id,id),
                fecha_ins = NVL(p_inscripciones_rec.fecha_ins,fecha_ins),
                est_matricula = NVL(p_inscripciones_rec.est_matricula,est_matricula),
                fecha_pago = NVL(p_inscripciones_rec.fecha_pago,fecha_pago),
                estatus = NVL(p_inscripciones_rec.estatus,estatus),
                seccion_id = NVL(p_inscripciones_rec.seccion_id,seccion_id),
                periodo_id = NVL(p_inscripciones_rec.periodo_id,periodo_id),
                creado_por = NVL(p_inscripciones_rec.creado_por,creado_por),
                es_exonerado = NVL(p_inscripciones_rec.es_exonerado,es_exonerado),
                prog_academico = NVL(p_inscripciones_rec.prog_academico,prog_academico),
                es_suspendido = NVL(p_inscripciones_rec.es_suspendido,es_suspendido),
                cohorte_id = NVL(p_inscripciones_rec.cohorte_id,cohorte_id),
                horario_id = NVL(p_inscripciones_rec.horario_id,horario_id),
                modificado_por = NVL(p_inscripciones_rec.modificado_por,modificado_por),
                modificado_el = NVL(p_inscripciones_rec.modificado_el,modificado_el)
           WHERE
                id = upd.p_inscripciones_rec.id
                ;
       ELSE
          UPDATE   inscripciones
             SET id = p_inscripciones_rec.id,
                fecha_ins = p_inscripciones_rec.fecha_ins,
                est_matricula = p_inscripciones_rec.est_matricula,
                fecha_pago = p_inscripciones_rec.fecha_pago,
                estatus = p_inscripciones_rec.estatus,
                seccion_id = p_inscripciones_rec.seccion_id,
                periodo_id = p_inscripciones_rec.periodo_id,
                creado_por = p_inscripciones_rec.creado_por,
                es_exonerado = p_inscripciones_rec.es_exonerado,
                prog_academico = p_inscripciones_rec.prog_academico,
                es_suspendido = p_inscripciones_rec.es_suspendido,
                cohorte_id = p_inscripciones_rec.cohorte_id,
                horario_id = p_inscripciones_rec.horario_id,
                modificado_por = p_inscripciones_rec.modificado_por,
                modificado_el = p_inscripciones_rec.modificado_el
           WHERE
                id = upd.p_inscripciones_rec.id
                ;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd;


    PROCEDURE upd_rowid (
                         p_inscripciones_rec         IN inscripciones_rt,
                         p_ignore_nulls         IN boolean := FALSE
                        )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   inscripciones
             SET id = NVL(p_inscripciones_rec.id,id),
                fecha_ins = NVL(p_inscripciones_rec.fecha_ins,fecha_ins),
                est_matricula = NVL(p_inscripciones_rec.est_matricula,est_matricula),
                fecha_pago = NVL(p_inscripciones_rec.fecha_pago,fecha_pago),
                estatus = NVL(p_inscripciones_rec.estatus,estatus),
                seccion_id = NVL(p_inscripciones_rec.seccion_id,seccion_id),
                periodo_id = NVL(p_inscripciones_rec.periodo_id,periodo_id),
                creado_por = NVL(p_inscripciones_rec.creado_por,creado_por),
                es_exonerado = NVL(p_inscripciones_rec.es_exonerado,es_exonerado),
                prog_academico = NVL(p_inscripciones_rec.prog_academico,prog_academico),
                es_suspendido = NVL(p_inscripciones_rec.es_suspendido,es_suspendido),
                cohorte_id = NVL(p_inscripciones_rec.cohorte_id,cohorte_id),
                horario_id = NVL(p_inscripciones_rec.horario_id,horario_id),
                modificado_por = NVL(p_inscripciones_rec.modificado_por,modificado_por),
                modificado_el = NVL(p_inscripciones_rec.modificado_el,modificado_el)
           WHERE  ROWID = p_inscripciones_rec.row_id;
       ELSE
          UPDATE   inscripciones
             SET id = p_inscripciones_rec.id,
                fecha_ins = p_inscripciones_rec.fecha_ins,
                est_matricula = p_inscripciones_rec.est_matricula,
                fecha_pago = p_inscripciones_rec.fecha_pago,
                estatus = p_inscripciones_rec.estatus,
                seccion_id = p_inscripciones_rec.seccion_id,
                periodo_id = p_inscripciones_rec.periodo_id,
                creado_por = p_inscripciones_rec.creado_por,
                es_exonerado = p_inscripciones_rec.es_exonerado,
                prog_academico = p_inscripciones_rec.prog_academico,
                es_suspendido = p_inscripciones_rec.es_suspendido,
                cohorte_id = p_inscripciones_rec.cohorte_id,
                horario_id = p_inscripciones_rec.horario_id,
                modificado_por = p_inscripciones_rec.modificado_por,
                modificado_el = p_inscripciones_rec.modificado_el
           WHERE  ROWID = p_inscripciones_rec.row_id;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd_rowid;

   PROCEDURE web_upd (
                  p_inscripciones_rec         IN inscripciones_rt,
                  p_ignore_nulls         IN boolean := FALSE
                )
   IS
      l_inscripciones_rec inscripciones_rt;
   BEGIN

      OPEN inscripciones_cur(
                             web_upd.p_inscripciones_rec.id
                        );

      FETCH inscripciones_cur INTO l_inscripciones_rec;

      IF inscripciones_cur%NOTFOUND THEN
         CLOSE inscripciones_cur;
         RAISE e_row_missing;
      ELSE
         IF p_inscripciones_rec.hash != l_inscripciones_rec.hash THEN
            CLOSE inscripciones_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(p_ignore_nulls, FALSE)
            THEN

                UPDATE   inscripciones
                   SET id = NVL(p_inscripciones_rec.id,id),
                       fecha_ins = NVL(p_inscripciones_rec.fecha_ins,fecha_ins),
                       est_matricula = NVL(p_inscripciones_rec.est_matricula,est_matricula),
                       fecha_pago = NVL(p_inscripciones_rec.fecha_pago,fecha_pago),
                       estatus = NVL(p_inscripciones_rec.estatus,estatus),
                       seccion_id = NVL(p_inscripciones_rec.seccion_id,seccion_id),
                       periodo_id = NVL(p_inscripciones_rec.periodo_id,periodo_id),
                       creado_por = NVL(p_inscripciones_rec.creado_por,creado_por),
                       es_exonerado = NVL(p_inscripciones_rec.es_exonerado,es_exonerado),
                       prog_academico = NVL(p_inscripciones_rec.prog_academico,prog_academico),
                       es_suspendido = NVL(p_inscripciones_rec.es_suspendido,es_suspendido),
                       cohorte_id = NVL(p_inscripciones_rec.cohorte_id,cohorte_id),
                       horario_id = NVL(p_inscripciones_rec.horario_id,horario_id),
                       modificado_por = NVL(p_inscripciones_rec.modificado_por,modificado_por),
                       modificado_el = NVL(p_inscripciones_rec.modificado_el,modificado_el)
               WHERE CURRENT OF inscripciones_cur;
            ELSE
                UPDATE   inscripciones
                   SET id = p_inscripciones_rec.id,
                       fecha_ins = p_inscripciones_rec.fecha_ins,
                       est_matricula = p_inscripciones_rec.est_matricula,
                       fecha_pago = p_inscripciones_rec.fecha_pago,
                       estatus = p_inscripciones_rec.estatus,
                       seccion_id = p_inscripciones_rec.seccion_id,
                       periodo_id = p_inscripciones_rec.periodo_id,
                       creado_por = p_inscripciones_rec.creado_por,
                       es_exonerado = p_inscripciones_rec.es_exonerado,
                       prog_academico = p_inscripciones_rec.prog_academico,
                       es_suspendido = p_inscripciones_rec.es_suspendido,
                       cohorte_id = p_inscripciones_rec.cohorte_id,
                       horario_id = p_inscripciones_rec.horario_id,
                       modificado_por = p_inscripciones_rec.modificado_por,
                       modificado_el = p_inscripciones_rec.modificado_el
               WHERE CURRENT OF inscripciones_cur;
            END IF;

            CLOSE inscripciones_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd;

   PROCEDURE web_upd_rowid (
                            p_inscripciones_rec    IN inscripciones_rt,
                            p_ignore_nulls         IN boolean := FALSE
                           )
   IS
      l_inscripciones_rec inscripciones_rt;
   BEGIN

      OPEN inscripciones_rowid_cur(web_upd_rowid.p_inscripciones_rec.row_id);

      FETCH inscripciones_rowid_cur INTO l_inscripciones_rec;

      IF inscripciones_rowid_cur%NOTFOUND THEN
         CLOSE inscripciones_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_upd_rowid.p_inscripciones_rec.hash != l_inscripciones_rec.hash THEN
            CLOSE inscripciones_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(web_upd_rowid.p_ignore_nulls, FALSE)
            THEN
                UPDATE   inscripciones
                   SET id = NVL(p_inscripciones_rec.id,id),
                       fecha_ins = NVL(p_inscripciones_rec.fecha_ins,fecha_ins),
                       est_matricula = NVL(p_inscripciones_rec.est_matricula,est_matricula),
                       fecha_pago = NVL(p_inscripciones_rec.fecha_pago,fecha_pago),
                       estatus = NVL(p_inscripciones_rec.estatus,estatus),
                       seccion_id = NVL(p_inscripciones_rec.seccion_id,seccion_id),
                       periodo_id = NVL(p_inscripciones_rec.periodo_id,periodo_id),
                       creado_por = NVL(p_inscripciones_rec.creado_por,creado_por),
                       es_exonerado = NVL(p_inscripciones_rec.es_exonerado,es_exonerado),
                       prog_academico = NVL(p_inscripciones_rec.prog_academico,prog_academico),
                       es_suspendido = NVL(p_inscripciones_rec.es_suspendido,es_suspendido),
                       cohorte_id = NVL(p_inscripciones_rec.cohorte_id,cohorte_id),
                       horario_id = NVL(p_inscripciones_rec.horario_id,horario_id),
                       modificado_por = NVL(p_inscripciones_rec.modificado_por,modificado_por),
                       modificado_el = NVL(p_inscripciones_rec.modificado_el,modificado_el)
               WHERE CURRENT OF inscripciones_rowid_cur;
            ELSE
                UPDATE   inscripciones
                   SET id = p_inscripciones_rec.id,
                       fecha_ins = p_inscripciones_rec.fecha_ins,
                       est_matricula = p_inscripciones_rec.est_matricula,
                       fecha_pago = p_inscripciones_rec.fecha_pago,
                       estatus = p_inscripciones_rec.estatus,
                       seccion_id = p_inscripciones_rec.seccion_id,
                       periodo_id = p_inscripciones_rec.periodo_id,
                       creado_por = p_inscripciones_rec.creado_por,
                       es_exonerado = p_inscripciones_rec.es_exonerado,
                       prog_academico = p_inscripciones_rec.prog_academico,
                       es_suspendido = p_inscripciones_rec.es_suspendido,
                       cohorte_id = p_inscripciones_rec.cohorte_id,
                       horario_id = p_inscripciones_rec.horario_id,
                       modificado_por = p_inscripciones_rec.modificado_por,
                       modificado_el = p_inscripciones_rec.modificado_el
               WHERE CURRENT OF inscripciones_rowid_cur;
            END IF;

            CLOSE inscripciones_rowid_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd_rowid;

    PROCEDURE del (
                  p_id IN inscripciones.id%TYPE
                  )
    IS
    BEGIN

       DELETE FROM   inscripciones
             WHERE
                  id = del.p_id
                   ;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del;

    PROCEDURE del_rowid (p_rowid IN varchar2)
    IS
    BEGIN

       DELETE FROM   inscripciones
             WHERE   ROWID = del_rowid.p_rowid;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del_rowid;

    PROCEDURE web_del (
                      p_id IN inscripciones.id%TYPE,
                      p_hash IN varchar2
                      )
   IS
      l_inscripciones_rec inscripciones_rt;
   BEGIN


      OPEN inscripciones_cur(
                            web_del.p_id
                            );

      FETCH inscripciones_cur INTO l_inscripciones_rec;

      IF inscripciones_cur%NOTFOUND THEN
         CLOSE inscripciones_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del.p_hash != l_inscripciones_rec.hash THEN
            CLOSE inscripciones_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM inscripciones
            WHERE CURRENT OF inscripciones_cur;

            CLOSE inscripciones_cur;
         END IF;
      END IF;



   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del;

   PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2)
   IS
      l_inscripciones_rec inscripciones_rt;
   BEGIN


      OPEN inscripciones_rowid_cur(web_del_rowid.p_rowid);

      FETCH inscripciones_rowid_cur INTO l_inscripciones_rec;

      IF inscripciones_rowid_cur%NOTFOUND THEN
         CLOSE inscripciones_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del_rowid.p_hash != l_inscripciones_rec.hash THEN
            CLOSE inscripciones_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM inscripciones
            WHERE CURRENT OF inscripciones_rowid_cur;

            CLOSE inscripciones_rowid_cur;
         END IF;
      END IF;

   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del_rowid;

END tapi_inscripciones;

 

/
--------------------------------------------------------
--  DDL for Package Body TAPI_INSTANCIAS_SECCIONES
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."TAPI_INSTANCIAS_SECCIONES" IS

   /**
   * TAPI_INSTANCIAS_SECCIONES
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: 25-FEB-2020 23:11
   * Created By: FUNDAUC
   */


   --GLOBAL_PRIVATE_CURSORS
   --By PK
   CURSOR instancias_secciones_cur (
                       p_id IN instancias_secciones.id%TYPE
                       )
   IS
      SELECT
            id,
            seccion_id,
            codigo_sec,
            metodo_id,
            nivel,
            periodo_id,
            horario_id,
            modalidad_id,
            cedula_prof,
            f_inicio,
            f_fin,
            estatus,
            tapi_instancias_secciones.hash(id),
            ROWID
      FROM instancias_secciones
      WHERE
           id = instancias_secciones_cur.p_id
      FOR UPDATE;

    --By Rowid
    CURSOR instancias_secciones_rowid_cur (p_rowid IN VARCHAR2)
    IS
      SELECT
             id,
             seccion_id,
             codigo_sec,
             metodo_id,
             nivel,
             periodo_id,
             horario_id,
             modalidad_id,
             cedula_prof,
             f_inicio,
             f_fin,
             estatus,
             tapi_instancias_secciones.hash(id),
             ROWID
      FROM instancias_secciones
      WHERE ROWID = p_rowid
      FOR UPDATE;


    FUNCTION hash (
                  p_id IN instancias_secciones.id%TYPE
                  )
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format VARCHAR2(64);
   BEGIN


     --Get actual NLS_DATE_FORMAT
     SELECT   VALUE
       INTO   l_date_format
       FROM   v$nls_parameters
      WHERE   parameter = 'NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            id||
            seccion_id||
            codigo_sec||
            metodo_id||
            nivel||
            periodo_id||
            horario_id||
            modalidad_id||
            cedula_prof||
            f_inicio||
            f_fin||
            estatus
      INTO l_string
      FROM instancias_secciones
      WHERE
           id = hash.p_id
           ;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash;

    FUNCTION hash_rowid (p_rowid IN varchar2)
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format varchar2(64);
   BEGIN

      --Get actual NLS_DATE_FORMAT
      SELECT VALUE INTO l_date_format  FROM v$nls_parameters WHERE parameter ='NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            id||
            seccion_id||
            codigo_sec||
            metodo_id||
            nivel||
            periodo_id||
            horario_id||
            modalidad_id||
            cedula_prof||
            f_inicio||
            f_fin||
            estatus
      INTO l_string
      FROM instancias_secciones
      WHERE  ROWID = hash_rowid.p_rowid;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash_rowid;

   FUNCTION rt (
               p_id IN instancias_secciones.id%TYPE
               )
      RETURN instancias_secciones_rt RESULT_CACHE
   IS
      l_instancias_secciones_rec instancias_secciones_rt;
   BEGIN

      SELECT a.*,
             tapi_instancias_secciones.hash(id),
             rowid
      INTO l_instancias_secciones_rec
      FROM instancias_secciones a
      WHERE
           id = rt.p_id
           ;


      RETURN l_instancias_secciones_rec;

   END rt;

   FUNCTION rt_for_update (
                          p_id IN instancias_secciones.id%TYPE
                          )
      RETURN instancias_secciones_rt RESULT_CACHE
   IS
      l_instancias_secciones_rec instancias_secciones_rt;
   BEGIN


      SELECT a.*,
             tapi_instancias_secciones.hash(id),
             rowid
      INTO l_instancias_secciones_rec
      FROM instancias_secciones a
      WHERE
           id = rt_for_update.p_id
      FOR UPDATE;


      RETURN l_instancias_secciones_rec;

   END rt_for_update;

    FUNCTION tt (
                p_id IN instancias_secciones.id%TYPE DEFAULT NULL
                )
       RETURN instancias_secciones_tt
       PIPELINED
    IS
       l_instancias_secciones_rec   instancias_secciones_rt;
    BEGIN

       FOR c1 IN (SELECT   a.*, ROWID
                    FROM   instancias_secciones a
                   WHERE
                        id = NVL(tt.p_id,id)
                        )
       LOOP
              l_instancias_secciones_rec.id := c1.id;
              l_instancias_secciones_rec.seccion_id := c1.seccion_id;
              l_instancias_secciones_rec.codigo_sec := c1.codigo_sec;
              l_instancias_secciones_rec.metodo_id := c1.metodo_id;
              l_instancias_secciones_rec.nivel := c1.nivel;
              l_instancias_secciones_rec.periodo_id := c1.periodo_id;
              l_instancias_secciones_rec.horario_id := c1.horario_id;
              l_instancias_secciones_rec.modalidad_id := c1.modalidad_id;
              l_instancias_secciones_rec.cedula_prof := c1.cedula_prof;
              l_instancias_secciones_rec.f_inicio := c1.f_inicio;
              l_instancias_secciones_rec.f_fin := c1.f_fin;
              l_instancias_secciones_rec.estatus := c1.estatus;
              l_instancias_secciones_rec.hash := tapi_instancias_secciones.hash( c1.id);
              l_instancias_secciones_rec.row_id := c1.ROWID;
              PIPE ROW (l_instancias_secciones_rec);
       END LOOP;

       RETURN;

    END tt;


    PROCEDURE ins (p_instancias_secciones_rec IN OUT instancias_secciones_rt)
    IS
        l_rowtype     instancias_secciones%ROWTYPE;

    BEGIN


        l_rowtype.id := ins.p_instancias_secciones_rec.id;
        l_rowtype.seccion_id := ins.p_instancias_secciones_rec.seccion_id;
        l_rowtype.codigo_sec := ins.p_instancias_secciones_rec.codigo_sec;
        l_rowtype.metodo_id := ins.p_instancias_secciones_rec.metodo_id;
        l_rowtype.nivel := ins.p_instancias_secciones_rec.nivel;
        l_rowtype.periodo_id := ins.p_instancias_secciones_rec.periodo_id;
        l_rowtype.horario_id := ins.p_instancias_secciones_rec.horario_id;
        l_rowtype.modalidad_id := ins.p_instancias_secciones_rec.modalidad_id;
        l_rowtype.cedula_prof := ins.p_instancias_secciones_rec.cedula_prof;
        l_rowtype.f_inicio := ins.p_instancias_secciones_rec.f_inicio;
        l_rowtype.f_fin := ins.p_instancias_secciones_rec.f_fin;
        l_rowtype.estatus := ins.p_instancias_secciones_rec.estatus;

       INSERT INTO instancias_secciones
          VALUES   l_rowtype
       RETURNING
                   id ,
                   seccion_id ,
                   codigo_sec ,
                   metodo_id ,
                   nivel ,
                   periodo_id ,
                   horario_id ,
                   modalidad_id ,
                   cedula_prof ,
                   f_inicio ,
                   f_fin ,
                   estatus 
            INTO   l_rowtype;

         ins.p_instancias_secciones_rec.id := l_rowtype.id;
         ins.p_instancias_secciones_rec.seccion_id := l_rowtype.seccion_id;
         ins.p_instancias_secciones_rec.codigo_sec := l_rowtype.codigo_sec;
         ins.p_instancias_secciones_rec.metodo_id := l_rowtype.metodo_id;
         ins.p_instancias_secciones_rec.nivel := l_rowtype.nivel;
         ins.p_instancias_secciones_rec.periodo_id := l_rowtype.periodo_id;
         ins.p_instancias_secciones_rec.horario_id := l_rowtype.horario_id;
         ins.p_instancias_secciones_rec.modalidad_id := l_rowtype.modalidad_id;
         ins.p_instancias_secciones_rec.cedula_prof := l_rowtype.cedula_prof;
         ins.p_instancias_secciones_rec.f_inicio := l_rowtype.f_inicio;
         ins.p_instancias_secciones_rec.f_fin := l_rowtype.f_fin;
         ins.p_instancias_secciones_rec.estatus := l_rowtype.estatus;



    END ins;

    PROCEDURE upd (
                  p_instancias_secciones_rec         IN instancias_secciones_rt,
                  p_ignore_nulls         IN boolean := FALSE
                  )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   instancias_secciones
             SET id = NVL(p_instancias_secciones_rec.id,id),
                seccion_id = NVL(p_instancias_secciones_rec.seccion_id,seccion_id),
                codigo_sec = NVL(p_instancias_secciones_rec.codigo_sec,codigo_sec),
                metodo_id = NVL(p_instancias_secciones_rec.metodo_id,metodo_id),
                nivel = NVL(p_instancias_secciones_rec.nivel,nivel),
                periodo_id = NVL(p_instancias_secciones_rec.periodo_id,periodo_id),
                horario_id = NVL(p_instancias_secciones_rec.horario_id,horario_id),
                modalidad_id = NVL(p_instancias_secciones_rec.modalidad_id,modalidad_id),
                cedula_prof = NVL(p_instancias_secciones_rec.cedula_prof,cedula_prof),
                f_inicio = NVL(p_instancias_secciones_rec.f_inicio,f_inicio),
                f_fin = NVL(p_instancias_secciones_rec.f_fin,f_fin),
                estatus = NVL(p_instancias_secciones_rec.estatus,estatus)
           WHERE
                id = upd.p_instancias_secciones_rec.id
                ;
       ELSE
          UPDATE   instancias_secciones
             SET id = p_instancias_secciones_rec.id,
                seccion_id = p_instancias_secciones_rec.seccion_id,
                codigo_sec = p_instancias_secciones_rec.codigo_sec,
                metodo_id = p_instancias_secciones_rec.metodo_id,
                nivel = p_instancias_secciones_rec.nivel,
                periodo_id = p_instancias_secciones_rec.periodo_id,
                horario_id = p_instancias_secciones_rec.horario_id,
                modalidad_id = p_instancias_secciones_rec.modalidad_id,
                cedula_prof = p_instancias_secciones_rec.cedula_prof,
                f_inicio = p_instancias_secciones_rec.f_inicio,
                f_fin = p_instancias_secciones_rec.f_fin,
                estatus = p_instancias_secciones_rec.estatus
           WHERE
                id = upd.p_instancias_secciones_rec.id
                ;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd;


    PROCEDURE upd_rowid (
                         p_instancias_secciones_rec         IN instancias_secciones_rt,
                         p_ignore_nulls         IN boolean := FALSE
                        )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   instancias_secciones
             SET id = NVL(p_instancias_secciones_rec.id,id),
                seccion_id = NVL(p_instancias_secciones_rec.seccion_id,seccion_id),
                codigo_sec = NVL(p_instancias_secciones_rec.codigo_sec,codigo_sec),
                metodo_id = NVL(p_instancias_secciones_rec.metodo_id,metodo_id),
                nivel = NVL(p_instancias_secciones_rec.nivel,nivel),
                periodo_id = NVL(p_instancias_secciones_rec.periodo_id,periodo_id),
                horario_id = NVL(p_instancias_secciones_rec.horario_id,horario_id),
                modalidad_id = NVL(p_instancias_secciones_rec.modalidad_id,modalidad_id),
                cedula_prof = NVL(p_instancias_secciones_rec.cedula_prof,cedula_prof),
                f_inicio = NVL(p_instancias_secciones_rec.f_inicio,f_inicio),
                f_fin = NVL(p_instancias_secciones_rec.f_fin,f_fin),
                estatus = NVL(p_instancias_secciones_rec.estatus,estatus)
           WHERE  ROWID = p_instancias_secciones_rec.row_id;
       ELSE
          UPDATE   instancias_secciones
             SET id = p_instancias_secciones_rec.id,
                seccion_id = p_instancias_secciones_rec.seccion_id,
                codigo_sec = p_instancias_secciones_rec.codigo_sec,
                metodo_id = p_instancias_secciones_rec.metodo_id,
                nivel = p_instancias_secciones_rec.nivel,
                periodo_id = p_instancias_secciones_rec.periodo_id,
                horario_id = p_instancias_secciones_rec.horario_id,
                modalidad_id = p_instancias_secciones_rec.modalidad_id,
                cedula_prof = p_instancias_secciones_rec.cedula_prof,
                f_inicio = p_instancias_secciones_rec.f_inicio,
                f_fin = p_instancias_secciones_rec.f_fin,
                estatus = p_instancias_secciones_rec.estatus
           WHERE  ROWID = p_instancias_secciones_rec.row_id;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd_rowid;

   PROCEDURE web_upd (
                  p_instancias_secciones_rec         IN instancias_secciones_rt,
                  p_ignore_nulls         IN boolean := FALSE
                )
   IS
      l_instancias_secciones_rec instancias_secciones_rt;
   BEGIN

      OPEN instancias_secciones_cur(
                             web_upd.p_instancias_secciones_rec.id
                        );

      FETCH instancias_secciones_cur INTO l_instancias_secciones_rec;

      IF instancias_secciones_cur%NOTFOUND THEN
         CLOSE instancias_secciones_cur;
         RAISE e_row_missing;
      ELSE
         IF p_instancias_secciones_rec.hash != l_instancias_secciones_rec.hash THEN
            CLOSE instancias_secciones_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(p_ignore_nulls, FALSE)
            THEN

                UPDATE   instancias_secciones
                   SET id = NVL(p_instancias_secciones_rec.id,id),
                       seccion_id = NVL(p_instancias_secciones_rec.seccion_id,seccion_id),
                       codigo_sec = NVL(p_instancias_secciones_rec.codigo_sec,codigo_sec),
                       metodo_id = NVL(p_instancias_secciones_rec.metodo_id,metodo_id),
                       nivel = NVL(p_instancias_secciones_rec.nivel,nivel),
                       periodo_id = NVL(p_instancias_secciones_rec.periodo_id,periodo_id),
                       horario_id = NVL(p_instancias_secciones_rec.horario_id,horario_id),
                       modalidad_id = NVL(p_instancias_secciones_rec.modalidad_id,modalidad_id),
                       cedula_prof = NVL(p_instancias_secciones_rec.cedula_prof,cedula_prof),
                       f_inicio = NVL(p_instancias_secciones_rec.f_inicio,f_inicio),
                       f_fin = NVL(p_instancias_secciones_rec.f_fin,f_fin),
                       estatus = NVL(p_instancias_secciones_rec.estatus,estatus)
               WHERE CURRENT OF instancias_secciones_cur;
            ELSE
                UPDATE   instancias_secciones
                   SET id = p_instancias_secciones_rec.id,
                       seccion_id = p_instancias_secciones_rec.seccion_id,
                       codigo_sec = p_instancias_secciones_rec.codigo_sec,
                       metodo_id = p_instancias_secciones_rec.metodo_id,
                       nivel = p_instancias_secciones_rec.nivel,
                       periodo_id = p_instancias_secciones_rec.periodo_id,
                       horario_id = p_instancias_secciones_rec.horario_id,
                       modalidad_id = p_instancias_secciones_rec.modalidad_id,
                       cedula_prof = p_instancias_secciones_rec.cedula_prof,
                       f_inicio = p_instancias_secciones_rec.f_inicio,
                       f_fin = p_instancias_secciones_rec.f_fin,
                       estatus = p_instancias_secciones_rec.estatus
               WHERE CURRENT OF instancias_secciones_cur;
            END IF;

            CLOSE instancias_secciones_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd;

   PROCEDURE web_upd_rowid (
                            p_instancias_secciones_rec    IN instancias_secciones_rt,
                            p_ignore_nulls         IN boolean := FALSE
                           )
   IS
      l_instancias_secciones_rec instancias_secciones_rt;
   BEGIN

      OPEN instancias_secciones_rowid_cur(web_upd_rowid.p_instancias_secciones_rec.row_id);

      FETCH instancias_secciones_rowid_cur INTO l_instancias_secciones_rec;

      IF instancias_secciones_rowid_cur%NOTFOUND THEN
         CLOSE instancias_secciones_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_upd_rowid.p_instancias_secciones_rec.hash != l_instancias_secciones_rec.hash THEN
            CLOSE instancias_secciones_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(web_upd_rowid.p_ignore_nulls, FALSE)
            THEN
                UPDATE   instancias_secciones
                   SET id = NVL(p_instancias_secciones_rec.id,id),
                       seccion_id = NVL(p_instancias_secciones_rec.seccion_id,seccion_id),
                       codigo_sec = NVL(p_instancias_secciones_rec.codigo_sec,codigo_sec),
                       metodo_id = NVL(p_instancias_secciones_rec.metodo_id,metodo_id),
                       nivel = NVL(p_instancias_secciones_rec.nivel,nivel),
                       periodo_id = NVL(p_instancias_secciones_rec.periodo_id,periodo_id),
                       horario_id = NVL(p_instancias_secciones_rec.horario_id,horario_id),
                       modalidad_id = NVL(p_instancias_secciones_rec.modalidad_id,modalidad_id),
                       cedula_prof = NVL(p_instancias_secciones_rec.cedula_prof,cedula_prof),
                       f_inicio = NVL(p_instancias_secciones_rec.f_inicio,f_inicio),
                       f_fin = NVL(p_instancias_secciones_rec.f_fin,f_fin),
                       estatus = NVL(p_instancias_secciones_rec.estatus,estatus)
               WHERE CURRENT OF instancias_secciones_rowid_cur;
            ELSE
                UPDATE   instancias_secciones
                   SET id = p_instancias_secciones_rec.id,
                       seccion_id = p_instancias_secciones_rec.seccion_id,
                       codigo_sec = p_instancias_secciones_rec.codigo_sec,
                       metodo_id = p_instancias_secciones_rec.metodo_id,
                       nivel = p_instancias_secciones_rec.nivel,
                       periodo_id = p_instancias_secciones_rec.periodo_id,
                       horario_id = p_instancias_secciones_rec.horario_id,
                       modalidad_id = p_instancias_secciones_rec.modalidad_id,
                       cedula_prof = p_instancias_secciones_rec.cedula_prof,
                       f_inicio = p_instancias_secciones_rec.f_inicio,
                       f_fin = p_instancias_secciones_rec.f_fin,
                       estatus = p_instancias_secciones_rec.estatus
               WHERE CURRENT OF instancias_secciones_rowid_cur;
            END IF;

            CLOSE instancias_secciones_rowid_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd_rowid;

    PROCEDURE del (
                  p_id IN instancias_secciones.id%TYPE
                  )
    IS
    BEGIN

       DELETE FROM   instancias_secciones
             WHERE
                  id = del.p_id
                   ;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del;

    PROCEDURE del_rowid (p_rowid IN varchar2)
    IS
    BEGIN

       DELETE FROM   instancias_secciones
             WHERE   ROWID = del_rowid.p_rowid;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del_rowid;

    PROCEDURE web_del (
                      p_id IN instancias_secciones.id%TYPE,
                      p_hash IN varchar2
                      )
   IS
      l_instancias_secciones_rec instancias_secciones_rt;
   BEGIN


      OPEN instancias_secciones_cur(
                            web_del.p_id
                            );

      FETCH instancias_secciones_cur INTO l_instancias_secciones_rec;

      IF instancias_secciones_cur%NOTFOUND THEN
         CLOSE instancias_secciones_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del.p_hash != l_instancias_secciones_rec.hash THEN
            CLOSE instancias_secciones_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM instancias_secciones
            WHERE CURRENT OF instancias_secciones_cur;

            CLOSE instancias_secciones_cur;
         END IF;
      END IF;



   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del;

   PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2)
   IS
      l_instancias_secciones_rec instancias_secciones_rt;
   BEGIN


      OPEN instancias_secciones_rowid_cur(web_del_rowid.p_rowid);

      FETCH instancias_secciones_rowid_cur INTO l_instancias_secciones_rec;

      IF instancias_secciones_rowid_cur%NOTFOUND THEN
         CLOSE instancias_secciones_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del_rowid.p_hash != l_instancias_secciones_rec.hash THEN
            CLOSE instancias_secciones_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM instancias_secciones
            WHERE CURRENT OF instancias_secciones_rowid_cur;

            CLOSE instancias_secciones_rowid_cur;
         END IF;
      END IF;

   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del_rowid;

END tapi_instancias_secciones;

 

/
--------------------------------------------------------
--  DDL for Package Body TAPI_MATERIALES
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."TAPI_MATERIALES" IS

   /**
   * TAPI_MATERIALES
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: 01-OCT-2019 12:25
   * Created By: FUNDAUC
   */


   --GLOBAL_PRIVATE_CURSORS
   --By PK
   CURSOR materiales_cur (
                       p_id IN materiales.id%TYPE
                       )
   IS
      SELECT
            id_mat,
            tipo,
            descripcion,
            id_curso,
            evento,
            nivel,
            iva_exento,
            activo,
            id,
            seccion_id,
            creado_por,
            creado_el,
            modificado_por,
            modificado_el,
            cohorte_id,
            tapi_materiales.hash(id),
            ROWID
      FROM materiales
      WHERE
           id = materiales_cur.p_id
      FOR UPDATE;

    --By Rowid
    CURSOR materiales_rowid_cur (p_rowid IN VARCHAR2)
    IS
      SELECT
             id_mat,
             tipo,
             descripcion,
             id_curso,
             evento,
             nivel,
             iva_exento,
             activo,
             id,
             seccion_id,
             creado_por,
             creado_el,
             modificado_por,
             modificado_el,
             cohorte_id,
             tapi_materiales.hash(id),
             ROWID
      FROM materiales
      WHERE ROWID = p_rowid
      FOR UPDATE;


    FUNCTION hash (
                  p_id IN materiales.id%TYPE
                  )
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format VARCHAR2(64);
   BEGIN


     --Get actual NLS_DATE_FORMAT
     SELECT   VALUE
       INTO   l_date_format
       FROM   v$nls_parameters
      WHERE   parameter = 'NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            id_mat||
            tipo||
            descripcion||
            id_curso||
            evento||
            nivel||
            iva_exento||
            activo||
            id||
            seccion_id||
            creado_por||
            creado_el||
            modificado_por||
            modificado_el||
            cohorte_id
      INTO l_string
      FROM materiales
      WHERE
           id = hash.p_id
           ;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash;

    FUNCTION hash_rowid (p_rowid IN varchar2)
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format varchar2(64);
   BEGIN

      --Get actual NLS_DATE_FORMAT
      SELECT VALUE INTO l_date_format  FROM v$nls_parameters WHERE parameter ='NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            id_mat||
            tipo||
            descripcion||
            id_curso||
            evento||
            nivel||
            iva_exento||
            activo||
            id||
            seccion_id||
            creado_por||
            creado_el||
            modificado_por||
            modificado_el||
            cohorte_id
      INTO l_string
      FROM materiales
      WHERE  ROWID = hash_rowid.p_rowid;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash_rowid;

   FUNCTION rt (
               p_id IN materiales.id%TYPE
               )
      RETURN materiales_rt RESULT_CACHE
   IS
      l_materiales_rec materiales_rt;
   BEGIN

      SELECT a.*,
             tapi_materiales.hash(id),
             rowid
      INTO l_materiales_rec
      FROM materiales a
      WHERE
           id = rt.p_id
           ;


      RETURN l_materiales_rec;

   END rt;

   FUNCTION rt_for_update (
                          p_id IN materiales.id%TYPE
                          )
      RETURN materiales_rt RESULT_CACHE
   IS
      l_materiales_rec materiales_rt;
   BEGIN


      SELECT a.*,
             tapi_materiales.hash(id),
             rowid
      INTO l_materiales_rec
      FROM materiales a
      WHERE
           id = rt_for_update.p_id
      FOR UPDATE;


      RETURN l_materiales_rec;

   END rt_for_update;

    FUNCTION tt (
                p_id IN materiales.id%TYPE DEFAULT NULL
                )
       RETURN materiales_tt
       PIPELINED
    IS
       l_materiales_rec   materiales_rt;
    BEGIN

       FOR c1 IN (SELECT   a.*, ROWID
                    FROM   materiales a
                   WHERE
                        id = NVL(tt.p_id,id)
                        )
       LOOP
              l_materiales_rec.id_mat := c1.id_mat;
              l_materiales_rec.tipo := c1.tipo;
              l_materiales_rec.descripcion := c1.descripcion;
              l_materiales_rec.id_curso := c1.id_curso;
              l_materiales_rec.evento := c1.evento;
              l_materiales_rec.nivel := c1.nivel;
              l_materiales_rec.iva_exento := c1.iva_exento;
              l_materiales_rec.activo := c1.activo;
              l_materiales_rec.id := c1.id;
              l_materiales_rec.seccion_id := c1.seccion_id;
              l_materiales_rec.creado_por := c1.creado_por;
              l_materiales_rec.creado_el := c1.creado_el;
              l_materiales_rec.modificado_por := c1.modificado_por;
              l_materiales_rec.modificado_el := c1.modificado_el;
              l_materiales_rec.cohorte_id := c1.cohorte_id;
              l_materiales_rec.hash := tapi_materiales.hash( c1.id);
              l_materiales_rec.row_id := c1.ROWID;
              PIPE ROW (l_materiales_rec);
       END LOOP;

       RETURN;

    END tt;


    PROCEDURE ins (p_materiales_rec IN OUT materiales_rt)
    IS
        l_rowtype     materiales%ROWTYPE;

    BEGIN


        l_rowtype.id_mat := ins.p_materiales_rec.id_mat;
        l_rowtype.tipo := ins.p_materiales_rec.tipo;
        l_rowtype.descripcion := ins.p_materiales_rec.descripcion;
        l_rowtype.id_curso := ins.p_materiales_rec.id_curso;
        l_rowtype.evento := ins.p_materiales_rec.evento;
        l_rowtype.nivel := ins.p_materiales_rec.nivel;
        l_rowtype.iva_exento := ins.p_materiales_rec.iva_exento;
        l_rowtype.activo := ins.p_materiales_rec.activo;
        l_rowtype.id := ins.p_materiales_rec.id;
        l_rowtype.seccion_id := ins.p_materiales_rec.seccion_id;
        l_rowtype.creado_por := ins.p_materiales_rec.creado_por;
        l_rowtype.creado_el := ins.p_materiales_rec.creado_el;
        l_rowtype.modificado_por := ins.p_materiales_rec.modificado_por;
        l_rowtype.modificado_el := ins.p_materiales_rec.modificado_el;
        l_rowtype.cohorte_id := ins.p_materiales_rec.cohorte_id;

       INSERT INTO materiales
          VALUES   l_rowtype
       RETURNING
                   id_mat ,
                   tipo ,
                   descripcion ,
                   id_curso ,
                   evento ,
                   nivel ,
                   iva_exento ,
                   activo ,
                   id ,
                   seccion_id ,
                   creado_por ,
                   creado_el ,
                   modificado_por ,
                   modificado_el ,
                   cohorte_id 
            INTO   l_rowtype;

         ins.p_materiales_rec.id_mat := l_rowtype.id_mat;
         ins.p_materiales_rec.tipo := l_rowtype.tipo;
         ins.p_materiales_rec.descripcion := l_rowtype.descripcion;
         ins.p_materiales_rec.id_curso := l_rowtype.id_curso;
         ins.p_materiales_rec.evento := l_rowtype.evento;
         ins.p_materiales_rec.nivel := l_rowtype.nivel;
         ins.p_materiales_rec.iva_exento := l_rowtype.iva_exento;
         ins.p_materiales_rec.activo := l_rowtype.activo;
         ins.p_materiales_rec.id := l_rowtype.id;
         ins.p_materiales_rec.seccion_id := l_rowtype.seccion_id;
         ins.p_materiales_rec.creado_por := l_rowtype.creado_por;
         ins.p_materiales_rec.creado_el := l_rowtype.creado_el;
         ins.p_materiales_rec.modificado_por := l_rowtype.modificado_por;
         ins.p_materiales_rec.modificado_el := l_rowtype.modificado_el;
         ins.p_materiales_rec.cohorte_id := l_rowtype.cohorte_id;



    END ins;

    PROCEDURE upd (
                  p_materiales_rec         IN materiales_rt,
                  p_ignore_nulls         IN boolean := FALSE
                  )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   materiales
             SET id_mat = NVL(p_materiales_rec.id_mat,id_mat),
                tipo = NVL(p_materiales_rec.tipo,tipo),
                descripcion = NVL(p_materiales_rec.descripcion,descripcion),
                id_curso = NVL(p_materiales_rec.id_curso,id_curso),
                evento = NVL(p_materiales_rec.evento,evento),
                nivel = NVL(p_materiales_rec.nivel,nivel),
                iva_exento = NVL(p_materiales_rec.iva_exento,iva_exento),
                activo = NVL(p_materiales_rec.activo,activo),
                id = NVL(p_materiales_rec.id,id),
                seccion_id = NVL(p_materiales_rec.seccion_id,seccion_id),
                creado_por = NVL(p_materiales_rec.creado_por,creado_por),
                creado_el = NVL(p_materiales_rec.creado_el,creado_el),
                modificado_por = NVL(p_materiales_rec.modificado_por,modificado_por),
                modificado_el = NVL(p_materiales_rec.modificado_el,modificado_el),
                cohorte_id = NVL(p_materiales_rec.cohorte_id,cohorte_id)
           WHERE
                id = upd.p_materiales_rec.id
                ;
       ELSE
          UPDATE   materiales
             SET id_mat = p_materiales_rec.id_mat,
                tipo = p_materiales_rec.tipo,
                descripcion = p_materiales_rec.descripcion,
                id_curso = p_materiales_rec.id_curso,
                evento = p_materiales_rec.evento,
                nivel = p_materiales_rec.nivel,
                iva_exento = p_materiales_rec.iva_exento,
                activo = p_materiales_rec.activo,
                id = p_materiales_rec.id,
                seccion_id = p_materiales_rec.seccion_id,
                creado_por = p_materiales_rec.creado_por,
                creado_el = p_materiales_rec.creado_el,
                modificado_por = p_materiales_rec.modificado_por,
                modificado_el = p_materiales_rec.modificado_el,
                cohorte_id = p_materiales_rec.cohorte_id
           WHERE
                id = upd.p_materiales_rec.id
                ;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd;


    PROCEDURE upd_rowid (
                         p_materiales_rec         IN materiales_rt,
                         p_ignore_nulls         IN boolean := FALSE
                        )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   materiales
             SET id_mat = NVL(p_materiales_rec.id_mat,id_mat),
                tipo = NVL(p_materiales_rec.tipo,tipo),
                descripcion = NVL(p_materiales_rec.descripcion,descripcion),
                id_curso = NVL(p_materiales_rec.id_curso,id_curso),
                evento = NVL(p_materiales_rec.evento,evento),
                nivel = NVL(p_materiales_rec.nivel,nivel),
                iva_exento = NVL(p_materiales_rec.iva_exento,iva_exento),
                activo = NVL(p_materiales_rec.activo,activo),
                id = NVL(p_materiales_rec.id,id),
                seccion_id = NVL(p_materiales_rec.seccion_id,seccion_id),
                creado_por = NVL(p_materiales_rec.creado_por,creado_por),
                creado_el = NVL(p_materiales_rec.creado_el,creado_el),
                modificado_por = NVL(p_materiales_rec.modificado_por,modificado_por),
                modificado_el = NVL(p_materiales_rec.modificado_el,modificado_el),
                cohorte_id = NVL(p_materiales_rec.cohorte_id,cohorte_id)
           WHERE  ROWID = p_materiales_rec.row_id;
       ELSE
          UPDATE   materiales
             SET id_mat = p_materiales_rec.id_mat,
                tipo = p_materiales_rec.tipo,
                descripcion = p_materiales_rec.descripcion,
                id_curso = p_materiales_rec.id_curso,
                evento = p_materiales_rec.evento,
                nivel = p_materiales_rec.nivel,
                iva_exento = p_materiales_rec.iva_exento,
                activo = p_materiales_rec.activo,
                id = p_materiales_rec.id,
                seccion_id = p_materiales_rec.seccion_id,
                creado_por = p_materiales_rec.creado_por,
                creado_el = p_materiales_rec.creado_el,
                modificado_por = p_materiales_rec.modificado_por,
                modificado_el = p_materiales_rec.modificado_el,
                cohorte_id = p_materiales_rec.cohorte_id
           WHERE  ROWID = p_materiales_rec.row_id;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd_rowid;

   PROCEDURE web_upd (
                  p_materiales_rec         IN materiales_rt,
                  p_ignore_nulls         IN boolean := FALSE
                )
   IS
      l_materiales_rec materiales_rt;
   BEGIN

      OPEN materiales_cur(
                             web_upd.p_materiales_rec.id
                        );

      FETCH materiales_cur INTO l_materiales_rec;

      IF materiales_cur%NOTFOUND THEN
         CLOSE materiales_cur;
         RAISE e_row_missing;
      ELSE
         IF p_materiales_rec.hash != l_materiales_rec.hash THEN
            CLOSE materiales_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(p_ignore_nulls, FALSE)
            THEN

                UPDATE   materiales
                   SET id_mat = NVL(p_materiales_rec.id_mat,id_mat),
                       tipo = NVL(p_materiales_rec.tipo,tipo),
                       descripcion = NVL(p_materiales_rec.descripcion,descripcion),
                       id_curso = NVL(p_materiales_rec.id_curso,id_curso),
                       evento = NVL(p_materiales_rec.evento,evento),
                       nivel = NVL(p_materiales_rec.nivel,nivel),
                       iva_exento = NVL(p_materiales_rec.iva_exento,iva_exento),
                       activo = NVL(p_materiales_rec.activo,activo),
                       id = NVL(p_materiales_rec.id,id),
                       seccion_id = NVL(p_materiales_rec.seccion_id,seccion_id),
                       creado_por = NVL(p_materiales_rec.creado_por,creado_por),
                       creado_el = NVL(p_materiales_rec.creado_el,creado_el),
                       modificado_por = NVL(p_materiales_rec.modificado_por,modificado_por),
                       modificado_el = NVL(p_materiales_rec.modificado_el,modificado_el),
                       cohorte_id = NVL(p_materiales_rec.cohorte_id,cohorte_id)
               WHERE CURRENT OF materiales_cur;
            ELSE
                UPDATE   materiales
                   SET id_mat = p_materiales_rec.id_mat,
                       tipo = p_materiales_rec.tipo,
                       descripcion = p_materiales_rec.descripcion,
                       id_curso = p_materiales_rec.id_curso,
                       evento = p_materiales_rec.evento,
                       nivel = p_materiales_rec.nivel,
                       iva_exento = p_materiales_rec.iva_exento,
                       activo = p_materiales_rec.activo,
                       id = p_materiales_rec.id,
                       seccion_id = p_materiales_rec.seccion_id,
                       creado_por = p_materiales_rec.creado_por,
                       creado_el = p_materiales_rec.creado_el,
                       modificado_por = p_materiales_rec.modificado_por,
                       modificado_el = p_materiales_rec.modificado_el,
                       cohorte_id = p_materiales_rec.cohorte_id
               WHERE CURRENT OF materiales_cur;
            END IF;

            CLOSE materiales_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd;

   PROCEDURE web_upd_rowid (
                            p_materiales_rec    IN materiales_rt,
                            p_ignore_nulls         IN boolean := FALSE
                           )
   IS
      l_materiales_rec materiales_rt;
   BEGIN

      OPEN materiales_rowid_cur(web_upd_rowid.p_materiales_rec.row_id);

      FETCH materiales_rowid_cur INTO l_materiales_rec;

      IF materiales_rowid_cur%NOTFOUND THEN
         CLOSE materiales_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_upd_rowid.p_materiales_rec.hash != l_materiales_rec.hash THEN
            CLOSE materiales_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(web_upd_rowid.p_ignore_nulls, FALSE)
            THEN
                UPDATE   materiales
                   SET id_mat = NVL(p_materiales_rec.id_mat,id_mat),
                       tipo = NVL(p_materiales_rec.tipo,tipo),
                       descripcion = NVL(p_materiales_rec.descripcion,descripcion),
                       id_curso = NVL(p_materiales_rec.id_curso,id_curso),
                       evento = NVL(p_materiales_rec.evento,evento),
                       nivel = NVL(p_materiales_rec.nivel,nivel),
                       iva_exento = NVL(p_materiales_rec.iva_exento,iva_exento),
                       activo = NVL(p_materiales_rec.activo,activo),
                       id = NVL(p_materiales_rec.id,id),
                       seccion_id = NVL(p_materiales_rec.seccion_id,seccion_id),
                       creado_por = NVL(p_materiales_rec.creado_por,creado_por),
                       creado_el = NVL(p_materiales_rec.creado_el,creado_el),
                       modificado_por = NVL(p_materiales_rec.modificado_por,modificado_por),
                       modificado_el = NVL(p_materiales_rec.modificado_el,modificado_el),
                       cohorte_id = NVL(p_materiales_rec.cohorte_id,cohorte_id)
               WHERE CURRENT OF materiales_rowid_cur;
            ELSE
                UPDATE   materiales
                   SET id_mat = p_materiales_rec.id_mat,
                       tipo = p_materiales_rec.tipo,
                       descripcion = p_materiales_rec.descripcion,
                       id_curso = p_materiales_rec.id_curso,
                       evento = p_materiales_rec.evento,
                       nivel = p_materiales_rec.nivel,
                       iva_exento = p_materiales_rec.iva_exento,
                       activo = p_materiales_rec.activo,
                       id = p_materiales_rec.id,
                       seccion_id = p_materiales_rec.seccion_id,
                       creado_por = p_materiales_rec.creado_por,
                       creado_el = p_materiales_rec.creado_el,
                       modificado_por = p_materiales_rec.modificado_por,
                       modificado_el = p_materiales_rec.modificado_el,
                       cohorte_id = p_materiales_rec.cohorte_id
               WHERE CURRENT OF materiales_rowid_cur;
            END IF;

            CLOSE materiales_rowid_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd_rowid;

    PROCEDURE del (
                  p_id IN materiales.id%TYPE
                  )
    IS
    BEGIN

       DELETE FROM   materiales
             WHERE
                  id = del.p_id
                   ;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del;

    PROCEDURE del_rowid (p_rowid IN varchar2)
    IS
    BEGIN

       DELETE FROM   materiales
             WHERE   ROWID = del_rowid.p_rowid;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del_rowid;

    PROCEDURE web_del (
                      p_id IN materiales.id%TYPE,
                      p_hash IN varchar2
                      )
   IS
      l_materiales_rec materiales_rt;
   BEGIN


      OPEN materiales_cur(
                            web_del.p_id
                            );

      FETCH materiales_cur INTO l_materiales_rec;

      IF materiales_cur%NOTFOUND THEN
         CLOSE materiales_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del.p_hash != l_materiales_rec.hash THEN
            CLOSE materiales_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM materiales
            WHERE CURRENT OF materiales_cur;

            CLOSE materiales_cur;
         END IF;
      END IF;



   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del;

   PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2)
   IS
      l_materiales_rec materiales_rt;
   BEGIN


      OPEN materiales_rowid_cur(web_del_rowid.p_rowid);

      FETCH materiales_rowid_cur INTO l_materiales_rec;

      IF materiales_rowid_cur%NOTFOUND THEN
         CLOSE materiales_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del_rowid.p_hash != l_materiales_rec.hash THEN
            CLOSE materiales_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM materiales
            WHERE CURRENT OF materiales_rowid_cur;

            CLOSE materiales_rowid_cur;
         END IF;
      END IF;

   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del_rowid;

END tapi_materiales;

 

/
--------------------------------------------------------
--  DDL for Package Body TAPI_PRECIOS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."TAPI_PRECIOS" IS

   /**
   * TAPI_PRECIOS
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: 25-FEB-2020 17:08
   * Created By: FUNDAUC
   */


   --GLOBAL_PRIVATE_CURSORS
   --By PK
   CURSOR precios_cur (
                       p_id IN precios.id%TYPE
                       )
   IS
      SELECT
            tipo_item,
            fecha,
            precio1,
            precio2,
            precio3,
            status,
            precio4,
            precio5,
            id,
            tapi_precios.hash(id),
            ROWID
      FROM precios
      WHERE
           id = precios_cur.p_id
      FOR UPDATE;

    --By Rowid
    CURSOR precios_rowid_cur (p_rowid IN VARCHAR2)
    IS
      SELECT
             tipo_item,
             fecha,
             precio1,
             precio2,
             precio3,
             status,
             precio4,
             precio5,
             id,
             tapi_precios.hash(id),
             ROWID
      FROM precios
      WHERE ROWID = p_rowid
      FOR UPDATE;


    FUNCTION hash (
                  p_id IN precios.id%TYPE
                  )
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format VARCHAR2(64);
   BEGIN


     --Get actual NLS_DATE_FORMAT
     SELECT   VALUE
       INTO   l_date_format
       FROM   v$nls_parameters
      WHERE   parameter = 'NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            tipo_item||
            fecha||
            precio1||
            precio2||
            precio3||
            status||
            precio4||
            precio5||
            id
      INTO l_string
      FROM precios
      WHERE
           id = hash.p_id
           ;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash;

    FUNCTION hash_rowid (p_rowid IN varchar2)
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format varchar2(64);
   BEGIN

      --Get actual NLS_DATE_FORMAT
      SELECT VALUE INTO l_date_format  FROM v$nls_parameters WHERE parameter ='NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            tipo_item||
            fecha||
            precio1||
            precio2||
            precio3||
            status||
            precio4||
            precio5||
            id
      INTO l_string
      FROM precios
      WHERE  ROWID = hash_rowid.p_rowid;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash_rowid;

   FUNCTION rt (
               p_id IN precios.id%TYPE
               )
      RETURN precios_rt RESULT_CACHE
   IS
      l_precios_rec precios_rt;
   BEGIN

      SELECT a.*,
             tapi_precios.hash(id),
             rowid
      INTO l_precios_rec
      FROM precios a
      WHERE
           id = rt.p_id
           ;


      RETURN l_precios_rec;

   END rt;

   FUNCTION rt_for_update (
                          p_id IN precios.id%TYPE
                          )
      RETURN precios_rt RESULT_CACHE
   IS
      l_precios_rec precios_rt;
   BEGIN


      SELECT a.*,
             tapi_precios.hash(id),
             rowid
      INTO l_precios_rec
      FROM precios a
      WHERE
           id = rt_for_update.p_id
      FOR UPDATE;


      RETURN l_precios_rec;

   END rt_for_update;

    FUNCTION tt (
                p_id IN precios.id%TYPE DEFAULT NULL
                )
       RETURN precios_tt
       PIPELINED
    IS
       l_precios_rec   precios_rt;
    BEGIN

       FOR c1 IN (SELECT   a.*, ROWID
                    FROM   precios a
                   WHERE
                        id = NVL(tt.p_id,id)
                        )
       LOOP
              l_precios_rec.tipo_item := c1.tipo_item;
              l_precios_rec.fecha := c1.fecha;
              l_precios_rec.precio1 := c1.precio1;
              l_precios_rec.precio2 := c1.precio2;
              l_precios_rec.precio3 := c1.precio3;
              l_precios_rec.status := c1.status;
              l_precios_rec.precio4 := c1.precio4;
              l_precios_rec.precio5 := c1.precio5;
              l_precios_rec.id := c1.id;
              l_precios_rec.hash := tapi_precios.hash( c1.id);
              l_precios_rec.row_id := c1.ROWID;
              PIPE ROW (l_precios_rec);
       END LOOP;

       RETURN;

    END tt;


    PROCEDURE ins (p_precios_rec IN OUT precios_rt)
    IS
        l_rowtype     precios%ROWTYPE;

    BEGIN


        l_rowtype.tipo_item := ins.p_precios_rec.tipo_item;
        l_rowtype.fecha := ins.p_precios_rec.fecha;
        l_rowtype.precio1 := ins.p_precios_rec.precio1;
        l_rowtype.precio2 := ins.p_precios_rec.precio2;
        l_rowtype.precio3 := ins.p_precios_rec.precio3;
        l_rowtype.status := ins.p_precios_rec.status;
        l_rowtype.precio4 := ins.p_precios_rec.precio4;
        l_rowtype.precio5 := ins.p_precios_rec.precio5;
        l_rowtype.id := ins.p_precios_rec.id;

       INSERT INTO precios
          VALUES   l_rowtype
       RETURNING
                   tipo_item ,
                   fecha ,
                   precio1 ,
                   precio2 ,
                   precio3 ,
                   status ,
                   precio4 ,
                   precio5 ,
                   id 
            INTO   l_rowtype;

         ins.p_precios_rec.tipo_item := l_rowtype.tipo_item;
         ins.p_precios_rec.fecha := l_rowtype.fecha;
         ins.p_precios_rec.precio1 := l_rowtype.precio1;
         ins.p_precios_rec.precio2 := l_rowtype.precio2;
         ins.p_precios_rec.precio3 := l_rowtype.precio3;
         ins.p_precios_rec.status := l_rowtype.status;
         ins.p_precios_rec.precio4 := l_rowtype.precio4;
         ins.p_precios_rec.precio5 := l_rowtype.precio5;
         ins.p_precios_rec.id := l_rowtype.id;



    END ins;

    PROCEDURE upd (
                  p_precios_rec         IN precios_rt,
                  p_ignore_nulls         IN boolean := FALSE
                  )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   precios
             SET tipo_item = NVL(p_precios_rec.tipo_item,tipo_item),
                fecha = NVL(p_precios_rec.fecha,fecha),
                precio1 = NVL(p_precios_rec.precio1,precio1),
                precio2 = NVL(p_precios_rec.precio2,precio2),
                precio3 = NVL(p_precios_rec.precio3,precio3),
                status = NVL(p_precios_rec.status,status),
                precio4 = NVL(p_precios_rec.precio4,precio4),
                precio5 = NVL(p_precios_rec.precio5,precio5),
                id = NVL(p_precios_rec.id,id)
           WHERE
                id = upd.p_precios_rec.id
                ;
       ELSE
          UPDATE   precios
             SET tipo_item = p_precios_rec.tipo_item,
                fecha = p_precios_rec.fecha,
                precio1 = p_precios_rec.precio1,
                precio2 = p_precios_rec.precio2,
                precio3 = p_precios_rec.precio3,
                status = p_precios_rec.status,
                precio4 = p_precios_rec.precio4,
                precio5 = p_precios_rec.precio5,
                id = p_precios_rec.id
           WHERE
                id = upd.p_precios_rec.id
                ;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd;


    PROCEDURE upd_rowid (
                         p_precios_rec         IN precios_rt,
                         p_ignore_nulls         IN boolean := FALSE
                        )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   precios
             SET tipo_item = NVL(p_precios_rec.tipo_item,tipo_item),
                fecha = NVL(p_precios_rec.fecha,fecha),
                precio1 = NVL(p_precios_rec.precio1,precio1),
                precio2 = NVL(p_precios_rec.precio2,precio2),
                precio3 = NVL(p_precios_rec.precio3,precio3),
                status = NVL(p_precios_rec.status,status),
                precio4 = NVL(p_precios_rec.precio4,precio4),
                precio5 = NVL(p_precios_rec.precio5,precio5),
                id = NVL(p_precios_rec.id,id)
           WHERE  ROWID = p_precios_rec.row_id;
       ELSE
          UPDATE   precios
             SET tipo_item = p_precios_rec.tipo_item,
                fecha = p_precios_rec.fecha,
                precio1 = p_precios_rec.precio1,
                precio2 = p_precios_rec.precio2,
                precio3 = p_precios_rec.precio3,
                status = p_precios_rec.status,
                precio4 = p_precios_rec.precio4,
                precio5 = p_precios_rec.precio5,
                id = p_precios_rec.id
           WHERE  ROWID = p_precios_rec.row_id;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd_rowid;

   PROCEDURE web_upd (
                  p_precios_rec         IN precios_rt,
                  p_ignore_nulls         IN boolean := FALSE
                )
   IS
      l_precios_rec precios_rt;
   BEGIN

      OPEN precios_cur(
                             web_upd.p_precios_rec.id
                        );

      FETCH precios_cur INTO l_precios_rec;

      IF precios_cur%NOTFOUND THEN
         CLOSE precios_cur;
         RAISE e_row_missing;
      ELSE
         IF p_precios_rec.hash != l_precios_rec.hash THEN
            CLOSE precios_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(p_ignore_nulls, FALSE)
            THEN

                UPDATE   precios
                   SET tipo_item = NVL(p_precios_rec.tipo_item,tipo_item),
                       fecha = NVL(p_precios_rec.fecha,fecha),
                       precio1 = NVL(p_precios_rec.precio1,precio1),
                       precio2 = NVL(p_precios_rec.precio2,precio2),
                       precio3 = NVL(p_precios_rec.precio3,precio3),
                       status = NVL(p_precios_rec.status,status),
                       precio4 = NVL(p_precios_rec.precio4,precio4),
                       precio5 = NVL(p_precios_rec.precio5,precio5),
                       id = NVL(p_precios_rec.id,id)
               WHERE CURRENT OF precios_cur;
            ELSE
                UPDATE   precios
                   SET tipo_item = p_precios_rec.tipo_item,
                       fecha = p_precios_rec.fecha,
                       precio1 = p_precios_rec.precio1,
                       precio2 = p_precios_rec.precio2,
                       precio3 = p_precios_rec.precio3,
                       status = p_precios_rec.status,
                       precio4 = p_precios_rec.precio4,
                       precio5 = p_precios_rec.precio5,
                       id = p_precios_rec.id
               WHERE CURRENT OF precios_cur;
            END IF;

            CLOSE precios_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd;

   PROCEDURE web_upd_rowid (
                            p_precios_rec    IN precios_rt,
                            p_ignore_nulls         IN boolean := FALSE
                           )
   IS
      l_precios_rec precios_rt;
   BEGIN

      OPEN precios_rowid_cur(web_upd_rowid.p_precios_rec.row_id);

      FETCH precios_rowid_cur INTO l_precios_rec;

      IF precios_rowid_cur%NOTFOUND THEN
         CLOSE precios_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_upd_rowid.p_precios_rec.hash != l_precios_rec.hash THEN
            CLOSE precios_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(web_upd_rowid.p_ignore_nulls, FALSE)
            THEN
                UPDATE   precios
                   SET tipo_item = NVL(p_precios_rec.tipo_item,tipo_item),
                       fecha = NVL(p_precios_rec.fecha,fecha),
                       precio1 = NVL(p_precios_rec.precio1,precio1),
                       precio2 = NVL(p_precios_rec.precio2,precio2),
                       precio3 = NVL(p_precios_rec.precio3,precio3),
                       status = NVL(p_precios_rec.status,status),
                       precio4 = NVL(p_precios_rec.precio4,precio4),
                       precio5 = NVL(p_precios_rec.precio5,precio5),
                       id = NVL(p_precios_rec.id,id)
               WHERE CURRENT OF precios_rowid_cur;
            ELSE
                UPDATE   precios
                   SET tipo_item = p_precios_rec.tipo_item,
                       fecha = p_precios_rec.fecha,
                       precio1 = p_precios_rec.precio1,
                       precio2 = p_precios_rec.precio2,
                       precio3 = p_precios_rec.precio3,
                       status = p_precios_rec.status,
                       precio4 = p_precios_rec.precio4,
                       precio5 = p_precios_rec.precio5,
                       id = p_precios_rec.id
               WHERE CURRENT OF precios_rowid_cur;
            END IF;

            CLOSE precios_rowid_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd_rowid;

    PROCEDURE del (
                  p_id IN precios.id%TYPE
                  )
    IS
    BEGIN

       DELETE FROM   precios
             WHERE
                  id = del.p_id
                   ;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del;

    PROCEDURE del_rowid (p_rowid IN varchar2)
    IS
    BEGIN

       DELETE FROM   precios
             WHERE   ROWID = del_rowid.p_rowid;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del_rowid;

    PROCEDURE web_del (
                      p_id IN precios.id%TYPE,
                      p_hash IN varchar2
                      )
   IS
      l_precios_rec precios_rt;
   BEGIN


      OPEN precios_cur(
                            web_del.p_id
                            );

      FETCH precios_cur INTO l_precios_rec;

      IF precios_cur%NOTFOUND THEN
         CLOSE precios_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del.p_hash != l_precios_rec.hash THEN
            CLOSE precios_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM precios
            WHERE CURRENT OF precios_cur;

            CLOSE precios_cur;
         END IF;
      END IF;



   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del;

   PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2)
   IS
      l_precios_rec precios_rt;
   BEGIN


      OPEN precios_rowid_cur(web_del_rowid.p_rowid);

      FETCH precios_rowid_cur INTO l_precios_rec;

      IF precios_rowid_cur%NOTFOUND THEN
         CLOSE precios_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del_rowid.p_hash != l_precios_rec.hash THEN
            CLOSE precios_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM precios
            WHERE CURRENT OF precios_rowid_cur;

            CLOSE precios_rowid_cur;
         END IF;
      END IF;

   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del_rowid;

END tapi_precios;

 

/
--------------------------------------------------------
--  DDL for Package Body TAPI_SECCIONES
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."TAPI_SECCIONES" IS

   /**
   * TAPI_SECCIONES
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: 01-OCT-2019 11:06
   * Created By: FUNDAUC
   */


   --GLOBAL_PRIVATE_CURSORS
   --By PK
   CURSOR secciones_cur (
                       p_id IN secciones.id%TYPE
                       )
   IS
      SELECT
            id_seccion,
            id_metodo,
            nivel,
            id_salon,
            tope,
            status,
            id_edif,
            horario,
            cedula_prof,
            modalidad,
            fec_inicio,
            periodo,
            id_horario,
            id_calendario,
            id,
            creado_por,
            creado_el,
            modificado_por,
            modificado_el,
            tapi_secciones.hash(id),
            ROWID
      FROM secciones
      WHERE
           id = secciones_cur.p_id
      FOR UPDATE;

    --By Rowid
    CURSOR secciones_rowid_cur (p_rowid IN VARCHAR2)
    IS
      SELECT
             id_seccion,
             id_metodo,
             nivel,
             id_salon,
             tope,
             status,
             id_edif,
             horario,
             cedula_prof,
             modalidad,
             fec_inicio,
             periodo,
             id_horario,
             id_calendario,
             id,
             creado_por,
             creado_el,
             modificado_por,
             modificado_el,
             tapi_secciones.hash(id),
             ROWID
      FROM secciones
      WHERE ROWID = p_rowid
      FOR UPDATE;


    FUNCTION hash (
                  p_id IN secciones.id%TYPE
                  )
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format VARCHAR2(64);
   BEGIN


     --Get actual NLS_DATE_FORMAT
     SELECT   VALUE
       INTO   l_date_format
       FROM   v$nls_parameters
      WHERE   parameter = 'NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            id_seccion||
            id_metodo||
            nivel||
            id_salon||
            tope||
            status||
            id_edif||
            horario||
            cedula_prof||
            modalidad||
            fec_inicio||
            periodo||
            id_horario||
            id_calendario||
            id||
            creado_por||
            creado_el||
            modificado_por||
            modificado_el
      INTO l_string
      FROM secciones
      WHERE
           id = hash.p_id
           ;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash;

    FUNCTION hash_rowid (p_rowid IN varchar2)
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format varchar2(64);
   BEGIN

      --Get actual NLS_DATE_FORMAT
      SELECT VALUE INTO l_date_format  FROM v$nls_parameters WHERE parameter ='NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            id_seccion||
            id_metodo||
            nivel||
            id_salon||
            tope||
            status||
            id_edif||
            horario||
            cedula_prof||
            modalidad||
            fec_inicio||
            periodo||
            id_horario||
            id_calendario||
            id||
            creado_por||
            creado_el||
            modificado_por||
            modificado_el
      INTO l_string
      FROM secciones
      WHERE  ROWID = hash_rowid.p_rowid;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash_rowid;

   FUNCTION rt (
               p_id IN secciones.id%TYPE
               )
      RETURN secciones_rt RESULT_CACHE
   IS
      l_secciones_rec secciones_rt;
   BEGIN

      SELECT a.*,
             tapi_secciones.hash(id),
             rowid
      INTO l_secciones_rec
      FROM secciones a
      WHERE
           id = rt.p_id
           ;


      RETURN l_secciones_rec;

   END rt;

   FUNCTION rt_for_update (
                          p_id IN secciones.id%TYPE
                          )
      RETURN secciones_rt RESULT_CACHE
   IS
      l_secciones_rec secciones_rt;
   BEGIN


      SELECT a.*,
             tapi_secciones.hash(id),
             rowid
      INTO l_secciones_rec
      FROM secciones a
      WHERE
           id = rt_for_update.p_id
      FOR UPDATE;


      RETURN l_secciones_rec;

   END rt_for_update;

    FUNCTION tt (
                p_id IN secciones.id%TYPE DEFAULT NULL
                )
       RETURN secciones_tt
       PIPELINED
    IS
       l_secciones_rec   secciones_rt;
    BEGIN

       FOR c1 IN (SELECT   a.*, ROWID
                    FROM   secciones a
                   WHERE
                        id = NVL(tt.p_id,id)
                        )
       LOOP
              l_secciones_rec.id_seccion := c1.id_seccion;
              l_secciones_rec.id_metodo := c1.id_metodo;
              l_secciones_rec.nivel := c1.nivel;
              l_secciones_rec.id_salon := c1.id_salon;
              l_secciones_rec.tope := c1.tope;
              l_secciones_rec.status := c1.status;
              l_secciones_rec.id_edif := c1.id_edif;
              l_secciones_rec.horario := c1.horario;
              l_secciones_rec.cedula_prof := c1.cedula_prof;
              l_secciones_rec.modalidad := c1.modalidad;
              l_secciones_rec.fec_inicio := c1.fec_inicio;
              l_secciones_rec.periodo := c1.periodo;
              l_secciones_rec.id_horario := c1.id_horario;
              l_secciones_rec.id_calendario := c1.id_calendario;
              l_secciones_rec.id := c1.id;
              l_secciones_rec.creado_por := c1.creado_por;
              l_secciones_rec.creado_el := c1.creado_el;
              l_secciones_rec.modificado_por := c1.modificado_por;
              l_secciones_rec.modificado_el := c1.modificado_el;
              l_secciones_rec.hash := tapi_secciones.hash( c1.id);
              l_secciones_rec.row_id := c1.ROWID;
              PIPE ROW (l_secciones_rec);
       END LOOP;

       RETURN;

    END tt;


    PROCEDURE ins (p_secciones_rec IN OUT secciones_rt)
    IS
        l_rowtype     secciones%ROWTYPE;

    BEGIN


        l_rowtype.id_seccion := ins.p_secciones_rec.id_seccion;
        l_rowtype.id_metodo := ins.p_secciones_rec.id_metodo;
        l_rowtype.nivel := ins.p_secciones_rec.nivel;
        l_rowtype.id_salon := ins.p_secciones_rec.id_salon;
        l_rowtype.tope := ins.p_secciones_rec.tope;
        l_rowtype.status := ins.p_secciones_rec.status;
        l_rowtype.id_edif := ins.p_secciones_rec.id_edif;
        l_rowtype.horario := ins.p_secciones_rec.horario;
        l_rowtype.cedula_prof := ins.p_secciones_rec.cedula_prof;
        l_rowtype.modalidad := ins.p_secciones_rec.modalidad;
        l_rowtype.fec_inicio := ins.p_secciones_rec.fec_inicio;
        l_rowtype.periodo := ins.p_secciones_rec.periodo;
        l_rowtype.id_horario := ins.p_secciones_rec.id_horario;
        l_rowtype.id_calendario := ins.p_secciones_rec.id_calendario;
        l_rowtype.id := ins.p_secciones_rec.id;
        l_rowtype.creado_por := ins.p_secciones_rec.creado_por;
        l_rowtype.creado_el := ins.p_secciones_rec.creado_el;
        l_rowtype.modificado_por := ins.p_secciones_rec.modificado_por;
        l_rowtype.modificado_el := ins.p_secciones_rec.modificado_el;

       INSERT INTO secciones
          VALUES   l_rowtype
       RETURNING
                   id_seccion ,
                   id_metodo ,
                   nivel ,
                   id_salon ,
                   tope ,
                   status ,
                   id_edif ,
                   horario ,
                   cedula_prof ,
                   modalidad ,
                   fec_inicio ,
                   periodo ,
                   id_horario ,
                   id_calendario ,
                   id ,
                   creado_por ,
                   creado_el ,
                   modificado_por ,
                   modificado_el 
            INTO   l_rowtype;

         ins.p_secciones_rec.id_seccion := l_rowtype.id_seccion;
         ins.p_secciones_rec.id_metodo := l_rowtype.id_metodo;
         ins.p_secciones_rec.nivel := l_rowtype.nivel;
         ins.p_secciones_rec.id_salon := l_rowtype.id_salon;
         ins.p_secciones_rec.tope := l_rowtype.tope;
         ins.p_secciones_rec.status := l_rowtype.status;
         ins.p_secciones_rec.id_edif := l_rowtype.id_edif;
         ins.p_secciones_rec.horario := l_rowtype.horario;
         ins.p_secciones_rec.cedula_prof := l_rowtype.cedula_prof;
         ins.p_secciones_rec.modalidad := l_rowtype.modalidad;
         ins.p_secciones_rec.fec_inicio := l_rowtype.fec_inicio;
         ins.p_secciones_rec.periodo := l_rowtype.periodo;
         ins.p_secciones_rec.id_horario := l_rowtype.id_horario;
         ins.p_secciones_rec.id_calendario := l_rowtype.id_calendario;
         ins.p_secciones_rec.id := l_rowtype.id;
         ins.p_secciones_rec.creado_por := l_rowtype.creado_por;
         ins.p_secciones_rec.creado_el := l_rowtype.creado_el;
         ins.p_secciones_rec.modificado_por := l_rowtype.modificado_por;
         ins.p_secciones_rec.modificado_el := l_rowtype.modificado_el;



    END ins;

    PROCEDURE upd (
                  p_secciones_rec         IN secciones_rt,
                  p_ignore_nulls         IN boolean := FALSE
                  )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   secciones
             SET id_seccion = NVL(p_secciones_rec.id_seccion,id_seccion),
                id_metodo = NVL(p_secciones_rec.id_metodo,id_metodo),
                nivel = NVL(p_secciones_rec.nivel,nivel),
                id_salon = NVL(p_secciones_rec.id_salon,id_salon),
                tope = NVL(p_secciones_rec.tope,tope),
                status = NVL(p_secciones_rec.status,status),
                id_edif = NVL(p_secciones_rec.id_edif,id_edif),
                horario = NVL(p_secciones_rec.horario,horario),
                cedula_prof = NVL(p_secciones_rec.cedula_prof,cedula_prof),
                modalidad = NVL(p_secciones_rec.modalidad,modalidad),
                fec_inicio = NVL(p_secciones_rec.fec_inicio,fec_inicio),
                periodo = NVL(p_secciones_rec.periodo,periodo),
                id_horario = NVL(p_secciones_rec.id_horario,id_horario),
                id_calendario = NVL(p_secciones_rec.id_calendario,id_calendario),
                id = NVL(p_secciones_rec.id,id),
                creado_por = NVL(p_secciones_rec.creado_por,creado_por),
                creado_el = NVL(p_secciones_rec.creado_el,creado_el),
                modificado_por = NVL(p_secciones_rec.modificado_por,modificado_por),
                modificado_el = NVL(p_secciones_rec.modificado_el,modificado_el)
           WHERE
                id = upd.p_secciones_rec.id
                ;
       ELSE
          UPDATE   secciones
             SET id_seccion = p_secciones_rec.id_seccion,
                id_metodo = p_secciones_rec.id_metodo,
                nivel = p_secciones_rec.nivel,
                id_salon = p_secciones_rec.id_salon,
                tope = p_secciones_rec.tope,
                status = p_secciones_rec.status,
                id_edif = p_secciones_rec.id_edif,
                horario = p_secciones_rec.horario,
                cedula_prof = p_secciones_rec.cedula_prof,
                modalidad = p_secciones_rec.modalidad,
                fec_inicio = p_secciones_rec.fec_inicio,
                periodo = p_secciones_rec.periodo,
                id_horario = p_secciones_rec.id_horario,
                id_calendario = p_secciones_rec.id_calendario,
                id = p_secciones_rec.id,
                creado_por = p_secciones_rec.creado_por,
                creado_el = p_secciones_rec.creado_el,
                modificado_por = p_secciones_rec.modificado_por,
                modificado_el = p_secciones_rec.modificado_el
           WHERE
                id = upd.p_secciones_rec.id
                ;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd;


    PROCEDURE upd_rowid (
                         p_secciones_rec         IN secciones_rt,
                         p_ignore_nulls         IN boolean := FALSE
                        )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   secciones
             SET id_seccion = NVL(p_secciones_rec.id_seccion,id_seccion),
                id_metodo = NVL(p_secciones_rec.id_metodo,id_metodo),
                nivel = NVL(p_secciones_rec.nivel,nivel),
                id_salon = NVL(p_secciones_rec.id_salon,id_salon),
                tope = NVL(p_secciones_rec.tope,tope),
                status = NVL(p_secciones_rec.status,status),
                id_edif = NVL(p_secciones_rec.id_edif,id_edif),
                horario = NVL(p_secciones_rec.horario,horario),
                cedula_prof = NVL(p_secciones_rec.cedula_prof,cedula_prof),
                modalidad = NVL(p_secciones_rec.modalidad,modalidad),
                fec_inicio = NVL(p_secciones_rec.fec_inicio,fec_inicio),
                periodo = NVL(p_secciones_rec.periodo,periodo),
                id_horario = NVL(p_secciones_rec.id_horario,id_horario),
                id_calendario = NVL(p_secciones_rec.id_calendario,id_calendario),
                id = NVL(p_secciones_rec.id,id),
                creado_por = NVL(p_secciones_rec.creado_por,creado_por),
                creado_el = NVL(p_secciones_rec.creado_el,creado_el),
                modificado_por = NVL(p_secciones_rec.modificado_por,modificado_por),
                modificado_el = NVL(p_secciones_rec.modificado_el,modificado_el)
           WHERE  ROWID = p_secciones_rec.row_id;
       ELSE
          UPDATE   secciones
             SET id_seccion = p_secciones_rec.id_seccion,
                id_metodo = p_secciones_rec.id_metodo,
                nivel = p_secciones_rec.nivel,
                id_salon = p_secciones_rec.id_salon,
                tope = p_secciones_rec.tope,
                status = p_secciones_rec.status,
                id_edif = p_secciones_rec.id_edif,
                horario = p_secciones_rec.horario,
                cedula_prof = p_secciones_rec.cedula_prof,
                modalidad = p_secciones_rec.modalidad,
                fec_inicio = p_secciones_rec.fec_inicio,
                periodo = p_secciones_rec.periodo,
                id_horario = p_secciones_rec.id_horario,
                id_calendario = p_secciones_rec.id_calendario,
                id = p_secciones_rec.id,
                creado_por = p_secciones_rec.creado_por,
                creado_el = p_secciones_rec.creado_el,
                modificado_por = p_secciones_rec.modificado_por,
                modificado_el = p_secciones_rec.modificado_el
           WHERE  ROWID = p_secciones_rec.row_id;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd_rowid;

   PROCEDURE web_upd (
                  p_secciones_rec         IN secciones_rt,
                  p_ignore_nulls         IN boolean := FALSE
                )
   IS
      l_secciones_rec secciones_rt;
   BEGIN

      OPEN secciones_cur(
                             web_upd.p_secciones_rec.id
                        );

      FETCH secciones_cur INTO l_secciones_rec;

      IF secciones_cur%NOTFOUND THEN
         CLOSE secciones_cur;
         RAISE e_row_missing;
      ELSE
         IF p_secciones_rec.hash != l_secciones_rec.hash THEN
            CLOSE secciones_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(p_ignore_nulls, FALSE)
            THEN

                UPDATE   secciones
                   SET id_seccion = NVL(p_secciones_rec.id_seccion,id_seccion),
                       id_metodo = NVL(p_secciones_rec.id_metodo,id_metodo),
                       nivel = NVL(p_secciones_rec.nivel,nivel),
                       id_salon = NVL(p_secciones_rec.id_salon,id_salon),
                       tope = NVL(p_secciones_rec.tope,tope),
                       status = NVL(p_secciones_rec.status,status),
                       id_edif = NVL(p_secciones_rec.id_edif,id_edif),
                       horario = NVL(p_secciones_rec.horario,horario),
                       cedula_prof = NVL(p_secciones_rec.cedula_prof,cedula_prof),
                       modalidad = NVL(p_secciones_rec.modalidad,modalidad),
                       fec_inicio = NVL(p_secciones_rec.fec_inicio,fec_inicio),
                       periodo = NVL(p_secciones_rec.periodo,periodo),
                       id_horario = NVL(p_secciones_rec.id_horario,id_horario),
                       id_calendario = NVL(p_secciones_rec.id_calendario,id_calendario),
                       id = NVL(p_secciones_rec.id,id),
                       creado_por = NVL(p_secciones_rec.creado_por,creado_por),
                       creado_el = NVL(p_secciones_rec.creado_el,creado_el),
                       modificado_por = NVL(p_secciones_rec.modificado_por,modificado_por),
                       modificado_el = NVL(p_secciones_rec.modificado_el,modificado_el)
               WHERE CURRENT OF secciones_cur;
            ELSE
                UPDATE   secciones
                   SET id_seccion = p_secciones_rec.id_seccion,
                       id_metodo = p_secciones_rec.id_metodo,
                       nivel = p_secciones_rec.nivel,
                       id_salon = p_secciones_rec.id_salon,
                       tope = p_secciones_rec.tope,
                       status = p_secciones_rec.status,
                       id_edif = p_secciones_rec.id_edif,
                       horario = p_secciones_rec.horario,
                       cedula_prof = p_secciones_rec.cedula_prof,
                       modalidad = p_secciones_rec.modalidad,
                       fec_inicio = p_secciones_rec.fec_inicio,
                       periodo = p_secciones_rec.periodo,
                       id_horario = p_secciones_rec.id_horario,
                       id_calendario = p_secciones_rec.id_calendario,
                       id = p_secciones_rec.id,
                       creado_por = p_secciones_rec.creado_por,
                       creado_el = p_secciones_rec.creado_el,
                       modificado_por = p_secciones_rec.modificado_por,
                       modificado_el = p_secciones_rec.modificado_el
               WHERE CURRENT OF secciones_cur;
            END IF;

            CLOSE secciones_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd;

   PROCEDURE web_upd_rowid (
                            p_secciones_rec    IN secciones_rt,
                            p_ignore_nulls         IN boolean := FALSE
                           )
   IS
      l_secciones_rec secciones_rt;
   BEGIN

      OPEN secciones_rowid_cur(web_upd_rowid.p_secciones_rec.row_id);

      FETCH secciones_rowid_cur INTO l_secciones_rec;

      IF secciones_rowid_cur%NOTFOUND THEN
         CLOSE secciones_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_upd_rowid.p_secciones_rec.hash != l_secciones_rec.hash THEN
            CLOSE secciones_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(web_upd_rowid.p_ignore_nulls, FALSE)
            THEN
                UPDATE   secciones
                   SET id_seccion = NVL(p_secciones_rec.id_seccion,id_seccion),
                       id_metodo = NVL(p_secciones_rec.id_metodo,id_metodo),
                       nivel = NVL(p_secciones_rec.nivel,nivel),
                       id_salon = NVL(p_secciones_rec.id_salon,id_salon),
                       tope = NVL(p_secciones_rec.tope,tope),
                       status = NVL(p_secciones_rec.status,status),
                       id_edif = NVL(p_secciones_rec.id_edif,id_edif),
                       horario = NVL(p_secciones_rec.horario,horario),
                       cedula_prof = NVL(p_secciones_rec.cedula_prof,cedula_prof),
                       modalidad = NVL(p_secciones_rec.modalidad,modalidad),
                       fec_inicio = NVL(p_secciones_rec.fec_inicio,fec_inicio),
                       periodo = NVL(p_secciones_rec.periodo,periodo),
                       id_horario = NVL(p_secciones_rec.id_horario,id_horario),
                       id_calendario = NVL(p_secciones_rec.id_calendario,id_calendario),
                       id = NVL(p_secciones_rec.id,id),
                       creado_por = NVL(p_secciones_rec.creado_por,creado_por),
                       creado_el = NVL(p_secciones_rec.creado_el,creado_el),
                       modificado_por = NVL(p_secciones_rec.modificado_por,modificado_por),
                       modificado_el = NVL(p_secciones_rec.modificado_el,modificado_el)
               WHERE CURRENT OF secciones_rowid_cur;
            ELSE
                UPDATE   secciones
                   SET id_seccion = p_secciones_rec.id_seccion,
                       id_metodo = p_secciones_rec.id_metodo,
                       nivel = p_secciones_rec.nivel,
                       id_salon = p_secciones_rec.id_salon,
                       tope = p_secciones_rec.tope,
                       status = p_secciones_rec.status,
                       id_edif = p_secciones_rec.id_edif,
                       horario = p_secciones_rec.horario,
                       cedula_prof = p_secciones_rec.cedula_prof,
                       modalidad = p_secciones_rec.modalidad,
                       fec_inicio = p_secciones_rec.fec_inicio,
                       periodo = p_secciones_rec.periodo,
                       id_horario = p_secciones_rec.id_horario,
                       id_calendario = p_secciones_rec.id_calendario,
                       id = p_secciones_rec.id,
                       creado_por = p_secciones_rec.creado_por,
                       creado_el = p_secciones_rec.creado_el,
                       modificado_por = p_secciones_rec.modificado_por,
                       modificado_el = p_secciones_rec.modificado_el
               WHERE CURRENT OF secciones_rowid_cur;
            END IF;

            CLOSE secciones_rowid_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd_rowid;

    PROCEDURE del (
                  p_id IN secciones.id%TYPE
                  )
    IS
    BEGIN

       DELETE FROM   secciones
             WHERE
                  id = del.p_id
                   ;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del;

    PROCEDURE del_rowid (p_rowid IN varchar2)
    IS
    BEGIN

       DELETE FROM   secciones
             WHERE   ROWID = del_rowid.p_rowid;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del_rowid;

    PROCEDURE web_del (
                      p_id IN secciones.id%TYPE,
                      p_hash IN varchar2
                      )
   IS
      l_secciones_rec secciones_rt;
   BEGIN


      OPEN secciones_cur(
                            web_del.p_id
                            );

      FETCH secciones_cur INTO l_secciones_rec;

      IF secciones_cur%NOTFOUND THEN
         CLOSE secciones_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del.p_hash != l_secciones_rec.hash THEN
            CLOSE secciones_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM secciones
            WHERE CURRENT OF secciones_cur;

            CLOSE secciones_cur;
         END IF;
      END IF;



   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del;

   PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2)
   IS
      l_secciones_rec secciones_rt;
   BEGIN


      OPEN secciones_rowid_cur(web_del_rowid.p_rowid);

      FETCH secciones_rowid_cur INTO l_secciones_rec;

      IF secciones_rowid_cur%NOTFOUND THEN
         CLOSE secciones_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del_rowid.p_hash != l_secciones_rec.hash THEN
            CLOSE secciones_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM secciones
            WHERE CURRENT OF secciones_rowid_cur;

            CLOSE secciones_rowid_cur;
         END IF;
      END IF;

   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del_rowid;

END tapi_secciones;

 

/
--------------------------------------------------------
--  DDL for Package Body TAPI_USUARIOS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."TAPI_USUARIOS" IS

   /**
   * TAPI_USUARIOS
   * Generated by: tapiGen2 - DO NOT MODIFY!
   * Website: github.com/osalvador/tapiGen2
   * Created On: 18-AGO-2019 18:18
   * Created By: FUNDAUC
   */


   --GLOBAL_PRIVATE_CURSORS
   --By PK
   CURSOR usuarios_cur (
                       p_cedula IN usuarios.cedula%TYPE
                       )
   IS
      SELECT
            cedula,
            nombre_usuario,
            contrasena,
            id_rol,
            email,
            nombre,
            cia,
            prog_academico,
            activo,
            bloqueado,
            creado_por,
            creado_el,
            modificado_por,
            modificado_el,
            tapi_usuarios.hash(cedula),
            ROWID
      FROM usuarios
      WHERE
           cedula = usuarios_cur.p_cedula
      FOR UPDATE;

    --By Rowid
    CURSOR usuarios_rowid_cur (p_rowid IN VARCHAR2)
    IS
      SELECT
             cedula,
             nombre_usuario,
             contrasena,
             id_rol,
             email,
             nombre,
             cia,
             prog_academico,
             activo,
             bloqueado,
             creado_por,
             creado_el,
             modificado_por,
             modificado_el,
             tapi_usuarios.hash(cedula),
             ROWID
      FROM usuarios
      WHERE ROWID = p_rowid
      FOR UPDATE;


    FUNCTION hash (
                  p_cedula IN usuarios.cedula%TYPE
                  )
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format VARCHAR2(64);
   BEGIN


     --Get actual NLS_DATE_FORMAT
     SELECT   VALUE
       INTO   l_date_format
       FROM   v$nls_parameters
      WHERE   parameter = 'NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            cedula||
            nombre_usuario||
            contrasena||
            id_rol||
            email||
            nombre||
            cia||
            prog_academico||
            activo||
            bloqueado||
            creado_por||
            creado_el||
            modificado_por||
            modificado_el
      INTO l_string
      FROM usuarios
      WHERE
           cedula = hash.p_cedula
           ;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash;

    FUNCTION hash_rowid (p_rowid IN varchar2)
      RETURN varchar2
   IS
      l_retval hash_t;
      l_string CLOB;
      l_date_format varchar2(64);
   BEGIN

      --Get actual NLS_DATE_FORMAT
      SELECT VALUE INTO l_date_format  FROM v$nls_parameters WHERE parameter ='NLS_DATE_FORMAT';

      --Alter session for date columns
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''YYYY/MM/DD hh24:mi:ss''';

      SELECT
            cedula||
            nombre_usuario||
            contrasena||
            id_rol||
            email||
            nombre||
            cia||
            prog_academico||
            activo||
            bloqueado||
            creado_por||
            creado_el||
            modificado_por||
            modificado_el
      INTO l_string
      FROM usuarios
      WHERE  ROWID = hash_rowid.p_rowid;

      --Restore NLS_DATE_FORMAT to default
      EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT=''' || l_date_format|| '''';

      l_retval := DBMS_CRYPTO.hash(l_string, DBMS_CRYPTO.hash_sh1);

      RETURN l_retval;

   END hash_rowid;

   FUNCTION rt (
               p_cedula IN usuarios.cedula%TYPE
               )
      RETURN usuarios_rt RESULT_CACHE
   IS
      l_usuarios_rec usuarios_rt;
   BEGIN

      SELECT a.*,
             tapi_usuarios.hash(cedula),
             rowid
      INTO l_usuarios_rec
      FROM usuarios a
      WHERE
           cedula = rt.p_cedula
           ;


      RETURN l_usuarios_rec;

   END rt;

   FUNCTION rt_for_update (
                          p_cedula IN usuarios.cedula%TYPE
                          )
      RETURN usuarios_rt RESULT_CACHE
   IS
      l_usuarios_rec usuarios_rt;
   BEGIN


      SELECT a.*,
             tapi_usuarios.hash(cedula),
             rowid
      INTO l_usuarios_rec
      FROM usuarios a
      WHERE
           cedula = rt_for_update.p_cedula
      FOR UPDATE;


      RETURN l_usuarios_rec;

   END rt_for_update;

    FUNCTION tt (
                p_cedula IN usuarios.cedula%TYPE DEFAULT NULL
                )
       RETURN usuarios_tt
       PIPELINED
    IS
       l_usuarios_rec   usuarios_rt;
    BEGIN

       FOR c1 IN (SELECT   a.*, ROWID
                    FROM   usuarios a
                   WHERE
                        cedula = NVL(tt.p_cedula,cedula)
                        )
       LOOP
              l_usuarios_rec.cedula := c1.cedula;
              l_usuarios_rec.nombre_usuario := c1.nombre_usuario;
              l_usuarios_rec.contrasena := c1.contrasena;
              l_usuarios_rec.id_rol := c1.id_rol;
              l_usuarios_rec.email := c1.email;
              l_usuarios_rec.nombre := c1.nombre;
              l_usuarios_rec.cia := c1.cia;
              l_usuarios_rec.prog_academico := c1.prog_academico;
              l_usuarios_rec.activo := c1.activo;
              l_usuarios_rec.bloqueado := c1.bloqueado;
              l_usuarios_rec.creado_por := c1.creado_por;
              l_usuarios_rec.creado_el := c1.creado_el;
              l_usuarios_rec.modificado_por := c1.modificado_por;
              l_usuarios_rec.modificado_el := c1.modificado_el;
              l_usuarios_rec.hash := tapi_usuarios.hash( c1.cedula);
              l_usuarios_rec.row_id := c1.ROWID;
              PIPE ROW (l_usuarios_rec);
       END LOOP;

       RETURN;

    END tt;


    PROCEDURE ins (p_usuarios_rec IN OUT usuarios_rt)
    IS
        l_rowtype     usuarios%ROWTYPE;

    BEGIN


        l_rowtype.cedula := ins.p_usuarios_rec.cedula;
        l_rowtype.nombre_usuario := ins.p_usuarios_rec.nombre_usuario;
        l_rowtype.contrasena := ins.p_usuarios_rec.contrasena;
        l_rowtype.id_rol := ins.p_usuarios_rec.id_rol;
        l_rowtype.email := ins.p_usuarios_rec.email;
        l_rowtype.nombre := ins.p_usuarios_rec.nombre;
        l_rowtype.cia := ins.p_usuarios_rec.cia;
        l_rowtype.prog_academico := ins.p_usuarios_rec.prog_academico;
        l_rowtype.activo := ins.p_usuarios_rec.activo;
        l_rowtype.bloqueado := ins.p_usuarios_rec.bloqueado;
        l_rowtype.creado_por := ins.p_usuarios_rec.creado_por;
        l_rowtype.creado_el := ins.p_usuarios_rec.creado_el;
        l_rowtype.modificado_por := ins.p_usuarios_rec.modificado_por;
        l_rowtype.modificado_el := ins.p_usuarios_rec.modificado_el;

       INSERT INTO usuarios
          VALUES   l_rowtype
       RETURNING
                   cedula ,
                   nombre_usuario ,
                   contrasena ,
                   id_rol ,
                   email ,
                   nombre ,
                   cia ,
                   prog_academico ,
                   activo ,
                   bloqueado ,
                   creado_por ,
                   creado_el ,
                   modificado_por ,
                   modificado_el 
            INTO   l_rowtype;

         ins.p_usuarios_rec.cedula := l_rowtype.cedula;
         ins.p_usuarios_rec.nombre_usuario := l_rowtype.nombre_usuario;
         ins.p_usuarios_rec.contrasena := l_rowtype.contrasena;
         ins.p_usuarios_rec.id_rol := l_rowtype.id_rol;
         ins.p_usuarios_rec.email := l_rowtype.email;
         ins.p_usuarios_rec.nombre := l_rowtype.nombre;
         ins.p_usuarios_rec.cia := l_rowtype.cia;
         ins.p_usuarios_rec.prog_academico := l_rowtype.prog_academico;
         ins.p_usuarios_rec.activo := l_rowtype.activo;
         ins.p_usuarios_rec.bloqueado := l_rowtype.bloqueado;
         ins.p_usuarios_rec.creado_por := l_rowtype.creado_por;
         ins.p_usuarios_rec.creado_el := l_rowtype.creado_el;
         ins.p_usuarios_rec.modificado_por := l_rowtype.modificado_por;
         ins.p_usuarios_rec.modificado_el := l_rowtype.modificado_el;



    END ins;

    PROCEDURE upd (
                  p_usuarios_rec         IN usuarios_rt,
                  p_ignore_nulls         IN boolean := FALSE
                  )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   usuarios
             SET cedula = NVL(p_usuarios_rec.cedula,cedula),
                nombre_usuario = NVL(p_usuarios_rec.nombre_usuario,nombre_usuario),
                contrasena = NVL(p_usuarios_rec.contrasena,contrasena),
                id_rol = NVL(p_usuarios_rec.id_rol,id_rol),
                email = NVL(p_usuarios_rec.email,email),
                nombre = NVL(p_usuarios_rec.nombre,nombre),
                cia = NVL(p_usuarios_rec.cia,cia),
                prog_academico = NVL(p_usuarios_rec.prog_academico,prog_academico),
                activo = NVL(p_usuarios_rec.activo,activo),
                bloqueado = NVL(p_usuarios_rec.bloqueado,bloqueado),
                creado_por = NVL(p_usuarios_rec.creado_por,creado_por),
                creado_el = NVL(p_usuarios_rec.creado_el,creado_el),
                modificado_por = NVL(p_usuarios_rec.modificado_por,modificado_por),
                modificado_el = NVL(p_usuarios_rec.modificado_el,modificado_el)
           WHERE
                cedula = upd.p_usuarios_rec.cedula
                ;
       ELSE
          UPDATE   usuarios
             SET cedula = p_usuarios_rec.cedula,
                nombre_usuario = p_usuarios_rec.nombre_usuario,
                contrasena = p_usuarios_rec.contrasena,
                id_rol = p_usuarios_rec.id_rol,
                email = p_usuarios_rec.email,
                nombre = p_usuarios_rec.nombre,
                cia = p_usuarios_rec.cia,
                prog_academico = p_usuarios_rec.prog_academico,
                activo = p_usuarios_rec.activo,
                bloqueado = p_usuarios_rec.bloqueado,
                creado_por = p_usuarios_rec.creado_por,
                creado_el = p_usuarios_rec.creado_el,
                modificado_por = p_usuarios_rec.modificado_por,
                modificado_el = p_usuarios_rec.modificado_el
           WHERE
                cedula = upd.p_usuarios_rec.cedula
                ;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd;


    PROCEDURE upd_rowid (
                         p_usuarios_rec         IN usuarios_rt,
                         p_ignore_nulls         IN boolean := FALSE
                        )
    IS
    BEGIN

       IF NVL (p_ignore_nulls, FALSE)
       THEN
          UPDATE   usuarios
             SET cedula = NVL(p_usuarios_rec.cedula,cedula),
                nombre_usuario = NVL(p_usuarios_rec.nombre_usuario,nombre_usuario),
                contrasena = NVL(p_usuarios_rec.contrasena,contrasena),
                id_rol = NVL(p_usuarios_rec.id_rol,id_rol),
                email = NVL(p_usuarios_rec.email,email),
                nombre = NVL(p_usuarios_rec.nombre,nombre),
                cia = NVL(p_usuarios_rec.cia,cia),
                prog_academico = NVL(p_usuarios_rec.prog_academico,prog_academico),
                activo = NVL(p_usuarios_rec.activo,activo),
                bloqueado = NVL(p_usuarios_rec.bloqueado,bloqueado),
                creado_por = NVL(p_usuarios_rec.creado_por,creado_por),
                creado_el = NVL(p_usuarios_rec.creado_el,creado_el),
                modificado_por = NVL(p_usuarios_rec.modificado_por,modificado_por),
                modificado_el = NVL(p_usuarios_rec.modificado_el,modificado_el)
           WHERE  ROWID = p_usuarios_rec.row_id;
       ELSE
          UPDATE   usuarios
             SET cedula = p_usuarios_rec.cedula,
                nombre_usuario = p_usuarios_rec.nombre_usuario,
                contrasena = p_usuarios_rec.contrasena,
                id_rol = p_usuarios_rec.id_rol,
                email = p_usuarios_rec.email,
                nombre = p_usuarios_rec.nombre,
                cia = p_usuarios_rec.cia,
                prog_academico = p_usuarios_rec.prog_academico,
                activo = p_usuarios_rec.activo,
                bloqueado = p_usuarios_rec.bloqueado,
                creado_por = p_usuarios_rec.creado_por,
                creado_el = p_usuarios_rec.creado_el,
                modificado_por = p_usuarios_rec.modificado_por,
                modificado_el = p_usuarios_rec.modificado_el
           WHERE  ROWID = p_usuarios_rec.row_id;
       END IF;

       IF SQL%ROWCOUNT != 1 THEN RAISE e_upd_failed; END IF;

    EXCEPTION
       WHEN e_upd_failed
       THEN
          raise_application_error (-20000, 'No rows were updated. The update failed.');
    END upd_rowid;

   PROCEDURE web_upd (
                  p_usuarios_rec         IN usuarios_rt,
                  p_ignore_nulls         IN boolean := FALSE
                )
   IS
      l_usuarios_rec usuarios_rt;
   BEGIN

      OPEN usuarios_cur(
                             web_upd.p_usuarios_rec.cedula
                        );

      FETCH usuarios_cur INTO l_usuarios_rec;

      IF usuarios_cur%NOTFOUND THEN
         CLOSE usuarios_cur;
         RAISE e_row_missing;
      ELSE
         IF p_usuarios_rec.hash != l_usuarios_rec.hash THEN
            CLOSE usuarios_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(p_ignore_nulls, FALSE)
            THEN

                UPDATE   usuarios
                   SET cedula = NVL(p_usuarios_rec.cedula,cedula),
                       nombre_usuario = NVL(p_usuarios_rec.nombre_usuario,nombre_usuario),
                       contrasena = NVL(p_usuarios_rec.contrasena,contrasena),
                       id_rol = NVL(p_usuarios_rec.id_rol,id_rol),
                       email = NVL(p_usuarios_rec.email,email),
                       nombre = NVL(p_usuarios_rec.nombre,nombre),
                       cia = NVL(p_usuarios_rec.cia,cia),
                       prog_academico = NVL(p_usuarios_rec.prog_academico,prog_academico),
                       activo = NVL(p_usuarios_rec.activo,activo),
                       bloqueado = NVL(p_usuarios_rec.bloqueado,bloqueado),
                       creado_por = NVL(p_usuarios_rec.creado_por,creado_por),
                       creado_el = NVL(p_usuarios_rec.creado_el,creado_el),
                       modificado_por = NVL(p_usuarios_rec.modificado_por,modificado_por),
                       modificado_el = NVL(p_usuarios_rec.modificado_el,modificado_el)
               WHERE CURRENT OF usuarios_cur;
            ELSE
                UPDATE   usuarios
                   SET cedula = p_usuarios_rec.cedula,
                       nombre_usuario = p_usuarios_rec.nombre_usuario,
                       contrasena = p_usuarios_rec.contrasena,
                       id_rol = p_usuarios_rec.id_rol,
                       email = p_usuarios_rec.email,
                       nombre = p_usuarios_rec.nombre,
                       cia = p_usuarios_rec.cia,
                       prog_academico = p_usuarios_rec.prog_academico,
                       activo = p_usuarios_rec.activo,
                       bloqueado = p_usuarios_rec.bloqueado,
                       creado_por = p_usuarios_rec.creado_por,
                       creado_el = p_usuarios_rec.creado_el,
                       modificado_por = p_usuarios_rec.modificado_por,
                       modificado_el = p_usuarios_rec.modificado_el
               WHERE CURRENT OF usuarios_cur;
            END IF;

            CLOSE usuarios_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd;

   PROCEDURE web_upd_rowid (
                            p_usuarios_rec    IN usuarios_rt,
                            p_ignore_nulls         IN boolean := FALSE
                           )
   IS
      l_usuarios_rec usuarios_rt;
   BEGIN

      OPEN usuarios_rowid_cur(web_upd_rowid.p_usuarios_rec.row_id);

      FETCH usuarios_rowid_cur INTO l_usuarios_rec;

      IF usuarios_rowid_cur%NOTFOUND THEN
         CLOSE usuarios_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_upd_rowid.p_usuarios_rec.hash != l_usuarios_rec.hash THEN
            CLOSE usuarios_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            IF NVL(web_upd_rowid.p_ignore_nulls, FALSE)
            THEN
                UPDATE   usuarios
                   SET cedula = NVL(p_usuarios_rec.cedula,cedula),
                       nombre_usuario = NVL(p_usuarios_rec.nombre_usuario,nombre_usuario),
                       contrasena = NVL(p_usuarios_rec.contrasena,contrasena),
                       id_rol = NVL(p_usuarios_rec.id_rol,id_rol),
                       email = NVL(p_usuarios_rec.email,email),
                       nombre = NVL(p_usuarios_rec.nombre,nombre),
                       cia = NVL(p_usuarios_rec.cia,cia),
                       prog_academico = NVL(p_usuarios_rec.prog_academico,prog_academico),
                       activo = NVL(p_usuarios_rec.activo,activo),
                       bloqueado = NVL(p_usuarios_rec.bloqueado,bloqueado),
                       creado_por = NVL(p_usuarios_rec.creado_por,creado_por),
                       creado_el = NVL(p_usuarios_rec.creado_el,creado_el),
                       modificado_por = NVL(p_usuarios_rec.modificado_por,modificado_por),
                       modificado_el = NVL(p_usuarios_rec.modificado_el,modificado_el)
               WHERE CURRENT OF usuarios_rowid_cur;
            ELSE
                UPDATE   usuarios
                   SET cedula = p_usuarios_rec.cedula,
                       nombre_usuario = p_usuarios_rec.nombre_usuario,
                       contrasena = p_usuarios_rec.contrasena,
                       id_rol = p_usuarios_rec.id_rol,
                       email = p_usuarios_rec.email,
                       nombre = p_usuarios_rec.nombre,
                       cia = p_usuarios_rec.cia,
                       prog_academico = p_usuarios_rec.prog_academico,
                       activo = p_usuarios_rec.activo,
                       bloqueado = p_usuarios_rec.bloqueado,
                       creado_por = p_usuarios_rec.creado_por,
                       creado_el = p_usuarios_rec.creado_el,
                       modificado_por = p_usuarios_rec.modificado_por,
                       modificado_el = p_usuarios_rec.modificado_el
               WHERE CURRENT OF usuarios_rowid_cur;
            END IF;

            CLOSE usuarios_rowid_cur;
         END IF;
      END IF;


   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Update operation failed because the row is no longer in the database.');
   END web_upd_rowid;

    PROCEDURE del (
                  p_cedula IN usuarios.cedula%TYPE
                  )
    IS
    BEGIN

       DELETE FROM   usuarios
             WHERE
                  cedula = del.p_cedula
                   ;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del;

    PROCEDURE del_rowid (p_rowid IN varchar2)
    IS
    BEGIN

       DELETE FROM   usuarios
             WHERE   ROWID = del_rowid.p_rowid;

       IF sql%ROWCOUNT != 1
       THEN
          RAISE e_del_failed;
       END IF;


    EXCEPTION
       WHEN e_del_failed
       THEN
          raise_application_error (-20000, 'No rows were deleted. The delete failed.');
    END del_rowid;

    PROCEDURE web_del (
                      p_cedula IN usuarios.cedula%TYPE,
                      p_hash IN varchar2
                      )
   IS
      l_usuarios_rec usuarios_rt;
   BEGIN


      OPEN usuarios_cur(
                            web_del.p_cedula
                            );

      FETCH usuarios_cur INTO l_usuarios_rec;

      IF usuarios_cur%NOTFOUND THEN
         CLOSE usuarios_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del.p_hash != l_usuarios_rec.hash THEN
            CLOSE usuarios_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM usuarios
            WHERE CURRENT OF usuarios_cur;

            CLOSE usuarios_cur;
         END IF;
      END IF;



   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del;

   PROCEDURE web_del_rowid (p_rowid IN varchar2, p_hash IN varchar2)
   IS
      l_usuarios_rec usuarios_rt;
   BEGIN


      OPEN usuarios_rowid_cur(web_del_rowid.p_rowid);

      FETCH usuarios_rowid_cur INTO l_usuarios_rec;

      IF usuarios_rowid_cur%NOTFOUND THEN
         CLOSE usuarios_rowid_cur;
         RAISE e_row_missing;
      ELSE
         IF web_del_rowid.p_hash != l_usuarios_rec.hash THEN
            CLOSE usuarios_rowid_cur;
            RAISE e_ol_check_failed;
         ELSE
            DELETE FROM usuarios
            WHERE CURRENT OF usuarios_rowid_cur;

            CLOSE usuarios_rowid_cur;
         END IF;
      END IF;

   EXCEPTION
     WHEN e_ol_check_failed
     THEN
        raise_application_error (-20000 , 'Current version of data in database has changed since last page refresh.');
     WHEN e_row_missing
     THEN
        raise_application_error (-20000 , 'Delete operation failed because the row is no longer in the database.');
   END web_del_rowid;

END tapi_usuarios;



/
--------------------------------------------------------
--  DDL for Package Body TEPLSQL
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."TEPLSQL" 
AS
   g_buffer   CLOB;

   PROCEDURE output_clob (p_clob IN CLOB)
   AS
      l_offset   NUMBER DEFAULT 1 ;
   BEGIN
      LOOP
         EXIT WHEN l_offset > DBMS_LOB.getlength (p_clob);
         DBMS_OUTPUT.put_line (DBMS_LOB.SUBSTR (p_clob, 255, l_offset));
         l_offset    := l_offset + 255;
      END LOOP;
   END output_clob;

   /**
   * Receives the template directive key-value data separated by commas
   * and assign this key-values to the associative array
   *
   * @param  p_directive      the key-value data template directive
   * @param  p_vars           the associative array
   */
   PROCEDURE set_template_directive (p_directive IN CLOB, p_vars IN OUT NOCOPY t_assoc_array)
   AS
      l_key         VARCHAR2 (256);
      l_value       VARCHAR2 (256);
      l_directive   VARCHAR2 (32767);
   BEGIN
      l_directive := REGEXP_REPLACE (p_directive, '\s', '');

      FOR c1 IN (    SELECT   REGEXP_REPLACE (REGEXP_SUBSTR (l_directive
                                                           , '[^,]+'
                                                           , 1
                                                           , LEVEL), '\s', '')
                                 text
                       FROM   DUAL
                 CONNECT BY   REGEXP_SUBSTR (l_directive
                                           , '[^,]+'
                                           , 1
                                           , LEVEL) IS NOT NULL)
      LOOP
         l_key       := SUBSTR (c1.text, 1, INSTR (c1.text, '=') - 1);
         l_value     := SUBSTR (c1.text, INSTR (c1.text, '=') + 1);
         p_vars ('template_' || l_key) := l_value;
      END LOOP;
   END set_template_directive;

   /**
   * Receives the name of the object, usually a package,
   * which contains an embedded template and return the template.
   *
   * @param  p_template_name    the name of the template
   * @param  p_object_name      the name of the object (usually the name of the package)
   * @param  p_object_type      the type of the object (PACKAGE, PROCEDURE, FUNCTION...)
   * @param  p_schema           the schema of the object
   * @return                    the template.
   */
    FUNCTION include (p_template_name   IN VARCHAR2 DEFAULT NULL
                    , p_object_name     IN VARCHAR2 DEFAULT 'TE_TEMPLATES'
                    , p_object_type     IN VARCHAR2 DEFAULT 'PACKAGE'
                    , p_schema          IN VARCHAR2 DEFAULT NULL )
       RETURN CLOB
    AS
       l_result       CLOB;
       l_object_ddl   CLOB;
       l_template     CLOB;
       l_tmp          CLOB;
       i              PLS_INTEGER := 1;
       l_found        PLS_INTEGER := 0;
       l_object_name     VARCHAR2 (64);
       l_template_name   VARCHAR2 (64);
       l_object_type     VARCHAR2 (64);
       l_schema          VARCHAR2 (64);
    BEGIN

        --Force Defaults
        l_template_name := p_template_name;
        l_object_name := NVL(p_object_name,'TE_TEMPLATES');
        l_object_type := NVL(p_object_type,'PACKAGE');
        l_schema := p_schema;

       --Search for the template in the table TE_TEMPLATES
       IF  l_template_name IS NOT NULL
       AND l_object_name = 'TE_TEMPLATES'
       THEN
          BEGIN
              SELECT   template
                INTO   l_template
                FROM   te_templates
               WHERE   name = UPPER (l_template_name);
          EXCEPTION
          WHEN NO_DATA_FOUND
          THEN
            l_template := EMPTY_CLOB();
          END;

           RETURN l_template;

       ELSE
          --Search the template in other Oracle Object

          --Get package source DDL
          l_object_ddl :=
             DBMS_METADATA.get_ddl (NVL (UPPER (l_object_type), 'PACKAGE'), UPPER (l_object_name), UPPER (l_schema));

          --If p_template_name is null get all templates from the object
          --else get only this template.
          IF l_template_name IS NOT NULL
          THEN
             LOOP
                l_tmp       :=
                   REGEXP_SUBSTR (l_object_ddl
                                , '<%@ template([^%>].*?)%>'
                                , 1
                                , i
                                , 'n');

                l_found     := INSTR (l_tmp, 'name=' || l_template_name);

                EXIT WHEN LENGTH (l_tmp) = 0 OR l_found <> 0;
                i           := i + 1;
             END LOOP;
          ELSE
             l_found     := 0;
          END IF;

          -- i has the occurrence of the substr where the template is
          l_tmp       := NULL;

          LOOP
             --Get Template from the object
             $IF DBMS_DB_VERSION.ver_le_10
             $THEN
                l_tmp       :=
                   REGEXP_REPLACE (REGEXP_REPLACE (REGEXP_SUBSTR (l_object_ddl
                                                                , '\$if[[:blank:]]+false[[:blank:]]+\$then' || CHR (10) || '([^\$end].*?)\$end'
                                                                , 1
                                                                , i
                                                                , 'n')
                                                 , '\$if[[:blank:]]+false[[:blank:]]+\$then' || CHR (10)
                                                 , ''
                                                 , 1
                                                 , 1)
                                 , '\$end'
                                 , ''
                                 , 1
                                 , INSTR ('$end', 1, -1));
             $ELSE
                l_tmp       :=
                   REGEXP_SUBSTR (l_object_ddl
                                , '\$if[[:blank:]]+false[[:blank:]]+\$then' || CHR (10) || '([^\$end].*?)\$end'
                                , 1
                                , i
                                , 'n'
                                , 1);
             $END

             l_template  := l_template || l_tmp;
             EXIT WHEN LENGTH (l_tmp) = 0 OR l_found <> 0;
             i           := i + 1;
          END LOOP;

          RETURN l_template;
       END IF;
    END include;

   /**
   * Bind associative array variables in the template
   *
   * @param  p_template      the template
   * @param  p_vars        the associative array
   */
   PROCEDURE bind_vars (p_template IN OUT NOCOPY CLOB, p_vars IN t_assoc_array)
   AS
      l_key   VARCHAR2 (256);
   BEGIN
      IF p_vars.COUNT () <> 0
      THEN
         l_key       := p_vars.FIRST;

         LOOP
            EXIT WHEN l_key IS NULL;
            p_template    := REPLACE (p_template, '${' || l_key || '}', TO_CLOB (p_vars (l_key)));
            l_key       := p_vars.NEXT (l_key);
         END LOOP;
      END IF;
   END bind_vars;

   /**
   * Parse template marks
   *
   * @param  p_template      the template
   * @param  p_vars        the associative array
   */
   PROCEDURE parse (p_template IN CLOB, p_vars IN t_assoc_array DEFAULT null_assoc_array)
   AS
      l_open_count    PLS_INTEGER;
      l_close_count   PLS_INTEGER;
   BEGIN
      $if dbms_db_version.ver_le_10 $then
          /**
          *  ATTENTION, these instructions are very slow and penalize template processing time.
          *  If performance is critical to your system, you should disable the parser only for BD <= 10g
          */
          l_open_count :=
             NVL (LENGTH (REGEXP_REPLACE (p_template
                                        , '(<)%|.'
                                        , '\1'
                                        , 1
                                        , 0
                                        , 'n')), 0);

          l_close_count :=
             NVL (LENGTH (REGEXP_REPLACE (p_template
                                        , '(%)>|.'
                                        , '\1'
                                        , 1
                                        , 0
                                        , 'n')), 0);
      $else
          l_open_count := regexp_count (p_template, '<\%');
          l_close_count := regexp_count (p_template, '\%>');
      $end


      IF l_open_count <> l_close_count
      THEN
         raise_application_error (-20001
                                ,    '##Parser Exception processing the template: '||p_vars('template_name')
                                  || '. One or more tags (<% %>) are not closed: '
                                  || l_open_count
                                  || ' <> '
                                  || l_close_count
                                  || CHR (10));
      END IF;
   END parse;

   /**
   * Interprets the received template and convert it into executable plsql
   *
   * @param  p_template    the template
   * @param  p_vars        the associative array
   */
   PROCEDURE interpret (p_template IN OUT NOCOPY CLOB, p_vars IN t_assoc_array DEFAULT null_assoc_array)
   AS
      l_vars       t_assoc_array := p_vars;
      l_declare    CLOB;
      l_tmp        CLOB;
      i            PLS_INTEGER := 0;
   BEGIN

      --Template directive
      $if dbms_db_version.ver_le_10 $then
          l_tmp       :=
             REPLACE (REPLACE (REGEXP_SUBSTR (p_template
                                            , '<%@ template([^%>].*?)\s*%>'
                                            , 1
                                            , 1
                                            , 'n'), '<%@ template', ''), '%>', '');
      $else
          l_tmp       :=
             REGEXP_SUBSTR (p_template
                          , '<%@ template([^%>].*?)\s*%>'
                          , 1
                          , 1
                          , 'n'
                          , 1);
      $end

      --Set template directive variables into var associative array
      set_template_directive (l_tmp, l_vars);

      --Bind the variables into template
      bind_vars (p_template, l_vars);

      --Null all variables not binded
      p_template    := REGEXP_REPLACE (p_template, '\$\{\S*\}', '');

      --Parse <% %> tags
      parse (p_template, l_vars);

      --Dos to Unix
      p_template  :=
         REGEXP_REPLACE (p_template
                       , CHR(13)||CHR(10)
                       , CHR(10)
                       , 1,0,'nm');

      --Delete all template directives
      p_template  :=
         REGEXP_REPLACE (p_template
                       , '<%@ template([^%>].*?)\s*%>[[:blank:]]*\s$?'
                       , ''
                       , 1
                       , 0
                       , 'n');

      --Escaped chars except \\n
      p_template  :=
         REGEXP_REPLACE (p_template
                       , '\\\\([^n])'
                       , ']'');tePLSQL.p(q''[\1]'');tePLSQL.p(q''['
                       , 1
                       , 0
                       , 'n');


      --New lines.
      p_template  :=
         REGEXP_REPLACE (p_template
                       , '(\\\\n)'
                       , CHR (10) --|| ']'');tePLSQL.p(q''['
                       , 1
                       , 0
                       , 'n');


      --Delete the line breaks for lines ending in %>[blanks]CHR(10)
      p_template  :=
         REGEXP_REPLACE (p_template
                       , '(%>[[:blank:]]*?' || CHR (10) || ')'
                       , '%>'
                       , 1
                       , 0
                       , '');

      --Delete new lines with !\n
      p_template  :=
         REGEXP_REPLACE (p_template
                       , '([[:blank:]]*\!\\n[[:blank:]]*' || CHR (10) || '?[[:blank:]]*)'
                       , ''
                       , 1
                       , 0
                       , 'm');

      -- Delete all blanks before <% in the beginning of each line
      p_template  :=
         REGEXP_REPLACE (p_template
                       , '(^[[:blank:]]*<%)'
                       , '<%'
                       , 1
                       , 0
                       , 'm');

      --Merge all declaration blocks into a single block
      l_tmp       := NULL;

      LOOP
         i           := i + 1;
          $if dbms_db_version.ver_le_10 $then
             l_tmp       :=
                REPLACE (REPLACE (REGEXP_SUBSTR (p_template
                                               , '<%!([^%>].*?)%>'
                                               , 1
                                               , i
                                               , 'n'), '<%!', ''), '%>', '');
         $else
             l_tmp       :=
                REGEXP_SUBSTR (p_template
                             , '<%!([^%>].*?)%>'
                             , 1
                             , i
                             , 'n'
                             , 1);
         $end

         l_declare   := l_declare || l_tmp;
         EXIT WHEN LENGTH (l_tmp) = 0;
      END LOOP;

      --Delete declaration blocks from template
      p_template  :=
         REGEXP_REPLACE (p_template
                       , '<%!([^%>].*?)%>'
                       , ''
                       , 1
                       , 0
                       , 'n');

      --Expresison directive
      p_template  :=
         REGEXP_REPLACE (p_template
                       , '<%=([^%>].*?)%>'
                       , ']'');tePLSQL.p(\1);tePLSQL.p(q''['
                       , 1
                       , 0
                       , 'n');

      --Code blocks directive
      --p_template  :=
      --   REGEXP_REPLACE (p_template
      --                 , '<%([^%>].*?)%>'
      --                 , ']''); \1 tePLSQL.p(q''['
      --                , 1
      --                 , 0
      --                 , 'n');

      p_template  := 'DECLARE ' || l_declare || ' BEGIN tePLSQL.p(q''[' || p_template || ' ]''); END;';

   END interpret;

   /**
   * Search for include directives, includes and evaluates the specified templates.
   * Nested include are allowed
   *
   * @param  p_template    the template
   * @param  p_vars        the associative array
   */
   PROCEDURE get_includes (p_template IN OUT NOCOPY CLOB, p_vars IN t_assoc_array DEFAULT null_assoc_array )
    AS
       l_tmp             CLOB;
       l_result          CLOB;

       l_str_tmp         VARCHAR2 (64);

       TYPE array_t IS TABLE OF VARCHAR2 (64);

       l_strig_tt        array_t;
       l_object_name     VARCHAR2 (64);
       l_template_name   VARCHAR2 (64);
       l_object_type     VARCHAR2 (64);
       l_schema          VARCHAR2 (64);

       l_start           PLS_INTEGER := 0;
       l_end             PLS_INTEGER := 0;
       l_number_includes PLS_INTEGER := 0;
    BEGIN
       /*
       --Pseudocode
       while there includes
       do
           get include
           interpret template
           concatenate result template into p_template
       done
       */
       WHILE REGEXP_INSTR (p_template, '<%@ include\((.*?)\)\s*%>') <> 0
       LOOP
          --Init
          l_str_tmp   := NULL;
          l_object_name := NULL;
          l_template_name := NULL;
          l_object_type := NULL;
          l_schema    := NULL;
          l_tmp       := NULL;
          l_start     := 0;
          l_end       := 0;

          --get include directive
          l_str_tmp   :=
             REGEXP_SUBSTR (p_template
                          , '<%@ include\((.*?)\)\s*%>'
                          , 1
                          , 1
                          , 'n'
                          , 1);

          IF LENGTH (l_str_tmp) > 0
          THEN
                 SELECT   REGEXP_REPLACE (REGEXP_SUBSTR (l_str_tmp
                                                       , '[^,]+'
                                                       , 1
                                                       , LEVEL), '\s', '')
                             text
                   BULK   COLLECT
                   INTO   l_strig_tt
                   FROM   DUAL
             CONNECT BY   REGEXP_SUBSTR (l_str_tmp
                                       , '[^,]+'
                                       , 1
                                       , LEVEL) IS NOT NULL;

             --populate variables
             IF l_strig_tt.EXISTS (1)
             THEN
                l_template_name := l_strig_tt (1);
             END IF;

             IF l_strig_tt.EXISTS (2)
             THEN
                l_object_name := l_strig_tt (2);
             END IF;

             IF l_strig_tt.EXISTS (3)
             THEN
                l_object_type := l_strig_tt (3);
             END IF;

             IF l_strig_tt.EXISTS (4)
             THEN
                l_schema    := l_strig_tt (4);
             END IF;

             --get included template
             l_tmp       :=
                include (l_template_name
                       , l_object_name
                       , l_object_type
                       , l_object_type);

             --Interpret the template
             interpret (l_tmp, p_vars);


             l_tmp := ']''); '|| l_tmp ||' tePLSQL.p(q''[';

             --Start and End of the expression
             l_start     :=
                REGEXP_INSTR (p_template
                            , '<%@ include\((.*?)\)\s*%>'
                            , 1
                            , 1
                            , 0
                            , 'n');

             l_end       :=
                REGEXP_INSTR (p_template
                            , '<%@ include\((.*?)\)\s*%>'
                            , 1
                            , 1
                            , 1
                            , 'n');

             --concatenate result template into first template
             IF (NVL (l_start, 0) > 0)
             THEN
                DBMS_LOB.createtemporary (l_result, FALSE, DBMS_LOB.call);

                IF l_start > 1
                THEN
                   DBMS_LOB.COPY (l_result
                                , p_template
                                , l_start - 1
                                , 1
                                , 1);
                END IF;

                IF LENGTH (l_tmp) > 0
                THEN
                   DBMS_LOB.COPY (l_result
                                , l_tmp
                                , DBMS_LOB.getlength (l_tmp)
                                , DBMS_LOB.getlength (l_result) +1
                                , 1);
                END IF;

                --A�adimos el resto de la fuente a la varbiable resultado
                DBMS_LOB.COPY (l_result
                             , p_template
                             , DBMS_LOB.getlength (p_template)
                             , DBMS_LOB.getlength (l_result) +1
                             , l_end);
             END IF;


             p_template  := l_result;

             DBMS_LOB.freetemporary (l_result);
          END IF;

          l_number_includes := l_number_includes +1;
          if l_number_includes >= 50
          then
            raise_application_error (-20001, 'Too much include directive in the template, Recursive include?');
          end if;

       END LOOP;
    END get_includes;

   PROCEDURE PRINT (p_data IN CLOB)
   AS
   BEGIN
      g_buffer    := g_buffer || p_data;
   END PRINT;

   PROCEDURE PRINT (p_data IN VARCHAR2)
   AS
   BEGIN
      g_buffer    := g_buffer || p_data;
   END PRINT;

   PROCEDURE PRINT (p_data IN NUMBER)
   AS
   BEGIN
      g_buffer    := g_buffer || TO_CHAR (p_data);
   END PRINT;

   PROCEDURE p (p_data IN CLOB)
   AS
   BEGIN
      g_buffer    := g_buffer || p_data;
   END p;

   PROCEDURE p (p_data IN VARCHAR2)
   AS
   BEGIN
      g_buffer    := g_buffer || p_data;
   END p;

   PROCEDURE p (p_data IN NUMBER)
   AS
   BEGIN
      g_buffer    := g_buffer || TO_CHAR (p_data);
   END p;

   FUNCTION render (p_vars IN t_assoc_array DEFAULT null_assoc_array, p_template IN CLOB)
      RETURN CLOB
   AS
    l_template   CLOB := p_template;
    l_length pls_integer;
   BEGIN
      --Clear buffer
      g_buffer    := NULL;

      --Parse <% %> tags
      --parse (l_template);

      --Get Includes
      get_includes(l_template);

      --Interpret the template
      interpret(l_template, p_vars);

      --Code blocks directive
      l_template  :=
         REGEXP_REPLACE (l_template
                       , '<%([^%>].*?)%>'
                       , ']''); \1 tePLSQL.p(q''['
                       , 1
                       , 0
                       , 'n');

      --DBMS_OUTPUT.put_line (l_template);

      --Execute the template
      $if dbms_db_version.ver_le_10 $then
          --10g
          DECLARE
             v_upperbound   NUMBER;
             v_cur          INTEGER;
             v_sql          DBMS_SQL.varchar2a;
             v_ret          NUMBER;
          BEGIN
             v_upperbound := CEIL (DBMS_LOB.getlength (l_template) / 32767);

             FOR i IN 1 .. v_upperbound
             LOOP
                v_sql (i)   := DBMS_LOB.SUBSTR (l_template, -- clob statement
                                                  32767, -- amount
                                                  ( (i - 1) * 32767) + 1);
             END LOOP;

             v_cur       := DBMS_SQL.open_cursor;
             -- parse sql statement
             DBMS_SQL.parse (v_cur
                           , v_sql
                           , 1
                           , v_upperbound
                           , FALSE
                           , DBMS_SQL.native);
             -- execute
             v_ret       := DBMS_SQL.execute (v_cur);
          EXCEPTION
             WHEN OTHERS
             THEN
                --Trim buffer
                l_length := DBMS_LOB.getlength (g_buffer);
                IF l_length > 500
                THEN
                    l_length := 500;
                END IF;
                g_buffer := DBMS_LOB.SUBSTR (g_buffer, l_length, DBMS_LOB.getlength (g_buffer) - (l_length - 1));

                --Print error
                PRINT ('### tePLSQL Render Error ###');
                PRINT (CHR (10));
                PRINT (SQLERRM || ' ' || DBMS_UTILITY.format_error_backtrace ());
                PRINT (CHR (10));
                PRINT ('### Processed template ###');
                PRINT (CHR (10));
                PRINT (l_template);
          END;

      $else
          -- 11g
          BEGIN
             EXECUTE IMMEDIATE l_template;
          EXCEPTION
             WHEN OTHERS
             THEN
                --Trim buffer
                l_length := DBMS_LOB.getlength (g_buffer);
                IF l_length > 500
                THEN
                    l_length := 500;
                END IF;
                g_buffer := DBMS_LOB.SUBSTR (g_buffer, l_length, DBMS_LOB.getlength (g_buffer) - (l_length - 1));

                --Print error
                PRINT ('### tePLSQL Render Error ###');
                PRINT (CHR (10));
                PRINT (SQLERRM || ' ' || DBMS_UTILITY.format_error_backtrace ());
                PRINT (CHR (10));
                PRINT ('### Processed template ###');
                PRINT (CHR (10));
                PRINT (l_template);
          END;
      $end

      l_template  := g_buffer;
      g_buffer    := NULL;

      RETURN l_template;
   EXCEPTION
      WHEN OTHERS
      THEN
         raise_application_error (-20001, SQLERRM || ' ' || DBMS_UTILITY.format_error_backtrace ());
   END render;


   FUNCTION process (p_vars            IN t_assoc_array DEFAULT null_assoc_array
                   , p_template_name   IN VARCHAR2 DEFAULT NULL
                   , p_object_name     IN VARCHAR2 DEFAULT 'TE_TEMPLATES'
                   , p_object_type     IN VARCHAR2 DEFAULT 'PACKAGE'
                   , p_schema          IN VARCHAR2 DEFAULT NULL )
      RETURN CLOB
   AS
      l_result       CLOB;
      l_template     CLOB;
   BEGIN
      --Get template
      l_template := include(p_template_name,p_object_name,p_object_type,p_schema);

      IF LENGTH (l_template) = 0
      THEN
         IF p_template_name IS NOT NULL
         THEN
            raise_application_error (-20002
                                   , 'Template ' || p_template_name || ' not found in object ' || UPPER (p_object_name));
         ELSE
            raise_application_error (-20002
                                   , 'The object ' || p_object_name || ' not has a template inside the "$if false $then"');
         END IF;
      END IF;

      --Render template
      l_result    := render (p_vars,l_template);
      RETURN l_result;
   END process;
END teplsql;

/
--------------------------------------------------------
--  DDL for Package Body TOOLKIT
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."TOOLKIT" AS

  g_key     RAW(32767)  := UTL_RAW.cast_to_raw('fundauc2019');
  g_pad_chr VARCHAR2(1) := '~';

  PROCEDURE padstring (p_text  IN OUT  VARCHAR2);


  -- --------------------------------------------------
  FUNCTION encrypt (p_text  IN  VARCHAR2) RETURN RAW IS
  -- --------------------------------------------------
    l_text       VARCHAR2(32767) := p_text;
    l_encrypted  RAW(32767);
  BEGIN
    padstring(l_text);
    DBMS_OBFUSCATION_TOOLKIT.desencrypt(input          => UTL_RAW.cast_to_raw(l_text),
                                        key            => g_key,
                                        encrypted_data => l_encrypted);
    RETURN l_encrypted;
  END;
  -- --------------------------------------------------



  -- --------------------------------------------------
  FUNCTION decrypt (p_raw  IN  RAW) RETURN VARCHAR2 IS
  -- --------------------------------------------------
    l_decrypted  VARCHAR2(32767);
  BEGIN
    DBMS_OBFUSCATION_TOOLKIT.desdecrypt(input => p_raw,
                                        key   => g_key,
                                        decrypted_data => l_decrypted);

    RETURN RTrim(UTL_RAW.cast_to_varchar2(l_decrypted), g_pad_chr);
  END;
  -- --------------------------------------------------

  -- --------------------------------------------------
  FUNCTION LOGIN (p_username IN VARCHAR2, p_password VARCHAR2) RETURN BOOLEAN IS
    l_return number;
    l_usuario usuarios.nombre_usuario%type;
    l_password usuarios.contrasena%type;
    begin 
      begin
      select nombre_usuario,contrasena into l_usuario, l_password from usuarios where UPPER(nombre_usuario) = UPPER(p_username);

     if toolkit.encrypt(p_password) = l_password and l_usuario = p_username then
--      DBMS_OUTPUT.PUT_LINE('if = ' || upper(p_password)||'='||l_password ||' and '||l_usuario||'='||upper(p_username));
--      if upper(p_password) = upper(l_password) and upper(l_usuario) = upper(p_username) then
        return true;
        else
        return false;
      end if;
      exception when no_data_found then
        return false;  
      end;
  END;
  -- --------------------------------------------------

  -- --------------------------------------------------
  PROCEDURE padstring (p_text  IN OUT  VARCHAR2) IS
  -- --------------------------------------------------
    l_units  NUMBER;
  BEGIN
    IF LENGTH(p_text) MOD 8 > 0 THEN
      l_units := TRUNC(LENGTH(p_text)/8) + 1;
      p_text  := RPAD(p_text, l_units * 8, g_pad_chr);
    END IF;
  END;
  -- --------------------------------------------------

  FUNCTION get_tipo_acceso (p_usr IN VARCHAR2, p_app VARCHAR2) RETURN CHAR IS
    l_return CHAR(1) := null;
    l_usuario usuarios.nombre_usuario%type;
    l_app_id  number;
  BEGIN
    FOR c IN (select role_static_id from apex_appl_acl_user_roles where application_id = p_app and user_name = p_usr) LOOP
        IF c.role_static_id in ('CONTROLEST','SUPCONTROLEST') and l_return is null THEN
            l_return := 'I';
        ELSIF c.role_static_id in ('DIPLOMADOS','SUPDIPLO') and l_return is null THEN
            l_return := 'D';
        ELSIF c.role_static_id in ('ADMINISTRATOR') THEN
            l_return := 'T';
        END IF;
    END LOOP;
    return l_return;
  END;

END toolkit;

/
--------------------------------------------------------
--  DDL for Package Body UTL_CALENDARIOS_DETALLES
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."UTL_CALENDARIOS_DETALLES" AS

    FUNCTION getTotalPeriodosCal (
        vid_calendario NUMBER
    ) RETURN NUMBER AS
        eof  NUMBER;
        dml  VARCHAR2(2000);
    BEGIN
        dml := 'SELECT count(*) FROM Calendarios_detalle WHERE id_calendario = '|| vid_calendario;

        EXECUTE IMMEDIATE dml
        INTO eof;

--DBMS_OUTPUT.PUT_LINE(dml);
        IF eof IS NULL THEN
            eof := 0;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := 0;
            RETURN eof;
        WHEN OTHERS THEN
            eof := 0;
            dbms_output.put_line('COUNT: '
                                 || sqlerrm
                                 || dml);
            RETURN eof;
    END getTotalPeriodosCal;

    FUNCTION getTotalPeriodosCalMod (
        vid_calendario NUMBER,
        vid_modalidad NUMBER
    ) RETURN NUMBER AS
        eof  NUMBER;
        dml  VARCHAR2(2000);
    BEGIN
        dml := 'SELECT count(*) FROM Calendarios_detalle WHERE id_calendario = '|| vid_calendario||' and modalidad = '||vid_modalidad;

        EXECUTE IMMEDIATE dml
        INTO eof;

--DBMS_OUTPUT.PUT_LINE(dml);
        IF eof IS NULL THEN
            eof := 0;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := 0;
            RETURN eof;
        WHEN OTHERS THEN
            eof := 0;
            dbms_output.put_line('COUNT: '
                                 || sqlerrm
                                 || dml);
            RETURN eof;
    END getTotalPeriodosCalMod;


   FUNCTION getSiguentePeriodoMod (
        vid_calendario NUMBER,
        vid_modalidad NUMBER
    ) RETURN NUMBER AS
        eof   NUMBER;
        dml   VARCHAR2(2000);
    BEGIN

        dml := 'SELECT nvl(max(periodo),0)+1 FROM Calendarios_detalle WHERE id_calendario='||vid_calendario||' and modalidad = '|| vid_modalidad;

        EXECUTE IMMEDIATE dml
        INTO eof;

DBMS_OUTPUT.PUT_LINE(dml);
        IF eof IS NULL THEN
            eof := 0;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := 0;
            RETURN eof;
        WHEN OTHERS THEN
            eof := 0;
            dbms_output.put_line('COUNT: '
                                 || sqlerrm
                                 || dml);
            RETURN eof;
    END getSiguentePeriodoMod;
    
    FUNCTION getCalendario (
        vid_calendario NUMBER
    ) RETURN VARCHAR2 AS
        eof  VARCHAR2(100);
        dml  VARCHAR2(2000);
    BEGIN
        dml := 'SELECT DESCRIPCION FROM Calendarios WHERE id_calendario = '|| vid_calendario;

        EXECUTE IMMEDIATE dml
        INTO eof;

--DBMS_OUTPUT.PUT_LINE(dml);
        IF eof IS NULL THEN
            eof := NULL;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := NULL;
            RETURN eof;
        WHEN OTHERS THEN
            eof := NULL;
            dbms_output.put_line('COUNT: '
                                 || sqlerrm
                                 || dml);
            RETURN eof;
    END getCalendario;

END utl_calendarios_detalles;

/
--------------------------------------------------------
--  DDL for Package Body UTL_CONFIGURACION
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."UTL_CONFIGURACION" AS

    FUNCTION getConfIva RETURN NUMBER IS
        eof  NUMBER;
        dml  VARCHAR2(2000);
    BEGIN
        dml := 'SELECT TASA_IVA FROM configuracion';

        EXECUTE IMMEDIATE dml
        INTO eof;

DBMS_OUTPUT.PUT_LINE(dml);
        IF eof IS NULL THEN
            eof := 0;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := 0;
            RETURN eof;
        WHEN OTHERS THEN
            eof := 0;
            dbms_output.put_line('COUNT: '
                                 || sqlerrm
                                 || dml);
            RETURN eof;
    END getConfIva;

    FUNCTION getConfUltFactura RETURN NUMBER IS
        eof  NUMBER;
        dml  VARCHAR2(2000);
    BEGIN
        dml := 'SELECT ULT_FACTURA+1 FROM configuracion';

        EXECUTE IMMEDIATE dml
        INTO eof;

DBMS_OUTPUT.PUT_LINE(dml);
        IF eof IS NULL THEN
            eof := 0;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := 0;
            RETURN eof;
        WHEN OTHERS THEN
            eof := 0;
            dbms_output.put_line('COUNT: '
                                 || sqlerrm
                                 || dml);
            RETURN eof;
    END getConfUltFactura;

    PROCEDURE actConfUltFactura(numero IN number) IS
    BEGIN

        update configuracion set ULT_FACTURA = numero;

    END actConfUltFactura;

    FUNCTION getConfPorTDC RETURN NUMBER IS
        eof  NUMBER;
        dml  VARCHAR2(2000);
    BEGIN
        dml := 'SELECT PORC_TARJ_CRE FROM configuracion';

        EXECUTE IMMEDIATE dml
        INTO eof;

DBMS_OUTPUT.PUT_LINE(dml);
        IF eof IS NULL THEN
            eof := 0;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := 0;
            RETURN eof;
        WHEN OTHERS THEN
            eof := 0;
            dbms_output.put_line('COUNT: '
                                 || sqlerrm
                                 || dml);
            RETURN eof;
    END getConfPorTDC;

    FUNCTION getConfPorTDB RETURN NUMBER IS
        eof  NUMBER;
        dml  VARCHAR2(2000);
    BEGIN
        dml := 'SELECT PORC_TARJ_DEB FROM configuracion';

        EXECUTE IMMEDIATE dml
        INTO eof;

DBMS_OUTPUT.PUT_LINE(dml);
        IF eof IS NULL THEN
            eof := 0;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := 0;
            RETURN eof;
        WHEN OTHERS THEN
            eof := 0;
            dbms_output.put_line('COUNT: '
                                 || sqlerrm
                                 || dml);
            RETURN eof;
    END getConfPorTDB;


END utl_configuracion;

/
--------------------------------------------------------
--  DDL for Package Body UTL_ESTUDIANTES
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."UTL_ESTUDIANTES" AS

    FUNCTION getTipoEstudiante (
        vid_tipoest NUMBER
    ) RETURN VARCHAR2 AS
        eof  VARCHAR2(100);
        dml  VARCHAR2(2000);
    BEGIN
        dml := 'SELECT DESCRIPCION FROM tipo_estudiante WHERE id_tipo_est = '|| vid_tipoest;

        EXECUTE IMMEDIATE dml
        INTO eof;

--DBMS_OUTPUT.PUT_LINE(dml);
        IF eof IS NULL THEN
            eof := NULL;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := NULL;
            RETURN eof;
        WHEN OTHERS THEN
            eof := NULL;
            dbms_output.put_line('COUNT: '
                                 || sqlerrm
                                 || dml);
            RETURN eof;
    END getTipoEstudiante;

END utl_estudiantes;

/
--------------------------------------------------------
--  DDL for Package Body UTL_FACTURA
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."UTL_FACTURA" AS

    FUNCTION getTotal (
        vid NUMBER
    ) RETURN NUMBER AS
        eof  NUMBER := 0;
        dml  VARCHAR2(2000);
    BEGIN
        dml := 'SELECT MONTO FROM FACTURA WHERE id = '|| vid;

        EXECUTE IMMEDIATE dml
        INTO eof;

--DBMS_OUTPUT.PUT_LINE(dml);
        IF eof = 0 THEN
            eof := 0;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := 0;
            RETURN eof;
        WHEN OTHERS THEN
            eof := 0;
            dbms_output.put_line('MONTO: '
                                 || sqlerrm
                                 || dml);
            RETURN eof;
    END getTotal;

    PROCEDURE insIngDiferido (
        vfid IN NUMBER, 
        vmonto IN NUMBER,
        vresp OUT NUMBER
    ) IS
        p_detalle_factura_rec   fundauc.tapi_detalle_factura.detalle_factura_rt;
    BEGIN

        p_detalle_factura_rec.renglon := detalle_factura_seq.nextval;
        p_detalle_factura_rec.tipo_item := 'ID';
        p_detalle_factura_rec.item := case when sign(vmonto) = -1 then 'IDN' else 'IDP' end;
        p_detalle_factura_rec.descripcion := case when sign(vmonto) = -1 then 'INGRESO DIFERIDO NEGATIVO (DIFERENCIA FACTURA)' else 'INGRESO DIFERIDO POSITIVO (DIFERENCIA FACTURA)' end;
        p_detalle_factura_rec.cantidad := 1;
        p_detalle_factura_rec.p_unidad := vmonto;
        p_detalle_factura_rec.bs_descuento := 0;
        p_detalle_factura_rec.subtotal := 1*vmonto;
        p_detalle_factura_rec.materiales_id := case when sign(vmonto) = -1 then 94 else 95 end;
        p_detalle_factura_rec.factura_id := vfid;

        tapi_detalle_factura.ins(p_detalle_factura_rec => p_detalle_factura_rec);

        vresp := 0;
    EXCEPTION
        WHEN OTHERS THEN
            vresp := 1;
            dbms_output.put_line('COUNT: '
                                 || sqlerrm
                                 );

    END insIngDiferido;

END utl_factura;

/
--------------------------------------------------------
--  DDL for Package Body UTL_FACTURA_DEPOSITO
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."UTL_FACTURA_DEPOSITO" AS 

    PROCEDURE ins_multi (
        v_jsonfac IN varchar2,
        vid_deposito IN number
    ) IS

    l_idFact     factura.id%type;
    l_values    apex_json.t_values;
    l_row_count PLS_INTEGER;
    l_monto     NUMBER := 0;
    l_total     NUMBER := 0;
    P_FACTURA_DEPOSITO_REC FUNDAUC.TAPI_FACTURA_DEPOSITO.FACTURA_DEPOSITO_RT;

    BEGIN
        apex_debug.message('inside process Bulk Update Commission');
        -- parse text to JSON
        apex_json.parse(p_values => l_values, p_source => v_jsonfac);
     -- get number of rows selected
        l_row_count := apex_json.get_count(p_path => 'rows', p_values => l_values);
        -- loop through the selected rows
        FOR i IN 1..l_row_count LOOP
         -- get Primary Key value from JSON data
         l_idFact := null;  
            l_idFact := TO_NUMBER(apex_json.get_varchar2(p_path => 'rows[%d].facId', p0 => i, p_values => l_values));
            apex_debug.message('l_idFact' || l_idFact);
            -- update employee commission

            P_FACTURA_DEPOSITO_REC.FACTURA_ID := l_idFact;
            P_FACTURA_DEPOSITO_REC.DEPOSITO_ID := vid_deposito;

            TAPI_FACTURA_DEPOSITO.INS(P_FACTURA_DEPOSITO_REC);

        END LOOP;

    END;
END UTL_FACTURA_DEPOSITO;

/
--------------------------------------------------------
--  DDL for Package Body UTL_HORARIOS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."UTL_HORARIOS" AS

    FUNCTION getTotalHorarios (
        vid_modalidad NUMBER
    ) RETURN NUMBER AS
        eof  NUMBER;
        dml  VARCHAR2(2000);
    BEGIN
        dml := 'SELECT count(*) FROM Horarios WHERE modalidad = '|| vid_modalidad;

        EXECUTE IMMEDIATE dml
        INTO eof;

--DBMS_OUTPUT.PUT_LINE(dml);
        IF eof IS NULL THEN
            eof := 0;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := 0;
            RETURN eof;
        WHEN OTHERS THEN
            eof := 0;
            dbms_output.put_line('COUNT: '
                                 || sqlerrm
                                 || dml);
            RETURN eof;
    END getTotalHorarios;

    FUNCTION getHorario (
        vid_horario NUMBER
    ) RETURN VARCHAR2 AS
        eof  VARCHAR2(100);
        dml  VARCHAR2(2000);
    BEGIN
        dml := 'SELECT to_char(HORA,''HH:MI AM'')||''-''||to_char(HORA_FIN,''HH:MI AM'') FROM Horarios WHERE id_horario = '|| vid_horario;

        EXECUTE IMMEDIATE dml
        INTO eof;

--DBMS_OUTPUT.PUT_LINE(dml);
        IF eof IS NULL THEN
            eof := NULL;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := NULL;
            RETURN eof;
        WHEN OTHERS THEN
            eof := NULL;
            dbms_output.put_line('COUNT: '
                                 || sqlerrm
                                 || dml);
            RETURN eof;
    END getHorario;

    FUNCTION getHorarioMin (
        vid_horario NUMBER
    ) RETURN VARCHAR2 AS
        eof  VARCHAR2(100);
        dml  VARCHAR2(2000);
    BEGIN
        dml := 'SELECT to_char(HORA,''HH'')||''A''||to_char(HORA_FIN,''HH'') FROM Horarios WHERE id_horario = '|| vid_horario;

        EXECUTE IMMEDIATE dml
        INTO eof;

--DBMS_OUTPUT.PUT_LINE(dml);
        IF eof IS NULL THEN
            eof := NULL;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := NULL;
            RETURN eof;
        WHEN OTHERS THEN
            eof := NULL;
            dbms_output.put_line('COUNT: '
                                 || sqlerrm
                                 || dml);
            RETURN eof;
    END getHorarioMin;

    FUNCTION getIdHorario (
        vdes_horario VARCHAR2,
        vid_modalidad NUMBER
    ) RETURN NUMBER AS
        eof  NUMBER;
        dml  VARCHAR2(2000);
    BEGIN
        dml := 'SELECT id_horario FROM Horarios WHERE to_char(HORA,''HH:MI AM'')||''-''||to_char(HORA_FIN,''HH:MI AM'') = '''||vdes_horario||''' AND modalidad= '||vid_modalidad;

        EXECUTE IMMEDIATE dml
        INTO eof;

DBMS_OUTPUT.PUT_LINE(dml);
        IF eof IS NULL THEN
            eof := NULL;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := NULL;
            RETURN eof;
        WHEN OTHERS THEN
            eof := NULL;
            dbms_output.put_line('COUNT: '
                                 || sqlerrm
                                 || dml);
            RETURN eof;
    END getIdHorario;

END utl_horarios;

/
--------------------------------------------------------
--  DDL for Package Body UTL_INSCRIPCIONES
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."UTL_INSCRIPCIONES" AS

    FUNCTION getinscripcionesseccion (
        vid_seccion NUMBER,
        vid_periodo NUMBER
    ) RETURN NUMBER AS
        eof   NUMBER;
        dml   VARCHAR2(2000);
    BEGIN
        dml := 'SELECT count(*) FROM Inscripciones WHERE estatus not in (''IF'',''IFXC'') and seccion_id = '
        || vid_seccion
        || ' and periodo_id='
        || vid_periodo;
        EXECUTE IMMEDIATE dml INTO
            eof;
        dbms_output.put_line(dml);
        IF
            eof IS NULL
        THEN
            eof := 0;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := 0;
            RETURN eof;
        WHEN OTHERS THEN
            eof := 0;
            dbms_output.put_line('COUNT: '
            || sqlerrm
            || dml);
            RETURN eof;
    END getinscripcionesseccion;

    FUNCTION getinscripcionescohorte (
        vid_cohorte NUMBER,
        vid_periodo NUMBER
    ) RETURN NUMBER AS
        eof   NUMBER;
        dml   VARCHAR2(2000);
    BEGIN
        dml := 'SELECT count(*) FROM Inscripciones WHERE estatus not in (''IF'',''IFXC'') and cohorte_id = '
        || vid_cohorte
        || ' and periodo_id='
        || vid_periodo;
        EXECUTE IMMEDIATE dml INTO
            eof;
        dbms_output.put_line(dml);
        IF
            eof IS NULL
        THEN
            eof := 0;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := 0;
            RETURN eof;
        WHEN OTHERS THEN
            eof := 0;
            dbms_output.put_line('COUNT: '
            || sqlerrm
            || dml);
            RETURN eof;
    END getinscripcionescohorte;

    FUNCTION getdesstatus (
        v_status VARCHAR2
    ) RETURN VARCHAR2 AS
        eof   VARCHAR2(50);
        dml   VARCHAR2(2000);
    BEGIN
        dml := 'SELECT CASE '
        || ' WHEN '''
        || v_status
        || ''' = ''ACXC'' THEN ''Activa en Curso, por Cobrar'''
        || ' WHEN '''
        || v_status
        || ''' = ''ACP'' THEN ''Activa en Curso, Pagada'''
        || ' WHEN '''
        || v_status
        || ''' = ''AEXC'' THEN ''Activa por Comenzar, por Cobrar'''
        || ' WHEN '''
        || v_status
        || ''' = ''AEP'' THEN ''Activa por Comenzar, Pagada'''
        || ' WHEN '''
        || v_status
        || ''' = ''IF'' THEN ''Inactiva Finalizada'''
        || ' WHEN '''
        || v_status
        || ''' = ''IFXC'' THEN ''Inactiva Finalizada, por Cobrar'''
        || ' WHEN '''
        || v_status
        || ''' = ''AN'' THEN ''Anulada'''
        || ' WHEN '''
        || v_status
        || ''' = ''AEX'' THEN ''Activa por Comenzar, Exonerado'''
        || ' WHEN '''
        || v_status
        || ''' = ''ACX'' THEN ''Activa en Curso, Exonerado'''
        || ' WHEN '''
        || v_status
        || ''' = ''AES'' THEN ''Activa por Comenzar, Suspendido'''
        || ' WHEN '''
        || v_status
        || ''' = ''ACS'' THEN ''Activa en Curso, Suspendido'''
        || ' ELSE ''No Registrada'' END ESTATUS FROM dual';

        EXECUTE IMMEDIATE dml INTO
            eof;
--DBMS_OUTPUT.PUT_LINE(v_status);
--DBMS_OUTPUT.PUT_LINE(dml);
        IF
            eof IS NULL
        THEN
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;
    EXCEPTION
        WHEN no_data_found THEN
            RETURN eof;
        WHEN OTHERS THEN
            dbms_output.put_line('COUNT: '
            || sqlerrm
            || dml);
            RETURN eof;
    END getdesstatus;

    FUNCTION getstatusfac (
        vid_insc NUMBER
    ) RETURN VARCHAR2 AS

        eof                   VARCHAR2(255);
        l_ins_fac_rec         inscripcion_factura%rowtype;
        l_factura_rec         factura%rowtype;
        l_inscripciones_rec   inscripciones%rowtype;
    BEGIN
        SELECT
            *
        INTO
            l_inscripciones_rec
        FROM
            inscripciones
        WHERE
            id = vid_insc;

        dbms_output.put_line('Entrando...'
        || vid_insc);
        dbms_output.put_line('ID='
        || vid_insc
        || ' EXONERADO '
        || l_inscripciones_rec.es_exonerado
        || ' SUSPENDIDO '
        || l_inscripciones_rec.es_suspendido);

        IF
            ( l_inscripciones_rec.es_exonerado = 'N' AND l_inscripciones_rec.es_suspendido = 'N' )
        THEN
            SELECT
                *
            INTO
                l_ins_fac_rec
            FROM
                inscripcion_factura
            WHERE
                inscripcion_id = vid_insc;

            SELECT
                *
            INTO
                l_factura_rec
            FROM
                factura
            WHERE
                id = l_ins_fac_rec.factura_id;

        END IF;

        dbms_output.put_line('ID='
        || vid_insc
        || ' EXONERADO '
        || l_inscripciones_rec.es_exonerado
        || ' SUSPENDIDO '
        || l_inscripciones_rec.es_suspendido);

        CASE
            WHEN l_inscripciones_rec.es_exonerado = 'S' THEN
                eof := '<span class="rap-badge-exonerado">EXONERADO</span>';
            WHEN l_inscripciones_rec.es_suspendido = 'S' THEN
                eof := '<span class="rap-badge-exonerado">SUSPENDIDO</span>';
            ELSE
                CASE
                    WHEN l_factura_rec.status = 'A' THEN
                        eof := '<span class="rap-badge-anulada">ANULADA</span>';
                    WHEN l_factura_rec.status = 'V' THEN
                        eof := '<span class="rap-badge-emitida">'
                        || l_factura_rec.id_fact
                        || '</span>';
                    WHEN l_factura_rec.status = 'PC' THEN
                        eof := '<span class="rap-badge-pendiente">POR COBRAR</span>';
                END CASE;
        END CASE;

        IF
            eof IS NULL
        THEN
            RETURN 'NO REGISTRADO';
        ELSE
            RETURN eof;
        END IF;
    EXCEPTION
        WHEN no_data_found THEN
            RETURN 'NO REGISTRADO';
        WHEN OTHERS THEN
            dbms_output.put_line('COUNT: '
            || sqlerrm);
            RETURN eof;
    END getstatusfac;

    PROCEDURE elimina_inscripciones IS
        l_rc   NUMBER;
    BEGIN
        l_rc := log_message('[INFO] EJECUTANDO JOB ELIMINA_INSCRIPCIONES ');
        DELETE inscripciones WHERE
            estatus = 'Activa, En Proceso';

        dbms_output.put_line('[INFO] JOB EJECUTADO');
        l_rc := log_message('[INFO] JOB ELIMINA_INSCRIPCIONES EJECUTADO');
    END;

    PROCEDURE actualiza_estatus IS
        l_rc   NUMBER;
    BEGIN
        l_rc := log_message('[INFO] EJECUTANDO JOB ACTUALIZA ESTATUS INSCRIPCIONES ');
        FOR cur IN (
            SELECT
                id,
                CASE
                        WHEN utl_periodos.getstatusperiodosec(seccion_id) = 'Finalizado'
                             AND (
                            CASE
                                WHEN instr(utl_inscripciones.getstatusfac(id),'EXONERADO') > 1  THEN 'E'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'SUSPENDIDO') > 1 THEN 'S'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'POR COBRAR') > 1 THEN 'PC'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'ANULADA') > 1    THEN 'A'
                                ELSE 'X'
                            END
                        ) = 'PC' THEN 'IFXC'
                        WHEN utl_periodos.getstatusperiodosec(seccion_id) = 'Finalizado'   THEN 'IF'
                        WHEN utl_periodos.getstatusperiodosec(seccion_id) = 'En Curso'
                             AND fecha_ins + 9 < TO_DATE(token(substr(utl_periodos.getperiodo(107),4),1,'-'),'DD/MM/YYYY')
                             AND (
                            CASE
                                WHEN instr(utl_inscripciones.getstatusfac(id),'EXONERADO') > 1  THEN 'E'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'SUSPENDIDO') > 1 THEN 'S'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'POR COBRAR') > 1 THEN 'PC'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'ANULADA') > 1    THEN 'A'
                                ELSE 'X'
                            END
                        ) <> 'PC' THEN 'IF'
                        WHEN utl_periodos.getstatusperiodosec(seccion_id) = 'En Curso'
                             AND (
                            CASE
                                WHEN instr(utl_inscripciones.getstatusfac(id),'EXONERADO') > 1  THEN 'E'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'SUSPENDIDO') > 1 THEN 'S'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'POR COBRAR') > 1 THEN 'PC'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'ANULADA') > 1    THEN 'A'
                                ELSE 'X'
                            END
                        ) = 'X' THEN 'ACP'
                        WHEN utl_periodos.getstatusperiodosec(seccion_id) = 'En Curso'
                             AND (
                            CASE
                                WHEN instr(utl_inscripciones.getstatusfac(id),'EXONERADO') > 1  THEN 'E'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'SUSPENDIDO') > 1 THEN 'S'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'POR COBRAR') > 1 THEN 'PC'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'ANULADA') > 1    THEN 'A'
                                ELSE 'X'
                            END
                        ) = 'PC' THEN 'ACXC'
                        WHEN utl_periodos.getstatusperiodosec(seccion_id) = 'En Curso'
                             AND (
                            CASE
                                WHEN instr(utl_inscripciones.getstatusfac(id),'EXONERADO') > 1  THEN 'E'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'SUSPENDIDO') > 1 THEN 'S'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'POR COBRAR') > 1 THEN 'PC'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'ANULADA') > 1    THEN 'A'
                                ELSE 'X'
                            END
                        ) = 'E' THEN 'ACX'
                        WHEN utl_periodos.getstatusperiodosec(seccion_id) = 'En Curso'
                             AND (
                            CASE
                                WHEN instr(utl_inscripciones.getstatusfac(id),'EXONERADO') > 1  THEN 'E'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'SUSPENDIDO') > 1 THEN 'S'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'POR COBRAR') > 1 THEN 'PC'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'ANULADA') > 1    THEN 'A'
                                ELSE 'X'
                            END
                        ) = 'S' THEN 'ACS'
                        WHEN utl_periodos.getstatusperiodosec(seccion_id) = 'Por Comenzar'
                             AND (
                            CASE
                                WHEN instr(utl_inscripciones.getstatusfac(id),'EXONERADO') > 1  THEN 'E'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'SUSPENDIDO') > 1 THEN 'S'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'POR COBRAR') > 1 THEN 'PC'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'ANULADA') > 1    THEN 'A'
                                ELSE 'X'
                            END
                        ) = 'X' THEN 'AEP'
                        WHEN utl_periodos.getstatusperiodosec(seccion_id) = 'Por Comenzar'
                             AND (
                            CASE
                                WHEN instr(utl_inscripciones.getstatusfac(id),'EXONERADO') > 1  THEN 'E'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'SUSPENDIDO') > 1 THEN 'S'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'POR COBRAR') > 1 THEN 'PC'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'ANULADA') > 1    THEN 'A'
                                ELSE 'X'
                            END
                        ) = 'PC' THEN 'AEXC'
                        WHEN utl_periodos.getstatusperiodosec(seccion_id) = 'Por Comenzar'
                             AND (
                            CASE
                                WHEN instr(utl_inscripciones.getstatusfac(id),'EXONERADO') > 1  THEN 'E'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'SUSPENDIDO') > 1 THEN 'S'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'POR COBRAR') > 1 THEN 'PC'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'ANULADA') > 1    THEN 'A'
                                ELSE 'X'
                            END
                        ) = 'E' THEN 'AEX'
                        WHEN utl_periodos.getstatusperiodosec(seccion_id) = 'Por Comenzar'
                             AND (
                            CASE
                                WHEN instr(utl_inscripciones.getstatusfac(id),'EXONERADO') > 1  THEN 'E'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'SUSPENDIDO') > 1 THEN 'S'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'POR COBRAR') > 1 THEN 'PC'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'ANULADA') > 1    THEN 'A'
                                ELSE 'X'
                            END
                        ) = 'S' THEN 'AES'
                        WHEN (
                            CASE
                                WHEN instr(utl_inscripciones.getstatusfac(id),'EXONERADO') > 1  THEN 'E'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'SUSPENDIDO') > 1 THEN 'S'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'POR COBRAR') > 1 THEN 'PC'
                                WHEN instr(utl_inscripciones.getstatusfac(id),'ANULADA') > 1    THEN 'A'
                                ELSE 'X'
                            END
                        ) = 'A' THEN 'AN'
                    END
                estatus
            FROM
                inscripciones
            WHERE
                estatus <> 'IF'
        ) LOOP
            EXECUTE IMMEDIATE 'update inscripciones set estatus='''
            || cur.estatus
            || ''' where id='
            || cur.id;
        END LOOP;

        dbms_output.put_line('[INFO] JOB EJECUTADO');
        l_rc := log_message('[INFO] JOB ACTUALIZA_ESTATUS EJECUTADO');
    END;

    PROCEDURE actualiza_est_ins (
        facturas IN VARCHAR2
    )
        IS
    BEGIN
        UPDATE inscripciones i
            SET
                estatus = (
                    SELECT
                            CASE
                                WHEN utl_periodos.getstatusperiodosec(seccion_id) = 'Finalizado'
                                     AND (
                                    CASE
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'EXONERADO') > 1  THEN 'E'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'SUSPENDIDO') > 1 THEN 'S'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'POR COBRAR') > 1 THEN 'PC'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'ANULADA') > 1    THEN 'A'
                                        ELSE 'X'
                                    END
                                ) = 'PC' THEN 'IFXC'
                                WHEN utl_periodos.getstatusperiodosec(seccion_id) = 'Finalizado'   THEN 'IF'
                                WHEN utl_periodos.getstatusperiodosec(seccion_id) = 'En Curso'
                                     AND fecha_ins + 9 < TO_DATE(token(substr(utl_periodos.getperiodo(107),4),1,'-'),'DD/MM/YYYY')
                                     AND (
                                    CASE
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'EXONERADO') > 1  THEN 'E'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'SUSPENDIDO') > 1 THEN 'S'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'POR COBRAR') > 1 THEN 'PC'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'ANULADA') > 1    THEN 'A'
                                        ELSE 'X'
                                    END
                                ) <> 'PC' THEN 'IF'
                                WHEN utl_periodos.getstatusperiodosec(seccion_id) = 'En Curso'
                                     AND (
                                    CASE
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'EXONERADO') > 1  THEN 'E'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'SUSPENDIDO') > 1 THEN 'S'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'POR COBRAR') > 1 THEN 'PC'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'ANULADA') > 1    THEN 'A'
                                        ELSE 'X'
                                    END
                                ) = 'X' THEN 'ACP'
                                WHEN utl_periodos.getstatusperiodosec(seccion_id) = 'En Curso'
                                     AND (
                                    CASE
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'EXONERADO') > 1  THEN 'E'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'SUSPENDIDO') > 1 THEN 'S'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'POR COBRAR') > 1 THEN 'PC'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'ANULADA') > 1    THEN 'A'
                                        ELSE 'X'
                                    END
                                ) = 'PC' THEN 'ACXC'
                                WHEN utl_periodos.getstatusperiodosec(seccion_id) = 'En Curso'
                                     AND (
                                    CASE
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'EXONERADO') > 1  THEN 'E'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'SUSPENDIDO') > 1 THEN 'S'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'POR COBRAR') > 1 THEN 'PC'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'ANULADA') > 1    THEN 'A'
                                        ELSE 'X'
                                    END
                                ) = 'E' THEN 'ACX'
                                WHEN utl_periodos.getstatusperiodosec(seccion_id) = 'En Curso'
                                     AND (
                                    CASE
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'EXONERADO') > 1  THEN 'E'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'SUSPENDIDO') > 1 THEN 'S'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'POR COBRAR') > 1 THEN 'PC'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'ANULADA') > 1    THEN 'A'
                                        ELSE 'X'
                                    END
                                ) = 'S' THEN 'ACS'
                                WHEN utl_periodos.getstatusperiodosec(seccion_id) = 'Por Comenzar'
                                     AND (
                                    CASE
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'EXONERADO') > 1  THEN 'E'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'SUSPENDIDO') > 1 THEN 'S'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'POR COBRAR') > 1 THEN 'PC'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'ANULADA') > 1    THEN 'A'
                                        ELSE 'X'
                                    END
                                ) = 'X' THEN 'AEP'
                                WHEN utl_periodos.getstatusperiodosec(seccion_id) = 'Por Comenzar'
                                     AND (
                                    CASE
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'EXONERADO') > 1  THEN 'E'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'SUSPENDIDO') > 1 THEN 'S'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'POR COBRAR') > 1 THEN 'PC'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'ANULADA') > 1    THEN 'A'
                                        ELSE 'X'
                                    END
                                ) = 'PC' THEN 'AEXC'
                                WHEN utl_periodos.getstatusperiodosec(seccion_id) = 'Por Comenzar'
                                     AND (
                                    CASE
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'EXONERADO') > 1  THEN 'E'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'SUSPENDIDO') > 1 THEN 'S'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'POR COBRAR') > 1 THEN 'PC'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'ANULADA') > 1    THEN 'A'
                                        ELSE 'X'
                                    END
                                ) = 'E' THEN 'AEX'
                                WHEN utl_periodos.getstatusperiodosec(seccion_id) = 'Por Comenzar'
                                     AND (
                                    CASE
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'EXONERADO') > 1  THEN 'E'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'SUSPENDIDO') > 1 THEN 'S'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'POR COBRAR') > 1 THEN 'PC'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'ANULADA') > 1    THEN 'A'
                                        ELSE 'X'
                                    END
                                ) = 'S' THEN 'AES'
                                WHEN (
                                    CASE
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'EXONERADO') > 1  THEN 'E'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'SUSPENDIDO') > 1 THEN 'S'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'POR COBRAR') > 1 THEN 'PC'
                                        WHEN instr(utl_inscripciones.getstatusfac(id),'ANULADA') > 1    THEN 'A'
                                        ELSE 'X'
                                    END
                                ) = 'A' THEN 'AN'
                            END
                        estatus
                    FROM
                        inscripciones
                    WHERE
                        id = i.id
                )
        WHERE
            estatus <> 'IF'
            AND   id IN (
                SELECT
                    regexp_substr(facturas,'[^:]+',1,level)
                FROM
                    dual
                CONNECT BY
                    regexp_substr(facturas,'[^:]+',1,level) IS NOT NULL
            );

    END;

    FUNCTION log_message (
        message IN VARCHAR2
    ) RETURN NUMBER AS
        l_id   NUMBER;
    BEGIN
        BEGIN
            SELECT
                ( nvl(MAX(log_id),0) + 1 )
            INTO
                l_id
            FROM
                job_log;

            INSERT INTO job_log (
                log_id,
                log_message,
                log_time
            ) VALUES (
                l_id,
                message,
                SYSDATE
            );

            RETURN 0;
        EXCEPTION
            WHEN OTHERS THEN
                dbms_output.put_line('[INFO] ERROR WHILE LOG_MESSAGE '
                || sqlcode
                || ' '
                || substr(sqlerrm,1,64) );

                RETURN 1;
        END;
    END log_message;

    FUNCTION getseccionrec (
        p_renglon   IN detalle_factura.renglon%TYPE
    ) RETURN seccion_rt
        RESULT_CACHE
    IS
        l_seccion_rec   seccion_rt;
        l_fecha_ini     DATE;
    BEGIN
        SELECT
            item,
            token(descripcion,1,'|') id_metodo,
            to_number(replace(token(descripcion,2,'|'),'NIVEL ','') ) nivel,
            utl_horarios.getidhorario(token(descripcion,3,'|'),utl_modalidades.getidmodalidad(token(descripcion,5,'|') ) ) id_horario,
            utl_modalidades.getidmodalidad(token(descripcion,5,'|') ) id_modalidad,
            TO_DATE(token(descripcion,4,'|'),'DD/MM/YYYY') fecha_ini
        INTO
            l_seccion_rec.seccion_id,l_seccion_rec.id_metodo,l_seccion_rec.nivel,l_seccion_rec.id_horario,l_seccion_rec.id_modalidad,l_fecha_ini
        FROM
            detalle_factura
        WHERE
            renglon = p_renglon;

    /*  DBMS_OUTPUT.PUT_LINE('Renglon='||p_renglon);
      DBMS_OUTPUT.PUT_LINE('SeccionID='||l_seccion_rec.seccion_id);
      DBMS_OUTPUT.PUT_LINE('IdMetodo='||l_seccion_rec.id_metodo);
      DBMS_OUTPUT.PUT_LINE('Nivel='||l_seccion_rec.nivel);
      DBMS_OUTPUT.PUT_LINE('Horario='||l_seccion_rec.id_horario);
      DBMS_OUTPUT.PUT_LINE('id_modalidad='||l_seccion_rec.id_modalidad);
      DBMS_OUTPUT.PUT_LINE('fecha_ini='||to_char(l_fecha_ini,'DDMMYYYY'));*/

        SELECT
            id
        INTO
            l_seccion_rec.id_periodo
        FROM
            calendarios_detalle cd,
            metodos m
        WHERE
            modalidad = l_seccion_rec.id_modalidad
            AND   fecha_ini = l_fecha_ini
            AND   m.id_metodo = l_seccion_rec.id_metodo
            AND   m.id_calendario = cd.id_calendario;

    --  DBMS_OUTPUT.PUT_LINE('id_periodo='||l_seccion_rec.id_periodo);

        RETURN l_seccion_rec;
    EXCEPTION
        WHEN no_data_found THEN
            l_seccion_rec := NULL;
            RETURN l_seccion_rec;
    END getseccionrec;

    FUNCTION getsecciondes (
        p_id_seccion   IN secciones.id%TYPE
    ) RETURN VARCHAR2 IS
        l_seccion_des   VARCHAR2(255);
    BEGIN
        SELECT
            s.id_seccion
            || '|'
            || s.id_metodo
            || '|NIVEL '
            || lpad(s.nivel,2,'0')
            || '|'
            || utl_horarios.gethorario(s.id_horario)
            || '|'
            || TO_CHAR(cd.fecha_ini,'DD/MM/YYYY')
            || '|'
            || m.descripcion
            || '|'
            || id_salon seccion
        INTO
            l_seccion_des
        FROM
            secciones s,
            modalidades m,
            calendarios_detalle cd
        WHERE
            s.id = p_id_seccion
            AND   s.modalidad = m.id_modalidad
            AND   s.periodo = cd.id;

    --  DBMS_OUTPUT.PUT_LINE('id_periodo='||l_seccion_rec.id_periodo);

        RETURN l_seccion_des;
    EXCEPTION
        WHEN no_data_found THEN
            l_seccion_des := NULL;
            RETURN l_seccion_des;
    END getsecciondes;

    FUNCTION getseccioncod (
        p_id_secc   IN secciones.id%TYPE
    ) RETURN VARCHAR2 IS
        l_seccion_des   VARCHAR2(255);
    BEGIN
        SELECT
            s.id_seccion
        INTO
            l_seccion_des
        FROM
            secciones s
        WHERE
            s.id = p_id_secc;

    --  DBMS_OUTPUT.PUT_LINE('id_periodo='||l_seccion_rec.id_periodo);

        RETURN l_seccion_des;
    EXCEPTION
        WHEN no_data_found THEN
            l_seccion_des := NULL;
            RETURN l_seccion_des;
    END getseccioncod;

    FUNCTION getcohortedes (
        p_id_cohorte   IN cohortes.id%TYPE
    ) RETURN VARCHAR2 IS
        l_cohorte_des   VARCHAR2(255);
    BEGIN
        SELECT
            upper(descripcion
            || ' - '
            || cd.nombre) des
        INTO
            l_cohorte_des
        FROM
            diplomados d,
            cohortes c,
            ciudades cd
        WHERE
            c.id = p_id_cohorte
            AND   c.diplomado_id = d.id
            AND   c.id_ciudad = cd.id_ciudad;

    --  DBMS_OUTPUT.PUT_LINE('id_periodo='||l_seccion_rec.id_periodo);

        RETURN l_cohorte_des;
    EXCEPTION
        WHEN no_data_found THEN
            l_cohorte_des := NULL;
            RETURN l_cohorte_des;
    END getcohortedes;

    FUNCTION getcodigoseccion (
        metodo_id      IN VARCHAR2,
        nivel          IN NUMBER,
        periodo_id     IN NUMBER,
        modalidad_id   IN NUMBER,
        horario_id     IN NUMBER
    ) RETURN VARCHAR2 AS

        l_codigo       VARCHAR2(50);
        l_codigo_new   VARCHAR2(50);
        l_letra        VARCHAR2(1);
        l_num          NUMBER;
        incompleto EXCEPTION;

        FUNCTION codif (
            num NUMBER
        ) RETURN VARCHAR2 AS
            let   VARCHAR2(1);
        BEGIN
            SELECT
                translate(TO_CHAR(num),'123456789','ABCDEFGHI')
            INTO
                let
            FROM
                dual;

            RETURN let;
        END codif;

        FUNCTION decod (
            let VARCHAR2
        ) RETURN NUMBER AS
            num   NUMBER;
        BEGIN
            SELECT
                translate(TO_CHAR(let),'ABCDEFGHI','123456789')
            INTO
                num
            FROM
                dual;

            RETURN num;
        END decod;

        PROCEDURE display (
            p_obj IN VARCHAR2
        )
            IS
        BEGIN
            dbms_output.put_line(p_obj);
        END;

    BEGIN
    
        if metodo_id is null or nivel is null or periodo_id is null or modalidad_id is null or horario_id is null then
            raise incompleto;
        end if;
        SELECT
            '('
            || metodo_id
            || '|'
            || lpad(nivel,2,'0')
            || '|'
            || periodo_id
            || '|'
            || utl_modalidades.getsiglas(modalidad_id)
            || '|'
            || utl_horarios.gethorariomin(horario_id)
            || ')' codigo
        INTO
            l_codigo_new
        FROM
            dual;

 
            l_letra := codif(1);
  --  display('l_codigo_new1='||i.codigo);
            SELECT
                MAX(id_seccion)
            INTO
                l_codigo
            FROM
                secciones
            WHERE
                substr(id_seccion,1,length(id_seccion) - 1) = l_codigo_new;
        
    --    display('l_codigo1='||l_codigo);

            IF
                l_codigo IS NULL
            THEN
   --         display('l codigo is null');
                l_letra := codif(1);
                RETURN l_codigo_new
                || l_letra; 
   --         display(i.codigo||l_letra);
            ELSE
                l_letra := substr(l_codigo,length(l_codigo),1);
   --         display('l_letra1='||l_letra);
                l_num := decod(l_letra) + 1;
   --         display('l_num='||l_num);
                l_letra := codif(l_num);
   --         display('l_letra2='||l_letra);
                RETURN l_codigo_new
                || l_letra; 
   --         display(i.codigo||l_letra);
            END IF;

        EXCEPTION
            WHEN incompleto THEN
                dbms_output.put_line('Parametros Incompletos');
                RETURN 'INCOMPLETO';
            WHEN no_data_found THEN
                l_letra := codif(1);
                RETURN l_codigo_new
                || l_letra;
            WHEN OTHERS THEN
                display(l_codigo_new
                || l_letra);
                RETURN 'INCOMPLETO';

    END getcodigoseccion;

END utl_inscripciones;

/
--------------------------------------------------------
--  DDL for Package Body UTL_MATERIALES
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."UTL_MATERIALES" IS

    FUNCTION getrecdetallefac (
        vid_material NUMBER,
        vtipo_mat VARCHAR2
    ) RETURN detalle_factura_rt
        RESULT_CACHE
    IS
        l_detalle_factura_rec detalle_factura_rt;
    BEGIN
        IF vtipo_mat = 'C' THEN
            SELECT
                0 renglon,
                tipo,
                id_mat,
                descripcion
                || ' '
                || DECODE(m.iva_exento, 'S', '(E)', NULL) descripcion,
                1 cantidad,
                p.precio1,
                0 bs_descuento,
                1 * p.precio1 subtotal,
                m.id,
                0 factura_id
            INTO l_detalle_factura_rec
            FROM
                materiales   m,
                precios      p
            WHERE
                m.id = p.id
                AND seccion_id = vid_material;

        ELSE
            SELECT
                0 renglon,
                tipo,
                id_mat,
                descripcion
                || ' '
                || DECODE(m.iva_exento, 'S', '(E)', NULL) descripcion,
                1 cantidad,
                p.precio1,
                0 bs_descuento,
                1 * p.precio1 subtotal,
                m.id,
                0 factura_id
            INTO l_detalle_factura_rec
            FROM
                materiales   m,
                precios      p
            WHERE
                m.id = p.id
                AND m.id = vid_material;

        END IF;

        RETURN l_detalle_factura_rec;
    EXCEPTION
        WHEN no_data_found THEN
            l_detalle_factura_rec := NULL;
            RETURN l_detalle_factura_rec;
        WHEN OTHERS THEN
            l_detalle_factura_rec := NULL;
            dbms_output.put_line('COUNT: ' || sqlerrm);
            RETURN l_detalle_factura_rec;
    END getrecdetallefac;

    FUNCTION getrecdetallefac (
        vcod_mat VARCHAR2
    ) RETURN detalle_factura_rt
        RESULT_CACHE
    IS
        l_detalle_factura_rec detalle_factura_rt;
    BEGIN
            SELECT
                0 renglon,
                tipo,
                id_mat,
                descripcion
                || ' '
                || DECODE(m.iva_exento, 'S', '(E)', NULL) descripcion,
                1 cantidad,
                p.precio1,
                0 bs_descuento,
                1 * p.precio1 subtotal,
                m.id,
                0 factura_id
            INTO l_detalle_factura_rec
            FROM
                materiales   m,
                precios      p
            WHERE
                m.id = p.id
                AND m.id_mat = vcod_mat;

        RETURN l_detalle_factura_rec;
    EXCEPTION
        WHEN no_data_found THEN
            l_detalle_factura_rec := NULL;
            RETURN l_detalle_factura_rec;
        WHEN OTHERS THEN
            l_detalle_factura_rec := NULL;
            dbms_output.put_line('COUNT: ' || sqlerrm);
            RETURN l_detalle_factura_rec;
    END getrecdetallefac;

    FUNCTION getexentoiva (
        vid_material NUMBER
    ) RETURN CHAR IS
        resp char(1);
    BEGIN
        SELECT
            iva_exento
        INTO resp
        FROM
            materiales m
        WHERE
            id = vid_material;

            RETURN resp;

    EXCEPTION
        WHEN no_data_found THEN
            resp := 'N';
            RETURN resp;
        WHEN OTHERS THEN
            resp := 'N';
            dbms_output.put_line('COUNT: ' || sqlerrm);
            RETURN resp;
    END getexentoiva;

END utl_materiales;

/
--------------------------------------------------------
--  DDL for Package Body UTL_MODALIDADES
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."UTL_MODALIDADES" AS

    FUNCTION getModalidad (
        vid_modalidad NUMBER
    ) RETURN VARCHAR2 AS
        eof  VARCHAR2(100);
        dml  VARCHAR2(2000);
    BEGIN
        dml := 'SELECT DESCRIPCION FROM Modalidades WHERE id_modalidad = '|| vid_modalidad;

        EXECUTE IMMEDIATE dml
        INTO eof;

--DBMS_OUTPUT.PUT_LINE(dml);
        IF eof IS NULL THEN
            eof := NULL;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := NULL;
            RETURN eof;
        WHEN OTHERS THEN
            eof := NULL;
            dbms_output.put_line('COUNT: '
                                 || sqlerrm
                                 || dml);
            RETURN eof;
    END getModalidad;
    
    FUNCTION getSiglas (
        vid_modalidad NUMBER
    ) RETURN VARCHAR2 AS
        eof  VARCHAR2(100);
        dml  VARCHAR2(2000);
    BEGIN
        dml := 'SELECT SIGLAS FROM Modalidades WHERE id_modalidad = '|| vid_modalidad;

        EXECUTE IMMEDIATE dml
        INTO eof;

--DBMS_OUTPUT.PUT_LINE(dml);
        IF eof IS NULL THEN
            eof := NULL;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := NULL;
            RETURN eof;
        WHEN OTHERS THEN
            eof := NULL;
            dbms_output.put_line('COUNT: '
                                 || sqlerrm
                                 || dml);
            RETURN eof;
    END getSiglas;

    FUNCTION getIdModalidad (
        vdes_modalidad VARCHAR2
    ) RETURN NUMBER AS
        eof  NUMBER;
        dml  VARCHAR2(2000);
    BEGIN
        dml := 'SELECT id_modalidad FROM Modalidades WHERE DESCRIPCION = '''||vdes_modalidad||'''';

        EXECUTE IMMEDIATE dml
        INTO eof;

--DBMS_OUTPUT.PUT_LINE(dml);
        IF eof IS NULL THEN
            eof := NULL;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := NULL;
            RETURN eof;
        WHEN OTHERS THEN
            eof := NULL;
            dbms_output.put_line('COUNT: '
                                 || sqlerrm
                                 || dml);
            RETURN eof;
    END getIdModalidad;

END utl_modalidades;

/
--------------------------------------------------------
--  DDL for Package Body UTL_PERIODOS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "FUNDAUC"."UTL_PERIODOS" AS

    FUNCTION getTotalPeriodos (
        vid_calendario NUMBER
    ) RETURN NUMBER AS
        eof  NUMBER;
        dml  VARCHAR2(2000);
    BEGIN
        dml := 'SELECT count(*) FROM calendarios_detalle WHERE id_calendario = '|| vid_calendario;

        EXECUTE IMMEDIATE dml
        INTO eof;

--DBMS_OUTPUT.PUT_LINE(dml);
        IF eof IS NULL THEN
            eof := 0;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := 0;
            RETURN eof;
        WHEN OTHERS THEN
            eof := 0;
            dbms_output.put_line('COUNT: '
                                 || sqlerrm
                                 || dml);
            RETURN eof;
    END getTotalPeriodos;

    FUNCTION getPeriodo (
        vid_periodo NUMBER
    ) RETURN VARCHAR2 AS
        eof  VARCHAR2(100);
        dml  VARCHAR2(2000);
    BEGIN
        dml := 'SELECT ''(''||ID||'') ''||TO_CHAR(FECHA_INI,''DD/MM/YYYY'')||''-''||TO_CHAR(FECHA_FIN,''DD/MM/YYYY'') FROM calendarios_detalle WHERE id = '|| vid_periodo;

        EXECUTE IMMEDIATE dml
        INTO eof;

--DBMS_OUTPUT.PUT_LINE(dml);
        IF eof IS NULL THEN
            eof := NULL;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := NULL;
            RETURN eof;
        WHEN OTHERS THEN
            eof := NULL;
            dbms_output.put_line('COUNT: '
                                 || sqlerrm
                                 || dml);
            RETURN eof;
    END getPeriodo;

    FUNCTION getPeriodoFInicio (
        vid_periodo NUMBER
    ) RETURN DATE AS
        eof  DATE;
        dml  VARCHAR2(2000);
    BEGIN
        dml := 'SELECT FECHA_INI FROM calendarios_detalle WHERE id = '|| vid_periodo;

        EXECUTE IMMEDIATE dml
        INTO eof;

--DBMS_OUTPUT.PUT_LINE(dml);
        IF eof IS NULL THEN
            eof := NULL;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := NULL;
            RETURN eof;
        WHEN OTHERS THEN
            eof := NULL;
            dbms_output.put_line('COUNT: '
                                 || sqlerrm
                                 || dml);
            RETURN eof;
    END getPeriodoFInicio;

    FUNCTION getPeriodoFFin (
        vid_periodo NUMBER
    ) RETURN DATE AS
        eof  DATE;
        dml  VARCHAR2(2000);
    BEGIN
        dml := 'SELECT FECHA_FIN FROM calendarios_detalle WHERE id = '|| vid_periodo;

        EXECUTE IMMEDIATE dml
        INTO eof;

--DBMS_OUTPUT.PUT_LINE(dml);
        IF eof IS NULL THEN
            eof := NULL;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := NULL;
            RETURN eof;
        WHEN OTHERS THEN
            eof := NULL;
            dbms_output.put_line('COUNT: '
                                 || sqlerrm
                                 || dml);
            RETURN eof;
    END getPeriodoFFin;


    FUNCTION getPeriodoSec (
        vid_seccion NUMBER
    ) RETURN VARCHAR2 AS
        eof  VARCHAR2(100);
        dml  VARCHAR2(2000);
        l_periodo number;
    BEGIN

        select periodo into l_periodo from secciones where id = vid_seccion;

        dml := 'SELECT ''(''||ID||'') ''||TO_CHAR(FECHA_INI,''DD/MM/YYYY'')||''-''||TO_CHAR(FECHA_FIN,''DD/MM/YYYY'') FROM calendarios_detalle WHERE id = '|| l_periodo;

        EXECUTE IMMEDIATE dml
        INTO eof;

--DBMS_OUTPUT.PUT_LINE(dml);
        IF eof IS NULL THEN
            eof := NULL;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := NULL;
            RETURN eof;
        WHEN OTHERS THEN
            eof := NULL;
            dbms_output.put_line('COUNT: '
                                 || sqlerrm
                                 || dml);
            RETURN eof;
    END getPeriodoSec;

    FUNCTION getPeriodoCor (
        vid_cohorte NUMBER
    ) RETURN VARCHAR2 AS
        eof  VARCHAR2(100);
        dml  VARCHAR2(2000);
        l_periodo number;
    BEGIN

        select periodo into l_periodo from cohortes where id = vid_cohorte;

        dml := 'SELECT ''(''||ID||'') ''||TO_CHAR(FECHA_INI,''DD/MM/YYYY'')||''-''||TO_CHAR(FECHA_FIN,''DD/MM/YYYY'') FROM calendarios_detalle WHERE id = '|| l_periodo;

        EXECUTE IMMEDIATE dml
        INTO eof;

--DBMS_OUTPUT.PUT_LINE(dml);
        IF eof IS NULL THEN
            eof := NULL;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := NULL;
            RETURN eof;
        WHEN OTHERS THEN
            eof := NULL;
            dbms_output.put_line('COUNT: '
                                 || sqlerrm
                                 || dml);
            RETURN eof;
    END getPeriodoCor;

    FUNCTION getStatusPeriodo (
        vid_periodo NUMBER
    ) RETURN VARCHAR2 AS
        l_fini date;
        l_ffin date;
        l_hoy date := sysdate;
        eof varchar(20);
    BEGIN
        SELECT FECHA_INI,FECHA_FIN into l_fini, l_ffin FROM calendarios_detalle WHERE id = vid_periodo;

        CASE
          WHEN l_hoy BETWEEN l_fini and l_ffin THEN eof := 'En Curso';
          WHEN l_hoy < l_fini THEN eof := 'Por Comenzar';
          WHEN l_hoy > l_ffin THEN eof := 'Finalizado';
        END CASE;

--DBMS_OUTPUT.PUT_LINE(dml);
        IF eof IS NULL THEN
            eof := 'Finalizado';
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := 'Finalizado';
            RETURN eof;
        WHEN OTHERS THEN
            eof := 'Finalizado';
            dbms_output.put_line('STATUS: '
                                 || sqlerrm);
            RETURN eof;
    END getStatusPeriodo;

    FUNCTION getStatusPeriodoSec (
        vid_seccion NUMBER
    ) RETURN VARCHAR2 AS
        l_fini date;
        l_ffin date;
        l_periodo number;
        l_hoy date := sysdate;
        eof varchar(20);
    BEGIN

        SELECT periodo into l_periodo from secciones where id = vid_seccion;

        SELECT FECHA_INI,FECHA_FIN into l_fini, l_ffin FROM calendarios_detalle WHERE id = l_periodo;

        CASE
          WHEN l_hoy BETWEEN l_fini and l_ffin THEN eof := 'En Curso';
          WHEN l_hoy < l_fini THEN eof := 'Por Comenzar';
          WHEN l_hoy > l_ffin THEN eof := 'Finalizado';
        END CASE;

--DBMS_OUTPUT.PUT_LINE(dml);
        IF eof IS NULL THEN
            eof := NULL;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := 'Finalizado';
            RETURN eof;
        WHEN OTHERS THEN
            eof := NULL;
            dbms_output.put_line('STATUS: '
                                 || sqlerrm);
            RETURN eof;
    END getStatusPeriodoSec;
    
    FUNCTION getPeriodoFecIniSec (
        vid_seccion NUMBER
    ) RETURN DATE AS
        eof  DATE;
        dml  VARCHAR2(2000);
        l_periodo number;
    BEGIN

        select periodo into l_periodo from secciones where id = vid_seccion;

        dml := 'SELECT FECHA_INI FROM calendarios_detalle WHERE id = '|| l_periodo;

        EXECUTE IMMEDIATE dml
        INTO eof;

--DBMS_OUTPUT.PUT_LINE(dml);
        IF eof IS NULL THEN
            eof := NULL;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := NULL;
            RETURN eof;
        WHEN OTHERS THEN
            eof := NULL;
            dbms_output.put_line('COUNT: '
                                 || sqlerrm
                                 || dml);
            RETURN eof;
    END getPeriodoFecIniSec;

    FUNCTION getPeriodoFecFinSec (
        vid_seccion NUMBER
    ) RETURN DATE AS
        eof  DATE;
        dml  VARCHAR2(2000);
        l_periodo number;
    BEGIN

        select periodo into l_periodo from secciones where id = vid_seccion;

        dml := 'SELECT FECHA_FIN FROM calendarios_detalle WHERE id = '|| l_periodo;

        EXECUTE IMMEDIATE dml
        INTO eof;

--DBMS_OUTPUT.PUT_LINE(dml);
        IF eof IS NULL THEN
            eof := NULL;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := NULL;
            RETURN eof;
        WHEN OTHERS THEN
            eof := NULL;
            dbms_output.put_line('COUNT: '
                                 || sqlerrm
                                 || dml);
            RETURN eof;
    END getPeriodoFecFinSec;


    FUNCTION getPeriodoFecIniCor (
        vid_cohorte NUMBER
    ) RETURN DATE AS
        eof  DATE;
        dml  VARCHAR2(2000);
        l_periodo number;
    BEGIN

        select periodo into l_periodo from cohortes where id = vid_cohorte;

        dml := 'SELECT FECHA_INI FROM calendarios_detalle WHERE id = '|| l_periodo;

        EXECUTE IMMEDIATE dml
        INTO eof;

--DBMS_OUTPUT.PUT_LINE(dml);
        IF eof IS NULL THEN
            eof := NULL;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := NULL;
            RETURN eof;
        WHEN OTHERS THEN
            eof := NULL;
            dbms_output.put_line('COUNT: '
                                 || sqlerrm
                                 || dml);
            RETURN eof;
    END getPeriodoFecIniCor;


    FUNCTION getStatusPeriodoCor (
        vid_cohorte NUMBER
    ) RETURN VARCHAR2 AS
        l_fini date;
        l_ffin date;
        l_periodo number;
        l_hoy date := sysdate;
        eof varchar(20);
    BEGIN

        SELECT periodo into l_periodo from cohortes where id = vid_cohorte;

        SELECT FECHA_INI,FECHA_FIN into l_fini, l_ffin FROM calendarios_detalle WHERE id = l_periodo;

        CASE
          WHEN l_hoy BETWEEN l_fini and l_ffin THEN eof := 'En Curso';
          WHEN l_hoy < l_fini THEN eof := 'Por Comenzar';
          WHEN l_hoy > l_ffin THEN eof := 'Finalizado';
        END CASE;

--DBMS_OUTPUT.PUT_LINE(dml);
        IF eof IS NULL THEN
            eof := NULL;
            RETURN eof;
        ELSE
            RETURN eof;
        END IF;

    EXCEPTION
        WHEN no_data_found THEN
            eof := 'Finalizado';
            RETURN eof;
        WHEN OTHERS THEN
            eof := NULL;
            dbms_output.put_line('STATUS: '
                                 || sqlerrm);
            RETURN eof;
    END getStatusPeriodoCor;

END utl_periodos;

/
